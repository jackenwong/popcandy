System.register([], (function (exports, module) {
  'use strict';
  return {
    execute: (function () {

      exports({
        BitMask: BitMask,
        CCClass: CCClass,
        Enum: Enum,
        Eventify: Eventify,
        WorldNode3DToLocalNodeUI: WorldNode3DToLocalNodeUI,
        WorldNode3DToWorldNodeUI: WorldNode3DToWorldNodeUI,
        __checkObsoleteInNamespace__: __checkObsoleteInNamespace__,
        __checkObsolete__: __checkObsolete__,
        _resetDebugSetting: _resetDebugSetting,
        absMax: absMax,
        absMaxComponent: absMaxComponent,
        applyMixins: applyMixins,
        approx: approx,
        assert: assert,
        assertID: assertID,
        assertIsNonNullable: assertIsNonNullable,
        assertIsTrue: assertIsTrue,
        assertsArrayIndex: assertsArrayIndex,
        bezier: bezier,
        bezierByTime: bezierByTime,
        binarySearch: binarySearch,
        binarySearchBy: binarySearchBy,
        binarySearchEpsilon: binarySearchEpsilon,
        ccenum: ccenum,
        clamp: clamp$1,
        clamp01: clamp01,
        color: color,
        debug: debug,
        deprecateModuleExportedName: deprecateModuleExportedName,
        deserialize: deserialize,
        enumerableProps: enumerableProps,
        equals: equals$1,
        error: error,
        errorID: errorID,
        find: find,
        flattenCodeArray: flattenCodeArray,
        floatToHalf: floatToHalf,
        formerlySerializedAs: formerlySerializedAs,
        fragmentText: fragmentText,
        getBaselineOffset: getBaselineOffset,
        getEnglishWordPartAtFirst: getEnglishWordPartAtFirst,
        getEnglishWordPartAtLast: getEnglishWordPartAtLast,
        getError: getError,
        getSerializationMetadata: getSerializationMetadata,
        halfToFloat: halfToFloat,
        instantiate: instantiate,
        inverseLerp: inverseLerp,
        isCCClassOrFastDefined: isCCClassOrFastDefined,
        isCCObject: isCCObject,
        isDisplayStats: isDisplayStats,
        isEnglishWordPartAtFirst: isEnglishWordPartAtFirst,
        isEnglishWordPartAtLast: isEnglishWordPartAtLast,
        isUnicodeCJK: isUnicodeCJK,
        isUnicodeSpace: isUnicodeSpace,
        isValid: isValid,
        lerp: lerp,
        log: log,
        logID: logID,
        mat4: mat4,
        murmurhash2_32_gc: murmurhash2_32_gc,
        nextPow2: nextPow2,
        pingPong: pingPong,
        pseudoRandom: pseudoRandom,
        pseudoRandomRange: pseudoRandomRange,
        pseudoRandomRangeInt: pseudoRandomRangeInt,
        quat: quat,
        random: random,
        randomRange: randomRange,
        randomRangeInt: randomRangeInt,
        rect: rect,
        repeat: repeat$1,
        safeMeasureText: safeMeasureText,
        setDefaultLogTimes: setDefaultLogTimes,
        setDisplayStats: setDisplayStats,
        setPropertyEnumType: setPropertyEnumType,
        setPropertyEnumTypeOnAttrs: setPropertyEnumTypeOnAttrs,
        setRandGenerator: setRandGenerator,
        shift: shift,
        size: size,
        toDegree: toDegree,
        toRadian: toRadian,
        tween: tween,
        tweenUtil: tweenUtil,
        v2: v2$1,
        v3: v3,
        v4: v4,
        warn: warn,
        warnID: warnID
      });

      function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
        var desc = {};
        Object.keys(descriptor).forEach(function (key) {
          desc[key] = descriptor[key];
        });
        desc.enumerable = !!desc.enumerable;
        desc.configurable = !!desc.configurable;
        if ('value' in desc || desc.initializer) {
          desc.writable = true;
        }
        desc = decorators.slice().reverse().reduce(function (desc, decorator) {
          return decorator(target, property, desc) || desc;
        }, desc);
        if (context && desc.initializer !== void 0) {
          desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
          desc.initializer = undefined;
        }
        if (desc.initializer === void 0) {
          Object.defineProperty(target, property, desc);
          desc = null;
        }
        return desc;
      }

      function tryDefineGlobal (name, value) {
          const _global = typeof window === 'undefined' ? global : window;
          if (typeof _global[name] === 'undefined') {
              return (_global[name] = value);
          } else {
              // eslint-disable-next-line @typescript-eslint/no-unsafe-return
              return _global[name];
          }
      }

      const NATIVE = true;

      const OPEN_HARMONY = false;
      tryDefineGlobal('CC_WECHAT', false);

      const WECHAT_MINI_PROGRAM = false;
      tryDefineGlobal('CC_BAIDU', false);

      const XIAOMI = false;
      tryDefineGlobal('CC_XIAOMI', false);
      tryDefineGlobal('CC_ALIPAY', false);
      tryDefineGlobal('CC_BYTEDANCE', false);
      tryDefineGlobal('CC_OPPO', false);
      tryDefineGlobal('CC_VIVO', false);
      tryDefineGlobal('CC_HUAWEI', false);
      tryDefineGlobal('CC_COCOSPLAY', false);
      tryDefineGlobal('CC_QTT', false);
      tryDefineGlobal('CC_LINKSURE', false);

      const EDITOR = false;
      tryDefineGlobal('CC_EDITOR', false);

      const EDITOR_NOT_IN_PREVIEW = false;

      const PREVIEW = false;
      tryDefineGlobal('CC_PREVIEW', false);
      tryDefineGlobal('CC_BUILD', true);
      tryDefineGlobal('CC_TEST', false);
      tryDefineGlobal('CC_DEBUG', true);
      tryDefineGlobal('CC_DEV', false);

      const MINIGAME = false;
      tryDefineGlobal('CC_MINIGAME', false);

      const RUNTIME_BASED = false;
      tryDefineGlobal('CC_RUNTIME_BASED', false);
      tryDefineGlobal('CC_SUPPORT_JIT', true);

      const JSB = true;
      tryDefineGlobal('CC_JSB', true);

      const _global = typeof window === 'undefined' ? global : window;
      const legacyCC = exports('cclegacy', {
        _global
      });
      legacyCC.internal = {};
      const engineVersion = exports('VERSION', '3.8.1');
      _global.CocosEngine = legacyCC.ENGINE_VERSION = engineVersion;
      _global.cc = legacyCC;
      const ccwindow$1 = typeof globalThis.jsb !== 'undefined' ? typeof jsb.window !== 'undefined' ? jsb.window : globalThis : globalThis;
      _global.ccwindow = ccwindow$1;

      const INT_BITS = 32;
      const INT_MAX = 0x7fffffff;
      const INT_MIN = -1 << INT_BITS - 1;
      function sign$1(v) {
        return (v > 0) - (v < 0);
      }
      function abs$1(v) {
        const mask = v >> INT_BITS - 1;
        return (v ^ mask) - mask;
      }
      function min$3(x, y) {
        return y ^ (x ^ y) & -(x < y);
      }
      function max$4(x, y) {
        return x ^ (x ^ y) & -(x < y);
      }
      function isPow2(v) {
        return !(v & v - 1) && !!v;
      }
      function log2(v) {
        let r;
        let shift;
        r = (v > 0xFFFF) << 4;
        v >>>= r;
        shift = (v > 0xFF) << 3;
        v >>>= shift;
        r |= shift;
        shift = (v > 0xF) << 2;
        v >>>= shift;
        r |= shift;
        shift = (v > 0x3) << 1;
        v >>>= shift;
        r |= shift;
        return r | v >> 1;
      }
      function log10(v) {
        return v >= 1000000000 ? 9 : v >= 100000000 ? 8 : v >= 10000000 ? 7 : v >= 1000000 ? 6 : v >= 100000 ? 5 : v >= 10000 ? 4 : v >= 1000 ? 3 : v >= 100 ? 2 : v >= 10 ? 1 : 0;
      }
      function popCount(v) {
        v -= v >>> 1 & 0x55555555;
        v = (v & 0x33333333) + (v >>> 2 & 0x33333333);
        return (v + (v >>> 4) & 0xF0F0F0F) * 0x1010101 >>> 24;
      }
      function countTrailingZeros(v) {
        let c = 32;
        v &= -v;
        if (v) {
          c--;
        }
        if (v & 0x0000FFFF) {
          c -= 16;
        }
        if (v & 0x00FF00FF) {
          c -= 8;
        }
        if (v & 0x0F0F0F0F) {
          c -= 4;
        }
        if (v & 0x33333333) {
          c -= 2;
        }
        if (v & 0x55555555) {
          c -= 1;
        }
        return c;
      }
      function nextPow2$1(v) {
        --v;
        v |= v >>> 1;
        v |= v >>> 2;
        v |= v >>> 4;
        v |= v >>> 8;
        v |= v >>> 16;
        return v + 1;
      }
      function prevPow2(v) {
        v |= v >>> 1;
        v |= v >>> 2;
        v |= v >>> 4;
        v |= v >>> 8;
        v |= v >>> 16;
        return v - (v >>> 1);
      }
      function parity(v) {
        v ^= v >>> 16;
        v ^= v >>> 8;
        v ^= v >>> 4;
        v &= 0xf;
        return 0x6996 >>> v & 1;
      }
      const REVERSE_TABLE = new Array(256);
      (tab => {
        for (let i = 0; i < 256; ++i) {
          let v = i;
          let r = i;
          let s = 7;
          for (v >>>= 1; v; v >>>= 1) {
            r <<= 1;
            r |= v & 1;
            --s;
          }
          tab[i] = r << s & 0xff;
        }
      })(REVERSE_TABLE);
      function reverse(v) {
        return REVERSE_TABLE[v & 0xff] << 24 | REVERSE_TABLE[v >>> 8 & 0xff] << 16 | REVERSE_TABLE[v >>> 16 & 0xff] << 8 | REVERSE_TABLE[v >>> 24 & 0xff];
      }
      function interleave2(x, y) {
        x &= 0xFFFF;
        x = (x | x << 8) & 0x00FF00FF;
        x = (x | x << 4) & 0x0F0F0F0F;
        x = (x | x << 2) & 0x33333333;
        x = (x | x << 1) & 0x55555555;
        y &= 0xFFFF;
        y = (y | y << 8) & 0x00FF00FF;
        y = (y | y << 4) & 0x0F0F0F0F;
        y = (y | y << 2) & 0x33333333;
        y = (y | y << 1) & 0x55555555;
        return x | y << 1;
      }
      function deinterleave2(v, n) {
        v = v >>> n & 0x55555555;
        v = (v | v >>> 1) & 0x33333333;
        v = (v | v >>> 2) & 0x0F0F0F0F;
        v = (v | v >>> 4) & 0x00FF00FF;
        v = (v | v >>> 16) & 0x000FFFF;
        return v << 16 >> 16;
      }
      function interleave3(x, y, z) {
        x &= 0x3FF;
        x = (x | x << 16) & 4278190335;
        x = (x | x << 8) & 251719695;
        x = (x | x << 4) & 3272356035;
        x = (x | x << 2) & 1227133513;
        y &= 0x3FF;
        y = (y | y << 16) & 4278190335;
        y = (y | y << 8) & 251719695;
        y = (y | y << 4) & 3272356035;
        y = (y | y << 2) & 1227133513;
        x |= y << 1;
        z &= 0x3FF;
        z = (z | z << 16) & 4278190335;
        z = (z | z << 8) & 251719695;
        z = (z | z << 4) & 3272356035;
        z = (z | z << 2) & 1227133513;
        return x | z << 2;
      }
      function deinterleave3(v, n) {
        v = v >>> n & 1227133513;
        v = (v | v >>> 2) & 3272356035;
        v = (v | v >>> 4) & 251719695;
        v = (v | v >>> 8) & 4278190335;
        v = (v | v >>> 16) & 0x3FF;
        return v << 22 >> 22;
      }
      function nextCombination(v) {
        const t = v | v - 1;
        return t + 1 | (~t & -~t) - 1 >>> countTrailingZeros(v) + 1;
      }

      var bits = /*#__PURE__*/Object.freeze({
        __proto__: null,
        INT_BITS: INT_BITS,
        INT_MAX: INT_MAX,
        INT_MIN: INT_MIN,
        sign: sign$1,
        abs: abs$1,
        min: min$3,
        max: max$4,
        isPow2: isPow2,
        log2: log2,
        log10: log10,
        popCount: popCount,
        countTrailingZeros: countTrailingZeros,
        nextPow2: nextPow2$1,
        prevPow2: prevPow2,
        parity: parity,
        reverse: reverse,
        interleave2: interleave2,
        deinterleave2: deinterleave2,
        interleave3: interleave3,
        deinterleave3: deinterleave3,
        nextCombination: nextCombination
      });
      exports('bits', bits);

      var debugInfos = {
      	"1006": "[Action step]. override me",
      	"1007": "[Action update]. override me",
      	"1008": "[Action reverse]. override me",
      	"1100": "Expected 'data' dict, but not found. Config file: %s",
      	"1101": "Please load the resource first : %s",
      	"1102": "Effect settings not found, effects will not be imported.",
      	"1103": "Success to load scene: %s",
      	"1200": "cocos2d: Director: Error in gettimeofday",
      	"1204": "Running scene should not be null",
      	"1205": "The scene should not be null",
      	"1206": "loadScene: The scene index to load (%s) is out of range.",
      	"1207": "loadScene: Unknown name type to load: '%s'",
      	"1208": "loadScene: Failed to load scene '%s' because '%s' is already being loaded.",
      	"1209": "loadScene: Can not load the scene '%s' because it was not in the build settings before playing.",
      	"1210": "Failed to preload '%s', %s",
      	"1211": "loadScene: The scene index to load (%s) is out of range.",
      	"1212": "loadScene: Unknown name type to load: '%s'",
      	"1213": "loadScene: Failed to load scene '%s' because '%s' is already loading",
      	"1214": "loadScene: Can not load the scene '%s' because it was not in the build settings before playing.",
      	"1215": "Failed to preload '%s', %s",
      	"1216": "Director.runSceneImmediate: scene is not valid",
      	"1217": "Director._initOnEngineInitialized: renderer root initialization failed",
      	"1218": "Forward render pipeline initialized.",
      	"1219": "Deferred render pipeline initialized. Note that non-transparent materials with no lighting will not be rendered, such as builtin-unlit.",
      	"1220": "Failed to set shading scale, pipelineSceneData is invalid.",
      	"1221": "Setting orientation is not supported yet.",
      	"1300": "%s is not in the model pool and cannot be destroyed by destroyModel.",
      	"1400": "'%s' is deprecated, please use '%s' instead.",
      	"1404": "cc.spriteFrameCache is removed, please use cc.loader to load and cache sprite frames of atlas format.",
      	"1406": "'%s.%s' is removed",
      	"1408": "'%s' is removed",
      	"1409": "element type is wrong!",
      	"1502": "cc.scheduler.scheduleCallbackForTarget(): target should be non-null.",
      	"1503": "cc.Scheduler.pauseTarget():target should be non-null",
      	"1504": "cc.Scheduler.resumeTarget():target should be non-null",
      	"1505": "cc.Scheduler.isTargetPaused():target should be non-null",
      	"1506": "warning: you CANNOT change update priority in scheduled function",
      	"1507": "scheduler#scheduleSelector. Selector already scheduled. Updating interval from: %.4f to %.4f",
      	"1508": "Argument callback must not be empty",
      	"1509": "Argument target must be non-nullptr",
      	"1510": "cc.Scheduler: Illegal target which doesn't have id, you should do Scheduler.enableForTarget(target) before all scheduler API usage on target",
      	"1511": "cc.Scheduler: pause state of the scheduled task doesn't match the element pause state in Scheduler, the given paused state will be ignored.",
      	"1513": "cc.Scheduler: scheduler stopped using `__instanceId` as id since v2.0, you should do Scheduler.enableForTarget(target) before all scheduler API usage on target",
      	"1514": "since v3.8.0, `Scheduler.schedule(target, callback, interval)` is deprecated, please use `Scheduler.schedule(callback, target, interval)` instead.",
      	"1607": "removeFromParentAndCleanup is deprecated. Use removeFromParent instead",
      	"1619": "callback function must be non-null",
      	"1620": "interval must be positive",
      	"1623": "Set '%s' to normal node (not persist root node).",
      	"1624": "Replacing with the same sgNode",
      	"1625": "The replacement sgNode should not contain any child.",
      	"1626": "Should not set alpha via 'color', set 'opacity' please.",
      	"1627": "Not support for asynchronous creating node in SG",
      	"1632": "Node name can not include '/'.",
      	"1633": "Internal error, should not remove unknown node from parent.",
      	"1635": "reorderChild: this child is not in children list.",
      	"1636": "Node's zIndex value can't be greater than cc.macro.MAX_ZINDEX, setting to the maximum value",
      	"1637": "Node's zIndex value can't be smaller than cc.macro.MIN_ZINDEX, setting to the minimum value",
      	"1638": "Private node's zIndex can't be set, it will keep cc.macro.MIN_ZINDEX as its value",
      	"1800": "cc._EventListenerKeyboard.checkAvailable(): Invalid EventListenerKeyboard!",
      	"1801": "cc._EventListenerTouchOneByOne.checkAvailable(): Invalid EventListenerTouchOneByOne!",
      	"1802": "cc._EventListenerTouchAllAtOnce.checkAvailable(): Invalid EventListenerTouchAllAtOnce!",
      	"1803": "cc._EventListenerAcceleration.checkAvailable():_onAccelerationEvent must be non-nil",
      	"1900": "Invalid parameter.",
      	"2104": "Layer collision. The name of layer (%s) is collided with the name or value of some layer",
      	"2200": "Design resolution not valid",
      	"2201": "should set resolutionPolicy",
      	"2300": "The touches is more than MAX_TOUCHES, nUnusedIndex = %s",
      	"2402": "Forward pipeline startup failed!",
      	"3103": "cc.Texture.addImage(): path should be non-null",
      	"3119": "Lazy init texture with image element failed due to image loading failure: %s",
      	"3120": "Loading texture with unsupported type: '%s'. Add '%s' into 'cc.macro.SUPPORT_TEXTURE_FORMATS' please.",
      	"3121": "Can't find a texture format supported by the current platform! Please add a fallback format in the editor.",
      	"3122": "Error Texture in %s.",
      	"3123": "Set same texture %s.",
      	"3124": "Texture: setMipRange failed because base level is larger than max level",
      	"3300": "Rect width exceeds maximum margin: %s",
      	"3301": "Rect height exceeds maximum margin: %s",
      	"3500": "0 priority is forbidden for fixed priority since it's used for scene graph based priority.",
      	"3501": "Invalid listener type!",
      	"3502": "Can't set fixed priority with scene graph based listener.",
      	"3503": "Invalid parameters.",
      	"3504": "listener must be a cc.EventListener object when adding a fixed priority listener",
      	"3505": "The listener has been registered, please don't register it again.",
      	"3506": "Unsupported listener target.",
      	"3507": "Invalid scene graph priority!",
      	"3508": "If program goes here, there should be event in dispatch.",
      	"3509": "_inDispatch should be 1 here.",
      	"3510": "%s's scene graph node not contains in the parent's children",
      	"3511": "event is undefined",
      	"3512": "Event manager only support scene graph priority for ui nodes which contain UIComponent",
      	"3520": "Device Motion Event request permission: %s",
      	"3521": "Device Motion Event request permission failed: %s",
      	"3601": "The editor property 'playOnFocus' should be used with 'executeInEditMode' in class '%s'",
      	"3602": "Unknown editor property '%s' in class '%s'.",
      	"3603": "Use 'cc.Float' or 'cc.Integer' instead of 'cc.Number' please.",
      	"3604": "Can only indicate one type attribute for %s.",
      	"3605": "The default value of %s is not instance of %s.",
      	"3606": "No needs to indicate the '%s' attribute for %s, which its default value is type of %s.",
      	"3607": "The default value of %s must be an empty string.",
      	"3608": "The type of %s must be CCString, not String.",
      	"3609": "The type of %s must be CCBoolean, not Boolean.",
      	"3610": "The type of %s must be CCFloat or CCInteger, not Number.",
      	"3611": "Can not indicate the '%s' attribute for %s, which its default value is type of %s.",
      	"3612": "%s Just set the default value to 'new %s()' and it will be handled properly.",
      	"3613": "'No need to use 'serializable: false' or 'editorOnly: true' for the getter of '%s.%s', every getter is actually non-serialized.",
      	"3614": "Should not define constructor for cc.Component %s.",
      	"3615": "Each script can have at most one Component.",
      	"3616": "Should not specify class name %s for Component which defines in project.",
      	"3618": "ctor of '%s' can not be another CCClass",
      	"3623": "Can not use 'editor' attribute, '%s' not inherits from Components.",
      	"3625": "[isChildClassOf] superclass should be function type, not",
      	"3626": "Can't remove '%s' because '%s' depends on it.",
      	"3627": "Should not add renderer component (%s) to a Canvas node.",
      	"3628": "Should not add %s to a node which size is already used by its other component.",
      	"3633": "Properties function of '%s' should return an object!",
      	"3634": "Disallow to use '.' in property name",
      	"3637": "Can not declare %s.%s, it is already defined in the prototype of %s",
      	"3639": "Can not apply the specified attribute to the getter of '%s.%s', attribute index: %s",
      	"3640": "'%s': the setter of '%s' is already defined!",
      	"3641": "Can not construct %s because it contains object property.",
      	"3644": "Please define 'type' parameter of %s.%s as the actual constructor.",
      	"3645": "Please define 'type' parameter of %s.%s as the constructor of %s.",
      	"3646": "Unknown 'type' parameter of %s.%s：%s",
      	"3647": "The length of range array must be equal or greater than 2",
      	"3648": "Can not declare %s.%s method, it is already defined in the properties of %s.",
      	"3652": "Failed to `new %s()` under the hood, %s\nIt is used for getting default values declared in TypeScript in the first place.\nPlease ensure the constructor can be called during the script's initialization.",
      	"3653": "Please do not specifiy \"default\" attribute in decorator of \"%s\" property in \"%s\" class.\nDefault value must be initialized at their declaration:\n\n \n// Before:\n@property({\n  type: cc.SpriteFrame\n  default: null  // <--\n})\nmyProp;\n// After:\n@property({\n  type: cc.SpriteFrame\n})\nmyProp = null;   // <--",
      	"3654": "Please specifiy a default value for \"%s.%s\" property at its declaration:\n\n \n// Before:\n@property(...)\nmyProp;\n// After:\n@property(...)\nmyProp = 0;",
      	"3655": "Can not specifiy \"get\" or \"set\"  attribute in decorator for \"%s\" property in \"%s\" class.\nPlease use:\n\n \n@property(...)\nget %s () {\n    ...\n}\n@property\nset %s (value) {\n    ...\n}",
      	"3659": "Violation error: extending enumerations shall have non-overlaped member names or member values",
      	"3660": "You are explicitly specifying `undefined` type to cc property \"%s\" of cc class \"%s\".\nIs this intended? If not, this may indicate a circular reference.\nFor example:\n\n \n// foo.ts\nimport { _decorator } from 'cc';\nimport { Bar } from './bar';  // Given that './bar' also reference 'foo.ts'.\n                              // When importing './bar', execution of './bar' is hung on to wait execution of 'foo.ts',\n                              // the `Bar` imported here is `undefined` until './bar' finish its execution.\n                              // It leads to that\n@_decorator.ccclass           //  ↓\nexport class Foo {            //  ↓\n    @_decorator.type(Bar)     //  → is equivalent to `@_decorator.type(undefined)`\n    public bar: Bar;          // To eliminate this error, either:\n                              // - Refactor your module structure(recommended), or\n                              // - specify the type as cc class name: `@_decorator.type('Bar'/* or any name you specified for `Bar` */)`\n}",
      	"3700": "internal error: _prefab is undefined",
      	"3701": "Failed to load prefab asset for node '%s'",
      	"3800": "The target can not be made persist because it's not a cc.Node or it doesn't have _id property.",
      	"3801": "The node can not be made persist because it's not under root node.",
      	"3802": "The node can not be made persist because it's not in current scene.",
      	"3803": "The target can not be made persist because it's not a cc.Node or it doesn't have _id property.",
      	"3804": "getComponent: Type must be non-nil",
      	"3805": "Can't add component '%s' because %s already contains the same component.",
      	"3806": "Can't add component '%s' to %s because it conflicts with the existing '%s' derived component.",
      	"3807": "addComponent: Failed to get class '%s'",
      	"3808": "addComponent: Should not add component ('%s') when the scripts are still loading.",
      	"3809": "addComponent: The component to add must be a constructor",
      	"3810": "addComponent: The component to add must be child class of cc.Component",
      	"3811": "_addComponentAt: The component to add must be a constructor",
      	"3812": "_addComponentAt: Index out of range",
      	"3813": "removeComponent: Component must be non-nil",
      	"3814": "Argument must be non-nil",
      	"3815": "Component not owned by this entity",
      	"3816": "Node '%s' is already activating",
      	"3817": "Sorry, the component of '%s' which with an index of %s is corrupted! It has been removed.",
      	"3818": "Failed to read or parse project.json",
      	"3819": "Warning: target element is not a DIV or CANVAS",
      	"3820": "The renderer doesn't support the renderMode %s",
      	"3821": "Cannot change hierarchy while activating or deactivating the parent.",
      	"3822": "addComponent: Cannot add any component to the scene.",
      	"3823": "The enabled component (id: %s, name: %s) doesn't have a valid node",
      	"3900": "Invalid clip to add",
      	"3901": "Invalid clip to remove",
      	"3902": "clip is defaultClip, set force to true to force remove clip and animation state",
      	"3903": "animation state is playing, set force to true to force stop and remove clip and animation state",
      	"3904": "motion path of target [%s] in prop [%s] frame [%s] is not valid",
      	"3905": "sprite frames must be an Array.",
      	"3906": "Can't find easing type [%s]",
      	"3907": "Animation state is not playing or already removed",
      	"3912": "already-playing",
      	"3920": "Current context does not allow root motion.",
      	"3921": "You provided a ill-formed track path. The last component of track path should be property key, or the setter should not be empty.",
      	"3923": "Root motion is ignored since root bone could not be located in animation.",
      	"3924": "Root motion is ignored since the root bone could not be located in scene.",
      	"3925": "Target of hierarchy path should be of type Node.",
      	"3926": "Node \"%s\" has no path \"%s\".",
      	"3927": "Target of component path should be of type Node.",
      	"3928": "Node \"%s\" has no component \"%s\".",
      	"3929": "Target object has no property \"%s\".",
      	"3930": "Can not decide type for untyped track: runtime binding does not provide a getter.",
      	"3931": "Can not decide type for untyped track: got a unsupported value from runtime binding.",
      	"3932": "Common targets should only target Vectors/`Size`/`Color`.",
      	"3933": "Each curve that has common target should be numeric curve and targets string property.",
      	"3934": "Misconfigured legacy curve: the first keyframe value is number but others aren't.",
      	"3935": "We don't currently support conversion of \\`CubicSplineQuatValue\\`.",
      	"3936": "Instancing/Batching enabled for non-baked skinning model '%s', this may result in unexpected rendering artifacts. Consider turning it off in the material if you do not intend to do this.",
      	"3937": "Previous error occurred when instantiating animation clip %s on node %s.",
      	"3938": "'%s' is not found from '%s'. It's specified as the root node to play animation clip '%s'.",
      	"3940": "Error when animation attempted to bind material uniform target: target %s is not a material.",
      	"3941": "Error when animation attempted to bind material uniform target: material %s has no recorded pass %s.",
      	"3942": "Error when animation attempted to bind material uniform target: material %s at pass %s has no recorded uniform %s.",
      	"3943": "Error when animation attempted to bind material uniform target: material %s at pass %s's uniform %s has no recorded channel %s.",
      	"4003": "Label font size can't be shirnked less than 0!",
      	"4004": "force notify all fonts loaded!",
      	"4011": "Property spriteFrame of Font '%s' is invalid. Using system font instead.",
      	"4012": "The texture of Font '%s' must be already loaded on JSB. Using system font instead.",
      	"4013": "Sorry, lineHeight of system font not supported on JSB.",
      	"4200": "MaskType: IMAGE_STENCIL only support WebGL mode.",
      	"4201": "The alphaThreshold invalid in Canvas Mode.",
      	"4202": "The inverted invalid in Canvas Mode.",
      	"4300": "Can not found the %s page.",
      	"4301": "Can not add a page without UITransform.",
      	"4302": "Can not set the scroll view content when it hasn't UITransform or its parent hasn't UITransform.",
      	"4303": "The %s scrollBar on the '%s' node is not available, please check it.",
      	"4400": "Invalid RichText img tag! The sprite frame name can't be found in the ImageAtlas!",
      	"4500": "Graphics: There is no model in %s.",
      	"4600": "Script attached to '%s' is missing or invalid.",
      	"4601": "Failed to load wasm module, WebAssembly is not supported on this platform, but as a fallback Asm.js module is culled by mistake.",
      	"4700": "The dom control is not created!",
      	"4800": "unknown asset type",
      	"4901": "loadRes: should not specify the extname in %s %s",
      	"4902": "No need to release non-cached asset.",
      	"4914": "Resources url '%s' does not exist.",
      	"4915": "Pack indices and data do not match in size",
      	"4916": "Failed to download package for %s",
      	"4921": "Invalid pipe or invalid index provided!",
      	"4922": "The pipe to be inserted is already in the pipeline!",
      	"4923": "Uuid Loader: Parse asset [ %s ] failed : %s",
      	"4924": "JSON Loader: Input item doesn't contain string content",
      	"4925": "Uuid Loader: Deserialize asset [ %s ] failed : %s",
      	"4926": "Audio Downloader: no web audio context.",
      	"4927": "Audio Downloader: audio not supported on this browser!",
      	"4928": "Load %s failed!",
      	"4929": "Load Webp ( %s ) failed",
      	"4930": "Load image ( %s ) failed",
      	"4932": "Since v1.10, for any atlas (\"%s\") in the \"resources\" directory, it is not possible to find the contained SpriteFrames via `loadRes`, `getRes` or `releaseRes`. Load the SpriteAtlas first and then use `spriteAtlas.getSpriteFrame(name)` instead please.",
      	"4933": "Download Font [ %s ] failed, using Arial or system default font instead",
      	"4934": "Please assure that the full path of sub asset is correct!",
      	"4935": "Failed to skip prefab asset while deserializing PrefabInfo",
      	"5000": "You are trying to destroy a object twice or more.",
      	"5001": "object not yet destroyed",
      	"5100": "Not a plist file!",
      	"5200": "Warning: localStorage isn't enabled. Please confirm browser cookie or privacy option",
      	"5201": "browser don't support web audio",
      	"5202": "This feature supports WebGL render mode only.",
      	"5300": "Type of target to deserialize not matched with data: target is %s, data is %s",
      	"5301": "Can not find script '%s'",
      	"5302": "Can not find class '%s'",
      	"5303": "Failed to deserialize %s, missing _deserialize function.",
      	"5304": "Unable to deserialize version %s data.",
      	"5402": "cc.js.addon called on non-object:",
      	"5403": "cc.js.mixin: arguments must be type object:",
      	"5404": "The base class to extend from must be non-nil",
      	"5405": "The class to extend must be non-nil",
      	"5406": "Class should be extended before assigning any prototype members.",
      	"5500": "'notify' can not be used in 'get/set' !",
      	"5501": "'notify' must be used with 'default' !",
      	"5507": "The 'default' attribute of '%s.%s' must be an array",
      	"5508": "Invalid type of %s.%s",
      	"5510": "The 'type' attribute of '%s.%s' can not be 'Number', use cc.Float or cc.Integer instead please.",
      	"5511": "The 'type' attribute of '%s.%s' is undefined when loading script",
      	"5512": "Can not serialize '%s.%s' because the specified type is anonymous, please provide a class name or set the 'serializable' attribute of '%s.%s' to 'false'.",
      	"5513": "The 'default' value of '%s.%s' should not be used with a 'get' function.",
      	"5514": "The 'default' value of '%s.%s' should not be used with a 'set' function.",
      	"5515": "The 'default' value of '%s.%s' can not be an constructor. Set default to null please.",
      	"5517": "'%s.%s' hides inherited property '%s.%s'. To make the current property override that implementation, add the `override: true` attribute please.",
      	"5601": "Can not get current scene.",
      	"5602": "Scene is destroyed",
      	"5603": "reference node is destroyed",
      	"5700": "no %s or %s on %s",
      	"5800": "%s.lerp not yet implemented.",
      	"5801": "%s.clone not yet implemented.",
      	"5802": "%s.equals not yet implemented.",
      	"5900": "MotionStreak only support WebGL mode.",
      	"5901": "cc.MotionStreak.getOpacity has not been supported.",
      	"5902": "cc.MotionStreak.setOpacity has not been supported.",
      	"6000": "Custom should not be false if file is not specified.",
      	"6001": "The new %s must not be NaN",
      	"6017": "Incomplete or corrupt PNG file",
      	"6018": "Invalid filter algorithm: %s",
      	"6019": "Invalid byte order value.",
      	"6020": "You forgot your towel!",
      	"6021": "Unknown Field Tag: %s",
      	"6022": "Too many bits requested",
      	"6023": "No bits requested",
      	"6024": "Cannot recover from missing StripByteCounts",
      	"6025": "Cannot handle sub-byte bits per sample",
      	"6026": "Cannot handle sub-byte bits per pixel",
      	"6027": "Palette image missing color map",
      	"6028": "Unknown Photometric Interpretation: %s",
      	"6029": "Unkown error",
      	"6030": "cc.ParticleSystem: error decoding or ungzipping textureImageData",
      	"6031": "cc.ParticleSystem: unknown image format with Data",
      	"6032": "cc.ParticleSystem.initWithDictionary() : error loading the texture",
      	"6033": "cc.ParticleSystem: not allowing create to be invoked twice with different particle system",
      	"6034": "cc.ParticleSystem: shouldn't be initialized repetitively, otherwise there will be potential leak",
      	"6035": "cc.ParticleSystem: change material failed, please use proper particle material",
      	"6036": "cc.ParticleSystem: life time should bigger than 1 or buffer will be insufficient",
      	"6400": "asset.url is not usable in core process",
      	"6402": "AssetLibrary has already been initialized!",
      	"6500": "Widget target must be one of the parent nodes of it",
      	"6600": "collider not added or already removed",
      	"6601": "Can't find testFunc for (%s, $s).",
      	"6700": "Can't init canvas '%s' because it conflicts with the existing '%s', the scene should only have one active canvas at the same time.",
      	"6705": "Argument must be non-nil",
      	"6706": "Priority can't be set in RenderRoot2D node",
      	"6800": "Callback of event must be non-nil",
      	"6801": "The message must be provided",
      	"6900": "The thing you want to instantiate must be an object",
      	"6901": "The thing you want to instantiate is nil",
      	"6902": "The thing you want to instantiate is destroyed",
      	"6903": "The instantiate method for given asset do not implemented",
      	"6904": "Can not instantiate array",
      	"6905": "Can not instantiate DOM element",
      	"7100": "%s already defined in Enum.",
      	"7101": "Sorry, 'cc.Enum' not available on this platform, please report this error here: <https://github.com/cocos-creator/engine/issues/new>",
      	"7200": "Method 'initWithTMXFile' is no effect now, please set property 'tmxAsset' instead.",
      	"7201": "Method 'initWithXML' is no effect now, please set property 'tmxAsset' instead.",
      	"7202": "Add component TiledLayer into node failed.",
      	"7203": "Property 'mapLoaded' is unused now. Please write the logic to the callback 'start'.",
      	"7210": "TMX Hexa zOrder not supported",
      	"7211": "TMX invalid value",
      	"7215": "cocos2d: Warning: TMX Layer %s has no tiles",
      	"7216": "cocos2d: TMXFormat: Unsupported TMX version: %s",
      	"7217": "cocos2d: TMXFomat: Unsupported orientation: %s",
      	"7218": "cc.TMXMapInfo.parseXMLFile(): unsupported compression method",
      	"7219": "cc.TMXMapInfo.parseXMLFile(): Only base64 and/or gzip/zlib maps are supported",
      	"7221": "cc.TMXMapInfo.parseXMLFile(): Texture '%s' not found.",
      	"7222": "Parse %s failed.",
      	"7236": "cc.TMXLayer.getTileAt(): TMXLayer: the tiles map has been released",
      	"7237": "cc.TMXLayer.getTileGIDAt(): TMXLayer: the tiles map has been released",
      	"7238": "cc.TMXLayer.setTileGID(): TMXLayer: the tiles map has been released",
      	"7239": "cc.TMXLayer.setTileGID(): invalid gid: %s",
      	"7240": "cc.TMXLayer.getTileFlagsAt(): TMXLayer: the tiles map has been released",
      	"7241": "cc.TiledMap.initWithXML(): Map not found. Please check the filename.",
      	"7401": "Failed to set _defaultArmatureIndex for '%s' because the index is out of range.",
      	"7402": "Failed to set _animationIndex for '%s' because the index is out of range.",
      	"7501": "Failed to set _defaultSkinIndex for '%s' because the index is out of range.",
      	"7502": "Failed to set _animationIndex for '%s' because its skeletonData is invalid.",
      	"7503": "Failed to set _animationIndex for '%s' because the index is out of range.",
      	"7504": "Can not render dynamic created SkeletonData",
      	"7506": "Failed to load spine atlas '$s'",
      	"7507": "Please re-import '%s' because its textures is not initialized! (This workflow will be improved in the future.)",
      	"7508": "The atlas asset of '%s' is not exists!",
      	"7509": "Spine: Animation not found: %s",
      	"7510": "Spine: Animation not found: %s",
      	"7511": "Spine: Invalid input!",
      	"7600": "The context of RenderTexture is invalid.",
      	"7601": "cc.RenderTexture._initWithWidthAndHeightForWebGL() : only RGB and RGBA formats are valid for a render texture;",
      	"7602": "Could not attach texture to the framebuffer",
      	"7603": "clearDepth isn't supported on Cocos2d-Html5",
      	"7604": "saveToFile isn't supported on Cocos2d-Html5",
      	"7605": "newCCImage isn't supported on Cocos2d-Html5",
      	"7606": "GFXTexture is null",
      	"7607": "readPixels buffer size smaller than %d",
      	"7700": "On the web is always keep the aspect ratio",
      	"7701": "Can't know status",
      	"7702": "Video player's duration is not ready to get now!",
      	"7703": "Video Downloader: video not supported on this browser!",
      	"7800": "Web does not support loading",
      	"7801": "Web does not support query history",
      	"7802": "Web does not support query history",
      	"7803": "The current browser does not support the GoBack",
      	"7804": "The current browser does not support the GoForward",
      	"7805": "Web does not support zoom",
      	"7900": "cc.math.Matrix3.assign(): current matrix equals matIn",
      	"7901": "cc.math.mat4Assign(): pOut equals pIn",
      	"7902": "cc.mat.Matrix4.assignFrom(): mat4 equals current matrix",
      	"7903": "cc.math.Matrix4 equal: pMat1 and pMat2 are same object.",
      	"7904": "cc.math.Matrix4.extractPlane: Invalid plane index",
      	"7905": "cc.math.mat4Assign(): pOut equals pIn",
      	"7906": "cc.mat.Matrix4.assignFrom(): mat4 equals current matrix",
      	"7907": "cc.math.Matrix4 equals: pMat1 and pMat2 are same object.",
      	"7908": "Invalid matrix mode specified",
      	"7909": "current quaternion is an invalid value",
      	"8000": "Can't handle this field type or size",
      	"8001": "No bytes requested",
      	"8002": "Too many bytes requested",
      	"8003": "Missing StripByteCounts!",
      	"8100": "cocos2d: ERROR: Failed to compile shader:\n %s",
      	"8101": "cocos2d: ERROR: Failed to compile vertex shader",
      	"8102": "cocos2d: ERROR: Failed to compile fragment shader",
      	"8103": "cc.GLProgram.link(): Cannot link invalid program",
      	"8104": "cocos2d: ERROR: Failed to link program: %s",
      	"8105": "cocos2d: cc.shaderCache._loadDefaultShader, error shader type",
      	"8106": "Please load the resource firset : %s",
      	"8107": "cc.GLProgram.getUniformLocationForName(): uniform name should be non-null",
      	"8108": "cc.GLProgram.getUniformLocationForName(): Invalid operation. Cannot get uniform location when program is not initialized",
      	"8109": "modelView matrix is undefined.",
      	"8200": "Please set node's active instead of rigidbody's enabled.",
      	"8300": "Should only one camera exists, please check your project.",
      	"8301": "Camera does not support Canvas Mode.",
      	"8302": "Camera.viewport is deprecated, please use setViewportInOrientedSpace instead.",
      	"8400": "Wrong type arguments, 'filePath' must be a String.",
      	"9000": "Stencil manager does not support level bigger than %d in this device.",
      	"9001": "Stencil manager is already empty, cannot pop any mask",
      	"9002": "Failed to request any buffer from a mesh buffer without accessor",
      	"9003": "The internal state of LinearBufferAccessor have severe issue and irreversible, please check the reason",
      	"9004": "Failed to allocate chunk in StaticVBAccessor, the requested buffer might be too large: %d bytes",
      	"9005": "BATCHER2D_MEM_INCREMENT is too large, the Max value for BATCHER2D_MEM_INCREMENT is 2303KB (smaller than 65536 *9* 4 / 1024 = 2304KB)",
      	"9006": "QuadRenderData is removed, please use MeshRenderData instead.",
      	"9007": "Since v3.6, Because mask changes the inheritance relationship, you can directly manipulate the rendering components under the same node to complete the operation.",
      	"9100": "texture size exceeds current device limits %d/%d",
      	"9101": "The length of the TypedArrayBuffer must be an integer.",
      	"9201": "Cannot access game frame or container.",
      	"9202": "Setting window size is not supported.",
      	"9300": "The current buffer beyond the limit in ui static component, please reduce the amount",
      	"9301": "The UI has not been initialized",
      	"9302": "Can't getGFXSampler with out device",
      	"9600": "[Physics]: please check to see if physics modules are included",
      	"9610": "[Physics]: cannon.js physics system doesn't support capsule collider",
      	"9611": "[Physics]: builtin physics system doesn't support mesh collider",
      	"9612": "[Physics]: builtin physics system doesn't support cylinder collider",
      	"9613": "[Physics]: cannon.js physics system doesn't support hinge drive and angular limit",
      	"9620": "[Physics][Ammo]: changing the mesh is not supported after the initialization is completed",
      	"9630": "[Physics]: A dynamic rigid body can not have the following collider shapes: Terrain, Plane and Non-convex Mesh. Node name: %s",
      	"9640": "[Physics][builtin]: sweep functions are not supported in builtin",
      	"9641": "[Physics][cannon.js]: sweep functions are not supported in cannon.js",
      	"10001": "The sub-mesh contains %d vertices, which beyonds the capability (%d vertices most) of renderer of your platform.",
      	"10002": "Sub-mesh may include at most %d morph targets, but you specified %d.",
      	"11000": "WebGL context lost.",
      	"12001": "BlendFactors are disabled when using custom material, please modify the blend state in the material instead.",
      	"12002": "Can't add renderable component to this node because it already have one.",
      	"12004": "SubModel can only support %d passes.",
      	"12005": "Material already initialized, request aborted.",
      	"12006": "Pass already destroyed.",
      	"12007": "This is old usage, please swap the parameters.",
      	"12008": "GeometryRenderer: too many lines.",
      	"12009": "GeometryRenderer: too many triangles.",
      	"12010": "PassUtils: illegal uniform handle, accessing uniform at offset %d",
      	"12011": "Pass: setUniform is invoked with incompatible uniform data type for binding %d, expected type is %s",
      	"12012": "Can't set a material instance to a sharedMaterial slot",
      	"12100": "The font size is too big to be fitted into texture atlas. Please switch to other label cache modes or choose a smaller font size.",
      	"12101": "The asset %s has been destroyed!",
      	"12102": "Base pass cannot override states, please use pass instance instead.",
      	"12103": "Custom pipeline create shader %s failed. Please restart editor.",
      	"12104": "Create shader %s failed.",
      	"12105": "Pass resources incomplete.",
      	"12106": "Cannot patch non-builtin macros.",
      	"12107": "Custom pipeline invalid render pass, program: %s. Please restart editor.",
      	"12108": "Custom pipeline invalid render phase, program: %s. Please restart editor.",
      	"13100": "Incorrect CCON magic.",
      	"13101": "Unknown CCON version number: %d.",
      	"13102": "CCON Format error.",
      	"13103": "Can not encode CCON binary: lack of text encoder.",
      	"13104": "Can not decode CCON binary: lack of text decoder.",
      	"14000": "State machine matched too many transitions(greater than %s) during this frame: %s.",
      	"14100": "Pool.destroy no longer take a function as parameter, Please specify destruct function in the construction of Pool instead",
      	"14200": "Can not update a static mesh.",
      	"14201": "The primitiveIndex is out of range.",
      	"14202": "meshopt asm decoder initialized",
      	"14203": "meshopt wasm decoder initialized",
      	"14204": "meshopt decoder error: %d",
      	"14300": "Can not keep world transform due to the zero scaling of parent node",
      	"14400": "Spline error: less than 2 knots.",
      	"14401": "Spline error: less than 4 knots or not a multiple of 4.\n\n<!-- Rendering algorithm reserved: 15000 - 16000 -->",
      	"15000": "Can not find corresponding diffuse map for environment lighting, use hemisphere diffuse instead, change environment lighting type to regenerate diffuse map",
      	"15001": "Can not find environment map, disable IBL lighting",
      	"15002": "Diffuse map resource is missing, please change environment lighting type to regenerate resource",
      	"15003": "The shadow visible distance is so small that CSM stratification is not effective, Please change the value of shadowDistance so that it is 10 times greater than 0.1",
      	"15004": "The native folder may be generated from older versions, please refer https://docs.cocos.com/creator/manual/en/release-notes/ to upgrade.",
      	"15100": "Camera '%s' clear flag is skybox, but skybox is disabled,  may cause strange background effect, please set camera clear flag to solid color.",
      	"16000": "'%s' is deprecated since v%s.",
      	"16001": "'%s' is deprecated since v%s, please use '%s' instead.",
      	"16002": "'%s' is removed since v%s.",
      	"16003": "'%s' is removed since v%s, please use '%s' instead.",
      	"16101": "The effect('%s') you are looking for does not exist, please confirm the effect name in the editor. NOTE: Since 3.6, the name of the built-in effect has been changed to its name in the editor, please check it out. More information please refer to https://docs.cocos.com/creator/manual/en/shader/effect-inspector.html",
      	"16201": "The asset replacing failed, can not found override asset('%s') for '%s'",
      	"16301": "node '%s' doesn't have any ModelRenderer component, this component will not work. please add ModelRenderer component first",
      	"16302": "There is no reflection probe in the scene or no probe is near the current object. No reflection probe will take effect on this object. Please create a new reflection probe or move existing ones closer.",
      	"16303": "Skin material needs floating-point render target, please check ENABLE_FLOAT_OUTPUT define in Project Settings--Macro",
      	"16304": "Skin material may need more accurate calculations, please select a head model of standard size, check the isGlobalStandardSkinObject option in the MeshRender component.",
      	"0100": "%s not yet implemented.",
      	"0200": "You should specify a valid DOM canvas element."
      };

      const ccdocument$4 = ccwindow$1.document;
      let logList = null;
      let ccLog = console.log.bind(console);
      let ccWarn = ccLog;
      let ccError = ccLog;
      let ccAssert = (condition, message, ...optionalParams) => {
        if (!condition) {
          console.log(`ASSERT: ${formatString(message, ...optionalParams)}`);
        }
      };
      let ccDebug = ccLog;
      function formatString(...data) {
        return legacyCC.js.formatStr.apply(null, data);
      }
      function log(...data) {
        return ccLog(...data);
      }
      function warn(...data) {
        return ccWarn(...data);
      }
      function error(...data) {
        return ccError(...data);
      }
      function assert(condition, message, ...optionalParams) {
        return ccAssert(condition, message, ...optionalParams);
      }
      function debug(...data) {
        return ccDebug(...data);
      }
      function _resetDebugSetting(mode) {
        ccLog = ccWarn = ccError = ccAssert = ccDebug = () => {};
        if (mode === DebugMode.NONE) {
          return;
        }
        if (mode > DebugMode.ERROR) {
          const logToWebPage = msg => {
            if (!legacyCC.game.canvas) {
              return;
            }
            if (!logList) {
              const logDiv = ccdocument$4.createElement('Div');
              logDiv.setAttribute('id', 'logInfoDiv');
              logDiv.setAttribute('width', '200');
              logDiv.setAttribute('height', legacyCC.game.canvas.height);
              const logDivStyle = logDiv.style;
              logDivStyle.zIndex = '99999';
              logDivStyle.position = 'absolute';
              logDivStyle.top = logDivStyle.left = '0';
              logList = ccdocument$4.createElement('textarea');
              logList.setAttribute('rows', '20');
              logList.setAttribute('cols', '30');
              logList.setAttribute('disabled', 'true');
              const logListStyle = logList.style;
              logListStyle.backgroundColor = 'transparent';
              logListStyle.borderBottom = '1px solid #cccccc';
              logListStyle.borderTopWidth = logListStyle.borderLeftWidth = logListStyle.borderRightWidth = '0px';
              logListStyle.borderTopStyle = logListStyle.borderLeftStyle = logListStyle.borderRightStyle = 'none';
              logListStyle.padding = '0px';
              logListStyle.margin = '0px';
              logDiv.appendChild(logList);
              legacyCC.game.canvas.parentNode.appendChild(logDiv);
            }
            logList.value = `${logList.value + msg}\r\n`;
            logList.scrollTop = logList.scrollHeight;
          };
          ccError = (...data) => {
            logToWebPage(`ERROR :  ${formatString(...data)}`);
          };
          ccAssert = (condition, message, ...optionalParams) => {
            if (!condition) {
              logToWebPage(`ASSERT: ${formatString(message, ...optionalParams)}`);
            }
          };
          if (mode !== DebugMode.ERROR_FOR_WEB_PAGE) {
            ccWarn = (...data) => {
              logToWebPage(`WARN :  ${formatString(...data)}`);
            };
          }
          if (mode === DebugMode.INFO_FOR_WEB_PAGE) {
            ccLog = (...data) => {
              logToWebPage(formatString(...data));
            };
          }
        } else if (console) {
          if (!console.error) {
            console.error = console.log;
          }
          if (!console.warn) {
            console.warn = console.log;
          }
          if (console.error.bind) {
            ccError = console.error.bind(console);
          } else {
            ccError = console.error ;
          }
          ccAssert = (condition, message, ...optionalParams) => {
            if (!condition) {
              const errorText = formatString(message, ...optionalParams);
              {
                throw new Error(errorText);
              }
            }
          };
        }
        if (mode !== DebugMode.ERROR) {
          if (console.warn.bind) {
            ccWarn = console.warn.bind(console);
          } else {
            ccWarn = console.warn ;
          }
        }
        if (mode <= DebugMode.INFO) {
          {
            ccLog = console.log;
          }
        }
        if (mode <= DebugMode.VERBOSE) {
          if (typeof console.debug === 'function') {
            const vendorDebug = console.debug.bind(console);
            ccDebug = (...data) => vendorDebug(...data);
          }
        }
      }
      function _throw(error_) {
        {
          const stack = error_.stack;
          if (stack) {
            error(`${error_}\n${stack}` );
          } else {
            error(error_);
          }
          return undefined;
        }
      }
      function getTypedFormatter(type) {
        return (id, ...args) => {
          const msg = debugInfos[id] || 'unknown id' ;
          if (args.length === 0) {
            return msg;
          }
          return formatString(msg, ...args) ;
        };
      }
      const logFormatter = getTypedFormatter();
      function logID(id, ...optionalParams) {
        log(logFormatter(id, ...optionalParams));
      }
      const warnFormatter = getTypedFormatter();
      function warnID(id, ...optionalParams) {
        warn(warnFormatter(id, ...optionalParams));
      }
      const errorFormatter = getTypedFormatter();
      function errorID(id, ...optionalParams) {
        error(errorFormatter(id, ...optionalParams));
      }
      const assertFormatter = getTypedFormatter();
      function assertID(condition, id, ...optionalParams) {
        if (condition) {
          return;
        }
        assert(false, assertFormatter(id, ...optionalParams));
      }
      let DebugMode; exports('DebugMode', DebugMode);
      (function (DebugMode) {
        DebugMode[DebugMode["NONE"] = 0] = "NONE";
        DebugMode[DebugMode["VERBOSE"] = 1] = "VERBOSE";
        DebugMode[DebugMode["INFO"] = 2] = "INFO";
        DebugMode[DebugMode["WARN"] = 3] = "WARN";
        DebugMode[DebugMode["ERROR"] = 4] = "ERROR";
        DebugMode[DebugMode["INFO_FOR_WEB_PAGE"] = 5] = "INFO_FOR_WEB_PAGE";
        DebugMode[DebugMode["WARN_FOR_WEB_PAGE"] = 6] = "WARN_FOR_WEB_PAGE";
        DebugMode[DebugMode["ERROR_FOR_WEB_PAGE"] = 7] = "ERROR_FOR_WEB_PAGE";
      })(DebugMode || (exports('DebugMode', DebugMode = {})));
      function getError(errorId, ...param) {
        return errorFormatter(errorId, ...param);
      }
      function isDisplayStats() {
        return legacyCC.profiler ? legacyCC.profiler.isShowingStats() : false;
      }
      function setDisplayStats(displayStats) {
        if (legacyCC.profiler) {
          displayStats ? legacyCC.profiler.showStats() : legacyCC.profiler.hideStats();
        }
      }

      var debug$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        log: log,
        warn: warn,
        error: error,
        assert: assert,
        debug: debug,
        _resetDebugSetting: _resetDebugSetting,
        _throw: _throw,
        logID: logID,
        warnID: warnID,
        errorID: errorID,
        assertID: assertID,
        get DebugMode () { return DebugMode; },
        getError: getError,
        isDisplayStats: isDisplayStats,
        setDisplayStats: setDisplayStats
      });

      let defaultLogTimes = 10;
      function setDefaultLogTimes(times) {
        if (times > 0) {
          defaultLogTimes = times;
        }
      }
      let replaceProperty; exports('replaceProperty', replaceProperty);
      let removeProperty; exports('removeProperty', removeProperty);
      let markAsWarning; exports('markAsWarning', markAsWarning);
      let replacePropertyLog;
      let markAsWarningLog;
      let removePropertyLog;
      let messageID = 0;
      const messageMap = new Map();
      replacePropertyLog = (n, dp, n2, newp, f, id, s) => {
        const item = messageMap.get(id);
        if (item && item.logTimes > item.count) {
          f(`'%s' is deprecated, please use '%s' instead. ${s}`, `${n}.${dp}`, `${n2}.${newp}`);
          item.count++;
        }
      };
      exports('replaceProperty', replaceProperty = (owner, ownerName, properties) => {
        if (owner == null) return;
        properties.forEach(item => {
          const id = messageID++;
          messageMap.set(id, {
            id,
            count: 0,
            logTimes: item.logTimes !== undefined ? item.logTimes : defaultLogTimes
          });
          const target = item.target != null ? item.target : owner;
          const newName = item.newName != null ? item.newName : item.name;
          const targetName = item.targetName != null ? item.targetName : ownerName;
          const sameTarget = target === owner;
          const suggest = item.suggest ? `(${item.suggest})` : '';
          if (item.customFunction != null) {
            owner[item.name] = function () {
              replacePropertyLog(ownerName, item.name, targetName, newName, warn, id, suggest);
              return item.customFunction.call(this, ...arguments);
            };
          } else if (item.customSetter != null || item.customGetter != null) {
            const hasSetter = item.customSetter != null;
            const hasGetter = item.customGetter != null;
            if (hasSetter && hasGetter) {
              Object.defineProperty(owner, item.name, {
                get() {
                  replacePropertyLog(ownerName, item.name, targetName, newName, warn, id, suggest);
                  return item.customGetter.call(this);
                },
                set(v) {
                  replacePropertyLog(ownerName, item.name, targetName, newName, warn, id, suggest);
                  item.customSetter.call(this, v);
                },
                enumerable: false
              });
            } else if (hasSetter) {
              Object.defineProperty(owner, item.name, {
                set(v) {
                  replacePropertyLog(ownerName, item.name, targetName, newName, warn, id, suggest);
                  item.customSetter.call(this, v);
                },
                enumerable: false
              });
            } else if (hasGetter) {
              Object.defineProperty(owner, item.name, {
                get() {
                  replacePropertyLog(ownerName, item.name, targetName, newName, warn, id, suggest);
                  return item.customGetter.call(this);
                },
                enumerable: false
              });
            }
          } else {
            Object.defineProperty(owner, item.name, {
              get() {
                replacePropertyLog(ownerName, item.name, targetName, newName, warn, id, suggest);
                return sameTarget ? this[newName] : target[newName];
              },
              set(v) {
                replacePropertyLog(ownerName, item.name, targetName, newName, warn, id, suggest);
                if (sameTarget) {
                  this[newName] = v;
                } else {
                  target[newName] = v;
                }
              },
              enumerable: false
            });
          }
        });
      });
      removePropertyLog = (n, dp, f, id, s) => {
        const item = messageMap.get(id);
        if (item && item.logTimes > item.count) {
          f(`'%s' has been removed. ${s}`, `${n}.${dp}`);
          item.count++;
        }
      };
      exports('removeProperty', removeProperty = (owner, ownerName, properties) => {
        if (owner == null) return;
        properties.forEach(item => {
          const id = messageID++;
          messageMap.set(id, {
            id,
            count: 0,
            logTimes: item.logTimes !== undefined ? item.logTimes : defaultLogTimes
          });
          const suggest = item.suggest ? `(${item.suggest})` : '';
          Object.defineProperty(owner, item.name, {
            get() {
              return removePropertyLog(ownerName, item.name, error, id, suggest);
            },
            set() {
              removePropertyLog(ownerName, item.name, error, id, suggest);
            },
            enumerable: false
          });
        });
      });
      markAsWarningLog = (n, dp, f, id, s) => {
        const item = messageMap.get(id);
        if (item && item.logTimes > item.count) {
          f(`'%s' is deprecated. ${s}`, `${n}.${dp}`);
          item.count++;
        }
      };
      exports('markAsWarning', markAsWarning = (owner, ownerName, properties) => {
        if (owner == null) return;
        const _defaultGetSet = (d, n, dp, f, id, s) => {
          if (d.get) {
            const oldGet = d.get;
            d.get = function () {
              markAsWarningLog(n, dp, f, id, s);
              return oldGet.call(this);
            };
          }
          if (d.set) {
            const oldSet = d.set;
            d.set = function (v) {
              markAsWarningLog(n, dp, f, id, s);
              oldSet.call(this, v);
            };
          }
          Object.defineProperty(owner, dp, d);
        };
        properties.forEach(item => {
          const deprecatedProp = item.name;
          const descriptor = Object.getOwnPropertyDescriptor(owner, deprecatedProp);
          if (!descriptor || !descriptor.configurable) {
            return;
          }
          const id = messageID++;
          messageMap.set(id, {
            id,
            count: 0,
            logTimes: item.logTimes !== undefined ? item.logTimes : defaultLogTimes
          });
          const suggest = item.suggest ? `(${item.suggest})` : '';
          if (typeof descriptor.value !== 'undefined') {
            if (typeof descriptor.value === 'function') {
              const oldValue = descriptor.value;
              owner[deprecatedProp] = function () {
                markAsWarningLog(ownerName, deprecatedProp, warn, id, suggest);
                return oldValue.call(this, ...arguments);
              };
            } else {
              let oldValue = descriptor.value;
              Object.defineProperty(owner, deprecatedProp, {
                configurable: true,
                get() {
                  markAsWarningLog(ownerName, deprecatedProp, warn, id, suggest);
                  return oldValue;
                }
              });
              if (descriptor.writable) {
                Object.defineProperty(owner, deprecatedProp, {
                  set(value) {
                    markAsWarningLog(ownerName, deprecatedProp, warn, id, suggest);
                    oldValue = value;
                  }
                });
              }
            }
          } else {
            _defaultGetSet(descriptor, ownerName, deprecatedProp, warn, id, suggest);
          }
          Object.defineProperty(owner, deprecatedProp, {
            enumerable: false
          });
        });
      });
      const topLevelDeprecateList = {};
      function deprecateModuleExportedName(deprecateList) {
        for (let deprecateName in deprecateList) {
          const deprecateInfo = deprecateList[deprecateName];
          topLevelDeprecateList[deprecateName] = deprecateInfo;
        }
      }
      function _checkObsoleteByName(checkName) {
        const deprecateInfo = topLevelDeprecateList[checkName];
        if (!deprecateInfo) {
          return;
        }
        const {
          newName,
          since,
          removed
        } = deprecateInfo;
        if (removed) {
          if (newName) {
            errorID(16003, checkName, since, newName);
          } else {
            errorID(16002, checkName, since);
          }
        } else if (newName) {
          warnID(16001, checkName, since, newName);
        } else {
          warnID(16000, checkName, since);
        }
      }
      function __checkObsolete__(checkList) {
        for (let checkName of checkList) {
          _checkObsoleteByName(checkName);
        }
      }
      let _cachedProxy;
      function __checkObsoleteInNamespace__(ccNamespace) {
        if (!_cachedProxy) {
          if (typeof Proxy === 'undefined') {
            _cachedProxy = {};
          } else {
            _cachedProxy = new Proxy(ccNamespace, {
              get(target, name, receiver) {
                _checkObsoleteByName(name);
                return Reflect.get(target, name, receiver);
              }
            });
          }
        }
        return _cachedProxy;
      }

      var _class$17;
      const NonUuidMark = '.';
      class IDGenerator {
        constructor(category) {
          this.id = void 0;
          this.prefix = void 0;
          this.id = 0 | Math.random() * 998;
          this.prefix = category ? category + NonUuidMark : '';
        }
        getNewId() {
          return this.prefix + (++this.id).toString();
        }
      }
      _class$17 = IDGenerator;
      IDGenerator.global = new _class$17('global');

      const tempCIDGenerator = new IDGenerator('TmpCId.');
      const aliasesTag = typeof Symbol === 'undefined' ? '__aliases__' : Symbol('[[Aliases]]');
      const classNameTag = '__classname__';
      const classIdTag = '__cid__';
      function isNumber(object) {
        return typeof object === 'number' || object instanceof Number;
      }
      function isString(object) {
        return typeof object === 'string' || object instanceof String;
      }
      function isEmptyObject(obj) {
        for (const key in obj) {
          return false;
        }
        return true;
      }
      const value = (() => {
        const descriptor = {
          value: undefined,
          enumerable: false,
          writable: false,
          configurable: true
        };
        return (object, propertyName, value_, writable, enumerable) => {
          descriptor.value = value_;
          descriptor.writable = writable;
          descriptor.enumerable = enumerable;
          Object.defineProperty(object, propertyName, descriptor);
          descriptor.value = undefined;
        };
      })();
      const getset = (() => {
        const descriptor = {
          get: undefined,
          set: undefined,
          enumerable: false
        };
        return (object, propertyName, getter, setter, enumerable = false, configurable = false) => {
          if (typeof setter === 'boolean') {
            console.log('Set `setter` to boolean is deprecated. Please don not use like this again.');
            enumerable = setter;
            setter = undefined;
          }
          descriptor.get = getter;
          descriptor.set = setter;
          descriptor.enumerable = enumerable;
          descriptor.configurable = configurable;
          Object.defineProperty(object, propertyName, descriptor);
          descriptor.get = undefined;
          descriptor.set = undefined;
        };
      })();
      const get = (() => {
        const descriptor = {
          get: undefined,
          enumerable: false,
          configurable: false
        };
        return (object, propertyName, getter, enumerable, configurable) => {
          descriptor.get = getter;
          descriptor.enumerable = enumerable;
          descriptor.configurable = configurable;
          Object.defineProperty(object, propertyName, descriptor);
          descriptor.get = undefined;
        };
      })();
      const set = (() => {
        const descriptor = {
          set: undefined,
          enumerable: false,
          configurable: false
        };
        return (object, propertyName, setter, enumerable, configurable) => {
          descriptor.set = setter;
          descriptor.enumerable = enumerable;
          descriptor.configurable = configurable;
          Object.defineProperty(object, propertyName, descriptor);
          descriptor.set = undefined;
        };
      })();
      function createMap(forceDictMode) {
        const map = Object.create(null);
        if (forceDictMode) {
          const INVALID_IDENTIFIER_1 = '.';
          const INVALID_IDENTIFIER_2 = '/';
          map[INVALID_IDENTIFIER_1] = 1;
          map[INVALID_IDENTIFIER_2] = 1;
          delete map[INVALID_IDENTIFIER_1];
          delete map[INVALID_IDENTIFIER_2];
        }
        return map;
      }
      function getClassName(objOrCtor) {
        if (typeof objOrCtor === 'function') {
          const prototype = objOrCtor.prototype;
          if (prototype && prototype.hasOwnProperty(classNameTag) && prototype[classNameTag]) {
            return prototype[classNameTag];
          }
          let ret = '';
          if (objOrCtor.name) {
            ret = objOrCtor.name;
          }
          if (objOrCtor.toString) {
            let arr;
            const str = objOrCtor.toString();
            if (str.charAt(0) === '[') {
              arr = /\[\w+\s*(\w+)\]/.exec(str);
            } else {
              arr = /function\s*(\w+)/.exec(str);
            }
            if (arr && arr.length === 2) {
              ret = arr[1];
            }
          }
          return ret !== 'Object' ? ret : '';
        } else if (objOrCtor && objOrCtor.constructor) {
          return getClassName(objOrCtor.constructor);
        }
        return '';
      }
      function obsolete(object, obsoleted, newExpr, writable) {
        const extractPropName = /([^.]+)$/;
        const oldProp = extractPropName.exec(obsoleted)[0];
        const newProp = extractPropName.exec(newExpr)[0];
        function getter() {
          return this[newProp];
        }
        function setter(value_) {
          this[newProp] = value_;
        }
        if (writable) {
          getset(object, oldProp, getter, setter);
        } else {
          get(object, oldProp, getter);
        }
      }
      function obsoletes(obj, objName, props, writable) {
        for (const obsoleted in props) {
          const newName = props[obsoleted];
          obsolete(obj, `${objName}.${obsoleted}`, newName, writable);
        }
      }
      const REGEXP_NUM_OR_STR = /(%d)|(%s)/;
      const REGEXP_STR = /%s/;
      function formatStr(msg, ...subst) {
        if (arguments.length === 0) {
          return '';
        }
        if (subst.length === 0) {
          return `${msg}`;
        }
        const hasSubstitution = typeof msg === 'string' && REGEXP_NUM_OR_STR.test(msg);
        if (hasSubstitution) {
          for (const arg of subst) {
            const regExpToTest = typeof arg === 'number' ? REGEXP_NUM_OR_STR : REGEXP_STR;
            if (regExpToTest.test(msg)) {
              const notReplaceFunction = `${arg}`;
              msg = msg.replace(regExpToTest, notReplaceFunction);
            } else {
              msg += ` ${arg}`;
            }
          }
        } else {
          for (const arg of subst) {
            msg += ` ${arg}`;
          }
        }
        return msg;
      }
      function shiftArguments() {
        const len = arguments.length - 1;
        const args = new Array(len);
        for (let i = 0; i < len; ++i) {
          args[i] = arguments[i + 1];
        }
        return args;
      }
      function getPropertyDescriptor(object, propertyName) {
        while (object) {
          const pd = Object.getOwnPropertyDescriptor(object, propertyName);
          if (pd) {
            return pd;
          }
          object = Object.getPrototypeOf(object);
        }
        return null;
      }
      function _copyProp(name, source, target) {
        const pd = getPropertyDescriptor(source, name);
        if (pd) {
          Object.defineProperty(target, name, pd);
        }
      }
      function copyAllProperties(source, target, excepts) {
        const propertyNames = Object.getOwnPropertyNames(source);
        for (let i = 0, len = propertyNames.length; i < len; ++i) {
          const propertyName = propertyNames[i];
          if (excepts.indexOf(propertyName) !== -1) {
            continue;
          }
          _copyProp(propertyName, source, target);
        }
      }
      function addon(object, ...sources) {
        object = object || {};
        for (const source of sources) {
          if (source) {
            if (typeof source !== 'object') {
              errorID(5402, source);
              continue;
            }
            for (const name in source) {
              if (!(name in object)) {
                _copyProp(name, source, object);
              }
            }
          }
        }
        return object;
      }
      function mixin(object, ...sources) {
        object = object || {};
        for (const source of sources) {
          if (source) {
            if (typeof source !== 'object') {
              errorID(5403, source);
              continue;
            }
            for (const name in source) {
              _copyProp(name, source, object);
            }
          }
        }
        return object;
      }
      function extend(cls, base) {
        for (const p in base) {
          if (base.hasOwnProperty(p)) {
            cls[p] = base[p];
          }
        }
        cls.prototype = Object.create(base.prototype, {
          constructor: {
            value: cls,
            writable: true,
            configurable: true
          }
        });
        return cls;
      }
      function getSuper(constructor) {
        const proto = constructor.prototype;
        const dunderProto = proto && Object.getPrototypeOf(proto);
        return dunderProto && dunderProto.constructor;
      }
      function isChildClassOf(subclass, superclass) {
        if (subclass && superclass) {
          if (typeof subclass !== 'function') {
            return false;
          }
          if (typeof superclass !== 'function') {
            return false;
          }
          if (subclass === superclass) {
            return true;
          }
          for (;;) {
            subclass = getSuper(subclass);
            if (!subclass) {
              return false;
            }
            if (subclass === superclass) {
              return true;
            }
          }
        }
        return false;
      }
      function clear$1(object) {
        for (const key of Object.keys(object)) {
          delete object[key];
        }
      }
      function isTempClassId(id) {
        return typeof id !== 'string' || id.startsWith(tempCIDGenerator.prefix);
      }
      const _idToClass = createMap(true);
      const _nameToClass = createMap(true);
      function setup(tag, table, allowExist) {
        return function (id, constructor) {
          if (constructor.prototype.hasOwnProperty(tag)) {
            delete table[constructor.prototype[tag]];
          }
          value(constructor.prototype, tag, id);
          if (id) {
            const registered = table[id];
            if (!allowExist && registered && registered !== constructor) {
              let err = `A Class already exists with the same ${tag} : "${id}".`;
              error(err);
            } else {
              table[id] = constructor;
            }
          }
        };
      }
      const _setClassId = setup('__cid__', _idToClass, false);
      const doSetClassName = setup('__classname__', _nameToClass, true);
      function setClassName(className, constructor) {
        doSetClassName(className, constructor);
        if (!constructor.prototype.hasOwnProperty(classIdTag)) {
          const id = className || tempCIDGenerator.getNewId();
          if (id) {
            _setClassId(id, constructor);
          }
        }
      }
      function setClassAlias(target, alias) {
        const nameRegistry = _nameToClass[alias];
        const idRegistry = _idToClass[alias];
        let ok = true;
        if (nameRegistry && nameRegistry !== target) {
          error(`"${alias}" has already been set as name or alias of another class.`);
          ok = false;
        }
        if (idRegistry && idRegistry !== target) {
          error(`"${alias}" has already been set as id or alias of another class.`);
          ok = false;
        }
        if (ok) {
          let classAliases = target[aliasesTag];
          if (!classAliases) {
            classAliases = [];
            target[aliasesTag] = classAliases;
          }
          classAliases.push(alias);
          _nameToClass[alias] = target;
          _idToClass[alias] = target;
        }
      }
      function unregisterClass(...constructors) {
        for (const constructor of constructors) {
          const p = constructor.prototype;
          const classId = p[classIdTag];
          if (classId) {
            delete _idToClass[classId];
          }
          const classname = p[classNameTag];
          if (classname) {
            delete _nameToClass[classname];
          }
          const aliases = p[aliasesTag];
          if (aliases) {
            for (let iAlias = 0; iAlias < aliases.length; ++iAlias) {
              const alias = aliases[iAlias];
              delete _nameToClass[alias];
              delete _idToClass[alias];
            }
          }
        }
      }
      function _getClassById(classId) {
        return getClassById(classId);
      }
      function getClassById(classId) {
        return _idToClass[classId];
      }
      function getClassByName(classname) {
        return _nameToClass[classname];
      }
      function _getClassId(obj, allowTempId) {
        return getClassId(obj, allowTempId);
      }
      function getClassId(obj, allowTempId) {
        allowTempId = typeof allowTempId !== 'undefined' ? allowTempId : true;
        let res;
        if (typeof obj === 'function' && obj.prototype.hasOwnProperty(classIdTag)) {
          res = obj.prototype[classIdTag];
          if (!allowTempId && (EDITOR) && isTempClassId(res)) {
            return '';
          }
          return res;
        }
        if (obj && obj.constructor) {
          const prototype = obj.constructor.prototype;
          if (prototype && prototype.hasOwnProperty(classIdTag)) {
            res = obj[classIdTag];
            if (!allowTempId && (EDITOR) && isTempClassId(res)) {
              return '';
            }
            return res;
          }
        }
        return '';
      }

      class Pool$1 {
        get() {
          return this._get();
        }
        constructor(_0, _1) {
          this.count = void 0;
          this._pool = void 0;
          this._cleanup = void 0;
          const size = _1 === undefined ? _0 : _1;
          const cleanupFunc = _1 === undefined ? null : _0;
          this.count = 0;
          this._pool = new Array(size);
          this._cleanup = cleanupFunc;
        }
        _get() {
          if (this.count > 0) {
            --this.count;
            const cache = this._pool[this.count];
            this._pool[this.count] = null;
            return cache;
          }
          return null;
        }
        put(obj) {
          const pool = this._pool;
          if (this.count < pool.length) {
            if (this._cleanup && this._cleanup(obj) === false) {
              return;
            }
            pool[this.count] = obj;
            ++this.count;
          }
        }
        resize(length) {
          if (length >= 0) {
            this._pool.length = length;
            if (this.count > length) {
              this.count = length;
            }
          }
        }
      }

      class MutableForwardIterator {
        constructor(array) {
          this.i = 0;
          this.array = array;
        }
        get length() {
          return this.array.length;
        }
        set length(value) {
          this.array.length = value;
          if (this.i >= value) {
            this.i = value - 1;
          }
        }
        remove(value) {
          const index = this.array.indexOf(value);
          if (index >= 0) {
            this.removeAt(index);
          }
        }
        removeAt(i) {
          this.array.splice(i, 1);
          if (i <= this.i) {
            --this.i;
          }
        }
        fastRemove(value) {
          const index = this.array.indexOf(value);
          if (index >= 0) {
            this.fastRemoveAt(index);
          }
        }
        fastRemoveAt(i) {
          const array = this.array;
          array[i] = array[array.length - 1];
          --array.length;
          if (i <= this.i) {
            --this.i;
          }
        }
        push(item) {
          this.array.push(item);
        }
      }

      function removeAt(array, index) {
        array.splice(index, 1);
      }
      function fastRemoveAt$2(array, index) {
        const length = array.length;
        if (index < 0 || index >= length) {
          return;
        }
        array[index] = array[length - 1];
        array.length = length - 1;
      }
      function remove(array, value) {
        const index = array.indexOf(value);
        if (index >= 0) {
          removeAt(array, index);
          return true;
        } else {
          return false;
        }
      }
      function fastRemove(array, value) {
        const index = array.indexOf(value);
        if (index >= 0) {
          array[index] = array[array.length - 1];
          --array.length;
        }
      }
      function removeIf(array, predicate) {
        const index = array.findIndex(predicate);
        if (index >= 0) {
          const value = array[index];
          removeAt(array, index);
          return value;
        }
      }
      function verifyType(array, type) {
        if (array && array.length > 0) {
          for (const item of array) {
            if (!(item instanceof type)) {
              logID(1300);
              return false;
            }
          }
        }
        return true;
      }
      function removeArray(array, removals) {
        for (let i = 0, l = removals.length; i < l; i++) {
          remove(array, removals[i]);
        }
      }
      function appendObjectsAt(array, objects, index) {
        array.splice.apply(array, [index, 0, ...objects]);
        return array;
      }
      function contains$2(array, value) {
        return array.indexOf(value) >= 0;
      }
      function copy(array) {
        const len = array.length;
        const cloned = new Array(len);
        for (let i = 0; i < len; i += 1) {
          cloned[i] = array[i];
        }
        return cloned;
      }

      var array = /*#__PURE__*/Object.freeze({
        __proto__: null,
        removeAt: removeAt,
        fastRemoveAt: fastRemoveAt$2,
        remove: remove,
        fastRemove: fastRemove,
        removeIf: removeIf,
        verifyType: verifyType,
        removeArray: removeArray,
        appendObjectsAt: appendObjectsAt,
        contains: contains$2,
        copy: copy,
        MutableForwardIterator: MutableForwardIterator
      });

      const js = {
        IDGenerator,
        Pool: Pool$1,
        array,
        isNumber,
        isString,
        isEmptyObject,
        getPropertyDescriptor,
        addon,
        mixin,
        extend,
        getSuper,
        isChildClassOf,
        clear: clear$1,
        value,
        getset,
        get,
        set,
        unregisterClass,
        getClassName,
        setClassName,
        setClassAlias,
        getClassByName,
        getClassById,
        get _registeredClassNames() {
          return {
            ..._nameToClass
          };
        },
        set _registeredClassNames(value) {
          clear$1(_nameToClass);
          Object.assign(_nameToClass, value);
        },
        get _registeredClassIds() {
          return {
            ..._idToClass
          };
        },
        set _registeredClassIds(value) {
          clear$1(_idToClass);
          Object.assign(_idToClass, value);
        },
        _getClassId,
        getClassId,
        _setClassId,
        _getClassById,
        obsolete,
        obsoletes,
        formatStr,
        shiftArguments,
        createMap
      };
      legacyCC.js = js;

      var js$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        array: array,
        js: js,
        IDGenerator: IDGenerator,
        Pool: Pool$1,
        isNumber: isNumber,
        isString: isString,
        isEmptyObject: isEmptyObject,
        value: value,
        getset: getset,
        get: get,
        set: set,
        createMap: createMap,
        getClassName: getClassName,
        obsolete: obsolete,
        obsoletes: obsoletes,
        formatStr: formatStr,
        shiftArguments: shiftArguments,
        getPropertyDescriptor: getPropertyDescriptor,
        copyAllProperties: copyAllProperties,
        addon: addon,
        mixin: mixin,
        extend: extend,
        getSuper: getSuper,
        isChildClassOf: isChildClassOf,
        clear: clear$1,
        _idToClass: _idToClass,
        _nameToClass: _nameToClass,
        _setClassId: _setClassId,
        setClassName: setClassName,
        setClassAlias: setClassAlias,
        unregisterClass: unregisterClass,
        _getClassById: _getClassById,
        getClassById: getClassById,
        getClassByName: getClassByName,
        _getClassId: _getClassId,
        getClassId: getClassId
      });
      exports('js', js$1);

      function BitMask(obj) {
        if ('__bitmask__' in obj) {
          return obj;
        }
        value(obj, '__bitmask__', null, true);
        let lastIndex = -1;
        const keys = Object.keys(obj);
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          let val = obj[key];
          if (val === -1) {
            val = ++lastIndex;
            obj[key] = val;
          } else if (typeof val === 'number') {
            lastIndex = val;
          } else if (typeof val === 'string' && Number.isInteger(parseFloat(key))) {
            continue;
          }
          const reverseKey = `${val}`;
          if (key !== reverseKey) {
            value(obj, reverseKey, key);
          }
        }
        return obj;
      }
      BitMask.isBitMask = BitMaskType => BitMaskType && BitMaskType.hasOwnProperty('__bitmask__');
      BitMask.getList = BitMaskDef => {
        if (BitMaskDef.__bitmask__) {
          return BitMaskDef.__bitmask__;
        }
        return BitMask.update(BitMaskDef);
      };
      BitMask.update = BitMaskDef => {
        if (!Array.isArray(BitMaskDef.__bitmask__)) {
          BitMaskDef.__bitmask__ = [];
        }
        const bitList = BitMaskDef.__bitmask__;
        bitList.length = 0;
        for (const name in BitMaskDef) {
          const v = BitMaskDef[name];
          if (Number.isInteger(v)) {
            bitList.push({
              name,
              value: v
            });
          }
        }
        bitList.sort((a, b) => a.value - b.value);
        return bitList;
      };
      legacyCC.BitMask = BitMask;

      function assertIsNonNullable(expr, message) {
        assertIsTrue(!(expr === null || expr === undefined), message);
      }
      function assertIsTrue(expr, message) {
        if (!expr) {
          throw new Error(`Assertion failed: ${message !== null && message !== void 0 ? message : '<no-message>'}`);
        }
      }
      function assertsArrayIndex(array, index) {
        assertIsTrue(index >= 0 && index < array.length, `Array index ${index} out of bounds: [0, ${array.length})`);
      }

      function Enum(obj) {
        if ('__enums__' in obj) {
          return obj;
        }
        value(obj, '__enums__', null, true);
        return Enum.update(obj);
      }
      Enum.update = obj => {
        let lastIndex = -1;
        const keys = Object.keys(obj);
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          let val = obj[key];
          if (val === -1) {
            val = ++lastIndex;
            obj[key] = val;
          } else if (typeof val === 'number') {
            lastIndex = val;
          } else if (typeof val === 'string' && Number.isInteger(parseFloat(key))) {
            continue;
          }
          const reverseKey = `${val}`;
          if (key !== reverseKey) {
            value(obj, reverseKey, key);
          }
        }
        if (Array.isArray(obj.__enums__)) {
          updateList(obj);
        }
        return obj;
      };
      (function (_Enum) {})(Enum || (exports('Enum', Enum = {})));
      Enum.isEnum = enumType => enumType && enumType.hasOwnProperty('__enums__');
      function assertIsEnum(enumType) {
        assertIsTrue(enumType.hasOwnProperty('__enums__'));
      }
      Enum.getList = enumType => {
        assertIsEnum(enumType);
        if (enumType.__enums__) {
          return enumType.__enums__;
        }
        return updateList(enumType);
      };
      function updateList(enumType) {
        assertIsEnum(enumType);
        const enums = enumType.__enums__ || [];
        enums.length = 0;
        for (const name in enumType) {
          const v = enumType[name];
          if (Number.isInteger(v)) {
            enums.push({
              name,
              value: v
            });
          }
        }
        enums.sort((a, b) => a.value - b.value);
        enumType.__enums__ = enums;
        return enums;
      }
      Enum.sortList = (enumType, compareFn) => {
        assertIsEnum(enumType);
        if (!Array.isArray(enumType.__enums__)) {
          return;
        }
        enumType.__enums__.sort(compareFn);
      };
      function ccenum(enumType) {
        if (!('__enums__' in enumType)) {
          value(enumType, '__enums__', null, true);
        }
      }
      legacyCC.Enum = Enum;

      class ValueType {
        clone() {
          errorID(100, `${getClassName(this)}.clone`);
          return this;
        }
        equals(other) {
          return false;
        }
        set(other) {
          errorID(100, `${getClassName(this)}.set`);
        }
        toString() {
          return `${''}`;
        }
      } exports('ValueType', ValueType);
      setClassName('cc.ValueType', ValueType);
      legacyCC.ValueType = ValueType;

      var Category;
      (function (Category) {
        Category["PATH"] = "path";
        Category["ENGINE"] = "engine";
        Category["ASSETS"] = "assets";
        Category["SCRIPTING"] = "scripting";
        Category["PHYSICS"] = "physics";
        Category["RENDERING"] = "rendering";
        Category["LAUNCH"] = "launch";
        Category["SCREEN"] = "screen";
        Category["SPLASH_SCREEN"] = "splashScreen";
        Category["ANIMATION"] = "animation";
        Category["PROFILING"] = "profiling";
        Category["PLUGINS"] = "plugins";
        Category["XR"] = "xr";
      })(Category || (Category = {}));
      class Settings {
        constructor() {
          this._settings = {};
          this._override = {};
        }
        init(path = '', overrides = {}) {
          for (const categoryName in overrides) {
            const category = overrides[categoryName];
            if (category) {
              for (const name in category) {
                this.overrideSettings(categoryName, name, category[name]);
              }
            }
          }
          if (!path) return Promise.resolve();
          if (window.oh) {
            return new Promise((resolve, reject) => {
              const settingsModule = '../settings.js';
              module.import(settingsModule).then(res => {
                this._settings = res.default;
                resolve();
              }).catch(e => reject(e));
            });
          }
          return new Promise((resolve, reject) => {
            if (!path.startsWith('http')) {
              {
                const result = fsUtils.readJsonSync(path);
                if (result instanceof Error) {
                  reject(result);
                } else {
                  this._settings = result;
                  resolve();
                }
              }
            } else {
              const xhr = new XMLHttpRequest();
              xhr.open('GET', path);
              xhr.responseType = 'text';
              xhr.onload = () => {
                this._settings = JSON.parse(xhr.response);
                resolve();
              };
              xhr.onerror = () => {
                reject(new Error('request settings failed!'));
              };
              xhr.send(null);
            }
          });
        }
        overrideSettings(category, name, value) {
          if (!(category in this._override)) {
            this._override[category] = {};
          }
          this._override[category][name] = value;
        }
        querySettings(category, name) {
          if (category in this._override) {
            const categorySettings = this._override[category];
            if (categorySettings && name in categorySettings) {
              return categorySettings[name];
            }
          }
          if (category in this._settings) {
            const categorySettings = this._settings[category];
            if (categorySettings && name in categorySettings) {
              return categorySettings[name];
            }
          }
          return null;
        }
      } exports('Settings', Settings);
      Settings.Category = Category;
      const settings = exports('settings', new Settings());
      legacyCC.settings = settings;

      const SUPPORT_TEXTURE_FORMATS = ['.astc', '.pkm', '.pvr', '.webp', '.jpg', '.jpeg', '.bmp', '.png'];
      const KEY = {
        none: 0,
        back: 6,
        menu: 18,
        backspace: 8,
        tab: 9,
        enter: 13,
        shift: 16,
        ctrl: 17,
        alt: 18,
        pause: 19,
        capslock: 20,
        escape: 27,
        space: 32,
        pageup: 33,
        pagedown: 34,
        end: 35,
        home: 36,
        left: 37,
        up: 38,
        right: 39,
        down: 40,
        select: 41,
        insert: 45,
        Delete: 46,
        0: 48,
        1: 49,
        2: 50,
        3: 51,
        4: 52,
        5: 53,
        6: 54,
        7: 55,
        8: 56,
        9: 57,
        a: 65,
        b: 66,
        c: 67,
        d: 68,
        e: 69,
        f: 70,
        g: 71,
        h: 72,
        i: 73,
        j: 74,
        k: 75,
        l: 76,
        m: 77,
        n: 78,
        o: 79,
        p: 80,
        q: 81,
        r: 82,
        s: 83,
        t: 84,
        u: 85,
        v: 86,
        w: 87,
        x: 88,
        y: 89,
        z: 90,
        num0: 96,
        num1: 97,
        num2: 98,
        num3: 99,
        num4: 100,
        num5: 101,
        num6: 102,
        num7: 103,
        num8: 104,
        num9: 105,
        '*': 106,
        '+': 107,
        '-': 109,
        numdel: 110,
        '/': 111,
        f1: 112,
        f2: 113,
        f3: 114,
        f4: 115,
        f5: 116,
        f6: 117,
        f7: 118,
        f8: 119,
        f9: 120,
        f10: 121,
        f11: 122,
        f12: 123,
        numlock: 144,
        scrolllock: 145,
        ';': 186,
        semicolon: 186,
        equal: 187,
        '=': 187,
        ',': 188,
        comma: 188,
        dash: 189,
        '.': 190,
        period: 190,
        forwardslash: 191,
        grave: 192,
        '[': 219,
        openbracket: 219,
        backslash: 220,
        ']': 221,
        closebracket: 221,
        quote: 222,
        dpadLeft: 1000,
        dpadRight: 1001,
        dpadUp: 1003,
        dpadDown: 1004,
        dpadCenter: 1005
      };
      const macro = exports('macro', {
        SUPPORT_TEXTURE_FORMATS,
        KEY,
        RAD: Math.PI / 180,
        DEG: 180 / Math.PI,
        REPEAT_FOREVER: Number.MAX_VALUE - 1,
        FLT_EPSILON: 0.0000001192092896,
        ORIENTATION_PORTRAIT: 1,
        ORIENTATION_LANDSCAPE: 2,
        ORIENTATION_AUTO: 3,
        ENABLE_TILEDMAP_CULLING: true,
        TOUCH_TIMEOUT: 5000,
        ENABLE_TRANSPARENT_CANVAS: false,
        ENABLE_WEBGL_ANTIALIAS: true,
        ENABLE_FLOAT_OUTPUT: false,
        CLEANUP_IMAGE_CACHE: false,
        ENABLE_MULTI_TOUCH: true,
        MAX_LABEL_CANVAS_POOL_SIZE: 20,
        ENABLE_WEBGL_HIGHP_STRUCT_VALUES: false,
        BATCHER2D_MEM_INCREMENT: 144,
        CUSTOM_PIPELINE_NAME: '',
        init() {
          {
            this.CLEANUP_IMAGE_CACHE = true;
          }
          const defaultValues = settings.querySettings(Settings.Category.ENGINE, 'macros');
          if (defaultValues) {
            for (const key in defaultValues) {
              macro[key] = defaultValues[key];
            }
          }
        }
      });
      legacyCC.macro = macro;

      function setTimeoutRAF(callback, delay, ...args) {
        var _globalThis$__globalX;
        const start = performance.now();
        const raf = requestAnimationFrame || window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame;
        if (raf === undefined || (_globalThis$__globalX = globalThis.__globalXR) !== null && _globalThis$__globalX !== void 0 && _globalThis$__globalX.isWebXR) {
          return setTimeout(callback, delay, ...args);
        }
        const handleRAF = () => {
          if (performance.now() - start < delay) {
            raf(handleRAF);
          } else {
            callback(...args);
          }
        };
        return raf(handleRAF);
      }

      const BUILTIN_CLASSID_RE = /^(?:cc|dragonBones|sp|ccsg)\..+/;
      const BASE64_KEYS$1 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
      const values = new Array(123);
      for (let i = 0; i < 123; ++i) {
        values[i] = 64;
      }
      for (let i = 0; i < 64; ++i) {
        values[BASE64_KEYS$1.charCodeAt(i)] = i;
      }
      const BASE64_VALUES$1 = values;
      function propertyDefine(ctor, sameNameGetSets, diffNameGetSets) {
        function define(np, propName, getter, setter) {
          const pd = Object.getOwnPropertyDescriptor(np, propName);
          if (pd) {
            if (pd.get) {
              np[getter] = pd.get;
            }
            if (pd.set && setter) {
              np[setter] = pd.set;
            }
          } else {
            const getterFunc = np[getter];
            {
              getset(np, propName, getterFunc, np[setter]);
            }
          }
        }
        let propName;
        const np = ctor.prototype;
        for (let i = 0; i < sameNameGetSets.length; i++) {
          propName = sameNameGetSets[i];
          const suffix = propName[0].toUpperCase() + propName.slice(1);
          define(np, propName, `get${suffix}`, `set${suffix}`);
        }
        for (propName in diffNameGetSets) {
          const gs = diffNameGetSets[propName];
          define(np, propName, gs[0], gs[1]);
        }
      }
      function pushToMap(map, key, value, pushFront) {
        const exists = map[key];
        if (exists) {
          if (Array.isArray(exists)) {
            if (pushFront) {
              exists.push(exists[0]);
              exists[0] = value;
            } else {
              exists.push(value);
            }
          } else {
            map[key] = pushFront ? [value, exists] : [exists, value];
          }
        } else {
          map[key] = value;
        }
      }
      function contains$1(refNode, otherNode) {
        if (typeof refNode.contains === 'function') {
          return refNode.contains(otherNode);
        } else if (typeof refNode.compareDocumentPosition === 'function') {
          return !!(refNode.compareDocumentPosition(otherNode) & 16);
        } else {
          let node = otherNode.parentNode;
          if (node) {
            do {
              if (node === refNode) {
                return true;
              } else {
                node = node.parentNode;
              }
            } while (node !== null);
          }
          return false;
        }
      }
      function isDomNode(node) {
        if (typeof window === 'object' && typeof Node === 'function') {
          return node instanceof Node;
        } else {
          return !!node && typeof node === 'object' && typeof node.nodeType === 'number' && typeof node.nodeName === 'string';
        }
      }
      function callInNextTick(callback, p1, p2) {
        if (callback) {
          setTimeoutRAF(() => {
            callback(p1, p2);
          }, 0);
        }
      }
      function tryCatchFunctor_EDITOR(funcName) {
        return Function('target', `${'try {\n' + '  target.'}${funcName}();\n` + `}\n` + `catch (e) {\n` + `  cc._throw(e);\n` + `}`);
      }
      function isPlainEmptyObj_DEV(obj) {
        if (!obj || obj.constructor !== Object) {
          return false;
        }
        return isEmptyObject(obj);
      }
      function clampf(value, min_inclusive, max_inclusive) {
        if (min_inclusive > max_inclusive) {
          const temp = min_inclusive;
          min_inclusive = max_inclusive;
          max_inclusive = temp;
        }
        return value < min_inclusive ? min_inclusive : value < max_inclusive ? value : max_inclusive;
      }
      function degreesToRadians(angle) {
        return angle * macro.RAD;
      }
      function radiansToDegrees(angle) {
        return angle * macro.DEG;
      }
      legacyCC.misc = {
        BUILTIN_CLASSID_RE,
        BASE64_VALUES: BASE64_VALUES$1,
        propertyDefine,
        pushToMap,
        contains: contains$1,
        isDomNode,
        callInNextTick,
        isPlainEmptyObj_DEV,
        clampf,
        degreesToRadians,
        radiansToDegrees
      };

      var misc = /*#__PURE__*/Object.freeze({
        __proto__: null,
        BUILTIN_CLASSID_RE: BUILTIN_CLASSID_RE,
        BASE64_VALUES: BASE64_VALUES$1,
        propertyDefine: propertyDefine,
        pushToMap: pushToMap,
        contains: contains$1,
        isDomNode: isDomNode,
        callInNextTick: callInNextTick,
        tryCatchFunctor_EDITOR: tryCatchFunctor_EDITOR,
        isPlainEmptyObj_DEV: isPlainEmptyObj_DEV,
        clampf: clampf,
        degreesToRadians: degreesToRadians,
        radiansToDegrees: radiansToDegrees
      });
      exports('misc', misc);

      const DELIMETER$1 = '$_$';
      function createAttrsSingle(owner, superAttrs) {
        const attrs = superAttrs ? Object.create(superAttrs) : {};
        value(owner, '__attrs__', attrs);
        return attrs;
      }
      function createAttrs(subclass) {
        if (typeof subclass !== 'function') {
          const instance = subclass;
          return createAttrsSingle(instance, getClassAttrs(instance.constructor));
        }
        let superClass;
        const chains = legacyCC.Class.getInheritanceChain(subclass);
        for (let i = chains.length - 1; i >= 0; i--) {
          const cls = chains[i];
          const attrs = cls.hasOwnProperty('__attrs__') && cls.__attrs__;
          if (!attrs) {
            superClass = chains[i + 1];
            createAttrsSingle(cls, superClass && superClass.__attrs__);
          }
        }
        superClass = chains[0];
        createAttrsSingle(subclass, superClass && superClass.__attrs__);
        return subclass.__attrs__;
      }
      function attr(constructor, propertyName) {
        const attrs = getClassAttrs(constructor);
        const prefix = propertyName + DELIMETER$1;
        const ret = {};
        for (const key in attrs) {
          if (key.startsWith(prefix)) {
            ret[key.slice(prefix.length)] = attrs[key];
          }
        }
        return ret;
      }
      function getClassAttrs(constructor) {
        return constructor.hasOwnProperty('__attrs__') && constructor.__attrs__ || createAttrs(constructor);
      }
      function setClassAttr(ctor, propName, key, value) {
        getClassAttrs(ctor)[propName + DELIMETER$1 + key] = value;
      }
      class PrimitiveType {
        constructor(name, defaultValue) {
          this.name = void 0;
          this.default = void 0;
          this.name = name;
          this.default = defaultValue;
        }
        toString() {
          return this.name;
        }
      }
      const CCInteger = exports('CCInteger', new PrimitiveType('Integer', 0));
      legacyCC.Integer = CCInteger;
      legacyCC.CCInteger = CCInteger;
      const CCFloat = exports('CCFloat', new PrimitiveType('Float', 0.0));
      legacyCC.Float = CCFloat;
      legacyCC.CCFloat = CCFloat;
      const CCBoolean = exports('CCBoolean', new PrimitiveType('Boolean', false));
      legacyCC.Boolean = CCBoolean;
      legacyCC.CCBoolean = CCBoolean;
      const CCString = exports('CCString', new PrimitiveType('String', ''));
      legacyCC.String = CCString;
      legacyCC.CCString = CCString;
      function getTypeChecker_ET(type, attributeName) {
        return function (constructor, mainPropertyName) {
          const propInfo = `"${getClassName(constructor)}.${mainPropertyName}"`;
          const mainPropAttrs = attr(constructor, mainPropertyName);
          let mainPropAttrsType = mainPropAttrs.type;
          if (mainPropAttrsType === CCInteger || mainPropAttrsType === CCFloat) {
            mainPropAttrsType = 'Number';
          } else if (mainPropAttrsType === CCString || mainPropAttrsType === CCBoolean) {
            mainPropAttrsType = `${mainPropAttrsType}`;
          }
          if (mainPropAttrsType !== type) {
            warnID(3604, propInfo);
            return;
          }
          if (!mainPropAttrs.hasOwnProperty('default')) {
            return;
          }
          const defaultVal = mainPropAttrs.default;
          if (typeof defaultVal === 'undefined') {
            return;
          }
          const isContainer = Array.isArray(defaultVal) || isPlainEmptyObj_DEV(defaultVal);
          if (isContainer) {
            return;
          }
          const defaultType = typeof defaultVal;
          const type_lowerCase = type.toLowerCase();
          if (defaultType === type_lowerCase) {
            if (type_lowerCase === 'object') {
              if (defaultVal && !(defaultVal instanceof mainPropAttrs.ctor)) {
                warnID(3605, propInfo, getClassName(mainPropAttrs.ctor));
              } else {
                return;
              }
            } else if (type !== 'Number') {
              warnID(3606, attributeName, propInfo, type);
            }
          } else if (defaultType !== 'function') {
            if (type === CCString.default && defaultVal == null) {
              warnID(3607, propInfo);
            } else {
              warnID(3611, attributeName, propInfo, defaultType);
            }
          } else {
            return;
          }
          delete mainPropAttrs.type;
        };
      }
      function getObjTypeChecker_ET(typeCtor) {
        return function (classCtor, mainPropName) {
          getTypeChecker_ET('Object', 'type')(classCtor, mainPropName);
          const defaultDef = getClassAttrs(classCtor)[`${mainPropName + DELIMETER$1}default`];
          const defaultVal = legacyCC.Class.getDefault(defaultDef);
          if (!Array.isArray(defaultVal) && isChildClassOf(typeCtor, legacyCC.ValueType)) {
            const typename = getClassName(typeCtor);
            const info = formatStr('No need to specify the "type" of "%s.%s" because %s is a child class of ValueType.', getClassName(classCtor), mainPropName, typename);
            if (defaultDef) {
              log(info);
            } else {
              warnID(3612, info, typename, getClassName(classCtor), mainPropName, typename);
            }
          }
        };
      }

      var attributeUtils = /*#__PURE__*/Object.freeze({
        __proto__: null,
        DELIMETER: DELIMETER$1,
        createAttrsSingle: createAttrsSingle,
        createAttrs: createAttrs,
        attr: attr,
        getClassAttrs: getClassAttrs,
        setClassAttr: setClassAttr,
        PrimitiveType: PrimitiveType,
        CCInteger: CCInteger,
        CCFloat: CCFloat,
        CCBoolean: CCBoolean,
        CCString: CCString,
        getTypeChecker_ET: getTypeChecker_ET,
        getObjTypeChecker_ET: getObjTypeChecker_ET
      });

      const SerializableAttrs = {
        default: {},
        serializable: {},
        editorOnly: {},
        formerlySerializedAs: {}
      };
      function parseNotify(val, propName, notify, properties) {
        if (val.get || val.set) {
          return;
        }
        if (val.hasOwnProperty('default')) {
          const newKey = `_N$${propName}`;
          val.get = function () {
            return this[newKey];
          };
          val.set = function (value) {
            const oldValue = this[newKey];
            this[newKey] = value;
            notify.call(this, oldValue);
          };
          const newValue = {};
          properties[newKey] = newValue;
          for (const attr in SerializableAttrs) {
            const v = SerializableAttrs[attr];
            if (val.hasOwnProperty(attr)) {
              newValue[attr] = val[attr];
              if (!v.canUsedInGet) {
                delete val[attr];
              }
            }
          }
        }
      }
      function parseType(val, type, className, propName) {
        if (Array.isArray(type)) {
          if (type.length > 0) {
            val.type = type = type[0];
          } else {
            return errorID(5508, className, propName);
          }
        }
        if (typeof type === 'function') {
          if (type === String) {
            val.type = legacyCC.String;
          } else if (type === Boolean) {
            val.type = legacyCC.Boolean;
          } else if (type === Number) {
            val.type = legacyCC.Float;
          }
        }
      }
      function _wrapOptions(isGetset, _default, type) {
        const res = isGetset || typeof _default === 'undefined' ? {
          _short: true
        } : {
          _short: true,
          default: _default
        };
        if (type) {
          res.type = type;
        }
        return res;
      }
      function getFullFormOfProperty(options, isGetset) {
        const isLiteral = options && options.constructor === Object;
        if (!isLiteral) {
          if (Array.isArray(options) && options.length > 0) {
            return _wrapOptions(isGetset, [], options);
          } else if (typeof options === 'function') {
            const type = options;
            return _wrapOptions(isGetset, isChildClassOf(type, legacyCC.ValueType) ? new type() : null, type);
          } else if (options instanceof PrimitiveType) {
            return _wrapOptions(isGetset, undefined, options);
          } else {
            return _wrapOptions(isGetset, options);
          }
        }
        return null;
      }
      function preprocessAttrs(properties, className, cls) {
        for (const propName in properties) {
          let val = properties[propName];
          const fullForm = getFullFormOfProperty(val, false);
          if (fullForm) {
            val = properties[propName] = fullForm;
          }
          if (val) {
            const notify = val.notify;
            if (notify) {
              {
                parseNotify(val, propName, notify, properties);
              }
            }
            if ('type' in val) {
              parseType(val, val.type, className, propName);
            }
          }
        }
      }

      let requiringFrames = [];
      function push(module, uuid, script, importMeta) {
        if (script === undefined) {
          script = uuid;
          uuid = '';
        }
        requiringFrames.push({
          uuid,
          script,
          module,
          exports: module.exports,
          beh: null,
          importMeta
        });
      }
      function pop() {
        const frameInfo = requiringFrames.pop();
        const module = frameInfo.module;
        let exports = module.exports;
        if (exports === frameInfo.exports) {
          for (const anykey in exports) {
            return;
          }
          module.exports = exports = frameInfo.cls;
        }
      }
      function peek() {
        return requiringFrames[requiringFrames.length - 1];
      }
      legacyCC._RF = {
        push,
        pop,
        peek
      };

      let PropertyStashInternalFlag;
      (function (PropertyStashInternalFlag) {
        PropertyStashInternalFlag[PropertyStashInternalFlag["STANDALONE"] = 1] = "STANDALONE";
        PropertyStashInternalFlag[PropertyStashInternalFlag["IMPLICIT_VISIBLE"] = 2] = "IMPLICIT_VISIBLE";
        PropertyStashInternalFlag[PropertyStashInternalFlag["IMPLICIT_SERIALIZABLE"] = 4] = "IMPLICIT_SERIALIZABLE";
      })(PropertyStashInternalFlag || (PropertyStashInternalFlag = {}));

      function setPropertyEnumType(objectOrConstructor, propertyName, enumType) {
        setPropertyEnumTypeOnAttrs(getClassAttrs(objectOrConstructor), propertyName, enumType);
      }
      function setPropertyEnumTypeOnAttrs(attrs, propertyName, enumType) {
        attrs[`${propertyName}${DELIMETER$1}type`] = 'Enum';
        attrs[`${propertyName}${DELIMETER$1}enumList`] = Enum.getList(enumType);
      }

      const DELIMETER = DELIMETER$1;
      const CCCLASS_TAG = '__ctors__';
      const ENUM_TAG = exports('ENUM_TAG', 'Enum');
      const BITMASK_TAG = exports('BITMASK_TAG', 'BitMask');
      function pushUnique(array, item) {
        if (array.indexOf(item) < 0) {
          array.push(item);
        }
      }
      function appendProp(cls, name) {
        pushUnique(cls.__props__, name);
      }
      function defineProp(cls, className, propName, val) {
        appendProp(cls, propName);
        parseAttributes(cls, val, className, propName);
      }
      function defineGetSet(cls, name, propName, val) {
        const getter = val.get;
        val.set;
        if (getter) {
          parseAttributes(cls, val, name, propName);
          setClassAttr(cls, propName, 'serializable', false);
        }
      }
      function getDefault(defaultVal) {
        if (typeof defaultVal === 'function') {
          {
            return defaultVal();
          }
        }
        return defaultVal;
      }
      function doDefine(className, baseClass, options) {
        const ctor = options.ctor;
        value(ctor, CCCLASS_TAG, true, true);
        ctor.prototype;
        if (baseClass) {
          ctor.$super = baseClass;
        }
        setClassName(className, ctor);
        return ctor;
      }
      function define$1(className, baseClass, options) {
        const Component = legacyCC.Component;
        const frame = peek();
        if (frame && isChildClassOf(baseClass, Component)) {
          if (isChildClassOf(frame.cls, Component)) {
            errorID(3615);
            return null;
          }
          className = className || frame.script;
        }
        const cls = doDefine(className, baseClass, options);
        if (frame) {
          if (isChildClassOf(baseClass, Component)) {
            const uuid = frame.uuid;
            if (uuid) {
              _setClassId(uuid, cls);
            }
            frame.cls = cls;
          } else if (!isChildClassOf(frame.cls, Component)) {
            frame.cls = cls;
          }
        }
        return cls;
      }
      function getNewValueTypeCodeJit(value) {
        const clsName = getClassName(value);
        const type = value.constructor;
        let res = `new ${clsName}(`;
        for (let i = 0; i < type.__props__.length; i++) {
          const prop = type.__props__[i];
          const propVal = value[prop];
          res += propVal;
          if (i < type.__props__.length - 1) {
            res += ',';
          }
        }
        return `${res})`;
      }
      function escapeForJS$1(s) {
        return JSON.stringify(s).replace(/\u2028/g, '\\u2028').replace(/\u2029/g, '\\u2029');
      }
      const IDENTIFIER_RE$1 = /^[A-Za-z_$][0-9A-Za-z_$]*$/;
      function declareProperties(cls, className, properties, baseClass) {
        cls.__props__ = [];
        if (baseClass && baseClass.__props__) {
          cls.__props__ = baseClass.__props__.slice();
        }
        if (properties) {
          preprocessAttrs(properties, className);
          for (const propName in properties) {
            const val = properties[propName];
            if (!val.get && !val.set) {
              defineProp(cls, className, propName, val);
            } else {
              defineGetSet(cls, className, propName, val);
            }
          }
        }
        const attrs = getClassAttrs(cls);
        cls.__values__ = cls.__props__.filter(prop => attrs[`${prop}${DELIMETER}serializable`] !== false);
      }
      function CCClass(options) {
        let name = options.name;
        const base = options.extends;
        const cls = define$1(name, base, options);
        if (!name) {
          name = legacyCC.js.getClassName(cls);
        }
        cls._sealed = true;
        if (base) {
          base._sealed = false;
        }
        const properties = options.properties;
        declareProperties(cls, name, properties, base);
        const editor = options.editor;
        if (editor) {
          if (isChildClassOf(base, legacyCC.Component)) {
            legacyCC.Component._registerEditorProps(cls, editor);
          }
        }
        return cls;
      }
      CCClass._isCCClass = function isCCClass(constructor) {
        var _constructor$hasOwnPr;
        return constructor === null || constructor === void 0 ? void 0 : (_constructor$hasOwnPr = constructor.hasOwnProperty) === null || _constructor$hasOwnPr === void 0 ? void 0 : _constructor$hasOwnPr.call(constructor, CCCLASS_TAG);
      };
      CCClass.fastDefine = function (className, constructor, serializableFields) {
        setClassName(className, constructor);
        const props = constructor.__props__ = constructor.__values__ = Object.keys(serializableFields);
        const attrs = getClassAttrs(constructor);
        for (let i = 0; i < props.length; i++) {
          const key = props[i];
          attrs[`${key + DELIMETER}visible`] = false;
          attrs[`${key + DELIMETER}default`] = serializableFields[key];
        }
      };
      CCClass.Attr = attributeUtils;
      CCClass.attr = attr;
      function isCCClassOrFastDefined(constructor) {
        var _constructor$hasOwnPr2;
        return constructor === null || constructor === void 0 ? void 0 : (_constructor$hasOwnPr2 = constructor.hasOwnProperty) === null || _constructor$hasOwnPr2 === void 0 ? void 0 : _constructor$hasOwnPr2.call(constructor, '__values__');
      }
      CCClass.isCCClassOrFastDefined = isCCClassOrFastDefined;
      function getInheritanceChain(constructor) {
        const chain = [];
        for (;;) {
          constructor = getSuper(constructor);
          if (!constructor) {
            break;
          }
          if (constructor !== Object) {
            chain.push(constructor);
          }
        }
        return chain;
      }
      CCClass.getInheritanceChain = getInheritanceChain;
      const PrimitiveTypes = {
        Integer: 'Number',
        Float: 'Number',
        Boolean: 'Boolean',
        String: 'String'
      };
      function parseAttributes(constructor, attributes, className, propertyName, usedInGetter) {
        let attrs = null;
        let propertyNamePrefix = '';
        function initAttrs() {
          propertyNamePrefix = propertyName + DELIMETER;
          return attrs = getClassAttrs(constructor);
        }
        if ('type' in attributes && typeof attributes.type === 'undefined') {
          warnID(3660, propertyName, className);
        }
        const type = attributes.type;
        if (type) {
          const primitiveType = PrimitiveTypes[type];
          if (primitiveType) {
            (attrs || initAttrs())[`${propertyNamePrefix}type`] = type;
          } else if (type === 'Object') ; else if (typeof type === 'object') {
            if (Enum.isEnum(type)) {
              setPropertyEnumTypeOnAttrs(attrs || initAttrs(), propertyName, type);
            } else if (BitMask.isBitMask(type)) {
              (attrs || initAttrs())[`${propertyNamePrefix}type`] = BITMASK_TAG;
              attrs[`${propertyNamePrefix}bitmaskList`] = BitMask.getList(type);
            } else ;
          } else if (typeof type === 'function') {
            (attrs || initAttrs())[`${propertyNamePrefix}type`] = 'Object';
            attrs[`${propertyNamePrefix}ctor`] = type;
          } else ;
        }
        if ('default' in attributes) {
          (attrs || initAttrs())[`${propertyNamePrefix}default`] = attributes.default;
        }
        const parseSimpleAttribute = (attributeName, expectType) => {
          if (attributeName in attributes) {
            const val = attributes[attributeName];
            if (typeof val === expectType) {
              (attrs || initAttrs())[propertyNamePrefix + attributeName] = val;
            }
          }
        };
        if (attributes.editorOnly) {
          {
            (attrs || initAttrs())[`${propertyNamePrefix}editorOnly`] = true;
          }
        }
        const isStandaloneMode = attributes.__internalFlags & PropertyStashInternalFlag.STANDALONE;
        let normalizedSerializable;
        if (isStandaloneMode) {
          normalizedSerializable = attributes.serializable === true || (attributes.__internalFlags & PropertyStashInternalFlag.IMPLICIT_SERIALIZABLE) !== 0;
        } else if (attributes.serializable === false) {
          normalizedSerializable = false;
        }
        if (typeof normalizedSerializable !== 'undefined') {
          (attrs || initAttrs())[`${propertyNamePrefix}serializable`] = normalizedSerializable;
        }
        parseSimpleAttribute('formerlySerializedAs', 'string');
        const range = attributes.range;
        if (range) {
          if (Array.isArray(range)) {
            if (range.length >= 2) {
              (attrs || initAttrs())[`${propertyNamePrefix}min`] = range[0];
              attrs[`${propertyNamePrefix}max`] = range[1];
              if (range.length > 2) {
                attrs[`${propertyNamePrefix}step`] = range[2];
              }
            }
          }
        }
        parseSimpleAttribute('min', 'number');
        parseSimpleAttribute('max', 'number');
        parseSimpleAttribute('step', 'number');
      }
      CCClass.isArray = function (defaultVal) {
        defaultVal = getDefault(defaultVal);
        return Array.isArray(defaultVal);
      };
      CCClass.getDefault = getDefault;
      CCClass.escapeForJS = escapeForJS$1;
      CCClass.IDENTIFIER_RE = IDENTIFIER_RE$1;
      CCClass.getNewValueTypeCode = getNewValueTypeCodeJit;
      legacyCC.Class = CCClass;

      const _d2r = Math.PI / 180.0;
      const _r2d = 180.0 / Math.PI;
      let _random = Math.random;
      const HALF_PI = exports('HALF_PI', Math.PI * 0.5);
      const TWO_PI = exports('TWO_PI', Math.PI * 2.0);
      const EPSILON$2 = exports('EPSILON', 0.000001);
      function equals$1(a, b) {
        return Math.abs(a - b) <= EPSILON$2 * Math.max(1.0, Math.abs(a), Math.abs(b));
      }
      function approx(a, b, maxDiff) {
        maxDiff = maxDiff || EPSILON$2;
        return Math.abs(a - b) <= maxDiff;
      }
      function clamp$1(val, min, max) {
        if (min > max) {
          const temp = min;
          min = max;
          max = temp;
        }
        return val < min ? min : val > max ? max : val;
      }
      function clamp01(val) {
        return val < 0 ? 0 : val > 1 ? 1 : val;
      }
      function lerp(from, to, ratio) {
        return from + (to - from) * ratio;
      }
      function toRadian(a) {
        return a * _d2r;
      }
      function toDegree(a) {
        return a * _r2d;
      }
      function random() {
        return _random();
      }
      function setRandGenerator(func) {
        _random = func;
      }
      function randomRange(min, max) {
        return random() * (max - min) + min;
      }
      function randomRangeInt(min, max) {
        return Math.floor(randomRange(min, max));
      }
      function pseudoRandom(seed) {
        seed = (seed * 9301 + 49297) % 233280;
        return seed / 233280.0;
      }
      function pseudoRandomRange(seed, min, max) {
        return pseudoRandom(seed) * (max - min) + min;
      }
      function pseudoRandomRangeInt(seed, min, max) {
        return Math.floor(pseudoRandomRange(seed, min, max));
      }
      function nextPow2(val) {
        return nextPow2$1(val);
      }
      function repeat$1(t, length) {
        return t - Math.floor(t / length) * length;
      }
      function pingPong(t, length) {
        t = repeat$1(t, length * 2);
        t = length - Math.abs(t - length);
        return t;
      }
      function inverseLerp(from, to, value) {
        return (value - from) / (to - from);
      }
      function absMaxComponent(v) {
        if (Math.abs(v.x) > Math.abs(v.y)) {
          if (Math.abs(v.x) > Math.abs(v.z)) {
            return v.x;
          } else {
            return v.z;
          }
        } else if (Math.abs(v.y) > Math.abs(v.z)) {
          return v.y;
        } else {
          return v.z;
        }
      }
      function absMax(a, b) {
        if (Math.abs(a) > Math.abs(b)) {
          return a;
        } else {
          return b;
        }
      }
      function enumerableProps(prototype, attrs) {
        attrs.forEach(key => {
          Object.defineProperty(prototype, key, {
            enumerable: true
          });
        });
      }
      const toHalf = function () {
        const floatView = new Float32Array(1);
        const int32View = new Int32Array(floatView.buffer);
        return function toHalf(fval) {
          floatView[0] = fval;
          const fbits = int32View[0];
          const s = fbits >> 16 & 0x8000;
          const em = fbits & 0x7fffffff;
          let h = em - (112 << 23) + (1 << 12) >> 13;
          h = em < 113 << 23 ? 0 : h;
          h = em >= 143 << 23 ? 0x7c00 : h;
          h = em > 255 << 23 ? 0x7e00 : h;
          int32View[0] = s | h;
          return int32View[0];
        };
      }();
      const fromHalf = function () {
        const floatView = new Float32Array(1);
        const int32View = new Int32Array(floatView.buffer);
        return function fromHalf(hval) {
          const s = hval >> 15 & 0x00000001;
          const em = hval & 0x00007fff;
          let h = em << 13;
          let fbits = 0;
          if (h !== 0x7c00) {
            h += 112 << 23;
            if (em === 0) {
              h = (h & 0xfffff) >> 1;
            } else if (em === 0x7fff) {
              h = 0x7fffffff;
            }
          } else {
            h = 0x7f800000;
          }
          fbits = s << 31 | h;
          int32View[0] = fbits;
          return floatView[0];
        };
      }();
      function floatToHalf(val) {
        return toHalf(val);
      }
      function halfToFloat(val) {
        return fromHalf(val);
      }

      var _class$16;
      class Vec4 extends ValueType {
        static clone(a) {
          return new Vec4(a.x, a.y, a.z, a.w);
        }
        static copy(out, a) {
          out.x = a.x;
          out.y = a.y;
          out.z = a.z;
          out.w = a.w;
          return out;
        }
        static set(out, x, y, z, w) {
          out.x = x;
          out.y = y;
          out.z = z;
          out.w = w;
          return out;
        }
        static fromColor(out, color) {
          out.x = color.r;
          out.y = color.g;
          out.z = color.b;
          out.w = color.a;
          return out;
        }
        static angle(a, b) {
          const dx = a.y * b.z - a.z * b.y;
          const dy = a.z * b.x - a.x * b.z;
          const dz = a.x * b.y - a.y * b.x;
          const dotVal = a.x * b.x + a.y * b.y + a.z * b.z;
          return Math.atan2(Math.sqrt(dx * dx + dy * dy + dz * dz), dotVal);
        }
        static add(out, a, b) {
          out.x = a.x + b.x;
          out.y = a.y + b.y;
          out.z = a.z + b.z;
          out.w = a.w + b.w;
          return out;
        }
        static subtract(out, a, b) {
          out.x = a.x - b.x;
          out.y = a.y - b.y;
          out.z = a.z - b.z;
          out.w = a.w - b.w;
          return out;
        }
        static multiply(out, a, b) {
          out.x = a.x * b.x;
          out.y = a.y * b.y;
          out.z = a.z * b.z;
          out.w = a.w * b.w;
          return out;
        }
        static divide(out, a, b) {
          out.x = a.x / b.x;
          out.y = a.y / b.y;
          out.z = a.z / b.z;
          out.w = a.w / b.w;
          return out;
        }
        static ceil(out, a) {
          out.x = Math.ceil(a.x);
          out.y = Math.ceil(a.y);
          out.z = Math.ceil(a.z);
          out.w = Math.ceil(a.w);
          return out;
        }
        static floor(out, a) {
          out.x = Math.floor(a.x);
          out.y = Math.floor(a.y);
          out.z = Math.floor(a.z);
          out.w = Math.floor(a.w);
          return out;
        }
        static min(out, a, b) {
          out.x = Math.min(a.x, b.x);
          out.y = Math.min(a.y, b.y);
          out.z = Math.min(a.z, b.z);
          out.w = Math.min(a.w, b.w);
          return out;
        }
        static max(out, a, b) {
          out.x = Math.max(a.x, b.x);
          out.y = Math.max(a.y, b.y);
          out.z = Math.max(a.z, b.z);
          out.w = Math.max(a.w, b.w);
          return out;
        }
        static round(out, a) {
          out.x = Math.round(a.x);
          out.y = Math.round(a.y);
          out.z = Math.round(a.z);
          out.w = Math.round(a.w);
          return out;
        }
        static multiplyScalar(out, a, b) {
          out.x = a.x * b;
          out.y = a.y * b;
          out.z = a.z * b;
          out.w = a.w * b;
          return out;
        }
        static scaleAndAdd(out, a, b, scale) {
          out.x = a.x + b.x * scale;
          out.y = a.y + b.y * scale;
          out.z = a.z + b.z * scale;
          out.w = a.w + b.w * scale;
          return out;
        }
        static distance(a, b) {
          const x = b.x - a.x;
          const y = b.y - a.y;
          const z = b.z - a.z;
          const w = b.w - a.w;
          return Math.sqrt(x * x + y * y + z * z + w * w);
        }
        static squaredDistance(a, b) {
          const x = b.x - a.x;
          const y = b.y - a.y;
          const z = b.z - a.z;
          const w = b.w - a.w;
          return x * x + y * y + z * z + w * w;
        }
        static len(a) {
          const x = a.x;
          const y = a.y;
          const z = a.z;
          const w = a.w;
          return Math.sqrt(x * x + y * y + z * z + w * w);
        }
        static lengthSqr(a) {
          const x = a.x;
          const y = a.y;
          const z = a.z;
          const w = a.w;
          return x * x + y * y + z * z + w * w;
        }
        static negate(out, a) {
          out.x = -a.x;
          out.y = -a.y;
          out.z = -a.z;
          out.w = -a.w;
          return out;
        }
        static inverse(out, a) {
          out.x = 1.0 / a.x;
          out.y = 1.0 / a.y;
          out.z = 1.0 / a.z;
          out.w = 1.0 / a.w;
          return out;
        }
        static inverseSafe(out, a) {
          const x = a.x;
          const y = a.y;
          const z = a.z;
          const w = a.w;
          if (Math.abs(x) < EPSILON$2) {
            out.x = 0;
          } else {
            out.x = 1.0 / x;
          }
          if (Math.abs(y) < EPSILON$2) {
            out.y = 0;
          } else {
            out.y = 1.0 / y;
          }
          if (Math.abs(z) < EPSILON$2) {
            out.z = 0;
          } else {
            out.z = 1.0 / z;
          }
          if (Math.abs(w) < EPSILON$2) {
            out.w = 0;
          } else {
            out.w = 1.0 / w;
          }
          return out;
        }
        static normalize(out, a) {
          const x = a.x;
          const y = a.y;
          const z = a.z;
          const w = a.w;
          let len = x * x + y * y + z * z + w * w;
          if (len > 0) {
            len = 1 / Math.sqrt(len);
            out.x = x * len;
            out.y = y * len;
            out.z = z * len;
            out.w = w * len;
          } else {
            out.x = 0;
            out.y = 0;
            out.z = 0;
            out.w = 0;
          }
          return out;
        }
        static dot(a, b) {
          return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;
        }
        static lerp(out, a, b, t) {
          out.x = a.x + t * (b.x - a.x);
          out.y = a.y + t * (b.y - a.y);
          out.z = a.z + t * (b.z - a.z);
          out.w = a.w + t * (b.w - a.w);
          return out;
        }
        static scale(out, a, b) {
          out.x = a.x * b;
          out.y = a.y * b;
          out.z = a.z * b;
          out.w = a.w * b;
          return out;
        }
        static random(out, scale) {
          scale = scale || 1.0;
          const phi = random() * 2.0 * Math.PI;
          const cosTheta = random() * 2 - 1;
          const sinTheta = Math.sqrt(1 - cosTheta * cosTheta);
          out.x = sinTheta * Math.cos(phi) * scale;
          out.y = sinTheta * Math.sin(phi) * scale;
          out.z = cosTheta * scale;
          out.w = 0;
          return out;
        }
        static transformMat4(out, a, m) {
          const x = a.x;
          const y = a.y;
          const z = a.z;
          const w = a.w;
          out.x = m.m00 * x + m.m04 * y + m.m08 * z + m.m12 * w;
          out.y = m.m01 * x + m.m05 * y + m.m09 * z + m.m13 * w;
          out.z = m.m02 * x + m.m06 * y + m.m10 * z + m.m14 * w;
          out.w = m.m03 * x + m.m07 * y + m.m11 * z + m.m15 * w;
          return out;
        }
        static transformAffine(out, v, m) {
          const x = v.x;
          const y = v.y;
          const z = v.z;
          const w = v.w;
          out.x = m.m00 * x + m.m04 * y + m.m08 * z + m.m12 * w;
          out.y = m.m01 * x + m.m05 * y + m.m09 * z + m.m13 * w;
          out.z = m.m02 * x + m.m06 * y + m.m10 * z + m.m14 * w;
          out.w = v.w;
          return out;
        }
        static transformQuat(out, a, q) {
          const {
            x,
            y,
            z
          } = a;
          const _x = q.x;
          const _y = q.y;
          const _z = q.z;
          const _w = q.w;
          const ix = _w * x + _y * z - _z * y;
          const iy = _w * y + _z * x - _x * z;
          const iz = _w * z + _x * y - _y * x;
          const iw = -_x * x - _y * y - _z * z;
          out.x = ix * _w + iw * -_x + iy * -_z - iz * -_y;
          out.y = iy * _w + iw * -_y + iz * -_x - ix * -_z;
          out.z = iz * _w + iw * -_z + ix * -_y - iy * -_x;
          out.w = a.w;
          return out;
        }
        static toArray(out, v, ofs = 0) {
          out[ofs + 0] = v.x;
          out[ofs + 1] = v.y;
          out[ofs + 2] = v.z;
          out[ofs + 3] = v.w;
          return out;
        }
        static fromArray(out, arr, ofs = 0) {
          out.x = arr[ofs + 0];
          out.y = arr[ofs + 1];
          out.z = arr[ofs + 2];
          out.w = arr[ofs + 3];
          return out;
        }
        static strictEquals(a, b) {
          return a.x === b.x && a.y === b.y && a.z === b.z && a.w === b.w;
        }
        static equals(a, b, epsilon = EPSILON$2) {
          const hasInf = Math.abs(a.x) === Infinity || Math.abs(a.y) === Infinity || Math.abs(a.z) === Infinity || Math.abs(a.w) === Infinity || Math.abs(b.x) === Infinity || Math.abs(b.y) === Infinity || Math.abs(b.z) === Infinity || Math.abs(b.w) === Infinity;
          return !hasInf && Math.abs(a.x - b.x) <= epsilon * Math.max(1.0, Math.abs(a.x), Math.abs(b.x)) && Math.abs(a.y - b.y) <= epsilon * Math.max(1.0, Math.abs(a.y), Math.abs(b.y)) && Math.abs(a.z - b.z) <= epsilon * Math.max(1.0, Math.abs(a.z), Math.abs(b.z)) && Math.abs(a.w - b.w) <= epsilon * Math.max(1.0, Math.abs(a.w), Math.abs(b.w));
        }
        constructor(x, y, z, w) {
          super();
          if (typeof x === 'object') {
            this.x = x.x;
            this.y = x.y;
            this.z = x.z;
            this.w = x.w;
          } else {
            this.x = x || 0;
            this.y = y || 0;
            this.z = z || 0;
            this.w = w || 0;
          }
        }
        clone() {
          return new Vec4(this.x, this.y, this.z, this.w);
        }
        set(x, y, z, w) {
          if (typeof x === 'object') {
            this.x = x.x;
            this.y = x.y;
            this.z = x.z;
            this.w = x.w;
          } else {
            this.x = x || 0;
            this.y = y || 0;
            this.z = z || 0;
            this.w = w || 0;
          }
          return this;
        }
        equals(other, epsilon = EPSILON$2) {
          return Math.abs(this.x - other.x) <= epsilon * Math.max(1.0, Math.abs(this.x), Math.abs(other.x)) && Math.abs(this.y - other.y) <= epsilon * Math.max(1.0, Math.abs(this.y), Math.abs(other.y)) && Math.abs(this.z - other.z) <= epsilon * Math.max(1.0, Math.abs(this.z), Math.abs(other.z)) && Math.abs(this.w - other.w) <= epsilon * Math.max(1.0, Math.abs(this.w), Math.abs(other.w));
        }
        equals4f(x, y, z, w, epsilon = EPSILON$2) {
          return Math.abs(this.x - x) <= epsilon * Math.max(1.0, Math.abs(this.x), Math.abs(x)) && Math.abs(this.y - y) <= epsilon * Math.max(1.0, Math.abs(this.y), Math.abs(y)) && Math.abs(this.z - z) <= epsilon * Math.max(1.0, Math.abs(this.z), Math.abs(z)) && Math.abs(this.w - w) <= epsilon * Math.max(1.0, Math.abs(this.w), Math.abs(w));
        }
        strictEquals(other) {
          return this.x === other.x && this.y === other.y && this.z === other.z && this.w === other.w;
        }
        strictEquals4f(x, y, z, w) {
          return this.x === x && this.y === y && this.z === z && this.w === w;
        }
        lerp(to, ratio) {
          const x = this.x;
          const y = this.y;
          const z = this.z;
          const w = this.w;
          this.x = x + ratio * (to.x - x);
          this.y = y + ratio * (to.y - y);
          this.z = z + ratio * (to.z - z);
          this.w = w + ratio * (to.w - w);
          return this;
        }
        toString() {
          return `(${this.x.toFixed(2)}, ${this.y.toFixed(2)}, ${this.z.toFixed(2)}, ${this.w.toFixed(2)})`;
        }
        clampf(minInclusive, maxInclusive) {
          this.x = clamp$1(this.x, minInclusive.x, maxInclusive.x);
          this.y = clamp$1(this.y, minInclusive.y, maxInclusive.y);
          this.z = clamp$1(this.z, minInclusive.z, maxInclusive.z);
          this.w = clamp$1(this.w, minInclusive.w, maxInclusive.w);
          return this;
        }
        add(other) {
          this.x += other.x;
          this.y += other.y;
          this.z += other.z;
          this.w += other.w;
          return this;
        }
        add4f(x, y, z, w) {
          this.x += x;
          this.y += y;
          this.z += z;
          this.w += w;
          return this;
        }
        subtract(other) {
          this.x -= other.x;
          this.y -= other.y;
          this.z -= other.z;
          this.w -= other.w;
          return this;
        }
        subtract4f(x, y, z, w) {
          this.x -= x;
          this.y -= y;
          this.z -= z;
          this.w -= w;
          return this;
        }
        multiplyScalar(scalar) {
          if (typeof scalar === 'object') {
            console.warn('should use Vec4.multiply for vector * vector operation');
          }
          this.x *= scalar;
          this.y *= scalar;
          this.z *= scalar;
          this.w *= scalar;
          return this;
        }
        multiply(other) {
          if (typeof other !== 'object') {
            console.warn('should use Vec4.scale for vector * scalar operation');
          }
          this.x *= other.x;
          this.y *= other.y;
          this.z *= other.z;
          this.w *= other.w;
          return this;
        }
        multiply4f(x, y, z, w) {
          this.x *= x;
          this.y *= y;
          this.z *= z;
          this.w *= w;
          return this;
        }
        divide(other) {
          this.x /= other.x;
          this.y /= other.y;
          this.z /= other.z;
          this.w /= other.w;
          return this;
        }
        divide4f(x, y, z, w) {
          this.x /= x;
          this.y /= y;
          this.z /= z;
          this.w /= w;
          return this;
        }
        negative() {
          this.x = -this.x;
          this.y = -this.y;
          this.z = -this.z;
          this.w = -this.w;
          return this;
        }
        dot(vector) {
          return this.x * vector.x + this.y * vector.y + this.z * vector.z + this.w * vector.w;
        }
        cross(vector) {
          const {
            x: ax,
            y: ay,
            z: az
          } = this;
          const {
            x: bx,
            y: by,
            z: bz
          } = vector;
          this.x = ay * bz - az * by;
          this.y = az * bx - ax * bz;
          this.z = ax * by - ay * bx;
          return this;
        }
        length() {
          const x = this.x;
          const y = this.y;
          const z = this.z;
          const w = this.w;
          return Math.sqrt(x * x + y * y + z * z + w * w);
        }
        lengthSqr() {
          const x = this.x;
          const y = this.y;
          const z = this.z;
          const w = this.w;
          return x * x + y * y + z * z + w * w;
        }
        normalize() {
          const x = this.x;
          const y = this.y;
          const z = this.z;
          const w = this.w;
          let len = x * x + y * y + z * z + w * w;
          if (len > 0) {
            len = 1 / Math.sqrt(len);
            this.x = x * len;
            this.y = y * len;
            this.z = z * len;
            this.w = w * len;
          }
          return this;
        }
        scale(scalar) {
          this.x *= scalar;
          this.y *= scalar;
          this.z *= scalar;
          this.w *= scalar;
          return this;
        }
        transformMat4(matrix) {
          const x = this.x;
          const y = this.y;
          const z = this.z;
          const w = this.w;
          this.x = matrix.m00 * x + matrix.m04 * y + matrix.m08 * z + matrix.m12 * w;
          this.y = matrix.m01 * x + matrix.m05 * y + matrix.m09 * z + matrix.m13 * w;
          this.z = matrix.m02 * x + matrix.m06 * y + matrix.m10 * z + matrix.m14 * w;
          this.w = matrix.m03 * x + matrix.m07 * y + matrix.m11 * z + matrix.m15 * w;
          return this;
        }
      } exports('Vec4', Vec4);
      _class$16 = Vec4;
      Vec4.ZERO = Object.freeze(new _class$16(0, 0, 0, 0));
      Vec4.ONE = Object.freeze(new _class$16(1, 1, 1, 1));
      Vec4.NEG_ONE = Object.freeze(new _class$16(-1, -1, -1, -1));
      Vec4.UNIT_X = Object.freeze(new _class$16(1, 0, 0, 0));
      Vec4.UNIT_Y = Object.freeze(new _class$16(0, 1, 0, 0));
      Vec4.UNIT_Z = Object.freeze(new _class$16(0, 0, 1, 0));
      Vec4.UNIT_W = Object.freeze(new _class$16(0, 0, 0, 1));
      CCClass.fastDefine('cc.Vec4', Vec4, {
        x: 0,
        y: 0,
        z: 0,
        w: 0
      });
      legacyCC.Vec4 = Vec4;
      function v4(x, y, z, w) {
        return new Vec4(x, y, z, w);
      }
      legacyCC.v4 = v4;

      var _class$15;
      class Vec3 extends ValueType {
        static zero(out) {
          out.x = 0;
          out.y = 0;
          out.z = 0;
          return out;
        }
        static clone(a) {
          return new Vec3(a.x, a.y, a.z);
        }
        static copy(out, a) {
          out.x = a.x;
          out.y = a.y;
          out.z = a.z;
          return out;
        }
        static set(out, x, y, z) {
          out.x = x;
          out.y = y;
          out.z = z;
          return out;
        }
        static add(out, a, b) {
          out.x = a.x + b.x;
          out.y = a.y + b.y;
          out.z = a.z + b.z;
          return out;
        }
        static subtract(out, a, b) {
          out.x = a.x - b.x;
          out.y = a.y - b.y;
          out.z = a.z - b.z;
          return out;
        }
        static multiply(out, a, b) {
          out.x = a.x * b.x;
          out.y = a.y * b.y;
          out.z = a.z * b.z;
          return out;
        }
        static divide(out, a, b) {
          out.x = a.x / b.x;
          out.y = a.y / b.y;
          out.z = a.z / b.z;
          return out;
        }
        static ceil(out, a) {
          out.x = Math.ceil(a.x);
          out.y = Math.ceil(a.y);
          out.z = Math.ceil(a.z);
          return out;
        }
        static floor(out, a) {
          out.x = Math.floor(a.x);
          out.y = Math.floor(a.y);
          out.z = Math.floor(a.z);
          return out;
        }
        static min(out, a, b) {
          out.x = Math.min(a.x, b.x);
          out.y = Math.min(a.y, b.y);
          out.z = Math.min(a.z, b.z);
          return out;
        }
        static max(out, a, b) {
          out.x = Math.max(a.x, b.x);
          out.y = Math.max(a.y, b.y);
          out.z = Math.max(a.z, b.z);
          return out;
        }
        static round(out, a) {
          out.x = Math.round(a.x);
          out.y = Math.round(a.y);
          out.z = Math.round(a.z);
          return out;
        }
        static multiplyScalar(out, a, b) {
          out.x = a.x * b;
          out.y = a.y * b;
          out.z = a.z * b;
          return out;
        }
        static scaleAndAdd(out, a, b, scale) {
          out.x = a.x + b.x * scale;
          out.y = a.y + b.y * scale;
          out.z = a.z + b.z * scale;
          return out;
        }
        static distance(a, b) {
          const x = b.x - a.x;
          const y = b.y - a.y;
          const z = b.z - a.z;
          return Math.sqrt(x * x + y * y + z * z);
        }
        static squaredDistance(a, b) {
          const x = b.x - a.x;
          const y = b.y - a.y;
          const z = b.z - a.z;
          return x * x + y * y + z * z;
        }
        static len(a) {
          const x = a.x;
          const y = a.y;
          const z = a.z;
          return Math.sqrt(x * x + y * y + z * z);
        }
        static lengthSqr(a) {
          const x = a.x;
          const y = a.y;
          const z = a.z;
          return x * x + y * y + z * z;
        }
        static negate(out, a) {
          out.x = -a.x;
          out.y = -a.y;
          out.z = -a.z;
          return out;
        }
        static invert(out, a) {
          out.x = 1.0 / a.x;
          out.y = 1.0 / a.y;
          out.z = 1.0 / a.z;
          return out;
        }
        static invertSafe(out, a) {
          const x = a.x;
          const y = a.y;
          const z = a.z;
          if (Math.abs(x) < EPSILON$2) {
            out.x = 0;
          } else {
            out.x = 1.0 / x;
          }
          if (Math.abs(y) < EPSILON$2) {
            out.y = 0;
          } else {
            out.y = 1.0 / y;
          }
          if (Math.abs(z) < EPSILON$2) {
            out.z = 0;
          } else {
            out.z = 1.0 / z;
          }
          return out;
        }
        static normalize(out, a) {
          const x = a.x;
          const y = a.y;
          const z = a.z;
          let len = x * x + y * y + z * z;
          if (len > 0) {
            len = 1 / Math.sqrt(len);
            out.x = x * len;
            out.y = y * len;
            out.z = z * len;
          } else {
            out.x = 0;
            out.y = 0;
            out.z = 0;
          }
          return out;
        }
        static dot(a, b) {
          return a.x * b.x + a.y * b.y + a.z * b.z;
        }
        static cross(out, a, b) {
          const {
            x: ax,
            y: ay,
            z: az
          } = a;
          const {
            x: bx,
            y: by,
            z: bz
          } = b;
          out.x = ay * bz - az * by;
          out.y = az * bx - ax * bz;
          out.z = ax * by - ay * bx;
          return out;
        }
        static lerp(out, a, b, t) {
          out.x = a.x + t * (b.x - a.x);
          out.y = a.y + t * (b.y - a.y);
          out.z = a.z + t * (b.z - a.z);
          return out;
        }
        static random(out, scale) {
          scale = scale || 1.0;
          const phi = random() * 2.0 * Math.PI;
          const cosTheta = random() * 2 - 1;
          const sinTheta = Math.sqrt(1 - cosTheta * cosTheta);
          out.x = sinTheta * Math.cos(phi) * scale;
          out.y = sinTheta * Math.sin(phi) * scale;
          out.z = cosTheta * scale;
          return out;
        }
        static transformMat4(out, a, m) {
          const x = a.x;
          const y = a.y;
          const z = a.z;
          let rhw = m.m03 * x + m.m07 * y + m.m11 * z + m.m15;
          rhw = rhw ? 1 / rhw : 1;
          out.x = (m.m00 * x + m.m04 * y + m.m08 * z + m.m12) * rhw;
          out.y = (m.m01 * x + m.m05 * y + m.m09 * z + m.m13) * rhw;
          out.z = (m.m02 * x + m.m06 * y + m.m10 * z + m.m14) * rhw;
          return out;
        }
        static transformMat4Normal(out, a, m) {
          const x = a.x;
          const y = a.y;
          const z = a.z;
          let rhw = m.m03 * x + m.m07 * y + m.m11 * z;
          rhw = rhw ? 1 / rhw : 1;
          out.x = (m.m00 * x + m.m04 * y + m.m08 * z) * rhw;
          out.y = (m.m01 * x + m.m05 * y + m.m09 * z) * rhw;
          out.z = (m.m02 * x + m.m06 * y + m.m10 * z) * rhw;
          return out;
        }
        static transformMat3(out, a, m) {
          const x = a.x;
          const y = a.y;
          const z = a.z;
          out.x = x * m.m00 + y * m.m03 + z * m.m06;
          out.y = x * m.m01 + y * m.m04 + z * m.m07;
          out.z = x * m.m02 + y * m.m05 + z * m.m08;
          return out;
        }
        static transformAffine(out, v, m) {
          const x = v.x;
          const y = v.y;
          const z = v.z;
          out.x = m.m00 * x + m.m04 * y + m.m08 * z + m.m12;
          out.y = m.m01 * x + m.m05 * y + m.m09 * z + m.m13;
          out.z = m.m02 * x + m.m06 * y + m.m10 * z + m.m14;
          return out;
        }
        static transformQuat(out, a, q) {
          const ix = q.w * a.x + q.y * a.z - q.z * a.y;
          const iy = q.w * a.y + q.z * a.x - q.x * a.z;
          const iz = q.w * a.z + q.x * a.y - q.y * a.x;
          const iw = -q.x * a.x - q.y * a.y - q.z * a.z;
          out.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;
          out.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;
          out.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;
          return out;
        }
        static transformRTS(out, a, r, t, s) {
          const x = a.x * s.x;
          const y = a.y * s.y;
          const z = a.z * s.z;
          const ix = r.w * x + r.y * z - r.z * y;
          const iy = r.w * y + r.z * x - r.x * z;
          const iz = r.w * z + r.x * y - r.y * x;
          const iw = -r.x * x - r.y * y - r.z * z;
          out.x = ix * r.w + iw * -r.x + iy * -r.z - iz * -r.y + t.x;
          out.y = iy * r.w + iw * -r.y + iz * -r.x - ix * -r.z + t.y;
          out.z = iz * r.w + iw * -r.z + ix * -r.y - iy * -r.x + t.z;
          return out;
        }
        static transformInverseRTS(out, a, r, t, s) {
          const x = a.x - t.x;
          const y = a.y - t.y;
          const z = a.z - t.z;
          const ix = r.w * x - r.y * z + r.z * y;
          const iy = r.w * y - r.z * x + r.x * z;
          const iz = r.w * z - r.x * y + r.y * x;
          const iw = r.x * x + r.y * y + r.z * z;
          out.x = (ix * r.w + iw * r.x + iy * r.z - iz * r.y) / s.x;
          out.y = (iy * r.w + iw * r.y + iz * r.x - ix * r.z) / s.y;
          out.z = (iz * r.w + iw * r.z + ix * r.y - iy * r.x) / s.z;
          return out;
        }
        static rotateX(out, v, o, a) {
          const x = v.x - o.x;
          const y = v.y - o.y;
          const z = v.z - o.z;
          const cos = Math.cos(a);
          const sin = Math.sin(a);
          const rx = x;
          const ry = y * cos - z * sin;
          const rz = y * sin + z * cos;
          out.x = rx + o.x;
          out.y = ry + o.y;
          out.z = rz + o.z;
          return out;
        }
        static rotateY(out, v, o, a) {
          const x = v.x - o.x;
          const y = v.y - o.y;
          const z = v.z - o.z;
          const cos = Math.cos(a);
          const sin = Math.sin(a);
          const rx = z * sin + x * cos;
          const ry = y;
          const rz = z * cos - x * sin;
          out.x = rx + o.x;
          out.y = ry + o.y;
          out.z = rz + o.z;
          return out;
        }
        static rotateZ(out, v, o, a) {
          const x = v.x - o.x;
          const y = v.y - o.y;
          const z = v.z - o.z;
          const cos = Math.cos(a);
          const sin = Math.sin(a);
          const rx = x * cos - y * sin;
          const ry = x * sin + y * cos;
          const rz = z;
          out.x = rx + o.x;
          out.y = ry + o.y;
          out.z = rz + o.z;
          return out;
        }
        static rotateN(out, v, o, n, a) {
          const x = v.x - o.x;
          const y = v.y - o.y;
          const z = v.z - o.z;
          const nx = n.x;
          const ny = n.y;
          const nz = n.z;
          const cos = Math.cos(a);
          const sin = Math.sin(a);
          const rx = x * (nx * nx * (1.0 - cos) + cos) + y * (nx * ny * (1.0 - cos) - nx * sin) + z * (nx * nz * (1.0 - cos) + ny * sin);
          const ry = x * (nx * ny * (1.0 - cos) + nz * sin) + y * (ny * ny * (1.0 - cos) + cos) + z * (ny * nz * (1.0 - cos) - nx * sin);
          const rz = x * (nx * nz * (1.0 - cos) - ny * sin) + y * (ny * nz * (1.0 - cos) + nx * sin) + z * (nz * nz * (1.0 - cos) + cos);
          out.x = rx + o.x;
          out.y = ry + o.y;
          out.z = rz + o.z;
          return out;
        }
        static toArray(out, v, ofs = 0) {
          out[ofs + 0] = v.x;
          out[ofs + 1] = v.y;
          out[ofs + 2] = v.z;
          return out;
        }
        static fromArray(out, arr, ofs = 0) {
          out.x = arr[ofs + 0];
          out.y = arr[ofs + 1];
          out.z = arr[ofs + 2];
          return out;
        }
        static strictEquals(a, b) {
          return a.x === b.x && a.y === b.y && a.z === b.z;
        }
        static equals(a, b, epsilon = EPSILON$2) {
          const {
            x: a0,
            y: a1,
            z: a2
          } = a;
          const {
            x: b0,
            y: b1,
            z: b2
          } = b;
          return Math.abs(a0 - b0) <= epsilon * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= epsilon * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= epsilon * Math.max(1.0, Math.abs(a2), Math.abs(b2));
        }
        static angle(a, b) {
          const magSqr1 = a.x * a.x + a.y * a.y + a.z * a.z;
          const magSqr2 = b.x * b.x + b.y * b.y + b.z * b.z;
          if (magSqr1 === 0 || magSqr2 === 0) {
            return 0.0;
          }
          const dot = a.x * b.x + a.y * b.y + a.z * b.z;
          let cosine = dot / Math.sqrt(magSqr1 * magSqr2);
          cosine = clamp$1(cosine, -1.0, 1.0);
          return Math.acos(cosine);
        }
        static projectOnPlane(out, a, n) {
          return Vec3.subtract(out, a, Vec3.project(out, a, n));
        }
        static project(out, a, b) {
          const sqrLen = Vec3.lengthSqr(b);
          if (sqrLen < 0.000001) {
            return Vec3.set(out, 0, 0, 0);
          } else {
            return Vec3.multiplyScalar(out, b, Vec3.dot(a, b) / sqrLen);
          }
        }
        static moveTowards(out, current, target, maxStep) {
          const deltaX = target.x - current.x;
          const deltaY = target.y - current.y;
          const deltaZ = target.z - current.z;
          const distanceSqr = deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ;
          if (distanceSqr === 0 || maxStep >= 0 && distanceSqr < maxStep * maxStep) {
            out.x = target.x;
            out.y = target.y;
            out.z = target.z;
            return out;
          }
          const distance = Math.sqrt(distanceSqr);
          const scale = maxStep / distance;
          out.x = current.x + deltaX * scale;
          out.y = current.y + deltaY * scale;
          out.z = current.z + deltaZ * scale;
          return out;
        }
        static generateOrthogonal(out, n) {
          const {
            x,
            y,
            z
          } = n;
          const absX = Math.abs(x);
          const absY = Math.abs(y);
          const absZ = Math.abs(z);
          if (absX < absY && absX < absZ) {
            Vec3.set(out, 0.0, z, -y);
          } else if (absY < absZ) {
            Vec3.set(out, z, 0.0, -x);
          } else {
            Vec3.set(out, y, -x, 0.0);
          }
          return Vec3.normalize(out, out);
        }
        constructor(x, y, z) {
          super();
          if (typeof x === 'object') {
            this.x = x.x;
            this.y = x.y;
            this.z = x.z;
          } else {
            this.x = x || 0;
            this.y = y || 0;
            this.z = z || 0;
          }
        }
        clone() {
          return new Vec3(this.x, this.y, this.z);
        }
        set(x, y, z) {
          if (typeof x === 'object') {
            this.x = x.x;
            this.y = x.y;
            this.z = x.z;
          } else {
            this.x = x || 0;
            this.y = y || 0;
            this.z = z || 0;
          }
          return this;
        }
        equals(other, epsilon = EPSILON$2) {
          return Math.abs(this.x - other.x) <= epsilon && Math.abs(this.y - other.y) <= epsilon && Math.abs(this.z - other.z) <= epsilon;
        }
        equals3f(x, y, z, epsilon = EPSILON$2) {
          return Math.abs(this.x - x) <= epsilon && Math.abs(this.y - y) <= epsilon && Math.abs(this.z - z) <= epsilon;
        }
        strictEquals(other) {
          return this.x === other.x && this.y === other.y && this.z === other.z;
        }
        strictEquals3f(x, y, z) {
          return this.x === x && this.y === y && this.z === z;
        }
        toString() {
          return `(${this.x.toFixed(2)}, ${this.y.toFixed(2)}, ${this.z.toFixed(2)})`;
        }
        lerp(to, ratio) {
          this.x += ratio * (to.x - this.x);
          this.y += ratio * (to.y - this.y);
          this.z += ratio * (to.z - this.z);
          return this;
        }
        add(other) {
          this.x += other.x;
          this.y += other.y;
          this.z += other.z;
          return this;
        }
        add3f(x, y, z) {
          this.x += x;
          this.y += y;
          this.z += z;
          return this;
        }
        subtract(other) {
          this.x -= other.x;
          this.y -= other.y;
          this.z -= other.z;
          return this;
        }
        subtract3f(x, y, z) {
          this.x -= x;
          this.y -= y;
          this.z -= z;
          return this;
        }
        multiplyScalar(scalar) {
          if (typeof scalar === 'object') {
            console.warn('should use Vec3.multiply for vector * vector operation');
          }
          this.x *= scalar;
          this.y *= scalar;
          this.z *= scalar;
          return this;
        }
        multiply(other) {
          if (typeof other !== 'object') {
            console.warn('should use Vec3.scale for vector * scalar operation');
          }
          this.x *= other.x;
          this.y *= other.y;
          this.z *= other.z;
          return this;
        }
        multiply3f(x, y, z) {
          this.x *= x;
          this.y *= y;
          this.z *= z;
          return this;
        }
        divide(other) {
          this.x /= other.x;
          this.y /= other.y;
          this.z /= other.z;
          return this;
        }
        divide3f(x, y, z) {
          this.x /= x;
          this.y /= y;
          this.z /= z;
          return this;
        }
        negative() {
          this.x = -this.x;
          this.y = -this.y;
          this.z = -this.z;
          return this;
        }
        clampf(minInclusive, maxInclusive) {
          this.x = clamp$1(this.x, minInclusive.x, maxInclusive.x);
          this.y = clamp$1(this.y, minInclusive.y, maxInclusive.y);
          this.z = clamp$1(this.z, minInclusive.z, maxInclusive.z);
          return this;
        }
        dot(other) {
          return this.x * other.x + this.y * other.y + this.z * other.z;
        }
        cross(other) {
          const {
            x: ax,
            y: ay,
            z: az
          } = this;
          const {
            x: bx,
            y: by,
            z: bz
          } = other;
          this.x = ay * bz - az * by;
          this.y = az * bx - ax * bz;
          this.z = ax * by - ay * bx;
          return this;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        }
        lengthSqr() {
          return this.x * this.x + this.y * this.y + this.z * this.z;
        }
        normalize() {
          const x = this.x;
          const y = this.y;
          const z = this.z;
          let len = x * x + y * y + z * z;
          if (len > 0) {
            len = 1 / Math.sqrt(len);
            this.x = x * len;
            this.y = y * len;
            this.z = z * len;
          }
          return this;
        }
        transformMat4(matrix) {
          const x = this.x;
          const y = this.y;
          const z = this.z;
          let rhw = matrix.m03 * x + matrix.m07 * y + matrix.m11 * z + matrix.m15;
          rhw = rhw ? 1 / rhw : 1;
          this.x = (matrix.m00 * x + matrix.m04 * y + matrix.m08 * z + matrix.m12) * rhw;
          this.y = (matrix.m01 * x + matrix.m05 * y + matrix.m09 * z + matrix.m13) * rhw;
          this.z = (matrix.m02 * x + matrix.m06 * y + matrix.m10 * z + matrix.m14) * rhw;
          return this;
        }
      } exports('Vec3', Vec3);
      _class$15 = Vec3;
      Vec3.UNIT_X = Object.freeze(new _class$15(1, 0, 0));
      Vec3.UNIT_Y = Object.freeze(new _class$15(0, 1, 0));
      Vec3.UNIT_Z = Object.freeze(new _class$15(0, 0, 1));
      Vec3.RIGHT = Object.freeze(new _class$15(1, 0, 0));
      Vec3.UP = Object.freeze(new _class$15(0, 1, 0));
      Vec3.FORWARD = Object.freeze(new _class$15(0, 0, -1));
      Vec3.ZERO = Object.freeze(new _class$15(0, 0, 0));
      Vec3.ONE = Object.freeze(new _class$15(1, 1, 1));
      Vec3.NEG_ONE = Object.freeze(new _class$15(-1, -1, -1));
      Vec3.slerp = (() => {
        const cacheV1 = new _class$15();
        const cacheV2 = new _class$15();
        const cacheV3 = new _class$15();
        return (out, from, to, t) => {
          const EPSILON = 1e-5;
          const lenFrom = _class$15.len(from);
          const lenTo = _class$15.len(to);
          if (lenFrom < EPSILON || lenTo < EPSILON) {
            return _class$15.lerp(out, from, to, t);
          }
          const lenLerped = lerp(lenFrom, lenTo, t);
          const dot = _class$15.dot(from, to) / (lenFrom * lenTo);
          if (dot > 1.0 - EPSILON) {
            return _class$15.lerp(out, from, to, t);
          } else if (dot < -1.0 + EPSILON) {
            const fromNormalized = _class$15.multiplyScalar(cacheV1, from, 1.0 / lenFrom);
            const axis = _class$15.generateOrthogonal(cacheV2, fromNormalized);
            const angle = Math.PI * t;
            rotateAxisAngle(cacheV3, fromNormalized, axis, angle);
            _class$15.multiplyScalar(out, cacheV3, lenLerped);
            return out;
          } else {
            const dotClamped = dot;
            const theta = Math.acos(dotClamped) * t;
            const fromNormalized = _class$15.multiplyScalar(cacheV1, from, 1.0 / lenFrom);
            const toNormalized = _class$15.multiplyScalar(cacheV2, to, 1.0 / lenTo);
            _class$15.scaleAndAdd(cacheV3, toNormalized, fromNormalized, -dotClamped);
            _class$15.normalize(cacheV3, cacheV3);
            _class$15.multiplyScalar(cacheV3, cacheV3, Math.sin(theta));
            _class$15.scaleAndAdd(cacheV3, cacheV3, fromNormalized, Math.cos(theta));
            _class$15.multiplyScalar(out, cacheV3, lenLerped);
            return out;
          }
        };
      })();
      CCClass.fastDefine('cc.Vec3', Vec3, {
        x: 0,
        y: 0,
        z: 0
      });
      legacyCC.Vec3 = Vec3;
      function v3(x, y, z) {
        return new Vec3(x, y, z);
      }
      const rotateAxisAngle = (() => {
        const cacheQ = {
          x: 0.0,
          y: 0.0,
          z: 0.0,
          w: 0.0
        };
        return (out, input, axis, angle) => {
          const rad = angle * 0.5;
          const s = Math.sin(rad);
          cacheQ.x = s * axis.x;
          cacheQ.y = s * axis.y;
          cacheQ.z = s * axis.z;
          cacheQ.w = Math.cos(rad);
          Vec3.transformQuat(out, input, cacheQ);
          return out;
        };
      })();
      legacyCC.v3 = v3;

      var _class$14;
      const toFloat = 1 / 255;
      class Color$1 extends ValueType {
        static clone(a) {
          const out = new Color$1();
          if (a._val) {
            out._val = a._val;
          } else {
            out._val = (a.a << 24 >>> 0) + (a.b << 16) + (a.g << 8) + a.r;
          }
          return out;
        }
        static copy(out, a) {
          out.r = a.r;
          out.g = a.g;
          out.b = a.b;
          out.a = a.a;
          return out;
        }
        static set(out, r, g, b, a) {
          out.r = r;
          out.g = g;
          out.b = b;
          out.a = a;
          return out;
        }
        static toVec4(color, out) {
          out = out !== undefined ? out : new Vec4();
          out.x = color.r * toFloat;
          out.y = color.g * toFloat;
          out.z = color.b * toFloat;
          out.w = color.a * toFloat;
          return out;
        }
        static fromVec4(value, out) {
          out = out === undefined ? new Color$1() : out;
          out.r = Math.floor(value.x / toFloat);
          out.g = Math.floor(value.y / toFloat);
          out.b = Math.floor(value.z / toFloat);
          out.a = Math.floor(value.w / toFloat);
          return out;
        }
        static fromHEX(out, hexString) {
          hexString = hexString.indexOf('#') === 0 ? hexString.substring(1) : hexString;
          out.r = parseInt(hexString.substr(0, 2), 16) || 0;
          out.g = parseInt(hexString.substr(2, 2), 16) || 0;
          out.b = parseInt(hexString.substr(4, 2), 16) || 0;
          const a = parseInt(hexString.substr(6, 2), 16);
          out.a = !Number.isNaN(a) ? a : 255;
          out._val = (out.a << 24 >>> 0) + (out.b << 16) + (out.g << 8) + out.r;
          return out;
        }
        static add(out, a, b) {
          out.r = a.r + b.r;
          out.g = a.g + b.g;
          out.b = a.b + b.b;
          out.a = a.a + b.a;
          return out;
        }
        static subtract(out, a, b) {
          out.r = a.r - b.r;
          out.g = a.g - b.g;
          out.b = a.b - b.b;
          out.a = a.a - b.a;
          return out;
        }
        static multiply(out, a, b) {
          out.r = a.r * b.r;
          out.g = a.g * b.g;
          out.b = a.b * b.b;
          out.a = a.a * b.a;
          return out;
        }
        static divide(out, a, b) {
          out.r = a.r / b.r;
          out.g = a.g / b.g;
          out.b = a.b / b.b;
          out.a = a.a / b.a;
          return out;
        }
        static scale(out, a, b) {
          out.r = a.r * b;
          out.g = a.g * b;
          out.b = a.b * b;
          out.a = a.a * b;
          return out;
        }
        static lerp(out, from, to, ratio) {
          let r = from.r;
          let g = from.g;
          let b = from.b;
          let a = from.a;
          r += (to.r - r) * ratio;
          g += (to.g - g) * ratio;
          b += (to.b - b) * ratio;
          a += (to.a - a) * ratio;
          out._val = Math.floor((a << 24 >>> 0) + (b << 16) + (g << 8) + r);
          return out;
        }
        static toArray(out, a, ofs = 0) {
          const scale = a instanceof Color$1 || a.a > 1 ? 1 / 255 : 1;
          out[ofs + 0] = a.r * scale;
          out[ofs + 1] = a.g * scale;
          out[ofs + 2] = a.b * scale;
          out[ofs + 3] = a.a * scale;
          return out;
        }
        static fromArray(arr, out, ofs = 0) {
          out.r = arr[ofs + 0] * 255;
          out.g = arr[ofs + 1] * 255;
          out.b = arr[ofs + 2] * 255;
          out.a = arr[ofs + 3] * 255;
          return out;
        }
        static fromUint32(out, uint32) {
          out._val = uint32;
          return out;
        }
        static toUint32(color) {
          return color._val;
        }
        static strictEquals(a, b) {
          return a.r === b.r && a.g === b.g && a.b === b.b && a.a === b.a;
        }
        static equals(a, b, epsilon = EPSILON$2) {
          const hasInf = Math.abs(a.r) === Infinity || Math.abs(a.g) === Infinity || Math.abs(a.b) === Infinity || Math.abs(a.a) === Infinity;
          return !hasInf && Math.abs(a.r - b.r) <= epsilon * Math.max(1.0, Math.abs(a.r), Math.abs(b.r)) && Math.abs(a.g - b.g) <= epsilon * Math.max(1.0, Math.abs(a.g), Math.abs(b.g)) && Math.abs(a.b - b.b) <= epsilon * Math.max(1.0, Math.abs(a.b), Math.abs(b.b)) && Math.abs(a.a - b.a) <= epsilon * Math.max(1.0, Math.abs(a.a), Math.abs(b.a));
        }
        static hex(a) {
          return (a.r * 255 << 24 | a.g * 255 << 16 | a.b * 255 << 8 | a.a * 255) >>> 0;
        }
        get r() {
          return this._val & 0x000000ff;
        }
        set r(red) {
          red = ~~clamp$1(red, 0, 255);
          this._val = (this._val & 0xffffff00 | red) >>> 0;
        }
        get g() {
          return (this._val & 0x0000ff00) >> 8;
        }
        set g(green) {
          green = ~~clamp$1(green, 0, 255);
          this._val = (this._val & 0xffff00ff | green << 8) >>> 0;
        }
        get b() {
          return (this._val & 0x00ff0000) >> 16;
        }
        set b(blue) {
          blue = ~~clamp$1(blue, 0, 255);
          this._val = (this._val & 0xff00ffff | blue << 16) >>> 0;
        }
        get a() {
          return (this._val & 0xff000000) >>> 24;
        }
        set a(alpha) {
          alpha = ~~clamp$1(alpha, 0, 255);
          this._val = (this._val & 0x00ffffff | alpha << 24) >>> 0;
        }
        get x() {
          return this.r * toFloat;
        }
        set x(value) {
          this.r = value * 255;
        }
        get y() {
          return this.g * toFloat;
        }
        set y(value) {
          this.g = value * 255;
        }
        get z() {
          return this.b * toFloat;
        }
        set z(value) {
          this.b = value * 255;
        }
        get w() {
          return this.a * toFloat;
        }
        set w(value) {
          this.a = value * 255;
        }
        constructor(r, g, b, a) {
          super();
          this._val = 0;
          if (typeof r === 'string') {
            this.fromHEX(r);
          } else if (g !== undefined) {
            this.set(r, g, b, a);
          } else {
            this.set(r);
          }
        }
        clone() {
          const ret = new Color$1();
          ret._val = this._val;
          return ret;
        }
        equals(other) {
          return other && this._val === other._val;
        }
        lerp(to, ratio) {
          let r = this.r;
          let g = this.g;
          let b = this.b;
          let a = this.a;
          r += (to.r - r) * ratio;
          g += (to.g - g) * ratio;
          b += (to.b - b) * ratio;
          a += (to.a - a) * ratio;
          this._val = Math.floor((a << 24 >>> 0) + (b << 16) + (g << 8) + r);
          return this;
        }
        toString() {
          return `rgba(${this.r.toFixed()}, ${this.g.toFixed()}, ${this.b.toFixed()}, ${this.a.toFixed()})`;
        }
        toCSS(opt = 'rgba') {
          if (opt === 'rgba') {
            return `rgba(${this.r},${this.g},${this.b},${(this.a * toFloat).toFixed(2)})`;
          } else if (opt === 'rgb') {
            return `rgb(${this.r},${this.g},${this.b})`;
          } else {
            return `#${this.toHEX(opt)}`;
          }
        }
        fromHEX(hexString) {
          hexString = hexString.indexOf('#') === 0 ? hexString.substring(1) : hexString;
          const r = parseInt(hexString.substr(0, 2), 16) || 0;
          const g = parseInt(hexString.substr(2, 2), 16) || 0;
          const b = parseInt(hexString.substr(4, 2), 16) || 0;
          let a = parseInt(hexString.substr(6, 2), 16);
          a = !Number.isNaN(a) ? a : 255;
          this._val = (a << 24 >>> 0) + (b << 16) + (g << 8) + (r | 0);
          return this;
        }
        toHEX(fmt = '#rrggbb') {
          const prefix = '0';
          const hex = [(this.r < 16 ? prefix : '') + this.r.toString(16), (this.g < 16 ? prefix : '') + this.g.toString(16), (this.b < 16 ? prefix : '') + this.b.toString(16)];
          if (fmt === '#rgb') {
            hex[0] = hex[0][0];
            hex[1] = hex[1][0];
            hex[2] = hex[2][0];
          } else if (fmt === '#rrggbbaa') {
            hex.push((this.a < 16 ? prefix : '') + this.a.toString(16));
          }
          return hex.join('');
        }
        toRGBValue() {
          return this._val & 0x00ffffff;
        }
        fromHSV(h, s, v) {
          let r = 0;
          let g = 0;
          let b = 0;
          if (s === 0) {
            r = g = b = v;
          } else if (v === 0) {
            r = g = b = 0;
          } else {
            if (h === 1) {
              h = 0;
            }
            h *= 6;
            const i = Math.floor(h);
            const f = h - i;
            const p = v * (1 - s);
            const q = v * (1 - s * f);
            const t = v * (1 - s * (1 - f));
            switch (i) {
              default:
                assertIsTrue(false);
              case 0:
                r = v;
                g = t;
                b = p;
                break;
              case 1:
                r = q;
                g = v;
                b = p;
                break;
              case 2:
                r = p;
                g = v;
                b = t;
                break;
              case 3:
                r = p;
                g = q;
                b = v;
                break;
              case 4:
                r = t;
                g = p;
                b = v;
                break;
              case 5:
                r = v;
                g = p;
                b = q;
                break;
            }
          }
          r *= 255;
          g *= 255;
          b *= 255;
          this._val = (this.a << 24 >>> 0) + (b << 16) + (g << 8) + (r | 0);
          return this;
        }
        toHSV() {
          const r = this.r * toFloat;
          const g = this.g * toFloat;
          const b = this.b * toFloat;
          const hsv = {
            h: 0,
            s: 0,
            v: 0
          };
          const max = Math.max(r, g, b);
          const min = Math.min(r, g, b);
          let delta = 0;
          hsv.v = max;
          hsv.s = max ? (max - min) / max : 0;
          if (!hsv.s) {
            hsv.h = 0;
          } else {
            delta = max - min;
            if (r === max) {
              hsv.h = (g - b) / delta;
            } else if (g === max) {
              hsv.h = 2 + (b - r) / delta;
            } else {
              hsv.h = 4 + (r - g) / delta;
            }
            hsv.h /= 6;
            if (hsv.h < 0) {
              hsv.h += 1.0;
            }
          }
          return hsv;
        }
        set(r, g, b, a) {
          if (typeof r === 'object') {
            if (r._val != null) {
              this._val = r._val;
            } else {
              g = r.g || 0;
              b = r.b || 0;
              a = typeof r.a === 'number' ? r.a : 255;
              r = r.r || 0;
              this._val = (a << 24 >>> 0) + (b << 16) + (g << 8) + (r | 0);
            }
          } else {
            r = r || 0;
            g = g || 0;
            b = b || 0;
            a = typeof a === 'number' ? a : 255;
            this._val = (a << 24 >>> 0) + (b << 16) + (g << 8) + (r | 0);
          }
          return this;
        }
        multiply(other) {
          const r = (this._val & 0x000000ff) * other.r >> 8;
          const g = (this._val & 0x0000ff00) * other.g >> 8;
          const b = (this._val & 0x00ff0000) * other.b >> 8;
          const a = ((this._val & 0xff000000) >>> 8) * other.a;
          this._val = a & 0xff000000 | b & 0x00ff0000 | g & 0x0000ff00 | r & 0x000000ff;
          return this;
        }
        _set_r_unsafe(red) {
          this._val = (this._val & 0xffffff00 | red) >>> 0;
          return this;
        }
        _set_g_unsafe(green) {
          this._val = (this._val & 0xffff00ff | green << 8) >>> 0;
          return this;
        }
        _set_b_unsafe(blue) {
          this._val = (this._val & 0xff00ffff | blue << 16) >>> 0;
          return this;
        }
        _set_a_unsafe(alpha) {
          this._val = (this._val & 0x00ffffff | alpha << 24) >>> 0;
          return this;
        }
      } exports('Color', Color$1);
      _class$14 = Color$1;
      Color$1.WHITE = Object.freeze(new _class$14(255, 255, 255, 255));
      Color$1.GRAY = Object.freeze(new _class$14(127, 127, 127, 255));
      Color$1.BLACK = Object.freeze(new _class$14(0, 0, 0, 255));
      Color$1.TRANSPARENT = Object.freeze(new _class$14(0, 0, 0, 0));
      Color$1.RED = Object.freeze(new _class$14(255, 0, 0, 255));
      Color$1.GREEN = Object.freeze(new _class$14(0, 255, 0, 255));
      Color$1.BLUE = Object.freeze(new _class$14(0, 0, 255, 255));
      Color$1.CYAN = Object.freeze(new _class$14(0, 255, 255, 255));
      Color$1.MAGENTA = Object.freeze(new _class$14(255, 0, 255, 255));
      Color$1.YELLOW = Object.freeze(new _class$14(255, 255, 0, 255));
      CCClass.fastDefine('cc.Color', Color$1, {
        r: 0,
        g: 0,
        b: 0,
        a: 255
      });
      legacyCC.Color = Color$1;
      function color(r, g, b, a) {
        return new Color$1(r, g, b, a);
      }
      legacyCC.color = color;

      var _class$13;
      class Mat3 extends ValueType {
        static clone(a) {
          return new Mat3(a.m00, a.m01, a.m02, a.m03, a.m04, a.m05, a.m06, a.m07, a.m08);
        }
        static copy(out, a) {
          out.m00 = a.m00;
          out.m01 = a.m01;
          out.m02 = a.m02;
          out.m03 = a.m03;
          out.m04 = a.m04;
          out.m05 = a.m05;
          out.m06 = a.m06;
          out.m07 = a.m07;
          out.m08 = a.m08;
          return out;
        }
        static set(out, m00, m01, m02, m03, m04, m05, m06, m07, m08) {
          out.m00 = m00;
          out.m01 = m01;
          out.m02 = m02;
          out.m03 = m03;
          out.m04 = m04;
          out.m05 = m05;
          out.m06 = m06;
          out.m07 = m07;
          out.m08 = m08;
          return out;
        }
        static identity(out) {
          out.m00 = 1;
          out.m01 = 0;
          out.m02 = 0;
          out.m03 = 0;
          out.m04 = 1;
          out.m05 = 0;
          out.m06 = 0;
          out.m07 = 0;
          out.m08 = 1;
          return out;
        }
        static transpose(out, a) {
          if (out === a) {
            const a01 = a.m01;
            const a02 = a.m02;
            const a12 = a.m05;
            out.m01 = a.m03;
            out.m02 = a.m06;
            out.m03 = a01;
            out.m05 = a.m07;
            out.m06 = a02;
            out.m07 = a12;
          } else {
            out.m00 = a.m00;
            out.m01 = a.m03;
            out.m02 = a.m06;
            out.m03 = a.m01;
            out.m04 = a.m04;
            out.m05 = a.m07;
            out.m06 = a.m02;
            out.m07 = a.m05;
            out.m08 = a.m08;
          }
          return out;
        }
        static invert(out, a) {
          const a00 = a.m00;
          const a01 = a.m01;
          const a02 = a.m02;
          const a10 = a.m03;
          const a11 = a.m04;
          const a12 = a.m05;
          const a20 = a.m06;
          const a21 = a.m07;
          const a22 = a.m08;
          const b01 = a22 * a11 - a12 * a21;
          const b11 = -a22 * a10 + a12 * a20;
          const b21 = a21 * a10 - a11 * a20;
          let det = a00 * b01 + a01 * b11 + a02 * b21;
          if (det === 0) {
            out.m00 = 0;
            out.m01 = 0;
            out.m02 = 0;
            out.m03 = 0;
            out.m04 = 0;
            out.m05 = 0;
            out.m06 = 0;
            out.m07 = 0;
            out.m08 = 0;
            return out;
          }
          det = 1.0 / det;
          out.m00 = b01 * det;
          out.m01 = (-a22 * a01 + a02 * a21) * det;
          out.m02 = (a12 * a01 - a02 * a11) * det;
          out.m03 = b11 * det;
          out.m04 = (a22 * a00 - a02 * a20) * det;
          out.m05 = (-a12 * a00 + a02 * a10) * det;
          out.m06 = b21 * det;
          out.m07 = (-a21 * a00 + a01 * a20) * det;
          out.m08 = (a11 * a00 - a01 * a10) * det;
          return out;
        }
        static determinant(a) {
          const a00 = a.m00;
          const a01 = a.m01;
          const a02 = a.m02;
          const a10 = a.m03;
          const a11 = a.m04;
          const a12 = a.m05;
          const a20 = a.m06;
          const a21 = a.m07;
          const a22 = a.m08;
          return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
        }
        static multiply(out, a, b) {
          const a00 = a.m00;
          const a01 = a.m01;
          const a02 = a.m02;
          const a10 = a.m03;
          const a11 = a.m04;
          const a12 = a.m05;
          const a20 = a.m06;
          const a21 = a.m07;
          const a22 = a.m08;
          const b00 = b.m00;
          const b01 = b.m01;
          const b02 = b.m02;
          const b10 = b.m03;
          const b11 = b.m04;
          const b12 = b.m05;
          const b20 = b.m06;
          const b21 = b.m07;
          const b22 = b.m08;
          out.m00 = b00 * a00 + b01 * a10 + b02 * a20;
          out.m01 = b00 * a01 + b01 * a11 + b02 * a21;
          out.m02 = b00 * a02 + b01 * a12 + b02 * a22;
          out.m03 = b10 * a00 + b11 * a10 + b12 * a20;
          out.m04 = b10 * a01 + b11 * a11 + b12 * a21;
          out.m05 = b10 * a02 + b11 * a12 + b12 * a22;
          out.m06 = b20 * a00 + b21 * a10 + b22 * a20;
          out.m07 = b20 * a01 + b21 * a11 + b22 * a21;
          out.m08 = b20 * a02 + b21 * a12 + b22 * a22;
          return out;
        }
        static multiplyMat4(out, a, b) {
          const a00 = a.m00;
          const a01 = a.m01;
          const a02 = a.m02;
          const a10 = a.m03;
          const a11 = a.m04;
          const a12 = a.m05;
          const a20 = a.m06;
          const a21 = a.m07;
          const a22 = a.m08;
          const b00 = b.m00;
          const b01 = b.m01;
          const b02 = b.m02;
          const b10 = b.m04;
          const b11 = b.m05;
          const b12 = b.m06;
          const b20 = b.m08;
          const b21 = b.m09;
          const b22 = b.m10;
          out.m00 = b00 * a00 + b01 * a10 + b02 * a20;
          out.m01 = b00 * a01 + b01 * a11 + b02 * a21;
          out.m02 = b00 * a02 + b01 * a12 + b02 * a22;
          out.m03 = b10 * a00 + b11 * a10 + b12 * a20;
          out.m04 = b10 * a01 + b11 * a11 + b12 * a21;
          out.m05 = b10 * a02 + b11 * a12 + b12 * a22;
          out.m06 = b20 * a00 + b21 * a10 + b22 * a20;
          out.m07 = b20 * a01 + b21 * a11 + b22 * a21;
          out.m08 = b20 * a02 + b21 * a12 + b22 * a22;
          return out;
        }
        static transform(out, a, v) {
          this.translate(out, a, v);
        }
        static translate(out, a, v) {
          const a00 = a.m00;
          const a01 = a.m01;
          const a02 = a.m02;
          const a10 = a.m03;
          const a11 = a.m04;
          const a12 = a.m05;
          const a20 = a.m06;
          const a21 = a.m07;
          const a22 = a.m08;
          const x = v.x;
          const y = v.y;
          out.m00 = a00;
          out.m01 = a01;
          out.m02 = a02;
          out.m03 = a10;
          out.m04 = a11;
          out.m05 = a12;
          out.m06 = x * a00 + y * a10 + a20;
          out.m07 = x * a01 + y * a11 + a21;
          out.m08 = x * a02 + y * a12 + a22;
          return out;
        }
        static scale(out, a, v) {
          const x = v.x;
          const y = v.y;
          out.m00 = x * a.m00;
          out.m01 = x * a.m01;
          out.m02 = x * a.m02;
          out.m03 = y * a.m03;
          out.m04 = y * a.m04;
          out.m05 = y * a.m05;
          out.m06 = a.m06;
          out.m07 = a.m07;
          out.m08 = a.m08;
          return out;
        }
        static rotate(out, a, rad) {
          const a00 = a.m00;
          const a01 = a.m01;
          const a02 = a.m02;
          const a10 = a.m03;
          const a11 = a.m04;
          const a12 = a.m05;
          const a20 = a.m06;
          const a21 = a.m07;
          const a22 = a.m08;
          const s = Math.sin(rad);
          const c = Math.cos(rad);
          out.m00 = c * a00 + s * a10;
          out.m01 = c * a01 + s * a11;
          out.m02 = c * a02 + s * a12;
          out.m03 = c * a10 - s * a00;
          out.m04 = c * a11 - s * a01;
          out.m05 = c * a12 - s * a02;
          out.m06 = a20;
          out.m07 = a21;
          out.m08 = a22;
          return out;
        }
        static fromMat4(out, a) {
          out.m00 = a.m00;
          out.m01 = a.m01;
          out.m02 = a.m02;
          out.m03 = a.m04;
          out.m04 = a.m05;
          out.m05 = a.m06;
          out.m06 = a.m08;
          out.m07 = a.m09;
          out.m08 = a.m10;
          return out;
        }
        static fromViewUp(out, view, up) {
          if (Vec3.lengthSqr(view) < EPSILON$2 * EPSILON$2) {
            Mat3.identity(out);
            return out;
          }
          up = up || Vec3.UNIT_Y;
          Vec3.normalize(v3_1$2, Vec3.cross(v3_1$2, up, view));
          if (Vec3.lengthSqr(v3_1$2) < EPSILON$2 * EPSILON$2) {
            Mat3.identity(out);
            return out;
          }
          Vec3.cross(v3_2, view, v3_1$2);
          Mat3.set(out, v3_1$2.x, v3_1$2.y, v3_1$2.z, v3_2.x, v3_2.y, v3_2.z, view.x, view.y, view.z);
          return out;
        }
        static fromTranslation(out, v) {
          out.m00 = 1;
          out.m01 = 0;
          out.m02 = 0;
          out.m03 = 0;
          out.m04 = 1;
          out.m05 = 0;
          out.m06 = v.x;
          out.m07 = v.y;
          out.m08 = 1;
          return out;
        }
        static fromScaling(out, v) {
          out.m00 = v.x;
          out.m01 = 0;
          out.m02 = 0;
          out.m03 = 0;
          out.m04 = v.y;
          out.m05 = 0;
          out.m06 = 0;
          out.m07 = 0;
          out.m08 = 1;
          return out;
        }
        static fromRotation(out, rad) {
          const s = Math.sin(rad);
          const c = Math.cos(rad);
          out.m00 = c;
          out.m01 = s;
          out.m02 = 0;
          out.m03 = -s;
          out.m04 = c;
          out.m05 = 0;
          out.m06 = 0;
          out.m07 = 0;
          out.m08 = 1;
          return out;
        }
        static fromQuat(out, q) {
          const x = q.x;
          const y = q.y;
          const z = q.z;
          const w = q.w;
          const x2 = x + x;
          const y2 = y + y;
          const z2 = z + z;
          const xx = x * x2;
          const yx = y * x2;
          const yy = y * y2;
          const zx = z * x2;
          const zy = z * y2;
          const zz = z * z2;
          const wx = w * x2;
          const wy = w * y2;
          const wz = w * z2;
          out.m00 = 1 - yy - zz;
          out.m03 = yx - wz;
          out.m06 = zx + wy;
          out.m01 = yx + wz;
          out.m04 = 1 - xx - zz;
          out.m07 = zy - wx;
          out.m02 = zx - wy;
          out.m05 = zy + wx;
          out.m08 = 1 - xx - yy;
          return out;
        }
        static inverseTransposeMat4(out, a) {
          const a00 = a.m00;
          const a01 = a.m01;
          const a02 = a.m02;
          const a03 = a.m03;
          const a10 = a.m04;
          const a11 = a.m05;
          const a12 = a.m06;
          const a13 = a.m07;
          const a20 = a.m08;
          const a21 = a.m09;
          const a22 = a.m10;
          const a23 = a.m11;
          const a30 = a.m12;
          const a31 = a.m13;
          const a32 = a.m14;
          const a33 = a.m15;
          const b00 = a00 * a11 - a01 * a10;
          const b01 = a00 * a12 - a02 * a10;
          const b02 = a00 * a13 - a03 * a10;
          const b03 = a01 * a12 - a02 * a11;
          const b04 = a01 * a13 - a03 * a11;
          const b05 = a02 * a13 - a03 * a12;
          const b06 = a20 * a31 - a21 * a30;
          const b07 = a20 * a32 - a22 * a30;
          const b08 = a20 * a33 - a23 * a30;
          const b09 = a21 * a32 - a22 * a31;
          const b10 = a21 * a33 - a23 * a31;
          const b11 = a22 * a33 - a23 * a32;
          let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
          if (!det) {
            return null;
          }
          det = 1.0 / det;
          out.m00 = (a11 * b11 - a12 * b10 + a13 * b09) * det;
          out.m01 = (a12 * b08 - a10 * b11 - a13 * b07) * det;
          out.m02 = (a10 * b10 - a11 * b08 + a13 * b06) * det;
          out.m03 = (a02 * b10 - a01 * b11 - a03 * b09) * det;
          out.m04 = (a00 * b11 - a02 * b08 + a03 * b07) * det;
          out.m05 = (a01 * b08 - a00 * b10 - a03 * b06) * det;
          out.m06 = (a31 * b05 - a32 * b04 + a33 * b03) * det;
          out.m07 = (a32 * b02 - a30 * b05 - a33 * b01) * det;
          out.m08 = (a30 * b04 - a31 * b02 + a33 * b00) * det;
          return out;
        }
        static toArray(out, m, ofs = 0) {
          out[ofs + 0] = m.m00;
          out[ofs + 1] = m.m01;
          out[ofs + 2] = m.m02;
          out[ofs + 3] = m.m03;
          out[ofs + 4] = m.m04;
          out[ofs + 5] = m.m05;
          out[ofs + 6] = m.m06;
          out[ofs + 7] = m.m07;
          out[ofs + 8] = m.m08;
          return out;
        }
        static fromArray(out, arr, ofs = 0) {
          out.m00 = arr[ofs + 0];
          out.m01 = arr[ofs + 1];
          out.m02 = arr[ofs + 2];
          out.m03 = arr[ofs + 3];
          out.m04 = arr[ofs + 4];
          out.m05 = arr[ofs + 5];
          out.m06 = arr[ofs + 6];
          out.m07 = arr[ofs + 7];
          out.m08 = arr[ofs + 8];
          return out;
        }
        static add(out, a, b) {
          out.m00 = a.m00 + b.m00;
          out.m01 = a.m01 + b.m01;
          out.m02 = a.m02 + b.m02;
          out.m03 = a.m03 + b.m03;
          out.m04 = a.m04 + b.m04;
          out.m05 = a.m05 + b.m05;
          out.m06 = a.m06 + b.m06;
          out.m07 = a.m07 + b.m07;
          out.m08 = a.m08 + b.m08;
          return out;
        }
        static subtract(out, a, b) {
          out.m00 = a.m00 - b.m00;
          out.m01 = a.m01 - b.m01;
          out.m02 = a.m02 - b.m02;
          out.m03 = a.m03 - b.m03;
          out.m04 = a.m04 - b.m04;
          out.m05 = a.m05 - b.m05;
          out.m06 = a.m06 - b.m06;
          out.m07 = a.m07 - b.m07;
          out.m08 = a.m08 - b.m08;
          return out;
        }
        static multiplyScalar(out, a, b) {
          out.m00 = a.m00 * b;
          out.m01 = a.m01 * b;
          out.m02 = a.m02 * b;
          out.m03 = a.m03 * b;
          out.m04 = a.m04 * b;
          out.m05 = a.m05 * b;
          out.m06 = a.m06 * b;
          out.m07 = a.m07 * b;
          out.m08 = a.m08 * b;
          return out;
        }
        static multiplyScalarAndAdd(out, a, b, scale) {
          out.m00 = b.m00 * scale + a.m00;
          out.m01 = b.m01 * scale + a.m01;
          out.m02 = b.m02 * scale + a.m02;
          out.m03 = b.m03 * scale + a.m03;
          out.m04 = b.m04 * scale + a.m04;
          out.m05 = b.m05 * scale + a.m05;
          out.m06 = b.m06 * scale + a.m06;
          out.m07 = b.m07 * scale + a.m07;
          out.m08 = b.m08 * scale + a.m08;
          return out;
        }
        static strictEquals(a, b) {
          return a.m00 === b.m00 && a.m01 === b.m01 && a.m02 === b.m02 && a.m03 === b.m03 && a.m04 === b.m04 && a.m05 === b.m05 && a.m06 === b.m06 && a.m07 === b.m07 && a.m08 === b.m08;
        }
        static equals(a, b, epsilon = EPSILON$2) {
          return Math.abs(a.m00 - b.m00) <= epsilon * Math.max(1.0, Math.abs(a.m00), Math.abs(b.m00)) && Math.abs(a.m01 - b.m01) <= epsilon * Math.max(1.0, Math.abs(a.m01), Math.abs(b.m01)) && Math.abs(a.m02 - b.m02) <= epsilon * Math.max(1.0, Math.abs(a.m02), Math.abs(b.m02)) && Math.abs(a.m03 - b.m03) <= epsilon * Math.max(1.0, Math.abs(a.m03), Math.abs(b.m03)) && Math.abs(a.m04 - b.m04) <= epsilon * Math.max(1.0, Math.abs(a.m04), Math.abs(b.m04)) && Math.abs(a.m05 - b.m05) <= epsilon * Math.max(1.0, Math.abs(a.m05), Math.abs(b.m05)) && Math.abs(a.m06 - b.m06) <= epsilon * Math.max(1.0, Math.abs(a.m06), Math.abs(b.m06)) && Math.abs(a.m07 - b.m07) <= epsilon * Math.max(1.0, Math.abs(a.m07), Math.abs(b.m07)) && Math.abs(a.m08 - b.m08) <= epsilon * Math.max(1.0, Math.abs(a.m08), Math.abs(b.m08));
        }
        static toEuler(matrix, v) {
          const a00 = matrix.m00;
          const a01 = matrix.m01;
          matrix.m02;
          const a10 = matrix.m03;
          const a11 = matrix.m04;
          matrix.m05;
          const a20 = matrix.m06;
          const a21 = matrix.m07;
          const a22 = matrix.m08;
          if (a21 < 0.999) {
            if (a21 > -0.999) {
              v.x = Math.asin(-a21);
              v.y = Math.atan2(a20, a22);
              v.z = Math.atan2(a01, a11);
              return true;
            } else {
              v.x = HALF_PI;
              v.y = Math.atan2(a10, a00);
              v.z = 0.0;
              return false;
            }
          } else {
            v.x = -HALF_PI;
            v.y = Math.atan2(-a10, a00);
            v.z = 0.0;
            return false;
          }
        }
        constructor(m00 = 1, m01 = 0, m02 = 0, m03 = 0, m04 = 1, m05 = 0, m06 = 0, m07 = 0, m08 = 1) {
          super();
          if (typeof m00 === 'object') {
            this.m00 = m00.m00;
            this.m01 = m00.m01;
            this.m02 = m00.m02;
            this.m03 = m00.m03;
            this.m04 = m00.m04;
            this.m05 = m00.m05;
            this.m06 = m00.m06;
            this.m07 = m00.m07;
            this.m08 = m00.m08;
          } else {
            this.m00 = m00;
            this.m01 = m01;
            this.m02 = m02;
            this.m03 = m03;
            this.m04 = m04;
            this.m05 = m05;
            this.m06 = m06;
            this.m07 = m07;
            this.m08 = m08;
          }
        }
        clone() {
          const t = this;
          return new Mat3(t.m00, t.m01, t.m02, t.m03, t.m04, t.m05, t.m06, t.m07, t.m08);
        }
        set(m00 = 1, m01 = 0, m02 = 0, m03 = 0, m04 = 1, m05 = 0, m06 = 0, m07 = 0, m08 = 1) {
          if (typeof m00 === 'object') {
            this.m00 = m00.m00;
            this.m01 = m00.m01;
            this.m02 = m00.m02;
            this.m03 = m00.m03;
            this.m04 = m00.m04;
            this.m05 = m00.m05;
            this.m06 = m00.m06;
            this.m07 = m00.m07;
            this.m08 = m00.m08;
          } else {
            this.m00 = m00;
            this.m01 = m01;
            this.m02 = m02;
            this.m03 = m03;
            this.m04 = m04;
            this.m05 = m05;
            this.m06 = m06;
            this.m07 = m07;
            this.m08 = m08;
          }
          return this;
        }
        equals(other, epsilon = EPSILON$2) {
          return Math.abs(this.m00 - other.m00) <= epsilon * Math.max(1.0, Math.abs(this.m00), Math.abs(other.m00)) && Math.abs(this.m01 - other.m01) <= epsilon * Math.max(1.0, Math.abs(this.m01), Math.abs(other.m01)) && Math.abs(this.m02 - other.m02) <= epsilon * Math.max(1.0, Math.abs(this.m02), Math.abs(other.m02)) && Math.abs(this.m03 - other.m03) <= epsilon * Math.max(1.0, Math.abs(this.m03), Math.abs(other.m03)) && Math.abs(this.m04 - other.m04) <= epsilon * Math.max(1.0, Math.abs(this.m04), Math.abs(other.m04)) && Math.abs(this.m05 - other.m05) <= epsilon * Math.max(1.0, Math.abs(this.m05), Math.abs(other.m05)) && Math.abs(this.m06 - other.m06) <= epsilon * Math.max(1.0, Math.abs(this.m06), Math.abs(other.m06)) && Math.abs(this.m07 - other.m07) <= epsilon * Math.max(1.0, Math.abs(this.m07), Math.abs(other.m07)) && Math.abs(this.m08 - other.m08) <= epsilon * Math.max(1.0, Math.abs(this.m08), Math.abs(other.m08));
        }
        strictEquals(other) {
          return this.m00 === other.m00 && this.m01 === other.m01 && this.m02 === other.m02 && this.m03 === other.m03 && this.m04 === other.m04 && this.m05 === other.m05 && this.m06 === other.m06 && this.m07 === other.m07 && this.m08 === other.m08;
        }
        toString() {
          const t = this;
          return `[\n${t.m00}, ${t.m01}, ${t.m02},\n${t.m03},\n${t.m04}, ${t.m05},\n${t.m06}, ${t.m07},\n${t.m08}\n` + `]`;
        }
        identity() {
          this.m00 = 1;
          this.m01 = 0;
          this.m02 = 0;
          this.m03 = 0;
          this.m04 = 1;
          this.m05 = 0;
          this.m06 = 0;
          this.m07 = 0;
          this.m08 = 1;
          return this;
        }
        transpose() {
          const a01 = this.m01;
          const a02 = this.m02;
          const a12 = this.m05;
          this.m01 = this.m03;
          this.m02 = this.m06;
          this.m03 = a01;
          this.m05 = this.m07;
          this.m06 = a02;
          this.m07 = a12;
          return this;
        }
        invert() {
          const a00 = this.m00;
          const a01 = this.m01;
          const a02 = this.m02;
          const a10 = this.m03;
          const a11 = this.m04;
          const a12 = this.m05;
          const a20 = this.m06;
          const a21 = this.m07;
          const a22 = this.m08;
          const b01 = a22 * a11 - a12 * a21;
          const b11 = -a22 * a10 + a12 * a20;
          const b21 = a21 * a10 - a11 * a20;
          let det = a00 * b01 + a01 * b11 + a02 * b21;
          if (det === 0) {
            this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
            return this;
          }
          det = 1.0 / det;
          this.m00 = b01 * det;
          this.m01 = (-a22 * a01 + a02 * a21) * det;
          this.m02 = (a12 * a01 - a02 * a11) * det;
          this.m03 = b11 * det;
          this.m04 = (a22 * a00 - a02 * a20) * det;
          this.m05 = (-a12 * a00 + a02 * a10) * det;
          this.m06 = b21 * det;
          this.m07 = (-a21 * a00 + a01 * a20) * det;
          this.m08 = (a11 * a00 - a01 * a10) * det;
          return this;
        }
        determinant() {
          const a00 = this.m00;
          const a01 = this.m01;
          const a02 = this.m02;
          const a10 = this.m03;
          const a11 = this.m04;
          const a12 = this.m05;
          const a20 = this.m06;
          const a21 = this.m07;
          const a22 = this.m08;
          return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
        }
        add(mat) {
          this.m00 += mat.m00;
          this.m01 += mat.m01;
          this.m02 += mat.m02;
          this.m03 += mat.m03;
          this.m04 += mat.m04;
          this.m05 += mat.m05;
          this.m06 += mat.m06;
          this.m07 += mat.m07;
          this.m08 += mat.m08;
          return this;
        }
        subtract(mat) {
          this.m00 -= mat.m00;
          this.m01 -= mat.m01;
          this.m02 -= mat.m02;
          this.m03 -= mat.m03;
          this.m04 -= mat.m04;
          this.m05 -= mat.m05;
          this.m06 -= mat.m06;
          this.m07 -= mat.m07;
          this.m08 -= mat.m08;
          return this;
        }
        multiply(mat) {
          const a00 = this.m00;
          const a01 = this.m01;
          const a02 = this.m02;
          const a10 = this.m03;
          const a11 = this.m04;
          const a12 = this.m05;
          const a20 = this.m06;
          const a21 = this.m07;
          const a22 = this.m08;
          const b00 = mat.m00;
          const b01 = mat.m01;
          const b02 = mat.m02;
          const b10 = mat.m03;
          const b11 = mat.m04;
          const b12 = mat.m05;
          const b20 = mat.m06;
          const b21 = mat.m07;
          const b22 = mat.m08;
          this.m00 = b00 * a00 + b01 * a10 + b02 * a20;
          this.m01 = b00 * a01 + b01 * a11 + b02 * a21;
          this.m02 = b00 * a02 + b01 * a12 + b02 * a22;
          this.m03 = b10 * a00 + b11 * a10 + b12 * a20;
          this.m04 = b10 * a01 + b11 * a11 + b12 * a21;
          this.m05 = b10 * a02 + b11 * a12 + b12 * a22;
          this.m06 = b20 * a00 + b21 * a10 + b22 * a20;
          this.m07 = b20 * a01 + b21 * a11 + b22 * a21;
          this.m08 = b20 * a02 + b21 * a12 + b22 * a22;
          return this;
        }
        multiplyScalar(scalar) {
          this.m00 *= scalar;
          this.m01 *= scalar;
          this.m02 *= scalar;
          this.m03 *= scalar;
          this.m04 *= scalar;
          this.m05 *= scalar;
          this.m06 *= scalar;
          this.m07 *= scalar;
          this.m08 *= scalar;
          return this;
        }
        scale(vec) {
          const x = vec.x;
          const y = vec.y;
          this.m00 = x * this.m00;
          this.m01 = x * this.m01;
          this.m02 = x * this.m02;
          this.m03 = y * this.m03;
          this.m04 = y * this.m04;
          this.m05 = y * this.m05;
          this.m06 = this.m06;
          this.m07 = this.m07;
          this.m08 = this.m08;
          return this;
        }
        rotate(rad) {
          const a00 = this.m00;
          const a01 = this.m01;
          const a02 = this.m02;
          const a10 = this.m03;
          const a11 = this.m04;
          const a12 = this.m05;
          const a20 = this.m06;
          const a21 = this.m07;
          const a22 = this.m08;
          const s = Math.sin(rad);
          const c = Math.cos(rad);
          this.m00 = c * a00 + s * a10;
          this.m01 = c * a01 + s * a11;
          this.m02 = c * a02 + s * a12;
          this.m03 = c * a10 - s * a00;
          this.m04 = c * a11 - s * a01;
          this.m05 = c * a12 - s * a02;
          this.m06 = a20;
          this.m07 = a21;
          this.m08 = a22;
          return this;
        }
        fromQuat(q) {
          const x = q.x;
          const y = q.y;
          const z = q.z;
          const w = q.w;
          const x2 = x + x;
          const y2 = y + y;
          const z2 = z + z;
          const xx = x * x2;
          const yx = y * x2;
          const yy = y * y2;
          const zx = z * x2;
          const zy = z * y2;
          const zz = z * z2;
          const wx = w * x2;
          const wy = w * y2;
          const wz = w * z2;
          this.m00 = 1 - yy - zz;
          this.m03 = yx - wz;
          this.m06 = zx + wy;
          this.m01 = yx + wz;
          this.m04 = 1 - xx - zz;
          this.m07 = zy - wx;
          this.m02 = zx - wy;
          this.m05 = zy + wx;
          this.m08 = 1 - xx - yy;
          return this;
        }
      } exports('Mat3', Mat3);
      _class$13 = Mat3;
      Mat3.IDENTITY = Object.freeze(new _class$13());
      const v3_1$2 = new Vec3();
      const v3_2 = new Vec3();
      CCClass.fastDefine('cc.Mat3', Mat3, {
        m00: 1,
        m01: 0,
        m02: 0,
        m03: 0,
        m04: 1,
        m05: 0,
        m06: 0,
        m07: 0,
        m08: 1
      });
      legacyCC.Mat3 = Mat3;

      var _class$12;
      class Quat extends ValueType {
        static clone(a) {
          return new Quat(a.x, a.y, a.z, a.w);
        }
        static copy(out, a) {
          out.x = a.x;
          out.y = a.y;
          out.z = a.z;
          out.w = a.w;
          return out;
        }
        static set(out, x, y, z, w) {
          out.x = x;
          out.y = y;
          out.z = z;
          out.w = w;
          return out;
        }
        static identity(out) {
          out.x = 0;
          out.y = 0;
          out.z = 0;
          out.w = 1;
          return out;
        }
        static rotationTo(out, a, b) {
          const dot = Vec3.dot(a, b);
          if (dot < -0.999999) {
            Vec3.cross(v3_1$1, Vec3.UNIT_X, a);
            if (v3_1$1.length() < 0.000001) {
              Vec3.cross(v3_1$1, Vec3.UNIT_Y, a);
            }
            Vec3.normalize(v3_1$1, v3_1$1);
            Quat.fromAxisAngle(out, v3_1$1, Math.PI);
            return out;
          } else if (dot > 0.999999) {
            out.x = 0;
            out.y = 0;
            out.z = 0;
            out.w = 1;
            return out;
          } else {
            Vec3.cross(v3_1$1, a, b);
            out.x = v3_1$1.x;
            out.y = v3_1$1.y;
            out.z = v3_1$1.z;
            out.w = 1 + dot;
            return Quat.normalize(out, out);
          }
        }
        static getAxisAngle(outAxis, q) {
          const rad = Math.acos(q.w) * 2.0;
          const s = Math.sin(rad / 2.0);
          if (s !== 0.0) {
            outAxis.x = q.x / s;
            outAxis.y = q.y / s;
            outAxis.z = q.z / s;
          } else {
            outAxis.x = 1;
            outAxis.y = 0;
            outAxis.z = 0;
          }
          return rad;
        }
        static multiply(out, a, b) {
          const x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;
          const y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;
          const z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;
          const w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;
          out.x = x;
          out.y = y;
          out.z = z;
          out.w = w;
          return out;
        }
        static multiplyScalar(out, a, b) {
          out.x = a.x * b;
          out.y = a.y * b;
          out.z = a.z * b;
          out.w = a.w * b;
          return out;
        }
        static scaleAndAdd(out, a, b, scale) {
          out.x = a.x + b.x * scale;
          out.y = a.y + b.y * scale;
          out.z = a.z + b.z * scale;
          out.w = a.w + b.w * scale;
          return out;
        }
        static rotateX(out, a, rad) {
          rad *= 0.5;
          const bx = Math.sin(rad);
          const bw = Math.cos(rad);
          const {
            x,
            y,
            z,
            w
          } = a;
          out.x = x * bw + w * bx;
          out.y = y * bw + z * bx;
          out.z = z * bw - y * bx;
          out.w = w * bw - x * bx;
          return out;
        }
        static rotateY(out, a, rad) {
          rad *= 0.5;
          const by = Math.sin(rad);
          const bw = Math.cos(rad);
          const {
            x,
            y,
            z,
            w
          } = a;
          out.x = x * bw - z * by;
          out.y = y * bw + w * by;
          out.z = z * bw + x * by;
          out.w = w * bw - y * by;
          return out;
        }
        static rotateZ(out, a, rad) {
          rad *= 0.5;
          const bz = Math.sin(rad);
          const bw = Math.cos(rad);
          const {
            x,
            y,
            z,
            w
          } = a;
          out.x = x * bw + y * bz;
          out.y = y * bw - x * bz;
          out.z = z * bw + w * bz;
          out.w = w * bw - z * bz;
          return out;
        }
        static rotateAround(out, rot, axis, rad) {
          Quat.invert(qt_1, rot);
          Vec3.transformQuat(v3_1$1, axis, qt_1);
          Quat.fromAxisAngle(qt_1, v3_1$1, rad);
          Quat.multiply(out, rot, qt_1);
          return out;
        }
        static rotateAroundLocal(out, rot, axis, rad) {
          Quat.fromAxisAngle(qt_1, axis, rad);
          Quat.multiply(out, rot, qt_1);
          return out;
        }
        static calculateW(out, a) {
          out.x = a.x;
          out.y = a.y;
          out.z = a.z;
          out.w = Math.sqrt(Math.abs(1.0 - a.x * a.x - a.y * a.y - a.z * a.z));
          return out;
        }
        static dot(a, b) {
          return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;
        }
        static lerp(out, a, b, t) {
          out.x = a.x + t * (b.x - a.x);
          out.y = a.y + t * (b.y - a.y);
          out.z = a.z + t * (b.z - a.z);
          out.w = a.w + t * (b.w - a.w);
          return out;
        }
        static slerp(out, a, b, t) {
          let scale0 = 0;
          let scale1 = 0;
          let bx = b.x;
          let by = b.y;
          let bz = b.z;
          let bw = b.w;
          let cosom = a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;
          if (cosom < 0.0) {
            cosom = -cosom;
            bx = -bx;
            by = -by;
            bz = -bz;
            bw = -bw;
          }
          if (1.0 - cosom > 0.000001) {
            const omega = Math.acos(cosom);
            const sinom = Math.sin(omega);
            scale0 = Math.sin((1.0 - t) * omega) / sinom;
            scale1 = Math.sin(t * omega) / sinom;
          } else {
            scale0 = 1.0 - t;
            scale1 = t;
          }
          out.x = scale0 * a.x + scale1 * bx;
          out.y = scale0 * a.y + scale1 * by;
          out.z = scale0 * a.z + scale1 * bz;
          out.w = scale0 * a.w + scale1 * bw;
          return out;
        }
        static sqlerp(out, a, b, c, d, t) {
          Quat.slerp(qt_1, a, d, t);
          Quat.slerp(qt_2, b, c, t);
          Quat.slerp(out, qt_1, qt_2, 2 * t * (1 - t));
          return out;
        }
        static invert(out, a) {
          const dot = a.x * a.x + a.y * a.y + a.z * a.z + a.w * a.w;
          const invDot = dot ? 1.0 / dot : 0;
          out.x = -a.x * invDot;
          out.y = -a.y * invDot;
          out.z = -a.z * invDot;
          out.w = a.w * invDot;
          return out;
        }
        static conjugate(out, a) {
          out.x = -a.x;
          out.y = -a.y;
          out.z = -a.z;
          out.w = a.w;
          return out;
        }
        static len(a) {
          return Math.sqrt(a.x * a.x + a.y * a.y + a.z * a.z + a.w * a.w);
        }
        static lengthSqr(a) {
          return a.x * a.x + a.y * a.y + a.z * a.z + a.w * a.w;
        }
        static normalize(out, a) {
          let len = a.x * a.x + a.y * a.y + a.z * a.z + a.w * a.w;
          if (len > 0) {
            len = 1 / Math.sqrt(len);
            out.x = a.x * len;
            out.y = a.y * len;
            out.z = a.z * len;
            out.w = a.w * len;
          } else {
            out.x = 0;
            out.y = 0;
            out.z = 0;
            out.w = 0;
          }
          return out;
        }
        static fromAxes(out, xAxis, yAxis, zAxis) {
          Mat3.set(m3_1$1, xAxis.x, xAxis.y, xAxis.z, yAxis.x, yAxis.y, yAxis.z, zAxis.x, zAxis.y, zAxis.z);
          return Quat.normalize(out, Quat.fromMat3(out, m3_1$1));
        }
        static fromViewUp(out, view, up) {
          Mat3.fromViewUp(m3_1$1, view, up);
          return Quat.normalize(out, Quat.fromMat3(out, m3_1$1));
        }
        static fromAxisAngle(out, axis, rad) {
          rad *= 0.5;
          const s = Math.sin(rad);
          out.x = s * axis.x;
          out.y = s * axis.y;
          out.z = s * axis.z;
          out.w = Math.cos(rad);
          return out;
        }
        static fromMat3(out, m) {
          const {
            m00,
            m01,
            m02,
            m03: m10,
            m04: m11,
            m05: m12,
            m06: m20,
            m07: m21,
            m08: m22
          } = m;
          const fourXSquaredMinus1 = m00 - m11 - m22;
          const fourYSquaredMinus1 = m11 - m00 - m22;
          const fourZSquaredMinus1 = m22 - m00 - m11;
          const fourWSquaredMinus1 = m00 + m11 + m22;
          let biggestIndex = 0;
          let fourBiggestSquaredMinus1 = fourWSquaredMinus1;
          if (fourXSquaredMinus1 > fourBiggestSquaredMinus1) {
            fourBiggestSquaredMinus1 = fourXSquaredMinus1;
            biggestIndex = 1;
          }
          if (fourYSquaredMinus1 > fourBiggestSquaredMinus1) {
            fourBiggestSquaredMinus1 = fourYSquaredMinus1;
            biggestIndex = 2;
          }
          if (fourZSquaredMinus1 > fourBiggestSquaredMinus1) {
            fourBiggestSquaredMinus1 = fourZSquaredMinus1;
            biggestIndex = 3;
          }
          const biggestVal = Math.sqrt(fourBiggestSquaredMinus1 + 1) * 0.5;
          const mult = 0.25 / biggestVal;
          switch (biggestIndex) {
            case 0:
              out.w = biggestVal;
              out.x = (m12 - m21) * mult;
              out.y = (m20 - m02) * mult;
              out.z = (m01 - m10) * mult;
              break;
            case 1:
              out.w = (m12 - m21) * mult;
              out.x = biggestVal;
              out.y = (m01 + m10) * mult;
              out.z = (m20 + m02) * mult;
              break;
            case 2:
              out.w = (m20 - m02) * mult;
              out.x = (m01 + m10) * mult;
              out.y = biggestVal;
              out.z = (m12 + m21) * mult;
              break;
            case 3:
              out.w = (m01 - m10) * mult;
              out.x = (m20 + m02) * mult;
              out.y = (m12 + m21) * mult;
              out.z = biggestVal;
              break;
            default:
              out.w = 1;
              out.x = 0;
              out.y = 0;
              out.z = 0;
              break;
          }
          return out;
        }
        static fromEuler(out, x, y, z) {
          x *= halfToRad;
          y *= halfToRad;
          z *= halfToRad;
          const sx = Math.sin(x);
          const cx = Math.cos(x);
          const sy = Math.sin(y);
          const cy = Math.cos(y);
          const sz = Math.sin(z);
          const cz = Math.cos(z);
          out.x = sx * cy * cz + cx * sy * sz;
          out.y = cx * sy * cz + sx * cy * sz;
          out.z = cx * cy * sz - sx * sy * cz;
          out.w = cx * cy * cz - sx * sy * sz;
          return out;
        }
        static fromAngleZ(out, z) {
          z *= halfToRad;
          out.x = out.y = 0;
          out.z = Math.sin(z);
          out.w = Math.cos(z);
          return out;
        }
        static toAxisX(out, q) {
          const fy = 2.0 * q.y;
          const fz = 2.0 * q.z;
          out.x = 1.0 - fy * q.y - fz * q.z;
          out.y = fy * q.x + fz * q.w;
          out.z = fz * q.x - fy * q.w;
          return out;
        }
        static toAxisY(out, q) {
          const fx = 2.0 * q.x;
          const fy = 2.0 * q.y;
          const fz = 2.0 * q.z;
          out.x = fy * q.x - fz * q.w;
          out.y = 1.0 - fx * q.x - fz * q.z;
          out.z = fz * q.y + fx * q.w;
          return out;
        }
        static toAxisZ(out, q) {
          const fx = 2.0 * q.x;
          const fy = 2.0 * q.y;
          const fz = 2.0 * q.z;
          out.x = fz * q.x + fy * q.w;
          out.y = fz * q.y - fx * q.w;
          out.z = 1.0 - fx * q.x - fy * q.y;
          return out;
        }
        static toEuler(out, q, outerZ) {
          const {
            x,
            y,
            z,
            w
          } = q;
          let bank = 0;
          let heading = 0;
          let attitude = 0;
          const test = x * y + z * w;
          if (test > 0.499999) {
            bank = 0;
            heading = toDegree(2 * Math.atan2(x, w));
            attitude = 90;
          } else if (test < -0.499999) {
            bank = 0;
            heading = -toDegree(2 * Math.atan2(x, w));
            attitude = -90;
          } else {
            const sqx = x * x;
            const sqy = y * y;
            const sqz = z * z;
            bank = toDegree(Math.atan2(2 * x * w - 2 * y * z, 1 - 2 * sqx - 2 * sqz));
            heading = toDegree(Math.atan2(2 * y * w - 2 * x * z, 1 - 2 * sqy - 2 * sqz));
            attitude = toDegree(Math.asin(2 * test));
            if (outerZ) {
              bank = -180 * Math.sign(bank + 1e-6) + bank;
              heading = -180 * Math.sign(heading + 1e-6) + heading;
              attitude = 180 * Math.sign(attitude + 1e-6) - attitude;
            }
          }
          out.x = bank;
          out.y = heading;
          out.z = attitude;
          return out;
        }
        static toEulerInYXZOrder(out, q) {
          Mat3.fromQuat(m3_1$1, q);
          Mat3.toEuler(m3_1$1, out);
          out.x = toDegree(out.x);
          out.y = toDegree(out.y);
          out.z = toDegree(out.z);
        }
        static toArray(out, q, ofs = 0) {
          out[ofs + 0] = q.x;
          out[ofs + 1] = q.y;
          out[ofs + 2] = q.z;
          out[ofs + 3] = q.w;
          return out;
        }
        static fromArray(out, arr, ofs = 0) {
          out.x = arr[ofs + 0];
          out.y = arr[ofs + 1];
          out.z = arr[ofs + 2];
          out.w = arr[ofs + 3];
          return out;
        }
        static strictEquals(a, b) {
          return a.x === b.x && a.y === b.y && a.z === b.z && a.w === b.w;
        }
        static equals(a, b, epsilon = EPSILON$2) {
          return Math.abs(a.x - b.x) <= epsilon * Math.max(1.0, Math.abs(a.x), Math.abs(b.x)) && Math.abs(a.y - b.y) <= epsilon * Math.max(1.0, Math.abs(a.y), Math.abs(b.y)) && Math.abs(a.z - b.z) <= epsilon * Math.max(1.0, Math.abs(a.z), Math.abs(b.z)) && Math.abs(a.w - b.w) <= epsilon * Math.max(1.0, Math.abs(a.w), Math.abs(b.w));
        }
        static angle(a, b) {
          const dot = Math.min(Math.abs(Quat.dot(a, b)), 1.0);
          return Math.acos(dot) * 2.0;
        }
        static rotateTowards(out, from, to, maxStep) {
          const angle = Quat.angle(from, to);
          if (angle === 0) {
            out.x = to.x;
            out.y = to.y;
            out.z = to.z;
            out.w = to.w;
            return out;
          }
          const t = Math.min(maxStep / toDegree(angle), 1.0);
          return Quat.slerp(out, from, to, t);
        }
        constructor(x, y, z, w) {
          super();
          if (typeof x === 'object') {
            this.x = x.x;
            this.y = x.y;
            this.z = x.z;
            this.w = x.w;
          } else {
            this.x = x || 0;
            this.y = y || 0;
            this.z = z || 0;
            this.w = w !== null && w !== void 0 ? w : 1;
          }
        }
        clone() {
          return new Quat(this.x, this.y, this.z, this.w);
        }
        set(x, y, z, w) {
          if (typeof x === 'object') {
            this.x = x.x;
            this.y = x.y;
            this.z = x.z;
            this.w = x.w;
          } else {
            this.x = x || 0;
            this.y = y || 0;
            this.z = z || 0;
            this.w = w !== null && w !== void 0 ? w : 1;
          }
          return this;
        }
        equals(other, epsilon = EPSILON$2) {
          return Math.abs(this.x - other.x) <= epsilon * Math.max(1.0, Math.abs(this.x), Math.abs(other.x)) && Math.abs(this.y - other.y) <= epsilon * Math.max(1.0, Math.abs(this.y), Math.abs(other.y)) && Math.abs(this.z - other.z) <= epsilon * Math.max(1.0, Math.abs(this.z), Math.abs(other.z)) && Math.abs(this.w - other.w) <= epsilon * Math.max(1.0, Math.abs(this.w), Math.abs(other.w));
        }
        strictEquals(other) {
          return other && this.x === other.x && this.y === other.y && this.z === other.z && this.w === other.w;
        }
        getEulerAngles(out) {
          return Quat.toEuler(out, this);
        }
        lerp(to, ratio) {
          this.x += ratio * (to.x - this.x);
          this.y += ratio * (to.y - this.y);
          this.z += ratio * (to.z - this.z);
          this.w += ratio * (to.w - this.w);
          return this;
        }
        slerp(to, ratio) {
          return Quat.slerp(this, this, to, ratio);
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
        }
        lengthSqr() {
          return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
        }
      } exports('Quat', Quat);
      _class$12 = Quat;
      Quat.IDENTITY = Object.freeze(new _class$12());
      const qt_1 = new Quat();
      const qt_2 = new Quat();
      const v3_1$1 = new Vec3();
      const m3_1$1 = new Mat3();
      const halfToRad = 0.5 * Math.PI / 180.0;
      CCClass.fastDefine('cc.Quat', Quat, {
        x: 0,
        y: 0,
        z: 0,
        w: 1
      });
      legacyCC.Quat = Quat;
      function quat(x = 0, y = 0, z = 0, w = 1) {
        return new Quat(x, y, z, w);
      }
      legacyCC.quat = quat;

      var _class$11;
      const preTransforms = exports('preTransforms', Object.freeze([Object.freeze([1, 0, 0, 1]), Object.freeze([0, 1, -1, 0]), Object.freeze([-1, 0, 0, -1]), Object.freeze([0, -1, 1, 0])]));
      class Mat4 extends ValueType {
        static clone(a) {
          return new Mat4(a.m00, a.m01, a.m02, a.m03, a.m04, a.m05, a.m06, a.m07, a.m08, a.m09, a.m10, a.m11, a.m12, a.m13, a.m14, a.m15);
        }
        static copy(out, a) {
          out.m00 = a.m00;
          out.m01 = a.m01;
          out.m02 = a.m02;
          out.m03 = a.m03;
          out.m04 = a.m04;
          out.m05 = a.m05;
          out.m06 = a.m06;
          out.m07 = a.m07;
          out.m08 = a.m08;
          out.m09 = a.m09;
          out.m10 = a.m10;
          out.m11 = a.m11;
          out.m12 = a.m12;
          out.m13 = a.m13;
          out.m14 = a.m14;
          out.m15 = a.m15;
          return out;
        }
        static set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
          out.m00 = m00;
          out.m01 = m01;
          out.m02 = m02;
          out.m03 = m03;
          out.m04 = m10;
          out.m05 = m11;
          out.m06 = m12;
          out.m07 = m13;
          out.m08 = m20;
          out.m09 = m21;
          out.m10 = m22;
          out.m11 = m23;
          out.m12 = m30;
          out.m13 = m31;
          out.m14 = m32;
          out.m15 = m33;
          return out;
        }
        static identity(out) {
          out.m00 = 1;
          out.m01 = 0;
          out.m02 = 0;
          out.m03 = 0;
          out.m04 = 0;
          out.m05 = 1;
          out.m06 = 0;
          out.m07 = 0;
          out.m08 = 0;
          out.m09 = 0;
          out.m10 = 1;
          out.m11 = 0;
          out.m12 = 0;
          out.m13 = 0;
          out.m14 = 0;
          out.m15 = 1;
          return out;
        }
        static transpose(out, a) {
          if (out === a) {
            const a01 = a.m01;
            const a02 = a.m02;
            const a03 = a.m03;
            const a12 = a.m06;
            const a13 = a.m07;
            const a23 = a.m11;
            out.m01 = a.m04;
            out.m02 = a.m08;
            out.m03 = a.m12;
            out.m04 = a01;
            out.m06 = a.m09;
            out.m07 = a.m13;
            out.m08 = a02;
            out.m09 = a12;
            out.m11 = a.m14;
            out.m12 = a03;
            out.m13 = a13;
            out.m14 = a23;
          } else {
            out.m00 = a.m00;
            out.m01 = a.m04;
            out.m02 = a.m08;
            out.m03 = a.m12;
            out.m04 = a.m01;
            out.m05 = a.m05;
            out.m06 = a.m09;
            out.m07 = a.m13;
            out.m08 = a.m02;
            out.m09 = a.m06;
            out.m10 = a.m10;
            out.m11 = a.m14;
            out.m12 = a.m03;
            out.m13 = a.m07;
            out.m14 = a.m11;
            out.m15 = a.m15;
          }
          return out;
        }
        static invert(out, a) {
          const a00 = a.m00;
          const a01 = a.m01;
          const a02 = a.m02;
          const a03 = a.m03;
          const a10 = a.m04;
          const a11 = a.m05;
          const a12 = a.m06;
          const a13 = a.m07;
          const a20 = a.m08;
          const a21 = a.m09;
          const a22 = a.m10;
          const a23 = a.m11;
          const a30 = a.m12;
          const a31 = a.m13;
          const a32 = a.m14;
          const a33 = a.m15;
          const b00 = a00 * a11 - a01 * a10;
          const b01 = a00 * a12 - a02 * a10;
          const b02 = a00 * a13 - a03 * a10;
          const b03 = a01 * a12 - a02 * a11;
          const b04 = a01 * a13 - a03 * a11;
          const b05 = a02 * a13 - a03 * a12;
          const b06 = a20 * a31 - a21 * a30;
          const b07 = a20 * a32 - a22 * a30;
          const b08 = a20 * a33 - a23 * a30;
          const b09 = a21 * a32 - a22 * a31;
          const b10 = a21 * a33 - a23 * a31;
          const b11 = a22 * a33 - a23 * a32;
          let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
          if (det === 0) {
            out.m00 = 0;
            out.m01 = 0;
            out.m02 = 0;
            out.m03 = 0;
            out.m04 = 0;
            out.m05 = 0;
            out.m06 = 0;
            out.m07 = 0;
            out.m08 = 0;
            out.m09 = 0;
            out.m10 = 0;
            out.m11 = 0;
            out.m12 = 0;
            out.m13 = 0;
            out.m14 = 0;
            out.m15 = 0;
            return out;
          }
          det = 1.0 / det;
          out.m00 = (a11 * b11 - a12 * b10 + a13 * b09) * det;
          out.m01 = (a02 * b10 - a01 * b11 - a03 * b09) * det;
          out.m02 = (a31 * b05 - a32 * b04 + a33 * b03) * det;
          out.m03 = (a22 * b04 - a21 * b05 - a23 * b03) * det;
          out.m04 = (a12 * b08 - a10 * b11 - a13 * b07) * det;
          out.m05 = (a00 * b11 - a02 * b08 + a03 * b07) * det;
          out.m06 = (a32 * b02 - a30 * b05 - a33 * b01) * det;
          out.m07 = (a20 * b05 - a22 * b02 + a23 * b01) * det;
          out.m08 = (a10 * b10 - a11 * b08 + a13 * b06) * det;
          out.m09 = (a01 * b08 - a00 * b10 - a03 * b06) * det;
          out.m10 = (a30 * b04 - a31 * b02 + a33 * b00) * det;
          out.m11 = (a21 * b02 - a20 * b04 - a23 * b00) * det;
          out.m12 = (a11 * b07 - a10 * b09 - a12 * b06) * det;
          out.m13 = (a00 * b09 - a01 * b07 + a02 * b06) * det;
          out.m14 = (a31 * b01 - a30 * b03 - a32 * b00) * det;
          out.m15 = (a20 * b03 - a21 * b01 + a22 * b00) * det;
          return out;
        }
        static determinant(a) {
          const a00 = a.m00;
          const a01 = a.m01;
          const a02 = a.m02;
          const a03 = a.m03;
          const a10 = a.m04;
          const a11 = a.m05;
          const a12 = a.m06;
          const a13 = a.m07;
          const a20 = a.m08;
          const a21 = a.m09;
          const a22 = a.m10;
          const a23 = a.m11;
          const a30 = a.m12;
          const a31 = a.m13;
          const a32 = a.m14;
          const a33 = a.m15;
          const b00 = a00 * a11 - a01 * a10;
          const b01 = a00 * a12 - a02 * a10;
          const b02 = a00 * a13 - a03 * a10;
          const b03 = a01 * a12 - a02 * a11;
          const b04 = a01 * a13 - a03 * a11;
          const b05 = a02 * a13 - a03 * a12;
          const b06 = a20 * a31 - a21 * a30;
          const b07 = a20 * a32 - a22 * a30;
          const b08 = a20 * a33 - a23 * a30;
          const b09 = a21 * a32 - a22 * a31;
          const b10 = a21 * a33 - a23 * a31;
          const b11 = a22 * a33 - a23 * a32;
          return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
        }
        static multiply(out, a, b) {
          const a00 = a.m00;
          const a01 = a.m01;
          const a02 = a.m02;
          const a03 = a.m03;
          const a10 = a.m04;
          const a11 = a.m05;
          const a12 = a.m06;
          const a13 = a.m07;
          const a20 = a.m08;
          const a21 = a.m09;
          const a22 = a.m10;
          const a23 = a.m11;
          const a30 = a.m12;
          const a31 = a.m13;
          const a32 = a.m14;
          const a33 = a.m15;
          let b0 = b.m00;
          let b1 = b.m01;
          let b2 = b.m02;
          let b3 = b.m03;
          out.m00 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
          out.m01 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
          out.m02 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
          out.m03 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
          b0 = b.m04;
          b1 = b.m05;
          b2 = b.m06;
          b3 = b.m07;
          out.m04 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
          out.m05 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
          out.m06 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
          out.m07 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
          b0 = b.m08;
          b1 = b.m09;
          b2 = b.m10;
          b3 = b.m11;
          out.m08 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
          out.m09 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
          out.m10 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
          out.m11 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
          b0 = b.m12;
          b1 = b.m13;
          b2 = b.m14;
          b3 = b.m15;
          out.m12 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
          out.m13 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
          out.m14 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
          out.m15 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
          return out;
        }
        static transform(out, a, v) {
          const x = v.x;
          const y = v.y;
          const z = v.z;
          if (a === out) {
            out.m12 = a.m00 * x + a.m04 * y + a.m08 * z + a.m12;
            out.m13 = a.m01 * x + a.m05 * y + a.m09 * z + a.m13;
            out.m14 = a.m02 * x + a.m06 * y + a.m10 * z + a.m14;
            out.m15 = a.m03 * x + a.m07 * y + a.m11 * z + a.m15;
          } else {
            const a00 = a.m00;
            const a01 = a.m01;
            const a02 = a.m02;
            const a03 = a.m03;
            const a10 = a.m04;
            const a11 = a.m05;
            const a12 = a.m06;
            const a13 = a.m07;
            const a20 = a.m08;
            const a21 = a.m09;
            const a22 = a.m10;
            const a23 = a.m11;
            out.m00 = a00;
            out.m01 = a01;
            out.m02 = a02;
            out.m03 = a03;
            out.m04 = a10;
            out.m05 = a11;
            out.m06 = a12;
            out.m07 = a13;
            out.m08 = a20;
            out.m09 = a21;
            out.m10 = a22;
            out.m11 = a23;
            out.m12 = a00 * x + a10 * y + a20 * z + a.m12;
            out.m13 = a01 * x + a11 * y + a21 * z + a.m13;
            out.m14 = a02 * x + a12 * y + a22 * z + a.m14;
            out.m15 = a03 * x + a13 * y + a23 * z + a.m15;
          }
          return out;
        }
        static translate(out, a, v) {
          if (a === out) {
            out.m12 += v.x;
            out.m13 += v.y;
            out.m14 += v.z;
          } else {
            out.m00 = a.m00;
            out.m01 = a.m01;
            out.m02 = a.m02;
            out.m03 = a.m03;
            out.m04 = a.m04;
            out.m05 = a.m05;
            out.m06 = a.m06;
            out.m07 = a.m07;
            out.m08 = a.m08;
            out.m09 = a.m09;
            out.m10 = a.m10;
            out.m11 = a.m11;
            out.m12 = a.m12 + v.x;
            out.m13 = a.m13 + v.y;
            out.m14 = a.m14 + v.z;
            out.m15 = a.m15;
          }
          return out;
        }
        static scale(out, a, v) {
          const x = v.x;
          const y = v.y;
          const z = v.z;
          out.m00 = a.m00 * x;
          out.m01 = a.m01 * x;
          out.m02 = a.m02 * x;
          out.m03 = a.m03 * x;
          out.m04 = a.m04 * y;
          out.m05 = a.m05 * y;
          out.m06 = a.m06 * y;
          out.m07 = a.m07 * y;
          out.m08 = a.m08 * z;
          out.m09 = a.m09 * z;
          out.m10 = a.m10 * z;
          out.m11 = a.m11 * z;
          out.m12 = a.m12;
          out.m13 = a.m13;
          out.m14 = a.m14;
          out.m15 = a.m15;
          return out;
        }
        static rotate(out, a, rad, axis) {
          let x = axis.x;
          let y = axis.y;
          let z = axis.z;
          let len = Math.sqrt(x * x + y * y + z * z);
          if (Math.abs(len) < EPSILON$2) {
            return null;
          }
          len = 1 / len;
          x *= len;
          y *= len;
          z *= len;
          const s = Math.sin(rad);
          const c = Math.cos(rad);
          const t = 1 - c;
          const a00 = a.m00;
          const a01 = a.m01;
          const a02 = a.m02;
          const a03 = a.m03;
          const a10 = a.m04;
          const a11 = a.m05;
          const a12 = a.m06;
          const a13 = a.m07;
          const a20 = a.m08;
          const a21 = a.m09;
          const a22 = a.m10;
          const a23 = a.m11;
          const b00 = x * x * t + c;
          const b01 = y * x * t + z * s;
          const b02 = z * x * t - y * s;
          const b10 = x * y * t - z * s;
          const b11 = y * y * t + c;
          const b12 = z * y * t + x * s;
          const b20 = x * z * t + y * s;
          const b21 = y * z * t - x * s;
          const b22 = z * z * t + c;
          out.m00 = a00 * b00 + a10 * b01 + a20 * b02;
          out.m01 = a01 * b00 + a11 * b01 + a21 * b02;
          out.m02 = a02 * b00 + a12 * b01 + a22 * b02;
          out.m03 = a03 * b00 + a13 * b01 + a23 * b02;
          out.m04 = a00 * b10 + a10 * b11 + a20 * b12;
          out.m05 = a01 * b10 + a11 * b11 + a21 * b12;
          out.m06 = a02 * b10 + a12 * b11 + a22 * b12;
          out.m07 = a03 * b10 + a13 * b11 + a23 * b12;
          out.m08 = a00 * b20 + a10 * b21 + a20 * b22;
          out.m09 = a01 * b20 + a11 * b21 + a21 * b22;
          out.m10 = a02 * b20 + a12 * b21 + a22 * b22;
          out.m11 = a03 * b20 + a13 * b21 + a23 * b22;
          if (a !== out) {
            out.m12 = a.m12;
            out.m13 = a.m13;
            out.m14 = a.m14;
            out.m15 = a.m15;
          }
          return out;
        }
        static rotateX(out, a, rad) {
          const s = Math.sin(rad);
          const c = Math.cos(rad);
          const a10 = a.m04;
          const a11 = a.m05;
          const a12 = a.m06;
          const a13 = a.m07;
          const a20 = a.m08;
          const a21 = a.m09;
          const a22 = a.m10;
          const a23 = a.m11;
          if (a !== out) {
            out.m00 = a.m00;
            out.m01 = a.m01;
            out.m02 = a.m02;
            out.m03 = a.m03;
            out.m12 = a.m12;
            out.m13 = a.m13;
            out.m14 = a.m14;
            out.m15 = a.m15;
          }
          out.m04 = a10 * c + a20 * s;
          out.m05 = a11 * c + a21 * s;
          out.m06 = a12 * c + a22 * s;
          out.m07 = a13 * c + a23 * s;
          out.m08 = a20 * c - a10 * s;
          out.m09 = a21 * c - a11 * s;
          out.m10 = a22 * c - a12 * s;
          out.m11 = a23 * c - a13 * s;
          return out;
        }
        static rotateY(out, a, rad) {
          const s = Math.sin(rad);
          const c = Math.cos(rad);
          const a00 = a.m00;
          const a01 = a.m01;
          const a02 = a.m02;
          const a03 = a.m03;
          const a20 = a.m08;
          const a21 = a.m09;
          const a22 = a.m10;
          const a23 = a.m11;
          if (a !== out) {
            out.m04 = a.m04;
            out.m05 = a.m05;
            out.m06 = a.m06;
            out.m07 = a.m07;
            out.m12 = a.m12;
            out.m13 = a.m13;
            out.m14 = a.m14;
            out.m15 = a.m15;
          }
          out.m00 = a00 * c - a20 * s;
          out.m01 = a01 * c - a21 * s;
          out.m02 = a02 * c - a22 * s;
          out.m03 = a03 * c - a23 * s;
          out.m08 = a00 * s + a20 * c;
          out.m09 = a01 * s + a21 * c;
          out.m10 = a02 * s + a22 * c;
          out.m11 = a03 * s + a23 * c;
          return out;
        }
        static rotateZ(out, a, rad) {
          const s = Math.sin(rad);
          const c = Math.cos(rad);
          const a00 = a.m00;
          const a01 = a.m01;
          const a02 = a.m02;
          const a03 = a.m03;
          const a10 = a.m04;
          const a11 = a.m05;
          const a12 = a.m06;
          const a13 = a.m07;
          if (a !== out) {
            out.m08 = a.m08;
            out.m09 = a.m09;
            out.m10 = a.m10;
            out.m11 = a.m11;
            out.m12 = a.m12;
            out.m13 = a.m13;
            out.m14 = a.m14;
            out.m15 = a.m15;
          }
          out.m00 = a00 * c + a10 * s;
          out.m01 = a01 * c + a11 * s;
          out.m02 = a02 * c + a12 * s;
          out.m03 = a03 * c + a13 * s;
          out.m04 = a10 * c - a00 * s;
          out.m05 = a11 * c - a01 * s;
          out.m06 = a12 * c - a02 * s;
          out.m07 = a13 * c - a03 * s;
          return out;
        }
        static fromTranslation(out, v) {
          out.m00 = 1;
          out.m01 = 0;
          out.m02 = 0;
          out.m03 = 0;
          out.m04 = 0;
          out.m05 = 1;
          out.m06 = 0;
          out.m07 = 0;
          out.m08 = 0;
          out.m09 = 0;
          out.m10 = 1;
          out.m11 = 0;
          out.m12 = v.x;
          out.m13 = v.y;
          out.m14 = v.z;
          out.m15 = 1;
          return out;
        }
        static fromScaling(out, v) {
          out.m00 = v.x;
          out.m01 = 0;
          out.m02 = 0;
          out.m03 = 0;
          out.m04 = 0;
          out.m05 = v.y;
          out.m06 = 0;
          out.m07 = 0;
          out.m08 = 0;
          out.m09 = 0;
          out.m10 = v.z;
          out.m11 = 0;
          out.m12 = 0;
          out.m13 = 0;
          out.m14 = 0;
          out.m15 = 1;
          return out;
        }
        static fromRotation(out, rad, axis) {
          let x = axis.x;
          let y = axis.y;
          let z = axis.z;
          let len = Math.sqrt(x * x + y * y + z * z);
          if (Math.abs(len) < EPSILON$2) {
            return null;
          }
          len = 1 / len;
          x *= len;
          y *= len;
          z *= len;
          const s = Math.sin(rad);
          const c = Math.cos(rad);
          const t = 1 - c;
          out.m00 = x * x * t + c;
          out.m01 = y * x * t + z * s;
          out.m02 = z * x * t - y * s;
          out.m03 = 0;
          out.m04 = x * y * t - z * s;
          out.m05 = y * y * t + c;
          out.m06 = z * y * t + x * s;
          out.m07 = 0;
          out.m08 = x * z * t + y * s;
          out.m09 = y * z * t - x * s;
          out.m10 = z * z * t + c;
          out.m11 = 0;
          out.m12 = 0;
          out.m13 = 0;
          out.m14 = 0;
          out.m15 = 1;
          return out;
        }
        static fromXRotation(out, rad) {
          const s = Math.sin(rad);
          const c = Math.cos(rad);
          out.m00 = 1;
          out.m01 = 0;
          out.m02 = 0;
          out.m03 = 0;
          out.m04 = 0;
          out.m05 = c;
          out.m06 = s;
          out.m07 = 0;
          out.m08 = 0;
          out.m09 = -s;
          out.m10 = c;
          out.m11 = 0;
          out.m12 = 0;
          out.m13 = 0;
          out.m14 = 0;
          out.m15 = 1;
          return out;
        }
        static fromYRotation(out, rad) {
          const s = Math.sin(rad);
          const c = Math.cos(rad);
          out.m00 = c;
          out.m01 = 0;
          out.m02 = -s;
          out.m03 = 0;
          out.m04 = 0;
          out.m05 = 1;
          out.m06 = 0;
          out.m07 = 0;
          out.m08 = s;
          out.m09 = 0;
          out.m10 = c;
          out.m11 = 0;
          out.m12 = 0;
          out.m13 = 0;
          out.m14 = 0;
          out.m15 = 1;
          return out;
        }
        static fromZRotation(out, rad) {
          const s = Math.sin(rad);
          const c = Math.cos(rad);
          out.m00 = c;
          out.m01 = s;
          out.m02 = 0;
          out.m03 = 0;
          out.m04 = -s;
          out.m05 = c;
          out.m06 = 0;
          out.m07 = 0;
          out.m08 = 0;
          out.m09 = 0;
          out.m10 = 1;
          out.m11 = 0;
          out.m12 = 0;
          out.m13 = 0;
          out.m14 = 0;
          out.m15 = 1;
          return out;
        }
        static fromRT(out, q, v) {
          const x = q.x;
          const y = q.y;
          const z = q.z;
          const w = q.w;
          const x2 = x + x;
          const y2 = y + y;
          const z2 = z + z;
          const xx = x * x2;
          const xy = x * y2;
          const xz = x * z2;
          const yy = y * y2;
          const yz = y * z2;
          const zz = z * z2;
          const wx = w * x2;
          const wy = w * y2;
          const wz = w * z2;
          out.m00 = 1 - (yy + zz);
          out.m01 = xy + wz;
          out.m02 = xz - wy;
          out.m03 = 0;
          out.m04 = xy - wz;
          out.m05 = 1 - (xx + zz);
          out.m06 = yz + wx;
          out.m07 = 0;
          out.m08 = xz + wy;
          out.m09 = yz - wx;
          out.m10 = 1 - (xx + yy);
          out.m11 = 0;
          out.m12 = v.x;
          out.m13 = v.y;
          out.m14 = v.z;
          out.m15 = 1;
          return out;
        }
        static getTranslation(out, mat) {
          out.x = mat.m12;
          out.y = mat.m13;
          out.z = mat.m14;
          return out;
        }
        static getScaling(out, mat) {
          const m00 = m3_1.m00 = mat.m00;
          const m01 = m3_1.m01 = mat.m01;
          const m02 = m3_1.m02 = mat.m02;
          const m04 = m3_1.m03 = mat.m04;
          const m05 = m3_1.m04 = mat.m05;
          const m06 = m3_1.m05 = mat.m06;
          const m08 = m3_1.m06 = mat.m08;
          const m09 = m3_1.m07 = mat.m09;
          const m10 = m3_1.m08 = mat.m10;
          out.x = Math.sqrt(m00 * m00 + m01 * m01 + m02 * m02);
          out.y = Math.sqrt(m04 * m04 + m05 * m05 + m06 * m06);
          out.z = Math.sqrt(m08 * m08 + m09 * m09 + m10 * m10);
          if (Mat3.determinant(m3_1) < 0) {
            out.x *= -1;
          }
          return out;
        }
        static getRotation(out, mat) {
          const trace = mat.m00 + mat.m05 + mat.m10;
          let S = 0;
          if (trace > 0) {
            S = Math.sqrt(trace + 1.0) * 2;
            out.w = 0.25 * S;
            out.x = (mat.m06 - mat.m09) / S;
            out.y = (mat.m08 - mat.m02) / S;
            out.z = (mat.m01 - mat.m04) / S;
          } else if (mat.m00 > mat.m05 && mat.m00 > mat.m10) {
            S = Math.sqrt(1.0 + mat.m00 - mat.m05 - mat.m10) * 2;
            out.w = (mat.m06 - mat.m09) / S;
            out.x = 0.25 * S;
            out.y = (mat.m01 + mat.m04) / S;
            out.z = (mat.m08 + mat.m02) / S;
          } else if (mat.m05 > mat.m10) {
            S = Math.sqrt(1.0 + mat.m05 - mat.m00 - mat.m10) * 2;
            out.w = (mat.m08 - mat.m02) / S;
            out.x = (mat.m01 + mat.m04) / S;
            out.y = 0.25 * S;
            out.z = (mat.m06 + mat.m09) / S;
          } else {
            S = Math.sqrt(1.0 + mat.m10 - mat.m00 - mat.m05) * 2;
            out.w = (mat.m01 - mat.m04) / S;
            out.x = (mat.m08 + mat.m02) / S;
            out.y = (mat.m06 + mat.m09) / S;
            out.z = 0.25 * S;
          }
          return out;
        }
        static toRTS(m, q, v, s) {
          const sx = Vec3.set(v3_1, m.m00, m.m01, m.m02).length();
          const sy = Vec3.set(v3_1, m.m04, m.m05, m.m06).length();
          const sz = Vec3.set(v3_1, m.m08, m.m09, m.m10).length();
          m3_1.m00 = m.m00 / sx;
          m3_1.m01 = m.m01 / sx;
          m3_1.m02 = m.m02 / sx;
          m3_1.m03 = m.m04 / sy;
          m3_1.m04 = m.m05 / sy;
          m3_1.m05 = m.m06 / sy;
          m3_1.m06 = m.m08 / sz;
          m3_1.m07 = m.m09 / sz;
          m3_1.m08 = m.m10 / sz;
          const det = Mat3.determinant(m3_1);
          if (s) {
            Vec3.set(s, sx, sy, sz);
            if (det < 0) {
              s.x *= -1;
            }
          }
          if (v) {
            Vec3.set(v, m.m12, m.m13, m.m14);
          }
          if (q) {
            if (det < 0) {
              m3_1.m00 *= -1;
              m3_1.m01 *= -1;
              m3_1.m02 *= -1;
            }
            Quat.fromMat3(q, m3_1);
          }
        }
        static toSRT(m, q, v, s) {
          const sx = Vec3.set(v3_1, m.m00, m.m01, m.m02).length();
          const sy = Vec3.set(v3_1, m.m04, m.m05, m.m06).length();
          const sz = Vec3.set(v3_1, m.m08, m.m09, m.m10).length();
          if (s) {
            s.x = sx;
            s.y = sy;
            s.z = sz;
          }
          if (v) {
            Vec3.set(v, m.m12, m.m13, m.m14);
          }
          if (q) {
            m3_1.m00 = m.m00 / sx;
            m3_1.m01 = m.m01 / sx;
            m3_1.m02 = m.m02 / sx;
            m3_1.m03 = m.m04 / sy;
            m3_1.m04 = m.m05 / sy;
            m3_1.m05 = m.m06 / sy;
            m3_1.m06 = m.m08 / sz;
            m3_1.m07 = m.m09 / sz;
            m3_1.m08 = m.m10 / sz;
            const det = Mat3.determinant(m3_1);
            if (det < 0) {
              if (s) s.x *= -1;
              m3_1.m00 *= -1;
              m3_1.m01 *= -1;
              m3_1.m02 *= -1;
            }
            Quat.fromMat3(q, m3_1);
          }
        }
        static toEuler(m, v) {
          Mat3.set(m3_1, m.m00, m.m01, m.m02, m.m04, m.m05, m.m06, m.m08, m.m09, m.m10);
          return Mat3.toEuler(m3_1, v);
        }
        static fromRTS(out, q, v, s) {
          const x = q.x;
          const y = q.y;
          const z = q.z;
          const w = q.w;
          const x2 = x + x;
          const y2 = y + y;
          const z2 = z + z;
          const xx = x * x2;
          const xy = x * y2;
          const xz = x * z2;
          const yy = y * y2;
          const yz = y * z2;
          const zz = z * z2;
          const wx = w * x2;
          const wy = w * y2;
          const wz = w * z2;
          const sx = s.x;
          const sy = s.y;
          const sz = s.z;
          out.m00 = (1 - (yy + zz)) * sx;
          out.m01 = (xy + wz) * sx;
          out.m02 = (xz - wy) * sx;
          out.m03 = 0;
          out.m04 = (xy - wz) * sy;
          out.m05 = (1 - (xx + zz)) * sy;
          out.m06 = (yz + wx) * sy;
          out.m07 = 0;
          out.m08 = (xz + wy) * sz;
          out.m09 = (yz - wx) * sz;
          out.m10 = (1 - (xx + yy)) * sz;
          out.m11 = 0;
          out.m12 = v.x;
          out.m13 = v.y;
          out.m14 = v.z;
          out.m15 = 1;
          return out;
        }
        static fromSRT(out, q, v, s) {
          const x = q.x;
          const y = q.y;
          const z = q.z;
          const w = q.w;
          const x2 = x + x;
          const y2 = y + y;
          const z2 = z + z;
          const xx = x * x2;
          const xy = x * y2;
          const xz = x * z2;
          const yy = y * y2;
          const yz = y * z2;
          const zz = z * z2;
          const wx = w * x2;
          const wy = w * y2;
          const wz = w * z2;
          const sx = s.x;
          const sy = s.y;
          const sz = s.z;
          out.m00 = (1 - (yy + zz)) * sx;
          out.m01 = (xy + wz) * sx;
          out.m02 = (xz - wy) * sx;
          out.m03 = 0;
          out.m04 = (xy - wz) * sy;
          out.m05 = (1 - (xx + zz)) * sy;
          out.m06 = (yz + wx) * sy;
          out.m07 = 0;
          out.m08 = (xz + wy) * sz;
          out.m09 = (yz - wx) * sz;
          out.m10 = (1 - (xx + yy)) * sz;
          out.m11 = 0;
          out.m12 = v.x;
          out.m13 = v.y;
          out.m14 = v.z;
          out.m15 = 1;
          return out;
        }
        static fromRTSOrigin(out, q, v, s, o) {
          const x = q.x;
          const y = q.y;
          const z = q.z;
          const w = q.w;
          const x2 = x + x;
          const y2 = y + y;
          const z2 = z + z;
          const xx = x * x2;
          const xy = x * y2;
          const xz = x * z2;
          const yy = y * y2;
          const yz = y * z2;
          const zz = z * z2;
          const wx = w * x2;
          const wy = w * y2;
          const wz = w * z2;
          const sx = s.x;
          const sy = s.y;
          const sz = s.z;
          const ox = o.x;
          const oy = o.y;
          const oz = o.z;
          out.m00 = (1 - (yy + zz)) * sx;
          out.m01 = (xy + wz) * sx;
          out.m02 = (xz - wy) * sx;
          out.m03 = 0;
          out.m04 = (xy - wz) * sy;
          out.m05 = (1 - (xx + zz)) * sy;
          out.m06 = (yz + wx) * sy;
          out.m07 = 0;
          out.m08 = (xz + wy) * sz;
          out.m09 = (yz - wx) * sz;
          out.m10 = (1 - (xx + yy)) * sz;
          out.m11 = 0;
          out.m12 = v.x + ox - (out.m00 * ox + out.m04 * oy + out.m08 * oz);
          out.m13 = v.y + oy - (out.m01 * ox + out.m05 * oy + out.m09 * oz);
          out.m14 = v.z + oz - (out.m02 * ox + out.m06 * oy + out.m10 * oz);
          out.m15 = 1;
          return out;
        }
        static fromSRTOrigin(out, q, v, s, o) {
          const x = q.x;
          const y = q.y;
          const z = q.z;
          const w = q.w;
          const x2 = x + x;
          const y2 = y + y;
          const z2 = z + z;
          const xx = x * x2;
          const xy = x * y2;
          const xz = x * z2;
          const yy = y * y2;
          const yz = y * z2;
          const zz = z * z2;
          const wx = w * x2;
          const wy = w * y2;
          const wz = w * z2;
          const sx = s.x;
          const sy = s.y;
          const sz = s.z;
          const ox = o.x;
          const oy = o.y;
          const oz = o.z;
          out.m00 = (1 - (yy + zz)) * sx;
          out.m01 = (xy + wz) * sx;
          out.m02 = (xz - wy) * sx;
          out.m03 = 0;
          out.m04 = (xy - wz) * sy;
          out.m05 = (1 - (xx + zz)) * sy;
          out.m06 = (yz + wx) * sy;
          out.m07 = 0;
          out.m08 = (xz + wy) * sz;
          out.m09 = (yz - wx) * sz;
          out.m10 = (1 - (xx + yy)) * sz;
          out.m11 = 0;
          out.m12 = v.x + ox - (out.m00 * ox + out.m04 * oy + out.m08 * oz);
          out.m13 = v.y + oy - (out.m01 * ox + out.m05 * oy + out.m09 * oz);
          out.m14 = v.z + oz - (out.m02 * ox + out.m06 * oy + out.m10 * oz);
          out.m15 = 1;
          return out;
        }
        static fromQuat(out, q) {
          const x = q.x;
          const y = q.y;
          const z = q.z;
          const w = q.w;
          const x2 = x + x;
          const y2 = y + y;
          const z2 = z + z;
          const xx = x * x2;
          const yx = y * x2;
          const yy = y * y2;
          const zx = z * x2;
          const zy = z * y2;
          const zz = z * z2;
          const wx = w * x2;
          const wy = w * y2;
          const wz = w * z2;
          out.m00 = 1 - yy - zz;
          out.m01 = yx + wz;
          out.m02 = zx - wy;
          out.m03 = 0;
          out.m04 = yx - wz;
          out.m05 = 1 - xx - zz;
          out.m06 = zy + wx;
          out.m07 = 0;
          out.m08 = zx + wy;
          out.m09 = zy - wx;
          out.m10 = 1 - xx - yy;
          out.m11 = 0;
          out.m12 = 0;
          out.m13 = 0;
          out.m14 = 0;
          out.m15 = 1;
          return out;
        }
        static frustum(out, left, right, bottom, top, near, far) {
          const rl = 1 / (right - left);
          const tb = 1 / (top - bottom);
          const nf = 1 / (near - far);
          out.m00 = near * 2 * rl;
          out.m01 = 0;
          out.m02 = 0;
          out.m03 = 0;
          out.m04 = 0;
          out.m05 = near * 2 * tb;
          out.m06 = 0;
          out.m07 = 0;
          out.m08 = (right + left) * rl;
          out.m09 = (top + bottom) * tb;
          out.m10 = (far + near) * nf;
          out.m11 = -1;
          out.m12 = 0;
          out.m13 = 0;
          out.m14 = far * near * 2 * nf;
          out.m15 = 0;
          return out;
        }
        static perspective(out, fov, aspect, near, far, isFOVY = true, minClipZ = -1, projectionSignY = 1, orientation = 0) {
          const f = 1.0 / Math.tan(fov / 2);
          const nf = 1 / (near - far);
          const x = isFOVY ? f / aspect : f;
          const y = (isFOVY ? f : f * aspect) * projectionSignY;
          const preTransform = preTransforms[orientation];
          out.m00 = x * preTransform[0];
          out.m01 = x * preTransform[1];
          out.m02 = 0;
          out.m03 = 0;
          out.m04 = y * preTransform[2];
          out.m05 = y * preTransform[3];
          out.m06 = 0;
          out.m07 = 0;
          out.m08 = 0;
          out.m09 = 0;
          out.m10 = (far - minClipZ * near) * nf;
          out.m11 = -1;
          out.m12 = 0;
          out.m13 = 0;
          out.m14 = far * near * nf * (1 - minClipZ);
          out.m15 = 0;
          return out;
        }
        static ortho(out, left, right, bottom, top, near, far, minClipZ = -1, projectionSignY = 1, orientation = 0) {
          const lr = 1 / (left - right);
          const bt = 1 / (bottom - top) * projectionSignY;
          const nf = 1 / (near - far);
          const x = -2 * lr;
          const y = -2 * bt;
          const dx = (left + right) * lr;
          const dy = (top + bottom) * bt;
          const preTransform = preTransforms[orientation];
          out.m00 = x * preTransform[0];
          out.m01 = x * preTransform[1];
          out.m02 = 0;
          out.m03 = 0;
          out.m04 = y * preTransform[2];
          out.m05 = y * preTransform[3];
          out.m06 = 0;
          out.m07 = 0;
          out.m08 = 0;
          out.m09 = 0;
          out.m10 = nf * (1 - minClipZ);
          out.m11 = 0;
          out.m12 = dx * preTransform[0] + dy * preTransform[2];
          out.m13 = dx * preTransform[1] + dy * preTransform[3];
          out.m14 = (near - minClipZ * far) * nf;
          out.m15 = 1;
          return out;
        }
        static lookAt(out, eye, center, up) {
          const eyex = eye.x;
          const eyey = eye.y;
          const eyez = eye.z;
          const upx = up.x;
          const upy = up.y;
          const upz = up.z;
          const centerx = center.x;
          const centery = center.y;
          const centerz = center.z;
          let z0 = eyex - centerx;
          let z1 = eyey - centery;
          let z2 = eyez - centerz;
          let len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
          z0 *= len;
          z1 *= len;
          z2 *= len;
          let x0 = upy * z2 - upz * z1;
          let x1 = upz * z0 - upx * z2;
          let x2 = upx * z1 - upy * z0;
          len = 1 / Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
          x0 *= len;
          x1 *= len;
          x2 *= len;
          const y0 = z1 * x2 - z2 * x1;
          const y1 = z2 * x0 - z0 * x2;
          const y2 = z0 * x1 - z1 * x0;
          out.m00 = x0;
          out.m01 = y0;
          out.m02 = z0;
          out.m03 = 0;
          out.m04 = x1;
          out.m05 = y1;
          out.m06 = z1;
          out.m07 = 0;
          out.m08 = x2;
          out.m09 = y2;
          out.m10 = z2;
          out.m11 = 0;
          out.m12 = -(x0 * eyex + x1 * eyey + x2 * eyez);
          out.m13 = -(y0 * eyex + y1 * eyey + y2 * eyez);
          out.m14 = -(z0 * eyex + z1 * eyey + z2 * eyez);
          out.m15 = 1;
          return out;
        }
        static inverseTranspose(out, a) {
          const a00 = a.m00;
          const a01 = a.m01;
          const a02 = a.m02;
          const a03 = a.m03;
          const a10 = a.m04;
          const a11 = a.m05;
          const a12 = a.m06;
          const a13 = a.m07;
          const a20 = a.m08;
          const a21 = a.m09;
          const a22 = a.m10;
          const a23 = a.m11;
          const a30 = a.m12;
          const a31 = a.m13;
          const a32 = a.m14;
          const a33 = a.m15;
          const b00 = a00 * a11 - a01 * a10;
          const b01 = a00 * a12 - a02 * a10;
          const b02 = a00 * a13 - a03 * a10;
          const b03 = a01 * a12 - a02 * a11;
          const b04 = a01 * a13 - a03 * a11;
          const b05 = a02 * a13 - a03 * a12;
          const b06 = a20 * a31 - a21 * a30;
          const b07 = a20 * a32 - a22 * a30;
          const b08 = a20 * a33 - a23 * a30;
          const b09 = a21 * a32 - a22 * a31;
          const b10 = a21 * a33 - a23 * a31;
          const b11 = a22 * a33 - a23 * a32;
          let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
          if (!det) {
            return null;
          }
          det = 1.0 / det;
          out.m00 = (a11 * b11 - a12 * b10 + a13 * b09) * det;
          out.m01 = (a12 * b08 - a10 * b11 - a13 * b07) * det;
          out.m02 = (a10 * b10 - a11 * b08 + a13 * b06) * det;
          out.m03 = 0;
          out.m04 = (a02 * b10 - a01 * b11 - a03 * b09) * det;
          out.m05 = (a00 * b11 - a02 * b08 + a03 * b07) * det;
          out.m06 = (a01 * b08 - a00 * b10 - a03 * b06) * det;
          out.m07 = 0;
          out.m08 = (a31 * b05 - a32 * b04 + a33 * b03) * det;
          out.m09 = (a32 * b02 - a30 * b05 - a33 * b01) * det;
          out.m10 = (a30 * b04 - a31 * b02 + a33 * b00) * det;
          out.m11 = 0;
          out.m12 = 0;
          out.m13 = 0;
          out.m14 = 0;
          out.m15 = 1;
          return out;
        }
        static toArray(out, m, ofs = 0) {
          out[ofs + 0] = m.m00;
          out[ofs + 1] = m.m01;
          out[ofs + 2] = m.m02;
          out[ofs + 3] = m.m03;
          out[ofs + 4] = m.m04;
          out[ofs + 5] = m.m05;
          out[ofs + 6] = m.m06;
          out[ofs + 7] = m.m07;
          out[ofs + 8] = m.m08;
          out[ofs + 9] = m.m09;
          out[ofs + 10] = m.m10;
          out[ofs + 11] = m.m11;
          out[ofs + 12] = m.m12;
          out[ofs + 13] = m.m13;
          out[ofs + 14] = m.m14;
          out[ofs + 15] = m.m15;
          return out;
        }
        static fromArray(out, arr, ofs = 0) {
          out.m00 = arr[ofs + 0];
          out.m01 = arr[ofs + 1];
          out.m02 = arr[ofs + 2];
          out.m03 = arr[ofs + 3];
          out.m04 = arr[ofs + 4];
          out.m05 = arr[ofs + 5];
          out.m06 = arr[ofs + 6];
          out.m07 = arr[ofs + 7];
          out.m08 = arr[ofs + 8];
          out.m09 = arr[ofs + 9];
          out.m10 = arr[ofs + 10];
          out.m11 = arr[ofs + 11];
          out.m12 = arr[ofs + 12];
          out.m13 = arr[ofs + 13];
          out.m14 = arr[ofs + 14];
          out.m15 = arr[ofs + 15];
          return out;
        }
        static add(out, a, b) {
          out.m00 = a.m00 + b.m00;
          out.m01 = a.m01 + b.m01;
          out.m02 = a.m02 + b.m02;
          out.m03 = a.m03 + b.m03;
          out.m04 = a.m04 + b.m04;
          out.m05 = a.m05 + b.m05;
          out.m06 = a.m06 + b.m06;
          out.m07 = a.m07 + b.m07;
          out.m08 = a.m08 + b.m08;
          out.m09 = a.m09 + b.m09;
          out.m10 = a.m10 + b.m10;
          out.m11 = a.m11 + b.m11;
          out.m12 = a.m12 + b.m12;
          out.m13 = a.m13 + b.m13;
          out.m14 = a.m14 + b.m14;
          out.m15 = a.m15 + b.m15;
          return out;
        }
        static subtract(out, a, b) {
          out.m00 = a.m00 - b.m00;
          out.m01 = a.m01 - b.m01;
          out.m02 = a.m02 - b.m02;
          out.m03 = a.m03 - b.m03;
          out.m04 = a.m04 - b.m04;
          out.m05 = a.m05 - b.m05;
          out.m06 = a.m06 - b.m06;
          out.m07 = a.m07 - b.m07;
          out.m08 = a.m08 - b.m08;
          out.m09 = a.m09 - b.m09;
          out.m10 = a.m10 - b.m10;
          out.m11 = a.m11 - b.m11;
          out.m12 = a.m12 - b.m12;
          out.m13 = a.m13 - b.m13;
          out.m14 = a.m14 - b.m14;
          out.m15 = a.m15 - b.m15;
          return out;
        }
        static multiplyScalar(out, a, b) {
          out.m00 = a.m00 * b;
          out.m01 = a.m01 * b;
          out.m02 = a.m02 * b;
          out.m03 = a.m03 * b;
          out.m04 = a.m04 * b;
          out.m05 = a.m05 * b;
          out.m06 = a.m06 * b;
          out.m07 = a.m07 * b;
          out.m08 = a.m08 * b;
          out.m09 = a.m09 * b;
          out.m10 = a.m10 * b;
          out.m11 = a.m11 * b;
          out.m12 = a.m12 * b;
          out.m13 = a.m13 * b;
          out.m14 = a.m14 * b;
          out.m15 = a.m15 * b;
          return out;
        }
        static multiplyScalarAndAdd(out, a, b, scale) {
          out.m00 = a.m00 + b.m00 * scale;
          out.m01 = a.m01 + b.m01 * scale;
          out.m02 = a.m02 + b.m02 * scale;
          out.m03 = a.m03 + b.m03 * scale;
          out.m04 = a.m04 + b.m04 * scale;
          out.m05 = a.m05 + b.m05 * scale;
          out.m06 = a.m06 + b.m06 * scale;
          out.m07 = a.m07 + b.m07 * scale;
          out.m08 = a.m08 + b.m08 * scale;
          out.m09 = a.m09 + b.m09 * scale;
          out.m10 = a.m10 + b.m10 * scale;
          out.m11 = a.m11 + b.m11 * scale;
          out.m12 = a.m12 + b.m12 * scale;
          out.m13 = a.m13 + b.m13 * scale;
          out.m14 = a.m14 + b.m14 * scale;
          out.m15 = a.m15 + b.m15 * scale;
          return out;
        }
        static strictEquals(a, b) {
          return a.m00 === b.m00 && a.m01 === b.m01 && a.m02 === b.m02 && a.m03 === b.m03 && a.m04 === b.m04 && a.m05 === b.m05 && a.m06 === b.m06 && a.m07 === b.m07 && a.m08 === b.m08 && a.m09 === b.m09 && a.m10 === b.m10 && a.m11 === b.m11 && a.m12 === b.m12 && a.m13 === b.m13 && a.m14 === b.m14 && a.m15 === b.m15;
        }
        static equals(a, b, epsilon = EPSILON$2) {
          return Math.abs(a.m00 - b.m00) <= epsilon * Math.max(1.0, Math.abs(a.m00), Math.abs(b.m00)) && Math.abs(a.m01 - b.m01) <= epsilon * Math.max(1.0, Math.abs(a.m01), Math.abs(b.m01)) && Math.abs(a.m02 - b.m02) <= epsilon * Math.max(1.0, Math.abs(a.m02), Math.abs(b.m02)) && Math.abs(a.m03 - b.m03) <= epsilon * Math.max(1.0, Math.abs(a.m03), Math.abs(b.m03)) && Math.abs(a.m04 - b.m04) <= epsilon * Math.max(1.0, Math.abs(a.m04), Math.abs(b.m04)) && Math.abs(a.m05 - b.m05) <= epsilon * Math.max(1.0, Math.abs(a.m05), Math.abs(b.m05)) && Math.abs(a.m06 - b.m06) <= epsilon * Math.max(1.0, Math.abs(a.m06), Math.abs(b.m06)) && Math.abs(a.m07 - b.m07) <= epsilon * Math.max(1.0, Math.abs(a.m07), Math.abs(b.m07)) && Math.abs(a.m08 - b.m08) <= epsilon * Math.max(1.0, Math.abs(a.m08), Math.abs(b.m08)) && Math.abs(a.m09 - b.m09) <= epsilon * Math.max(1.0, Math.abs(a.m09), Math.abs(b.m09)) && Math.abs(a.m10 - b.m10) <= epsilon * Math.max(1.0, Math.abs(a.m10), Math.abs(b.m10)) && Math.abs(a.m11 - b.m11) <= epsilon * Math.max(1.0, Math.abs(a.m11), Math.abs(b.m11)) && Math.abs(a.m12 - b.m12) <= epsilon * Math.max(1.0, Math.abs(a.m12), Math.abs(b.m12)) && Math.abs(a.m13 - b.m13) <= epsilon * Math.max(1.0, Math.abs(a.m13), Math.abs(b.m13)) && Math.abs(a.m14 - b.m14) <= epsilon * Math.max(1.0, Math.abs(a.m14), Math.abs(b.m14)) && Math.abs(a.m15 - b.m15) <= epsilon * Math.max(1.0, Math.abs(a.m15), Math.abs(b.m15));
        }
        constructor(m00 = 1, m01 = 0, m02 = 0, m03 = 0, m04 = 0, m05 = 1, m06 = 0, m07 = 0, m08 = 0, m09 = 0, m10 = 1, m11 = 0, m12 = 0, m13 = 0, m14 = 0, m15 = 1) {
          super();
          if (typeof m00 === 'object') {
            this.m00 = m00.m00;
            this.m01 = m00.m01;
            this.m02 = m00.m02;
            this.m03 = m00.m03;
            this.m04 = m00.m04;
            this.m05 = m00.m05;
            this.m06 = m00.m06;
            this.m07 = m00.m07;
            this.m08 = m00.m08;
            this.m09 = m00.m09;
            this.m10 = m00.m10;
            this.m11 = m00.m11;
            this.m12 = m00.m12;
            this.m13 = m00.m13;
            this.m14 = m00.m14;
            this.m15 = m00.m15;
          } else {
            this.m00 = m00;
            this.m01 = m01;
            this.m02 = m02;
            this.m03 = m03;
            this.m04 = m04;
            this.m05 = m05;
            this.m06 = m06;
            this.m07 = m07;
            this.m08 = m08;
            this.m09 = m09;
            this.m10 = m10;
            this.m11 = m11;
            this.m12 = m12;
            this.m13 = m13;
            this.m14 = m14;
            this.m15 = m15;
          }
        }
        clone() {
          return new Mat4(this.m00, this.m01, this.m02, this.m03, this.m04, this.m05, this.m06, this.m07, this.m08, this.m09, this.m10, this.m11, this.m12, this.m13, this.m14, this.m15);
        }
        set(m00 = 1, m01 = 0, m02 = 0, m03 = 0, m04 = 0, m05 = 1, m06 = 0, m07 = 0, m08 = 0, m09 = 0, m10 = 1, m11 = 0, m12 = 0, m13 = 0, m14 = 0, m15 = 1) {
          if (typeof m00 === 'object') {
            this.m01 = m00.m01;
            this.m02 = m00.m02;
            this.m03 = m00.m03;
            this.m04 = m00.m04;
            this.m05 = m00.m05;
            this.m06 = m00.m06;
            this.m07 = m00.m07;
            this.m08 = m00.m08;
            this.m09 = m00.m09;
            this.m10 = m00.m10;
            this.m11 = m00.m11;
            this.m12 = m00.m12;
            this.m13 = m00.m13;
            this.m14 = m00.m14;
            this.m15 = m00.m15;
            this.m00 = m00.m00;
          } else {
            this.m01 = m01;
            this.m02 = m02;
            this.m03 = m03;
            this.m04 = m04;
            this.m05 = m05;
            this.m06 = m06;
            this.m07 = m07;
            this.m08 = m08;
            this.m09 = m09;
            this.m10 = m10;
            this.m11 = m11;
            this.m12 = m12;
            this.m13 = m13;
            this.m14 = m14;
            this.m15 = m15;
            this.m00 = m00;
          }
          return this;
        }
        equals(other, epsilon = EPSILON$2) {
          const hasInf = Math.abs(this.m00) === Infinity || Math.abs(this.m01) === Infinity || Math.abs(this.m02) === Infinity || Math.abs(this.m03) === Infinity || Math.abs(this.m04) === Infinity || Math.abs(this.m05) === Infinity || Math.abs(this.m06) === Infinity || Math.abs(this.m07) === Infinity || Math.abs(this.m08) === Infinity || Math.abs(this.m09) === Infinity || Math.abs(this.m10) === Infinity || Math.abs(this.m11) === Infinity || Math.abs(this.m12) === Infinity || Math.abs(this.m13) === Infinity || Math.abs(this.m14) === Infinity || Math.abs(this.m15) === Infinity;
          return !hasInf && Math.abs(this.m00 - other.m00) <= epsilon * Math.max(1.0, Math.abs(this.m00), Math.abs(other.m00)) && Math.abs(this.m01 - other.m01) <= epsilon * Math.max(1.0, Math.abs(this.m01), Math.abs(other.m01)) && Math.abs(this.m02 - other.m02) <= epsilon * Math.max(1.0, Math.abs(this.m02), Math.abs(other.m02)) && Math.abs(this.m03 - other.m03) <= epsilon * Math.max(1.0, Math.abs(this.m03), Math.abs(other.m03)) && Math.abs(this.m04 - other.m04) <= epsilon * Math.max(1.0, Math.abs(this.m04), Math.abs(other.m04)) && Math.abs(this.m05 - other.m05) <= epsilon * Math.max(1.0, Math.abs(this.m05), Math.abs(other.m05)) && Math.abs(this.m06 - other.m06) <= epsilon * Math.max(1.0, Math.abs(this.m06), Math.abs(other.m06)) && Math.abs(this.m07 - other.m07) <= epsilon * Math.max(1.0, Math.abs(this.m07), Math.abs(other.m07)) && Math.abs(this.m08 - other.m08) <= epsilon * Math.max(1.0, Math.abs(this.m08), Math.abs(other.m08)) && Math.abs(this.m09 - other.m09) <= epsilon * Math.max(1.0, Math.abs(this.m09), Math.abs(other.m09)) && Math.abs(this.m10 - other.m10) <= epsilon * Math.max(1.0, Math.abs(this.m10), Math.abs(other.m10)) && Math.abs(this.m11 - other.m11) <= epsilon * Math.max(1.0, Math.abs(this.m11), Math.abs(other.m11)) && Math.abs(this.m12 - other.m12) <= epsilon * Math.max(1.0, Math.abs(this.m12), Math.abs(other.m12)) && Math.abs(this.m13 - other.m13) <= epsilon * Math.max(1.0, Math.abs(this.m13), Math.abs(other.m13)) && Math.abs(this.m14 - other.m14) <= epsilon * Math.max(1.0, Math.abs(this.m14), Math.abs(other.m14)) && Math.abs(this.m15 - other.m15) <= epsilon * Math.max(1.0, Math.abs(this.m15), Math.abs(other.m15));
        }
        strictEquals(other) {
          return this.m00 === other.m00 && this.m01 === other.m01 && this.m02 === other.m02 && this.m03 === other.m03 && this.m04 === other.m04 && this.m05 === other.m05 && this.m06 === other.m06 && this.m07 === other.m07 && this.m08 === other.m08 && this.m09 === other.m09 && this.m10 === other.m10 && this.m11 === other.m11 && this.m12 === other.m12 && this.m13 === other.m13 && this.m14 === other.m14 && this.m15 === other.m15;
        }
        toString() {
          return `[\n${this.m00}, ${this.m01}, ${this.m02}, ${this.m03},\n${this.m04}, ${this.m05}, ${this.m06}, ${this.m07},\n${this.m08}, ${this.m09}, ${this.m10}, ${this.m11},\n${this.m12}, ${this.m13}, ${this.m14}, ${this.m15}\n` + ']';
        }
        identity() {
          this.m00 = 1;
          this.m01 = 0;
          this.m02 = 0;
          this.m03 = 0;
          this.m04 = 0;
          this.m05 = 1;
          this.m06 = 0;
          this.m07 = 0;
          this.m08 = 0;
          this.m09 = 0;
          this.m10 = 1;
          this.m11 = 0;
          this.m12 = 0;
          this.m13 = 0;
          this.m14 = 0;
          this.m15 = 1;
          return this;
        }
        zero() {
          this.m00 = 0;
          this.m01 = 0;
          this.m02 = 0;
          this.m03 = 0;
          this.m04 = 0;
          this.m05 = 0;
          this.m06 = 0;
          this.m07 = 0;
          this.m08 = 0;
          this.m09 = 0;
          this.m10 = 0;
          this.m11 = 0;
          this.m12 = 0;
          this.m13 = 0;
          this.m14 = 0;
          this.m15 = 0;
          return this;
        }
        transpose() {
          const a01 = this.m01;
          const a02 = this.m02;
          const a03 = this.m03;
          const a12 = this.m06;
          const a13 = this.m07;
          const a23 = this.m11;
          this.m01 = this.m04;
          this.m02 = this.m08;
          this.m03 = this.m12;
          this.m04 = a01;
          this.m06 = this.m09;
          this.m07 = this.m13;
          this.m08 = a02;
          this.m09 = a12;
          this.m11 = this.m14;
          this.m12 = a03;
          this.m13 = a13;
          this.m14 = a23;
          return this;
        }
        invert() {
          const a00 = this.m00;
          const a01 = this.m01;
          const a02 = this.m02;
          const a03 = this.m03;
          const a10 = this.m04;
          const a11 = this.m05;
          const a12 = this.m06;
          const a13 = this.m07;
          const a20 = this.m08;
          const a21 = this.m09;
          const a22 = this.m10;
          const a23 = this.m11;
          const a30 = this.m12;
          const a31 = this.m13;
          const a32 = this.m14;
          const a33 = this.m15;
          const b00 = a00 * a11 - a01 * a10;
          const b01 = a00 * a12 - a02 * a10;
          const b02 = a00 * a13 - a03 * a10;
          const b03 = a01 * a12 - a02 * a11;
          const b04 = a01 * a13 - a03 * a11;
          const b05 = a02 * a13 - a03 * a12;
          const b06 = a20 * a31 - a21 * a30;
          const b07 = a20 * a32 - a22 * a30;
          const b08 = a20 * a33 - a23 * a30;
          const b09 = a21 * a32 - a22 * a31;
          const b10 = a21 * a33 - a23 * a31;
          const b11 = a22 * a33 - a23 * a32;
          let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
          if (det === 0) {
            this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
            return this;
          }
          det = 1.0 / det;
          this.m00 = (a11 * b11 - a12 * b10 + a13 * b09) * det;
          this.m01 = (a02 * b10 - a01 * b11 - a03 * b09) * det;
          this.m02 = (a31 * b05 - a32 * b04 + a33 * b03) * det;
          this.m03 = (a22 * b04 - a21 * b05 - a23 * b03) * det;
          this.m04 = (a12 * b08 - a10 * b11 - a13 * b07) * det;
          this.m05 = (a00 * b11 - a02 * b08 + a03 * b07) * det;
          this.m06 = (a32 * b02 - a30 * b05 - a33 * b01) * det;
          this.m07 = (a20 * b05 - a22 * b02 + a23 * b01) * det;
          this.m08 = (a10 * b10 - a11 * b08 + a13 * b06) * det;
          this.m09 = (a01 * b08 - a00 * b10 - a03 * b06) * det;
          this.m10 = (a30 * b04 - a31 * b02 + a33 * b00) * det;
          this.m11 = (a21 * b02 - a20 * b04 - a23 * b00) * det;
          this.m12 = (a11 * b07 - a10 * b09 - a12 * b06) * det;
          this.m13 = (a00 * b09 - a01 * b07 + a02 * b06) * det;
          this.m14 = (a31 * b01 - a30 * b03 - a32 * b00) * det;
          this.m15 = (a20 * b03 - a21 * b01 + a22 * b00) * det;
          return this;
        }
        determinant() {
          const a00 = this.m00;
          const a01 = this.m01;
          const a02 = this.m02;
          const a03 = this.m03;
          const a10 = this.m04;
          const a11 = this.m05;
          const a12 = this.m06;
          const a13 = this.m07;
          const a20 = this.m08;
          const a21 = this.m09;
          const a22 = this.m10;
          const a23 = this.m11;
          const a30 = this.m12;
          const a31 = this.m13;
          const a32 = this.m14;
          const a33 = this.m15;
          const b00 = a00 * a11 - a01 * a10;
          const b01 = a00 * a12 - a02 * a10;
          const b02 = a00 * a13 - a03 * a10;
          const b03 = a01 * a12 - a02 * a11;
          const b04 = a01 * a13 - a03 * a11;
          const b05 = a02 * a13 - a03 * a12;
          const b06 = a20 * a31 - a21 * a30;
          const b07 = a20 * a32 - a22 * a30;
          const b08 = a20 * a33 - a23 * a30;
          const b09 = a21 * a32 - a22 * a31;
          const b10 = a21 * a33 - a23 * a31;
          const b11 = a22 * a33 - a23 * a32;
          return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
        }
        add(mat) {
          this.m00 += mat.m00;
          this.m01 += mat.m01;
          this.m02 += mat.m02;
          this.m03 += mat.m03;
          this.m04 += mat.m04;
          this.m05 += mat.m05;
          this.m06 += mat.m06;
          this.m07 += mat.m07;
          this.m08 += mat.m08;
          this.m09 += mat.m09;
          this.m10 += mat.m10;
          this.m11 += mat.m11;
          this.m12 += mat.m12;
          this.m13 += mat.m13;
          this.m14 += mat.m14;
          this.m15 += mat.m15;
          return this;
        }
        subtract(mat) {
          this.m00 -= mat.m00;
          this.m01 -= mat.m01;
          this.m02 -= mat.m02;
          this.m03 -= mat.m03;
          this.m04 -= mat.m04;
          this.m05 -= mat.m05;
          this.m06 -= mat.m06;
          this.m07 -= mat.m07;
          this.m08 -= mat.m08;
          this.m09 -= mat.m09;
          this.m10 -= mat.m10;
          this.m11 -= mat.m11;
          this.m12 -= mat.m12;
          this.m13 -= mat.m13;
          this.m14 -= mat.m14;
          this.m15 -= mat.m15;
          return this;
        }
        multiply(mat) {
          const a00 = this.m00;
          const a01 = this.m01;
          const a02 = this.m02;
          const a03 = this.m03;
          const a10 = this.m04;
          const a11 = this.m05;
          const a12 = this.m06;
          const a13 = this.m07;
          const a20 = this.m08;
          const a21 = this.m09;
          const a22 = this.m10;
          const a23 = this.m11;
          const a30 = this.m12;
          const a31 = this.m13;
          const a32 = this.m14;
          const a33 = this.m15;
          let b0 = mat.m00;
          let b1 = mat.m01;
          let b2 = mat.m02;
          let b3 = mat.m03;
          this.m00 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
          this.m01 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
          this.m02 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
          this.m03 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
          b0 = mat.m04;
          b1 = mat.m05;
          b2 = mat.m06;
          b3 = mat.m07;
          this.m04 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
          this.m05 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
          this.m06 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
          this.m07 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
          b0 = mat.m08;
          b1 = mat.m09;
          b2 = mat.m10;
          b3 = mat.m11;
          this.m08 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
          this.m09 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
          this.m10 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
          this.m11 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
          b0 = mat.m12;
          b1 = mat.m13;
          b2 = mat.m14;
          b3 = mat.m15;
          this.m12 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
          this.m13 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
          this.m14 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
          this.m15 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
          return this;
        }
        multiplyScalar(scalar) {
          this.m00 *= scalar;
          this.m01 *= scalar;
          this.m02 *= scalar;
          this.m03 *= scalar;
          this.m04 *= scalar;
          this.m05 *= scalar;
          this.m06 *= scalar;
          this.m07 *= scalar;
          this.m08 *= scalar;
          this.m09 *= scalar;
          this.m10 *= scalar;
          this.m11 *= scalar;
          this.m12 *= scalar;
          this.m13 *= scalar;
          this.m14 *= scalar;
          this.m15 *= scalar;
          return this;
        }
        translate(vec) {
          this.m12 += vec.x;
          this.m13 += vec.y;
          this.m14 += vec.z;
          return this;
        }
        transform(vec) {
          const {
            x,
            y,
            z
          } = vec;
          const a00 = this.m00;
          const a01 = this.m01;
          const a02 = this.m02;
          const a03 = this.m03;
          const a10 = this.m04;
          const a11 = this.m05;
          const a12 = this.m06;
          const a13 = this.m07;
          const a20 = this.m08;
          const a21 = this.m09;
          const a22 = this.m10;
          const a23 = this.m11;
          this.m12 = a00 * x + a10 * y + a20 * z + this.m12;
          this.m13 = a01 * x + a11 * y + a21 * z + this.m13;
          this.m14 = a02 * x + a12 * y + a22 * z + this.m14;
          this.m15 = a03 * x + a13 * y + a23 * z + this.m15;
          return this;
        }
        scale(vec) {
          const x = vec.x;
          const y = vec.y;
          const z = vec.z;
          this.m00 *= x;
          this.m01 *= x;
          this.m02 *= x;
          this.m03 *= x;
          this.m04 *= y;
          this.m05 *= y;
          this.m06 *= y;
          this.m07 *= y;
          this.m08 *= z;
          this.m09 *= z;
          this.m10 *= z;
          this.m11 *= z;
          return this;
        }
        rotate(rad, axis) {
          let x = axis.x;
          let y = axis.y;
          let z = axis.z;
          let len = Math.sqrt(x * x + y * y + z * z);
          if (Math.abs(len) < EPSILON$2) {
            return null;
          }
          len = 1 / len;
          x *= len;
          y *= len;
          z *= len;
          const s = Math.sin(rad);
          const c = Math.cos(rad);
          const t = 1 - c;
          const a00 = this.m00;
          const a01 = this.m01;
          const a02 = this.m02;
          const a03 = this.m03;
          const a10 = this.m04;
          const a11 = this.m05;
          const a12 = this.m06;
          const a13 = this.m07;
          const a20 = this.m08;
          const a21 = this.m09;
          const a22 = this.m10;
          const a23 = this.m11;
          const b00 = x * x * t + c;
          const b01 = y * x * t + z * s;
          const b02 = z * x * t - y * s;
          const b10 = x * y * t - z * s;
          const b11 = y * y * t + c;
          const b12 = z * y * t + x * s;
          const b20 = x * z * t + y * s;
          const b21 = y * z * t - x * s;
          const b22 = z * z * t + c;
          this.m00 = a00 * b00 + a10 * b01 + a20 * b02;
          this.m01 = a01 * b00 + a11 * b01 + a21 * b02;
          this.m02 = a02 * b00 + a12 * b01 + a22 * b02;
          this.m03 = a03 * b00 + a13 * b01 + a23 * b02;
          this.m04 = a00 * b10 + a10 * b11 + a20 * b12;
          this.m05 = a01 * b10 + a11 * b11 + a21 * b12;
          this.m06 = a02 * b10 + a12 * b11 + a22 * b12;
          this.m07 = a03 * b10 + a13 * b11 + a23 * b12;
          this.m08 = a00 * b20 + a10 * b21 + a20 * b22;
          this.m09 = a01 * b20 + a11 * b21 + a21 * b22;
          this.m10 = a02 * b20 + a12 * b21 + a22 * b22;
          this.m11 = a03 * b20 + a13 * b21 + a23 * b22;
          return this;
        }
        getTranslation(out) {
          out.x = this.m12;
          out.y = this.m13;
          out.z = this.m14;
          return out;
        }
        getScale(out) {
          const m00 = m3_1.m00 = this.m00;
          const m01 = m3_1.m01 = this.m01;
          const m02 = m3_1.m02 = this.m02;
          const m04 = m3_1.m03 = this.m04;
          const m05 = m3_1.m04 = this.m05;
          const m06 = m3_1.m05 = this.m06;
          const m08 = m3_1.m06 = this.m08;
          const m09 = m3_1.m07 = this.m09;
          const m10 = m3_1.m08 = this.m10;
          out.x = Math.sqrt(m00 * m00 + m01 * m01 + m02 * m02);
          out.y = Math.sqrt(m04 * m04 + m05 * m05 + m06 * m06);
          out.z = Math.sqrt(m08 * m08 + m09 * m09 + m10 * m10);
          if (Mat3.determinant(m3_1) < 0) {
            out.x *= -1;
          }
          return out;
        }
        getRotation(out) {
          const sx = Vec3.set(v3_1, this.m00, this.m01, this.m02).length();
          const sy = Vec3.set(v3_1, this.m04, this.m05, this.m06).length();
          const sz = Vec3.set(v3_1, this.m08, this.m09, this.m10).length();
          m3_1.m00 = this.m00 / sx;
          m3_1.m01 = this.m01 / sx;
          m3_1.m02 = this.m02 / sx;
          m3_1.m03 = this.m04 / sy;
          m3_1.m04 = this.m05 / sy;
          m3_1.m05 = this.m06 / sy;
          m3_1.m06 = this.m08 / sz;
          m3_1.m07 = this.m09 / sz;
          m3_1.m08 = this.m10 / sz;
          const det = Mat3.determinant(m3_1);
          if (det < 0) {
            m3_1.m00 *= -1;
            m3_1.m01 *= -1;
            m3_1.m02 *= -1;
          }
          return Quat.fromMat3(out, m3_1);
        }
        fromRTS(q, v, s) {
          const x = q.x;
          const y = q.y;
          const z = q.z;
          const w = q.w;
          const x2 = x + x;
          const y2 = y + y;
          const z2 = z + z;
          const xx = x * x2;
          const xy = x * y2;
          const xz = x * z2;
          const yy = y * y2;
          const yz = y * z2;
          const zz = z * z2;
          const wx = w * x2;
          const wy = w * y2;
          const wz = w * z2;
          const sx = s.x;
          const sy = s.y;
          const sz = s.z;
          this.m00 = (1 - (yy + zz)) * sx;
          this.m01 = (xy + wz) * sx;
          this.m02 = (xz - wy) * sx;
          this.m03 = 0;
          this.m04 = (xy - wz) * sy;
          this.m05 = (1 - (xx + zz)) * sy;
          this.m06 = (yz + wx) * sy;
          this.m07 = 0;
          this.m08 = (xz + wy) * sz;
          this.m09 = (yz - wx) * sz;
          this.m10 = (1 - (xx + yy)) * sz;
          this.m11 = 0;
          this.m12 = v.x;
          this.m13 = v.y;
          this.m14 = v.z;
          this.m15 = 1;
          return this;
        }
        fromSRT(q, v, s) {
          const x = q.x;
          const y = q.y;
          const z = q.z;
          const w = q.w;
          const x2 = x + x;
          const y2 = y + y;
          const z2 = z + z;
          const xx = x * x2;
          const xy = x * y2;
          const xz = x * z2;
          const yy = y * y2;
          const yz = y * z2;
          const zz = z * z2;
          const wx = w * x2;
          const wy = w * y2;
          const wz = w * z2;
          const sx = s.x;
          const sy = s.y;
          const sz = s.z;
          this.m00 = (1 - (yy + zz)) * sx;
          this.m01 = (xy + wz) * sx;
          this.m02 = (xz - wy) * sx;
          this.m03 = 0;
          this.m04 = (xy - wz) * sy;
          this.m05 = (1 - (xx + zz)) * sy;
          this.m06 = (yz + wx) * sy;
          this.m07 = 0;
          this.m08 = (xz + wy) * sz;
          this.m09 = (yz - wx) * sz;
          this.m10 = (1 - (xx + yy)) * sz;
          this.m11 = 0;
          this.m12 = v.x;
          this.m13 = v.y;
          this.m14 = v.z;
          this.m15 = 1;
          return this;
        }
        fromQuat(q) {
          const x = q.x;
          const y = q.y;
          const z = q.z;
          const w = q.w;
          const x2 = x + x;
          const y2 = y + y;
          const z2 = z + z;
          const xx = x * x2;
          const yx = y * x2;
          const yy = y * y2;
          const zx = z * x2;
          const zy = z * y2;
          const zz = z * z2;
          const wx = w * x2;
          const wy = w * y2;
          const wz = w * z2;
          this.m00 = 1 - yy - zz;
          this.m01 = yx + wz;
          this.m02 = zx - wy;
          this.m03 = 0;
          this.m04 = yx - wz;
          this.m05 = 1 - xx - zz;
          this.m06 = zy + wx;
          this.m07 = 0;
          this.m08 = zx + wy;
          this.m09 = zy - wx;
          this.m10 = 1 - xx - yy;
          this.m11 = 0;
          this.m12 = 0;
          this.m13 = 0;
          this.m14 = 0;
          this.m15 = 1;
          return this;
        }
      } exports('Mat4', Mat4);
      _class$11 = Mat4;
      Mat4.IDENTITY = Object.freeze(new _class$11());
      const v3_1 = new Vec3();
      const m3_1 = new Mat3();
      CCClass.fastDefine('cc.Mat4', Mat4, {
        m00: 1,
        m01: 0,
        m02: 0,
        m03: 0,
        m04: 0,
        m05: 1,
        m06: 0,
        m07: 0,
        m08: 0,
        m09: 0,
        m10: 1,
        m11: 0,
        m12: 0,
        m13: 0,
        m14: 0,
        m15: 1
      });
      legacyCC.Mat4 = Mat4;
      function mat4(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
        return new Mat4(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33);
      }
      legacyCC.mat4 = mat4;

      var _class$10;
      class Vec2 extends ValueType {
        static clone(a) {
          return new Vec2(a.x, a.y);
        }
        static copy(out, a) {
          out.x = a.x;
          out.y = a.y;
          return out;
        }
        static set(out, x, y) {
          out.x = x;
          out.y = y;
          return out;
        }
        static add(out, a, b) {
          out.x = a.x + b.x;
          out.y = a.y + b.y;
          return out;
        }
        static subtract(out, a, b) {
          out.x = a.x - b.x;
          out.y = a.y - b.y;
          return out;
        }
        static multiply(out, a, b) {
          out.x = a.x * b.x;
          out.y = a.y * b.y;
          return out;
        }
        static divide(out, a, b) {
          out.x = a.x / b.x;
          out.y = a.y / b.y;
          return out;
        }
        static ceil(out, a) {
          out.x = Math.ceil(a.x);
          out.y = Math.ceil(a.y);
          return out;
        }
        static floor(out, a) {
          out.x = Math.floor(a.x);
          out.y = Math.floor(a.y);
          return out;
        }
        static min(out, a, b) {
          out.x = Math.min(a.x, b.x);
          out.y = Math.min(a.y, b.y);
          return out;
        }
        static max(out, a, b) {
          out.x = Math.max(a.x, b.x);
          out.y = Math.max(a.y, b.y);
          return out;
        }
        static round(out, a) {
          out.x = Math.round(a.x);
          out.y = Math.round(a.y);
          return out;
        }
        static multiplyScalar(out, a, b) {
          out.x = a.x * b;
          out.y = a.y * b;
          return out;
        }
        static scaleAndAdd(out, a, b, scale) {
          out.x = a.x + b.x * scale;
          out.y = a.y + b.y * scale;
          return out;
        }
        static distance(a, b) {
          const x = b.x - a.x;
          const y = b.y - a.y;
          return Math.sqrt(x * x + y * y);
        }
        static squaredDistance(a, b) {
          const x = b.x - a.x;
          const y = b.y - a.y;
          return x * x + y * y;
        }
        static len(a) {
          const x = a.x;
          const y = a.y;
          return Math.sqrt(x * x + y * y);
        }
        static lengthSqr(a) {
          const x = a.x;
          const y = a.y;
          return x * x + y * y;
        }
        static negate(out, a) {
          out.x = -a.x;
          out.y = -a.y;
          return out;
        }
        static inverse(out, a) {
          out.x = 1.0 / a.x;
          out.y = 1.0 / a.y;
          return out;
        }
        static inverseSafe(out, a) {
          const x = a.x;
          const y = a.y;
          if (Math.abs(x) < EPSILON$2) {
            out.x = 0;
          } else {
            out.x = 1.0 / x;
          }
          if (Math.abs(y) < EPSILON$2) {
            out.y = 0;
          } else {
            out.y = 1.0 / y;
          }
          return out;
        }
        static normalize(out, a) {
          const x = a.x;
          const y = a.y;
          let len = x * x + y * y;
          if (len > 0) {
            len = 1 / Math.sqrt(len);
            out.x = x * len;
            out.y = y * len;
          } else {
            out.x = 0;
            out.y = 0;
          }
          return out;
        }
        static dot(a, b) {
          return a.x * b.x + a.y * b.y;
        }
        static cross(out, a, b) {
          if (out instanceof Vec3) {
            out.x = out.y = 0;
            out.z = a.x * b.y - a.y * b.x;
            return out;
          } else {
            return out.x * a.y - out.y * a.x;
          }
        }
        static lerp(out, a, b, t) {
          const x = a.x;
          const y = a.y;
          out.x = x + t * (b.x - x);
          out.y = y + t * (b.y - y);
          return out;
        }
        static random(out, scale) {
          scale = scale || 1.0;
          const r = random() * 2.0 * Math.PI;
          out.x = Math.cos(r) * scale;
          out.y = Math.sin(r) * scale;
          return out;
        }
        static transformMat3(out, a, m) {
          const x = a.x;
          const y = a.y;
          out.x = m.m00 * x + m.m03 * y + m.m06;
          out.y = m.m01 * x + m.m04 * y + m.m07;
          return out;
        }
        static transformMat4(out, a, m) {
          const x = a.x;
          const y = a.y;
          out.x = m.m00 * x + m.m04 * y + m.m12;
          out.y = m.m01 * x + m.m05 * y + m.m13;
          return out;
        }
        static str(a) {
          return `Vec2(${a.x}, ${a.y})`;
        }
        static toArray(out, v, ofs = 0) {
          out[ofs + 0] = v.x;
          out[ofs + 1] = v.y;
          return out;
        }
        static fromArray(out, arr, ofs = 0) {
          out.x = arr[ofs + 0];
          out.y = arr[ofs + 1];
          return out;
        }
        static strictEquals(a, b) {
          return a.x === b.x && a.y === b.y;
        }
        static equals(a, b, epsilon = EPSILON$2) {
          return Math.abs(a.x - b.x) <= epsilon * Math.max(1.0, Math.abs(a.x), Math.abs(b.x)) && Math.abs(a.y - b.y) <= epsilon * Math.max(1.0, Math.abs(a.y), Math.abs(b.y));
        }
        static angle(a, b) {
          const magSqr1 = a.x * a.x + a.y * a.y;
          const magSqr2 = b.x * b.x + b.y * b.y;
          if (magSqr1 === 0 || magSqr2 === 0) {
            return 0.0;
          }
          const dot = a.x * b.x + a.y * b.y;
          let cosine = dot / Math.sqrt(magSqr1 * magSqr2);
          cosine = clamp$1(cosine, -1.0, 1.0);
          return Math.acos(cosine);
        }
        constructor(x, y) {
          super();
          if (typeof x === 'object') {
            this.x = x.x;
            this.y = x.y;
          } else {
            this.x = x || 0;
            this.y = y || 0;
          }
        }
        clone() {
          return new Vec2(this.x, this.y);
        }
        set(x, y) {
          if (typeof x === 'object') {
            this.x = x.x;
            this.y = x.y;
          } else {
            this.x = x || 0;
            this.y = y || 0;
          }
          return this;
        }
        equals(other, epsilon = EPSILON$2) {
          return Math.abs(this.x - other.x) <= epsilon * Math.max(1.0, Math.abs(this.x), Math.abs(other.x)) && Math.abs(this.y - other.y) <= epsilon * Math.max(1.0, Math.abs(this.y), Math.abs(other.y));
        }
        equals2f(x, y, epsilon = EPSILON$2) {
          return Math.abs(this.x - x) <= epsilon * Math.max(1.0, Math.abs(this.x), Math.abs(x)) && Math.abs(this.y - y) <= epsilon * Math.max(1.0, Math.abs(this.y), Math.abs(y));
        }
        strictEquals(other) {
          return other && this.x === other.x && this.y === other.y;
        }
        strictEquals2f(x, y) {
          return this.x === x && this.y === y;
        }
        toString() {
          return `(${this.x.toFixed(2)}, ${this.y.toFixed(2)})`;
        }
        lerp(to, ratio) {
          const x = this.x;
          const y = this.y;
          this.x = x + ratio * (to.x - x);
          this.y = y + ratio * (to.y - y);
          return this;
        }
        clampf(minInclusive, maxInclusive) {
          this.x = clamp$1(this.x, minInclusive.x, maxInclusive.x);
          this.y = clamp$1(this.y, minInclusive.y, maxInclusive.y);
          return this;
        }
        add(other) {
          this.x += other.x;
          this.y += other.y;
          return this;
        }
        add2f(x, y) {
          this.x += x;
          this.y += y;
          return this;
        }
        subtract(other) {
          this.x -= other.x;
          this.y -= other.y;
          return this;
        }
        subtract2f(x, y) {
          this.x -= x;
          this.y -= y;
          return this;
        }
        multiplyScalar(scalar) {
          if (typeof scalar === 'object') {
            console.warn('should use Vec2.multiply for vector * vector operation');
          }
          this.x *= scalar;
          this.y *= scalar;
          return this;
        }
        multiply(other) {
          if (typeof other !== 'object') {
            console.warn('should use Vec2.scale for vector * scalar operation');
          }
          this.x *= other.x;
          this.y *= other.y;
          return this;
        }
        multiply2f(x, y) {
          this.x *= x;
          this.y *= y;
          return this;
        }
        divide(other) {
          this.x /= other.x;
          this.y /= other.y;
          return this;
        }
        divide2f(x, y) {
          this.x /= x;
          this.y /= y;
          return this;
        }
        negative() {
          this.x = -this.x;
          this.y = -this.y;
          return this;
        }
        dot(other) {
          return this.x * other.x + this.y * other.y;
        }
        cross(other) {
          return this.x * other.y - this.y * other.x;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }
        lengthSqr() {
          return this.x * this.x + this.y * this.y;
        }
        normalize() {
          const x = this.x;
          const y = this.y;
          let len = x * x + y * y;
          if (len > 0) {
            len = 1 / Math.sqrt(len);
            this.x *= len;
            this.y *= len;
          }
          return this;
        }
        angle(other) {
          const magSqr1 = this.lengthSqr();
          const magSqr2 = other.lengthSqr();
          if (magSqr1 === 0 || magSqr2 === 0) {
            return 0.0;
          }
          const dot = this.dot(other);
          let cosine = dot / Math.sqrt(magSqr1 * magSqr2);
          cosine = clamp$1(cosine, -1.0, 1.0);
          return Math.acos(cosine);
        }
        signAngle(other) {
          const angle = this.angle(other);
          return this.cross(other) < 0 ? -angle : angle;
        }
        rotate(radians) {
          const x = this.x;
          const y = this.y;
          const sin = Math.sin(radians);
          const cos = Math.cos(radians);
          this.x = cos * x - sin * y;
          this.y = sin * x + cos * y;
          return this;
        }
        project(other) {
          const scalar = this.dot(other) / other.dot(other);
          this.x = other.x * scalar;
          this.y = other.y * scalar;
          return this;
        }
        transformMat4(matrix) {
          const x = this.x;
          const y = this.y;
          this.x = matrix.m00 * x + matrix.m04 * y + matrix.m12;
          this.y = matrix.m01 * x + matrix.m05 * y + matrix.m13;
          return this;
        }
      } exports('Vec2', Vec2);
      _class$10 = Vec2;
      Vec2.ZERO = Object.freeze(new _class$10(0, 0));
      Vec2.ONE = Object.freeze(new _class$10(1, 1));
      Vec2.NEG_ONE = Object.freeze(new _class$10(-1, -1));
      Vec2.UNIT_X = Object.freeze(new _class$10(1, 0));
      Vec2.UNIT_Y = Object.freeze(new _class$10(0, 1));
      CCClass.fastDefine('cc.Vec2', Vec2, {
        x: 0,
        y: 0
      });
      legacyCC.Vec2 = Vec2;
      function v2$1(x, y) {
        return new Vec2(x, y);
      }
      legacyCC.v2 = v2$1;

      replaceProperty(Vec2, 'Vec2', [{
        name: 'sub',
        newName: 'subtract',
        target: Vec2,
        targetName: 'Vec2'
      }, {
        name: 'mul',
        newName: 'multiply',
        target: Vec2,
        targetName: 'Vec2'
      }, {
        name: 'div',
        newName: 'divide',
        target: Vec2,
        targetName: 'Vec2'
      }, {
        name: 'dist',
        newName: 'distance',
        target: Vec2,
        targetName: 'Vec2'
      }, {
        name: 'sqrDist',
        newName: 'squaredDistance',
        target: Vec2,
        targetName: 'Vec2'
      }, {
        name: 'mag',
        newName: 'len',
        target: Vec2,
        targetName: 'Vec2'
      }, {
        name: 'sqrMag',
        newName: 'lengthSqr',
        target: Vec2,
        targetName: 'Vec2'
      }, {
        name: 'scale',
        newName: 'multiplyScalar',
        target: Vec2,
        targetName: 'Vec2'
      }, {
        name: 'exactEquals',
        newName: 'strictEquals',
        target: Vec2,
        targetName: 'Vec2'
      }]);
      replaceProperty(Vec2.prototype, 'Vec2', [{
        name: 'mag',
        newName: 'length',
        target: Vec2.prototype,
        targetName: 'Vec2'
      }, {
        name: 'magSqr',
        newName: 'lengthSqr',
        target: Vec2.prototype,
        targetName: 'Vec2'
      }, {
        name: 'scale',
        newName: 'multiplyScalar',
        target: Vec2.prototype,
        targetName: 'Vec2'
      }, {
        name: 'exactEquals',
        newName: 'strictEquals',
        target: Vec2.prototype,
        targetName: 'Vec2'
      }]);
      replaceProperty(Vec3, 'Vec3', [{
        name: 'sub',
        newName: 'subtract',
        target: Vec3,
        targetName: 'Vec3'
      }, {
        name: 'mul',
        newName: 'multiply',
        target: Vec3,
        targetName: 'Vec3'
      }, {
        name: 'div',
        newName: 'divide',
        target: Vec3,
        targetName: 'Vec3'
      }, {
        name: 'dist',
        newName: 'distance',
        target: Vec3,
        targetName: 'Vec3'
      }, {
        name: 'sqrDist',
        newName: 'squaredDistance',
        target: Vec3,
        targetName: 'Vec3'
      }, {
        name: 'mag',
        newName: 'len',
        target: Vec3,
        targetName: 'Vec3'
      }, {
        name: 'sqrMag',
        newName: 'lengthSqr',
        target: Vec3,
        targetName: 'Vec3'
      }, {
        name: 'scale',
        newName: 'multiplyScalar',
        target: Vec3,
        targetName: 'Vec3'
      }, {
        name: 'exactEquals',
        newName: 'strictEquals',
        target: Vec3,
        targetName: 'Vec3'
      }]);
      replaceProperty(Vec3.prototype, 'Vec3', [{
        name: 'mag',
        newName: 'length',
        target: Vec3.prototype,
        targetName: 'Vec3'
      }, {
        name: 'magSqr',
        newName: 'lengthSqr',
        target: Vec3.prototype,
        targetName: 'Vec3'
      }, {
        name: 'scale',
        newName: 'multiplyScalar',
        target: Vec3.prototype,
        targetName: 'Vec3'
      }, {
        name: 'exactEquals',
        newName: 'strictEquals',
        target: Vec3.prototype,
        targetName: 'Vec3'
      }]);
      replaceProperty(Vec4, 'Vec4', [{
        name: 'sub',
        newName: 'subtract',
        target: Vec4,
        targetName: 'Vec4'
      }, {
        name: 'mul',
        newName: 'multiply',
        target: Vec4,
        targetName: 'Vec4'
      }, {
        name: 'div',
        newName: 'divide',
        target: Vec4,
        targetName: 'Vec4'
      }, {
        name: 'dist',
        newName: 'distance',
        target: Vec4,
        targetName: 'Vec4'
      }, {
        name: 'sqrDist',
        newName: 'squaredDistance',
        target: Vec4,
        targetName: 'Vec4'
      }, {
        name: 'mag',
        newName: 'len',
        target: Vec4,
        targetName: 'Vec4'
      }, {
        name: 'sqrMag',
        newName: 'lengthSqr',
        target: Vec4,
        targetName: 'Vec4'
      }, {
        name: 'scale',
        newName: 'multiplyScalar',
        target: Vec4,
        targetName: 'Vec4'
      }, {
        name: 'exactEquals',
        newName: 'strictEquals',
        target: Vec4,
        targetName: 'Vec4'
      }]);
      replaceProperty(Vec4.prototype, 'Vec4', [{
        name: 'mag',
        newName: 'length',
        target: Vec4.prototype,
        targetName: 'Vec4'
      }, {
        name: 'magSqr',
        newName: 'lengthSqr',
        target: Vec4.prototype,
        targetName: 'Vec4'
      }, {
        name: 'scale',
        newName: 'multiplyScalar',
        target: Vec4.prototype,
        targetName: 'Vec4'
      }, {
        name: 'exactEquals',
        newName: 'strictEquals',
        target: Vec4.prototype,
        targetName: 'Vec4'
      }]);
      replaceProperty(Quat, 'Quat', [{
        name: 'mag',
        newName: 'len',
        target: Quat,
        targetName: 'Quat'
      }, {
        name: 'mul',
        newName: 'multiply',
        target: Quat,
        targetName: 'Quat'
      }, {
        name: 'sqrMag',
        newName: 'lengthSqr',
        target: Quat,
        targetName: 'Quat'
      }, {
        name: 'scale',
        newName: 'multiplyScalar',
        target: Quat,
        targetName: 'Quat'
      }, {
        name: 'exactEquals',
        newName: 'strictEquals',
        target: Quat,
        targetName: 'Quat'
      }]);
      replaceProperty(Quat.prototype, 'Quat', [{
        name: 'scale',
        newName: 'multiplyScalar',
        target: Quat.prototype,
        targetName: 'Quat'
      }, {
        name: 'exactEquals',
        newName: 'strictEquals',
        target: Quat.prototype,
        targetName: 'Quat'
      }]);
      replaceProperty(Color$1, 'Color', [{
        name: 'sub',
        newName: 'subtract',
        target: Color$1,
        targetName: 'Color'
      }, {
        name: 'mul',
        newName: 'multiply',
        target: Color$1,
        targetName: 'Color'
      }, {
        name: 'div',
        newName: 'divide',
        target: Color$1,
        targetName: 'Color'
      }, {
        name: 'exactEquals',
        newName: 'strictEquals',
        target: Color$1,
        targetName: 'Color'
      }, {
        name: 'fromHex',
        newName: 'fromHEX',
        customFunction(...args) {
          const arg1 = args[1].toString(16);
          return legacyCC.Color.fromHEX(args[0], arg1);
        }
      }]);
      replaceProperty(Mat3, 'Mat3', [{
        name: 'sub',
        newName: 'subtract',
        target: Mat3,
        targetName: 'Mat3'
      }, {
        name: 'mul',
        newName: 'multiply',
        target: Mat3,
        targetName: 'Mat3'
      }, {
        name: 'exactEquals',
        newName: 'strictEquals',
        target: Mat3,
        targetName: 'Mat3'
      }, {
        name: 'transfrom',
        newName: 'transform',
        target: Mat3,
        targetName: 'Mat3'
      }]);
      replaceProperty(Mat3.prototype, 'Mat3', [{
        name: 'sub',
        newName: 'subtract',
        target: Mat3.prototype,
        targetName: 'Mat3'
      }, {
        name: 'mul',
        newName: 'multiply',
        target: Mat3.prototype,
        targetName: 'Mat3'
      }, {
        name: 'mulScalar',
        newName: 'multiplyScalar',
        target: Mat3.prototype,
        targetName: 'Mat3'
      }, {
        name: 'exactEquals',
        newName: 'strictEquals',
        target: Mat3.prototype,
        targetName: 'Mat3'
      }]);
      replaceProperty(Mat4, 'Mat4', [{
        name: 'sub',
        newName: 'subtract',
        target: Mat4,
        targetName: 'Mat4'
      }, {
        name: 'mul',
        newName: 'multiply',
        target: Mat4,
        targetName: 'Mat4'
      }, {
        name: 'exactEquals',
        newName: 'strictEquals',
        target: Mat4,
        targetName: 'Mat4'
      }]);
      replaceProperty(Mat4.prototype, 'Mat4', [{
        name: 'sub',
        newName: 'subtract',
        target: Mat4.prototype,
        targetName: 'Mat4'
      }, {
        name: 'mul',
        newName: 'multiply',
        target: Mat4.prototype,
        targetName: 'Mat4'
      }, {
        name: 'mulScalar',
        newName: 'multiplyScalar',
        target: Mat4.prototype,
        targetName: 'Mat4'
      }, {
        name: 'exactEquals',
        newName: 'strictEquals',
        target: Mat4.prototype,
        targetName: 'Mat4'
      }]);

      const defineAttr = (proto, name, offset) => {
        Object.defineProperty(proto, name, {
          configurable: true,
          enumerable: true,
          get() {
            return this._data()[offset];
          },
          set(v) {
            this._data()[offset] = v;
          }
        });
      };
      let MathType$1;
      (function (MathType) {
        MathType[MathType["VEC2"] = 0] = "VEC2";
        MathType[MathType["VEC3"] = 1] = "VEC3";
        MathType[MathType["VEC4"] = 2] = "VEC4";
        MathType[MathType["QUATERNION"] = 3] = "QUATERNION";
        MathType[MathType["MAT3"] = 4] = "MAT3";
        MathType[MathType["MAT4"] = 5] = "MAT4";
        MathType[MathType["SIZE"] = 6] = "SIZE";
        MathType[MathType["RECT"] = 7] = "RECT";
        MathType[MathType["COLOR"] = 8] = "COLOR";
      })(MathType$1 || (MathType$1 = {}));
      function extendType(proto, parentProto, typ) {
        proto._data = function () {
          if (!this.__data) {
            this.__data = new Float32Array(this.underlyingData());
          }
          return this.__data;
        };
        Object.setPrototypeOf(proto, parentProto);
        Object.defineProperty(proto, 'type', {
          configurable: true,
          enumerable: true,
          writable: false,
          value: typ
        });
      }
      function inheritCCClass(ctor, parentCtor) {
        for (const attrName of ['__cid__', '__classname__']) {
          Object.defineProperty(ctor.prototype, attrName, {
            value: parentCtor.prototype[attrName],
            writable: false,
            enumerable: false,
            configurable: true
          });
        }
        for (const staticKey of ['__attrs__', '__props__', '__values__']) {
          ctor[staticKey] = parentCtor[staticKey];
        }
      }
      {
        extendType(jsb.Mat4.prototype, Mat4.prototype, MathType$1.MAT4);
        for (let i = 0; i < 16; i++) {
          const numb = `0${i}`;
          defineAttr(jsb.Mat4.prototype, `m${numb.substring(numb.length - 2)}`, i);
        }
        for (let i = 0; i < 9; i++) {
          const numb = `0${i}`;
          defineAttr(jsb.Mat3.prototype, `m${numb.substring(numb.length - 2)}`, i);
        }
        extendType(jsb.Mat3.prototype, Mat3.prototype, MathType$1.MAT3);
        defineAttr(jsb.Vec2.prototype, 'x', 0);
        defineAttr(jsb.Vec2.prototype, 'y', 1);
        extendType(jsb.Vec2.prototype, Vec2.prototype, MathType$1.VEC2);
        defineAttr(jsb.Vec3.prototype, 'x', 0);
        defineAttr(jsb.Vec3.prototype, 'y', 1);
        defineAttr(jsb.Vec3.prototype, 'z', 2);
        extendType(jsb.Vec3.prototype, Vec3.prototype, MathType$1.VEC3);
        defineAttr(jsb.Vec4.prototype, 'x', 0);
        defineAttr(jsb.Vec4.prototype, 'y', 1);
        defineAttr(jsb.Vec4.prototype, 'z', 2);
        defineAttr(jsb.Vec4.prototype, 'w', 3);
        extendType(jsb.Vec4.prototype, Vec4.prototype, MathType$1.VEC4);
        defineAttr(jsb.Quat.prototype, 'x', 0);
        defineAttr(jsb.Quat.prototype, 'y', 1);
        defineAttr(jsb.Quat.prototype, 'z', 2);
        defineAttr(jsb.Quat.prototype, 'w', 3);
        extendType(jsb.Quat.prototype, Quat.prototype, MathType$1.QUATERNION);
        Object.setPrototypeOf(jsb.Color.prototype, Color$1.prototype);
        Object.defineProperty(jsb.Color.prototype, 'type', {
          configurable: true,
          enumerable: true,
          writable: false,
          value: MathType$1.COLOR
        });
        inheritCCClass(jsb.Vec4, Vec4);
        inheritCCClass(jsb.Vec3, Vec3);
        inheritCCClass(jsb.Vec2, Vec2);
        inheritCCClass(jsb.Mat4, Mat4);
        inheritCCClass(jsb.Mat3, Mat3);
        inheritCCClass(jsb.Color, Color$1);
        inheritCCClass(jsb.Quat, Quat);
      }

      class AffineTransform {
        static identity() {
          return new AffineTransform();
        }
        static clone(affineTransform) {
          return new AffineTransform(affineTransform.a, affineTransform.b, affineTransform.c, affineTransform.d, affineTransform.tx, affineTransform.ty);
        }
        static concat(out, t1, t2) {
          const a = t1.a;
          const b = t1.b;
          const c = t1.c;
          const d = t1.d;
          const tx = t1.tx;
          const ty = t1.ty;
          out.a = a * t2.a + b * t2.c;
          out.b = a * t2.b + b * t2.d;
          out.c = c * t2.a + d * t2.c;
          out.d = c * t2.b + d * t2.d;
          out.tx = tx * t2.a + ty * t2.c + t2.tx;
          out.ty = tx * t2.b + ty * t2.d + t2.ty;
        }
        static invert(out, t) {
          const determinant = 1 / (t.a * t.d - t.b * t.c);
          out.a = determinant * t.d;
          out.b = -determinant * t.b;
          out.c = -determinant * t.c;
          out.d = determinant * t.a;
          out.tx = determinant * (t.c * t.ty - t.d * t.tx);
          out.ty = determinant * (t.b * t.tx - t.a * t.ty);
        }
        static fromMat4(out, mat) {
          out.a = mat.m00;
          out.b = mat.m01;
          out.c = mat.m04;
          out.d = mat.m05;
          out.tx = mat.m12;
          out.ty = mat.m13;
        }
        static transformVec2(out, point, transOrY, t) {
          let x;
          let y;
          if (!t) {
            t = transOrY;
            x = point.x;
            y = point.y;
          } else {
            x = point;
            y = transOrY;
          }
          out.x = t.a * x + t.c * y + t.tx;
          out.y = t.b * x + t.d * y + t.ty;
        }
        static transformSize(out, size, t) {
          out.width = t.a * size.width + t.c * size.height;
          out.height = t.b * size.width + t.d * size.height;
        }
        static transformRect(out, rect, t) {
          const or = rect.x + rect.width;
          const ot = rect.y + rect.height;
          const lbx = t.a * rect.x + t.c * rect.y + t.tx;
          const lby = t.b * rect.x + t.d * rect.y + t.ty;
          const rbx = t.a * or + t.c * rect.y + t.tx;
          const rby = t.b * or + t.d * rect.y + t.ty;
          const ltx = t.a * rect.x + t.c * ot + t.tx;
          const lty = t.b * rect.x + t.d * ot + t.ty;
          const rtx = t.a * or + t.c * ot + t.tx;
          const rty = t.b * or + t.d * ot + t.ty;
          const minX = Math.min(lbx, rbx, ltx, rtx);
          const maxX = Math.max(lbx, rbx, ltx, rtx);
          const minY = Math.min(lby, rby, lty, rty);
          const maxY = Math.max(lby, rby, lty, rty);
          out.x = minX;
          out.y = minY;
          out.width = maxX - minX;
          out.height = maxY - minY;
        }
        static transformObb(out_bl, out_tl, out_tr, out_br, rect, anAffineTransform, flipY = true) {
          const tx = anAffineTransform.a * rect.x + anAffineTransform.c * rect.y + anAffineTransform.tx;
          const ty = anAffineTransform.b * rect.x + anAffineTransform.d * rect.y + anAffineTransform.ty;
          const xa = anAffineTransform.a * rect.width;
          const xb = anAffineTransform.b * rect.width;
          const yc = anAffineTransform.c * rect.height;
          const yd = anAffineTransform.d * rect.height;
          if (flipY) {
            out_tl.x = tx;
            out_tl.y = ty;
            out_tr.x = xa + tx;
            out_tr.y = xb + ty;
            out_bl.x = yc + tx;
            out_bl.y = yd + ty;
            out_br.x = xa + yc + tx;
            out_br.y = xb + yd + ty;
          } else {
            out_bl.x = tx;
            out_bl.y = ty;
            out_br.x = xa + tx;
            out_br.y = xb + ty;
            out_tl.x = yc + tx;
            out_tl.y = yd + ty;
            out_tr.x = xa + yc + tx;
            out_tr.y = xb + yd + ty;
          }
        }
        constructor(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0) {
          this.a = a;
          this.b = b;
          this.c = c;
          this.d = d;
          this.tx = tx;
          this.ty = ty;
        }
      } exports('AffineTransform', AffineTransform);
      legacyCC.AffineTransform = AffineTransform;

      var _class$$;
      class Size$1 extends ValueType {
        static lerp(out, from, to, ratio) {
          out.width = from.width + (to.width - from.width) * ratio;
          out.height = from.height + (to.height - from.height) * ratio;
          return out;
        }
        static equals(a, b) {
          return a.width === b.width && a.height === b.height;
        }
        set x(val) {
          this.width = val;
        }
        get x() {
          return this.width;
        }
        set y(val) {
          this.height = val;
        }
        get y() {
          return this.height;
        }
        constructor(width, height) {
          super();
          if (typeof width === 'object') {
            this.width = width.width;
            this.height = width.height;
          } else {
            this.width = width || 0;
            this.height = height || 0;
          }
        }
        clone() {
          return new Size$1(this.width, this.height);
        }
        set(width, height) {
          if (typeof width === 'object') {
            this.height = width.height;
            this.width = width.width;
          } else {
            this.width = width || 0;
            this.height = height || 0;
          }
          return this;
        }
        equals(other) {
          return this.width === other.width && this.height === other.height;
        }
        lerp(to, ratio) {
          this.width += (to.width - this.width) * ratio;
          this.height += (to.height - this.height) * ratio;
          return this;
        }
        toString() {
          return `(${this.width.toFixed(2)}, ${this.height.toFixed(2)})`;
        }
      } exports('Size', Size$1);
      _class$$ = Size$1;
      Size$1.ZERO = Object.freeze(new _class$$(0, 0));
      Size$1.ONE = Object.freeze(new _class$$(1, 1));
      CCClass.fastDefine('cc.Size', Size$1, {
        width: 0,
        height: 0
      });
      function size(width = 0, height = 0) {
        return new Size$1(width, height);
      }
      legacyCC.size = size;
      legacyCC.Size = Size$1;

      class Rect$1 extends ValueType {
        static fromMinMax(out, v1, v2) {
          const minX = Math.min(v1.x, v2.x);
          const minY = Math.min(v1.y, v2.y);
          const maxX = Math.max(v1.x, v2.x);
          const maxY = Math.max(v1.y, v2.y);
          out.x = minX;
          out.y = minY;
          out.width = maxX - minX;
          out.height = maxY - minY;
          return out;
        }
        static lerp(out, from, to, ratio) {
          const x = from.x;
          const y = from.y;
          const w = from.width;
          const h = from.height;
          out.x = x + (to.x - x) * ratio;
          out.y = y + (to.y - y) * ratio;
          out.width = w + (to.width - w) * ratio;
          out.height = h + (to.height - h) * ratio;
          return out;
        }
        static intersection(out, one, other) {
          const axMin = one.x;
          const ayMin = one.y;
          const axMax = one.x + one.width;
          const ayMax = one.y + one.height;
          const bxMin = other.x;
          const byMin = other.y;
          const bxMax = other.x + other.width;
          const byMax = other.y + other.height;
          out.x = Math.max(axMin, bxMin);
          out.y = Math.max(ayMin, byMin);
          out.width = Math.min(axMax, bxMax) - out.x;
          out.height = Math.min(ayMax, byMax) - out.y;
          return out;
        }
        static union(out, one, other) {
          const x = one.x;
          const y = one.y;
          const w = one.width;
          const h = one.height;
          const bx = other.x;
          const by = other.y;
          const bw = other.width;
          const bh = other.height;
          out.x = Math.min(x, bx);
          out.y = Math.min(y, by);
          out.width = Math.max(x + w, bx + bw) - out.x;
          out.height = Math.max(y + h, by + bh) - out.y;
          return out;
        }
        static equals(a, b) {
          return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;
        }
        get xMin() {
          return this.x;
        }
        set xMin(value) {
          this.width += this.x - value;
          this.x = value;
        }
        get yMin() {
          return this.y;
        }
        set yMin(value) {
          this.height += this.y - value;
          this.y = value;
        }
        get xMax() {
          return this.x + this.width;
        }
        set xMax(value) {
          this.width = value - this.x;
        }
        get yMax() {
          return this.y + this.height;
        }
        set yMax(value) {
          this.height = value - this.y;
        }
        get center() {
          return new Vec2(this.x + this.width * 0.5, this.y + this.height * 0.5);
        }
        set center(value) {
          this.x = value.x - this.width * 0.5;
          this.y = value.y - this.height * 0.5;
        }
        get origin() {
          return new Vec2(this.x, this.y);
        }
        set origin(value) {
          this.x = value.x;
          this.y = value.y;
        }
        get size() {
          return new Size$1(this.width, this.height);
        }
        set size(value) {
          this.width = value.width;
          this.height = value.height;
        }
        set z(val) {
          this.width = val;
        }
        get z() {
          return this.width;
        }
        set w(val) {
          this.height = val;
        }
        get w() {
          return this.height;
        }
        constructor(x, y, width, height) {
          super();
          if (typeof x === 'object') {
            this.x = x.x;
            this.y = x.y;
            this.width = x.width;
            this.height = x.height;
          } else {
            this.x = x || 0;
            this.y = y || 0;
            this.width = width || 0;
            this.height = height || 0;
          }
        }
        clone() {
          return new Rect$1(this.x, this.y, this.width, this.height);
        }
        set(x, y, width, height) {
          if (typeof x === 'object') {
            this.x = x.x;
            this.y = x.y;
            this.width = x.width;
            this.height = x.height;
          } else {
            this.x = x || 0;
            this.y = y || 0;
            this.width = width || 0;
            this.height = height || 0;
          }
          return this;
        }
        equals(other) {
          return this.x === other.x && this.y === other.y && this.width === other.width && this.height === other.height;
        }
        lerp(to, ratio) {
          const x = this.x;
          const y = this.y;
          const w = this.width;
          const h = this.height;
          this.x = x + (to.x - x) * ratio;
          this.y = y + (to.y - y) * ratio;
          this.width = w + (to.width - w) * ratio;
          this.height = h + (to.height - h) * ratio;
          return this;
        }
        toString() {
          return `(${this.x.toFixed(2)}, ${this.y.toFixed(2)}, ${this.width.toFixed(2)}, ${this.height.toFixed(2)})`;
        }
        intersects(other) {
          const maxax = this.x + this.width;
          const maxay = this.y + this.height;
          const maxbx = other.x + other.width;
          const maxby = other.y + other.height;
          return !(maxax < other.x || maxbx < this.x || maxay < other.y || maxby < this.y);
        }
        contains(point) {
          return this.x <= point.x && this.x + this.width >= point.x && this.y <= point.y && this.y + this.height >= point.y;
        }
        containsRect(other) {
          return this.x <= other.x && this.x + this.width >= other.x + other.width && this.y <= other.y && this.y + this.height >= other.y + other.height;
        }
        transformMat4(mat) {
          const ol = this.x;
          const ob = this.y;
          const or = ol + this.width;
          const ot = ob + this.height;
          const lbx = mat.m00 * ol + mat.m04 * ob + mat.m12;
          const lby = mat.m01 * ol + mat.m05 * ob + mat.m13;
          const rbx = mat.m00 * or + mat.m04 * ob + mat.m12;
          const rby = mat.m01 * or + mat.m05 * ob + mat.m13;
          const ltx = mat.m00 * ol + mat.m04 * ot + mat.m12;
          const lty = mat.m01 * ol + mat.m05 * ot + mat.m13;
          const rtx = mat.m00 * or + mat.m04 * ot + mat.m12;
          const rty = mat.m01 * or + mat.m05 * ot + mat.m13;
          const minX = Math.min(lbx, rbx, ltx, rtx);
          const maxX = Math.max(lbx, rbx, ltx, rtx);
          const minY = Math.min(lby, rby, lty, rty);
          const maxY = Math.max(lby, rby, lty, rty);
          this.x = minX;
          this.y = minY;
          this.width = maxX - minX;
          this.height = maxY - minY;
          return this;
        }
        transformMat4ToPoints(mat, out_lb, out_lt, out_rt, out_rb) {
          const ol = this.x;
          const ob = this.y;
          const or = ol + this.width;
          const ot = ob + this.height;
          out_lb.x = mat.m00 * ol + mat.m04 * ob + mat.m12;
          out_lb.y = mat.m01 * ol + mat.m05 * ob + mat.m13;
          out_rb.x = mat.m00 * or + mat.m04 * ob + mat.m12;
          out_rb.y = mat.m01 * or + mat.m05 * ob + mat.m13;
          out_lt.x = mat.m00 * ol + mat.m04 * ot + mat.m12;
          out_lt.y = mat.m01 * ol + mat.m05 * ot + mat.m13;
          out_rt.x = mat.m00 * or + mat.m04 * ot + mat.m12;
          out_rt.y = mat.m01 * or + mat.m05 * ot + mat.m13;
        }
      } exports('Rect', Rect$1);
      CCClass.fastDefine('cc.Rect', Rect$1, {
        x: 0,
        y: 0,
        width: 0,
        height: 0
      });
      legacyCC.Rect = Rect$1;
      function rect(x = 0, y = 0, width = 0, height = 0) {
        return new Rect$1(x, y, width, height);
      }
      legacyCC.rect = rect;

      const MATH_FLOAT_ARRAY = exports('MATH_FLOAT_ARRAY', Float32Array );
      class MathBase extends ValueType {
        static createFloatArray(size) {
          return new MATH_FLOAT_ARRAY(size);
        }
        get array() {
          return this._array;
        }
      } exports('MathBase', MathBase);

      var math = /*#__PURE__*/Object.freeze({
        __proto__: null,
        bits: bits,
        Vec2: Vec2,
        v2: v2$1,
        Vec3: Vec3,
        v3: v3,
        Vec4: Vec4,
        v4: v4,
        Quat: Quat,
        quat: quat,
        Mat3: Mat3,
        Mat4: Mat4,
        mat4: mat4,
        AffineTransform: AffineTransform,
        Size: Size$1,
        size: size,
        Rect: Rect$1,
        rect: rect,
        Color: Color$1,
        color: color,
        preTransforms: preTransforms,
        HALF_PI: HALF_PI,
        TWO_PI: TWO_PI,
        EPSILON: EPSILON$2,
        equals: equals$1,
        approx: approx,
        clamp: clamp$1,
        clamp01: clamp01,
        lerp: lerp,
        toRadian: toRadian,
        toDegree: toDegree,
        random: random,
        setRandGenerator: setRandGenerator,
        randomRange: randomRange,
        randomRangeInt: randomRangeInt,
        pseudoRandom: pseudoRandom,
        pseudoRandomRange: pseudoRandomRange,
        pseudoRandomRangeInt: pseudoRandomRangeInt,
        nextPow2: nextPow2,
        repeat: repeat$1,
        pingPong: pingPong,
        inverseLerp: inverseLerp,
        absMaxComponent: absMaxComponent,
        absMax: absMax,
        enumerableProps: enumerableProps,
        floatToHalf: floatToHalf,
        halfToFloat: halfToFloat,
        MATH_FLOAT_ARRAY: MATH_FLOAT_ARRAY,
        MathBase: MathBase
      });
      exports('math', math);

      const X = new Vec3();
      const Y = new Vec3();
      const Z = new Vec3();
      const d = new Vec3();
      const min$2 = new Vec3();
      const max$3 = new Vec3();
      const u = new Array(3);
      const e = new Array(3);
      function point_plane(point, plane_) {
        return Vec3.dot(plane_.n, point) - plane_.d;
      }
      function pt_point_plane(out, point, plane_) {
        const t = point_plane(point, plane_);
        return Vec3.subtract(out, point, Vec3.multiplyScalar(out, plane_.n, t));
      }
      function pt_point_aabb(out, point, aabb_) {
        Vec3.copy(out, point);
        Vec3.subtract(min$2, aabb_.center, aabb_.halfExtents);
        Vec3.add(max$3, aabb_.center, aabb_.halfExtents);
        out.x = out.x < min$2.x ? min$2.x : out.x;
        out.y = out.y < min$2.y ? min$2.y : out.y;
        out.z = out.z < min$2.z ? min$2.z : out.z;
        out.x = out.x > max$3.x ? max$3.x : out.x;
        out.y = out.y > max$3.y ? max$3.y : out.y;
        out.z = out.z > max$3.z ? max$3.z : out.z;
        return out;
      }
      function pt_point_obb(out, point, obb_) {
        Vec3.set(X, obb_.orientation.m00, obb_.orientation.m01, obb_.orientation.m02);
        Vec3.set(Y, obb_.orientation.m03, obb_.orientation.m04, obb_.orientation.m05);
        Vec3.set(Z, obb_.orientation.m06, obb_.orientation.m07, obb_.orientation.m08);
        u[0] = X;
        u[1] = Y;
        u[2] = Z;
        e[0] = obb_.halfExtents.x;
        e[1] = obb_.halfExtents.y;
        e[2] = obb_.halfExtents.z;
        Vec3.subtract(d, point, obb_.center);
        Vec3.set(out, obb_.center.x, obb_.center.y, obb_.center.z);
        for (let i = 0; i < 3; i++) {
          let dist = Vec3.dot(d, u[i]);
          if (dist > e[i]) {
            dist = e[i];
          }
          if (dist < -e[i]) {
            dist = -e[i];
          }
          out.x += dist * u[i].x;
          out.y += dist * u[i].y;
          out.z += dist * u[i].z;
        }
        return out;
      }
      function pt_point_line(out, point, linePointA, linePointB) {
        Vec3.subtract(X, linePointA, linePointB);
        const dir = X.clone();
        const dirSquaredLength = Vec3.lengthSqr(dir);
        if (dirSquaredLength === 0) {
          Vec3.copy(out, linePointA);
        } else {
          Vec3.subtract(X, point, linePointA);
          const t = Vec3.dot(X, dir) / dirSquaredLength;
          if (t < 0) {
            Vec3.copy(out, linePointA);
          } else if (t > 1) {
            Vec3.copy(out, linePointB);
          } else {
            Vec3.scaleAndAdd(out, linePointA, dir, t);
          }
        }
      }

      var distance = /*#__PURE__*/Object.freeze({
        __proto__: null,
        point_plane: point_plane,
        pt_point_plane: pt_point_plane,
        pt_point_aabb: pt_point_aabb,
        pt_point_obb: pt_point_obb,
        pt_point_line: pt_point_line
      });

      var enums = {
        SHAPE_RAY: 1 << 0,
        SHAPE_LINE: 1 << 1,
        SHAPE_SPHERE: 1 << 2,
        SHAPE_AABB: 1 << 3,
        SHAPE_OBB: 1 << 4,
        SHAPE_PLANE: 1 << 5,
        SHAPE_TRIANGLE: 1 << 6,
        SHAPE_FRUSTUM: 1 << 7,
        SHAPE_FRUSTUM_ACCURATE: 1 << 8,
        SHAPE_CAPSULE: 1 << 9,
        SHAPE_SPLINE: 1 << 10
      };

      class Line {
        static create(sx, sy, sz, ex, ey, ez) {
          return new Line(sx, sy, sz, ex, ey, ez);
        }
        static clone(a) {
          return new Line(a.s.x, a.s.y, a.s.z, a.e.x, a.e.y, a.e.z);
        }
        static copy(out, a) {
          Vec3.copy(out.s, a.s);
          Vec3.copy(out.e, a.e);
          return out;
        }
        static fromPoints(out, start, end) {
          Vec3.copy(out.s, start);
          Vec3.copy(out.e, end);
          return out;
        }
        static set(out, sx, sy, sz, ex, ey, ez) {
          out.s.x = sx;
          out.s.y = sy;
          out.s.z = sz;
          out.e.x = ex;
          out.e.y = ey;
          out.e.z = ez;
          return out;
        }
        static len(a) {
          return Vec3.distance(a.s, a.e);
        }
        get type() {
          return this._type;
        }
        constructor(sx = 0, sy = 0, sz = 0, ex = 0, ey = 0, ez = -1) {
          this.s = void 0;
          this.e = void 0;
          this._type = void 0;
          this._type = enums.SHAPE_LINE;
          this.s = new Vec3(sx, sy, sz);
          this.e = new Vec3(ex, ey, ez);
        }
        length() {
          return Vec3.distance(this.s, this.e);
        }
      }

      class Ray {
        static create(ox = 0, oy = 0, oz = 0, dx = 0, dy = 0, dz = 1) {
          return new Ray(ox, oy, oz, dx, dy, dz);
        }
        static clone(a) {
          return new Ray(a.o.x, a.o.y, a.o.z, a.d.x, a.d.y, a.d.z);
        }
        static copy(out, a) {
          Vec3.copy(out.o, a.o);
          Vec3.copy(out.d, a.d);
          return out;
        }
        static fromPoints(out, origin, target) {
          Vec3.copy(out.o, origin);
          Vec3.normalize(out.d, Vec3.subtract(out.d, target, origin));
          return out;
        }
        static set(out, ox, oy, oz, dx, dy, dz) {
          out.o.x = ox;
          out.o.y = oy;
          out.o.z = oz;
          out.d.x = dx;
          out.d.y = dy;
          out.d.z = dz;
          return out;
        }
        get type() {
          return this._type;
        }
        constructor(ox = 0, oy = 0, oz = 0, dx = 0, dy = 0, dz = -1) {
          this.o = void 0;
          this.d = void 0;
          this._type = void 0;
          this._type = enums.SHAPE_RAY;
          this.o = new Vec3(ox, oy, oz);
          this.d = new Vec3(dx, dy, dz);
        }
        computeHit(out, distance) {
          Vec3.normalize(out, this.d);
          Vec3.scaleAndAdd(out, this.o, out, distance);
        }
      }

      const _v3_tmp$2 = new Vec3();
      const _offset = new Vec3();
      const _min = new Vec3();
      const _max = new Vec3();
      function maxComponent(v) {
        return Math.max(Math.max(v.x, v.y), v.z);
      }
      class Sphere {
        static create(cx, cy, cz, r) {
          return new Sphere(cx, cy, cz, r);
        }
        static clone(p) {
          return new Sphere(p.center.x, p.center.y, p.center.z, p.radius);
        }
        static copy(out, p) {
          Vec3.copy(out.center, p.center);
          out.radius = p.radius;
          return out;
        }
        static fromPoints(out, minPos, maxPos) {
          Vec3.multiplyScalar(out.center, Vec3.add(_v3_tmp$2, minPos, maxPos), 0.5);
          out.radius = Vec3.subtract(_v3_tmp$2, maxPos, minPos).length() * 0.5;
          return out;
        }
        static set(out, cx, cy, cz, r) {
          out.center.x = cx;
          out.center.y = cy;
          out.center.z = cz;
          out.radius = r;
          return out;
        }
        get center() {
          return this._center;
        }
        set center(val) {
          this._center = val;
        }
        get radius() {
          return this._radius;
        }
        set radius(val) {
          this._radius = val;
        }
        get type() {
          return this._type;
        }
        constructor(cx = 0, cy = 0, cz = 0, r = 1) {
          this._center = new Vec3(0, 0, 0);
          this._radius = 0;
          this._type = void 0;
          this._type = enums.SHAPE_SPHERE;
          this._center = new Vec3(cx, cy, cz);
          this._radius = r;
        }
        destroy() {}
        clone() {
          return Sphere.clone(this);
        }
        copy(a) {
          return Sphere.copy(this, a);
        }
        getBoundary(minPos, maxPos) {
          Vec3.set(minPos, this.center.x - this.radius, this.center.y - this.radius, this.center.z - this.radius);
          Vec3.set(maxPos, this.center.x + this.radius, this.center.y + this.radius, this.center.z + this.radius);
        }
        transform(m, pos, rot, scale, out) {
          Vec3.transformMat4(out.center, this.center, m);
          out.radius = this.radius * maxComponent(scale);
        }
        translateAndRotate(m, rot, out) {
          Vec3.transformMat4(out.center, this.center, m);
        }
        setScale(scale, out) {
          out.radius = this.radius * maxComponent(scale);
        }
        mergePoint(point) {
          if (this.radius < 0.0) {
            this.center.set(point);
            this.radius = 0.0;
          }
          Vec3.subtract(_offset, point, this.center);
          const dist = _offset.length();
          if (dist > this.radius) {
            const half = (dist - this.radius) * 0.5;
            this.radius += half;
            Vec3.multiplyScalar(_offset, _offset, half / dist);
            Vec3.add(this.center, this.center, _offset);
          }
        }
        mergePoints(points) {
          const length = points.length;
          if (length < 1) return;
          this.radius = -1.0;
          for (let i = 0; i < length; i++) {
            this.mergePoint(points[i]);
          }
        }
        mergeAABB(a) {
          a.getBoundary(_min, _max);
          this.mergePoint(_min);
          this.mergePoint(_max);
        }
      }

      const rayPlane = function () {
        return function (ray, plane) {
          const denom = Vec3.dot(ray.d, plane.n);
          if (Math.abs(denom) < Number.EPSILON) {
            return 0;
          }
          const d = point_plane(ray.o, plane);
          const t = -d / denom;
          if (t < 0) {
            return 0;
          }
          return t;
        };
      }();
      const rayTriangle = function () {
        const ab = new Vec3(0, 0, 0);
        const ac = new Vec3(0, 0, 0);
        const pvec = new Vec3(0, 0, 0);
        const tvec = new Vec3(0, 0, 0);
        const qvec = new Vec3(0, 0, 0);
        return function (ray, triangle, doubleSided) {
          Vec3.subtract(ab, triangle.b, triangle.a);
          Vec3.subtract(ac, triangle.c, triangle.a);
          Vec3.cross(pvec, ray.d, ac);
          const det = Vec3.dot(ab, pvec);
          if (det < Number.EPSILON && (!doubleSided || det > -Number.EPSILON)) {
            return 0;
          }
          const inv_det = 1 / det;
          Vec3.subtract(tvec, ray.o, triangle.a);
          const u = Vec3.dot(tvec, pvec) * inv_det;
          if (u < 0 || u > 1) {
            return 0;
          }
          Vec3.cross(qvec, tvec, ab);
          const v = Vec3.dot(ray.d, qvec) * inv_det;
          if (v < 0 || u + v > 1) {
            return 0;
          }
          const t = Vec3.dot(ac, qvec) * inv_det;
          return t < 0 ? 0 : t;
        };
      }();
      const raySphere = function () {
        const e = new Vec3(0, 0, 0);
        return function (ray, sphere) {
          const r = sphere.radius;
          const c = sphere.center;
          const o = ray.o;
          const d = ray.d;
          const rSq = r * r;
          Vec3.subtract(e, c, o);
          const eSq = e.lengthSqr();
          const aLength = Vec3.dot(e, d);
          const fSq = rSq - (eSq - aLength * aLength);
          if (fSq < 0) {
            return 0;
          }
          const f = Math.sqrt(fSq);
          const t = eSq < rSq ? aLength + f : aLength - f;
          if (t < 0) {
            return 0;
          }
          return t;
        };
      }();
      const rayAABB = function () {
        const min = new Vec3();
        const max = new Vec3();
        return function (ray, aabb) {
          Vec3.subtract(min, aabb.center, aabb.halfExtents);
          Vec3.add(max, aabb.center, aabb.halfExtents);
          return rayAABB2$1(ray, min, max);
        };
      }();
      function rayAABB2$1(ray, min, max) {
        const o = ray.o;
        const d = ray.d;
        const ix = 1 / d.x;
        const iy = 1 / d.y;
        const iz = 1 / d.z;
        const t1 = (min.x - o.x) * ix;
        const t2 = (max.x - o.x) * ix;
        const t3 = (min.y - o.y) * iy;
        const t4 = (max.y - o.y) * iy;
        const t5 = (min.z - o.z) * iz;
        const t6 = (max.z - o.z) * iz;
        const tmin = Math.max(Math.max(Math.min(t1, t2), Math.min(t3, t4)), Math.min(t5, t6));
        const tmax = Math.min(Math.min(Math.max(t1, t2), Math.max(t3, t4)), Math.max(t5, t6));
        if (tmax < 0 || tmin > tmax) {
          return 0;
        }
        return tmin > 0 ? tmin : tmax;
      }
      const rayOBB = function () {
        let center = new Vec3();
        let o = new Vec3();
        let d = new Vec3();
        const X = new Vec3();
        const Y = new Vec3();
        const Z = new Vec3();
        const p = new Vec3();
        const size = new Array(3);
        const f = new Array(3);
        const e = new Array(3);
        const t = new Array(6);
        return function (ray, obb) {
          size[0] = obb.halfExtents.x;
          size[1] = obb.halfExtents.y;
          size[2] = obb.halfExtents.z;
          center = obb.center;
          o = ray.o;
          d = ray.d;
          Vec3.set(X, obb.orientation.m00, obb.orientation.m01, obb.orientation.m02);
          Vec3.set(Y, obb.orientation.m03, obb.orientation.m04, obb.orientation.m05);
          Vec3.set(Z, obb.orientation.m06, obb.orientation.m07, obb.orientation.m08);
          Vec3.subtract(p, center, o);
          f[0] = Vec3.dot(X, d);
          f[1] = Vec3.dot(Y, d);
          f[2] = Vec3.dot(Z, d);
          e[0] = Vec3.dot(X, p);
          e[1] = Vec3.dot(Y, p);
          e[2] = Vec3.dot(Z, p);
          for (let i = 0; i < 3; ++i) {
            if (f[i] === 0) {
              if (-e[i] - size[i] > 0 || -e[i] + size[i] < 0) {
                return 0;
              }
              f[i] = 0.0000001;
            }
            t[i * 2 + 0] = (e[i] + size[i]) / f[i];
            t[i * 2 + 1] = (e[i] - size[i]) / f[i];
          }
          const tmin = Math.max(Math.max(Math.min(t[0], t[1]), Math.min(t[2], t[3])), Math.min(t[4], t[5]));
          const tmax = Math.min(Math.min(Math.max(t[0], t[1]), Math.max(t[2], t[3])), Math.max(t[4], t[5]));
          if (tmax < 0 || tmin > tmax) {
            return 0;
          }
          return tmin > 0 ? tmin : tmax;
        };
      }();
      const rayCapsule = function () {
        const v3_0 = new Vec3();
        const v3_1 = new Vec3();
        const v3_2 = new Vec3();
        const v3_3 = new Vec3();
        const v3_4 = new Vec3();
        const v3_5 = new Vec3();
        const v3_6 = new Vec3();
        const sphere_0 = new Sphere();
        return function (ray, capsule) {
          const A = capsule.ellipseCenter0;
          const B = capsule.ellipseCenter1;
          const BA = Vec3.subtract(v3_1, B, A);
          if (BA.length() < EPSILON$2) {
            sphere_0.radius = capsule.radius;
            sphere_0.center.set(capsule.ellipseCenter0);
            return intersect.raySphere(ray, sphere_0);
          }
          const O = ray.o;
          const OA = Vec3.subtract(v3_2, O, A);
          const vRayNorm = Vec3.normalize(v3_0, ray.d);
          const VxBA = Vec3.cross(v3_3, vRayNorm, BA);
          const a = VxBA.lengthSqr();
          if (a === 0) {
            sphere_0.radius = capsule.radius;
            const BO = Vec3.subtract(v3_4, B, O);
            if (OA.lengthSqr() < BO.lengthSqr()) {
              sphere_0.center.set(A);
            } else {
              sphere_0.center.set(B);
            }
            return intersect.raySphere(ray, sphere_0);
          }
          const OAxBA = Vec3.cross(v3_4, OA, BA);
          const ab2 = BA.lengthSqr();
          const b = 2 * Vec3.dot(VxBA, OAxBA);
          const radiusSqr = capsule.radius * capsule.radius;
          const c = OAxBA.lengthSqr() - radiusSqr * ab2;
          const d = b * b - 4 * a * c;
          if (d < 0) {
            return 0;
          }
          const t = (-b - Math.sqrt(d)) / (2 * a);
          if (t < 0) {
            sphere_0.radius = capsule.radius;
            const BO = Vec3.subtract(v3_5, B, O);
            if (OA.lengthSqr() < BO.lengthSqr()) {
              sphere_0.center.set(capsule.ellipseCenter0);
            } else {
              sphere_0.center.set(capsule.ellipseCenter1);
            }
            return intersect.raySphere(ray, sphere_0);
          } else {
            const iPos = Vec3.scaleAndAdd(v3_5, ray.o, vRayNorm, t);
            const iPosLen = Vec3.subtract(v3_6, iPos, A);
            const tLimit = Vec3.dot(iPosLen, BA) / ab2;
            if (tLimit >= 0 && tLimit <= 1) {
              return t;
            } else if (tLimit < 0) {
              sphere_0.radius = capsule.radius;
              sphere_0.center.set(capsule.ellipseCenter0);
              return intersect.raySphere(ray, sphere_0);
            } else if (tLimit > 1) {
              sphere_0.radius = capsule.radius;
              sphere_0.center.set(capsule.ellipseCenter1);
              return intersect.raySphere(ray, sphere_0);
            } else {
              return 0;
            }
          }
        };
      }();
      const linePlane = function () {
        const ab = new Vec3(0, 0, 0);
        return function (line, plane) {
          Vec3.subtract(ab, line.e, line.s);
          const t = -point_plane(line.s, plane) / Vec3.dot(ab, plane.n);
          if (t < 0 || t > 1) {
            return 0;
          }
          return t;
        };
      }();
      const lineTriangle = function () {
        const ab = new Vec3(0, 0, 0);
        const ac = new Vec3(0, 0, 0);
        const qp = new Vec3(0, 0, 0);
        const ap = new Vec3(0, 0, 0);
        const n = new Vec3(0, 0, 0);
        const e = new Vec3(0, 0, 0);
        return function (line, triangle, outPt) {
          Vec3.subtract(ab, triangle.b, triangle.a);
          Vec3.subtract(ac, triangle.c, triangle.a);
          Vec3.subtract(qp, line.s, line.e);
          Vec3.cross(n, ab, ac);
          const det = Vec3.dot(qp, n);
          if (det <= 0.0) {
            return 0;
          }
          Vec3.subtract(ap, line.s, triangle.a);
          const t = Vec3.dot(ap, n);
          if (t < 0 || t > det) {
            return 0;
          }
          Vec3.cross(e, qp, ap);
          let v = Vec3.dot(ac, e);
          if (v < 0 || v > det) {
            return 0;
          }
          let w = -Vec3.dot(ab, e);
          if (w < 0.0 || v + w > det) {
            return 0;
          }
          if (outPt) {
            const invDet = 1.0 / det;
            v *= invDet;
            w *= invDet;
            const u = 1.0 - v - w;
            Vec3.set(outPt, triangle.a.x * u + triangle.b.x * v + triangle.c.x * w, triangle.a.y * u + triangle.b.y * v + triangle.c.y * w, triangle.a.z * u + triangle.b.z * v + triangle.c.z * w);
          }
          return 1;
        };
      }();
      const r_t = new Ray();
      function lineAABB(line, aabb) {
        r_t.o.set(line.s);
        Vec3.subtract(r_t.d, line.e, line.s);
        r_t.d.normalize();
        const min = rayAABB(r_t, aabb);
        const len = line.length();
        if (min <= len) {
          return min;
        } else {
          return 0;
        }
      }
      function lineOBB(line, obb) {
        r_t.o.set(line.s);
        Vec3.subtract(r_t.d, line.e, line.s);
        r_t.d.normalize();
        const min = rayOBB(r_t, obb);
        const len = line.length();
        if (min <= len) {
          return min;
        } else {
          return 0;
        }
      }
      function lineSphere(line, sphere) {
        r_t.o.set(line.s);
        Vec3.subtract(r_t.d, line.e, line.s);
        r_t.d.normalize();
        const min = raySphere(r_t, sphere);
        const len = line.length();
        if (min <= len) {
          return min;
        } else {
          return 0;
        }
      }
      const aabbWithAABB = function () {
        const aMin = new Vec3();
        const aMax = new Vec3();
        const bMin = new Vec3();
        const bMax = new Vec3();
        return function (aabb1, aabb2) {
          Vec3.subtract(aMin, aabb1.center, aabb1.halfExtents);
          Vec3.add(aMax, aabb1.center, aabb1.halfExtents);
          Vec3.subtract(bMin, aabb2.center, aabb2.halfExtents);
          Vec3.add(bMax, aabb2.center, aabb2.halfExtents);
          return aMin.x <= bMax.x && aMax.x >= bMin.x && aMin.y <= bMax.y && aMax.y >= bMin.y && aMin.z <= bMax.z && aMax.z >= bMin.z;
        };
      }();
      function getAABBVertices(min, max, out) {
        Vec3.set(out[0], min.x, max.y, max.z);
        Vec3.set(out[1], min.x, max.y, min.z);
        Vec3.set(out[2], min.x, min.y, max.z);
        Vec3.set(out[3], min.x, min.y, min.z);
        Vec3.set(out[4], max.x, max.y, max.z);
        Vec3.set(out[5], max.x, max.y, min.z);
        Vec3.set(out[6], max.x, min.y, max.z);
        Vec3.set(out[7], max.x, min.y, min.z);
      }
      function getOBBVertices(c, e, a1, a2, a3, out) {
        Vec3.set(out[0], c.x + a1.x * e.x + a2.x * e.y + a3.x * e.z, c.y + a1.y * e.x + a2.y * e.y + a3.y * e.z, c.z + a1.z * e.x + a2.z * e.y + a3.z * e.z);
        Vec3.set(out[1], c.x - a1.x * e.x + a2.x * e.y + a3.x * e.z, c.y - a1.y * e.x + a2.y * e.y + a3.y * e.z, c.z - a1.z * e.x + a2.z * e.y + a3.z * e.z);
        Vec3.set(out[2], c.x + a1.x * e.x - a2.x * e.y + a3.x * e.z, c.y + a1.y * e.x - a2.y * e.y + a3.y * e.z, c.z + a1.z * e.x - a2.z * e.y + a3.z * e.z);
        Vec3.set(out[3], c.x + a1.x * e.x + a2.x * e.y - a3.x * e.z, c.y + a1.y * e.x + a2.y * e.y - a3.y * e.z, c.z + a1.z * e.x + a2.z * e.y - a3.z * e.z);
        Vec3.set(out[4], c.x - a1.x * e.x - a2.x * e.y - a3.x * e.z, c.y - a1.y * e.x - a2.y * e.y - a3.y * e.z, c.z - a1.z * e.x - a2.z * e.y - a3.z * e.z);
        Vec3.set(out[5], c.x + a1.x * e.x - a2.x * e.y - a3.x * e.z, c.y + a1.y * e.x - a2.y * e.y - a3.y * e.z, c.z + a1.z * e.x - a2.z * e.y - a3.z * e.z);
        Vec3.set(out[6], c.x - a1.x * e.x + a2.x * e.y - a3.x * e.z, c.y - a1.y * e.x + a2.y * e.y - a3.y * e.z, c.z - a1.z * e.x + a2.z * e.y - a3.z * e.z);
        Vec3.set(out[7], c.x - a1.x * e.x - a2.x * e.y + a3.x * e.z, c.y - a1.y * e.x - a2.y * e.y + a3.y * e.z, c.z - a1.z * e.x - a2.z * e.y + a3.z * e.z);
      }
      function getInterval(vertices, axis) {
        let min = Vec3.dot(axis, vertices[0]);
        let max = min;
        for (let i = 1; i < 8; ++i) {
          const projection = Vec3.dot(axis, vertices[i]);
          min = projection < min ? projection : min;
          max = projection > max ? projection : max;
        }
        return [min, max];
      }
      const aabbWithOBB = function () {
        const test = new Array(15);
        for (let i = 0; i < 15; i++) {
          test[i] = new Vec3(0, 0, 0);
        }
        const vertices = new Array(8);
        const vertices2 = new Array(8);
        for (let i = 0; i < 8; i++) {
          vertices[i] = new Vec3(0, 0, 0);
          vertices2[i] = new Vec3(0, 0, 0);
        }
        const min = new Vec3();
        const max = new Vec3();
        return function (aabb, obb) {
          Vec3.set(test[0], 1, 0, 0);
          Vec3.set(test[1], 0, 1, 0);
          Vec3.set(test[2], 0, 0, 1);
          Vec3.set(test[3], obb.orientation.m00, obb.orientation.m01, obb.orientation.m02);
          Vec3.set(test[4], obb.orientation.m03, obb.orientation.m04, obb.orientation.m05);
          Vec3.set(test[5], obb.orientation.m06, obb.orientation.m07, obb.orientation.m08);
          for (let i = 0; i < 3; ++i) {
            Vec3.cross(test[6 + i * 3 + 0], test[i], test[3]);
            Vec3.cross(test[6 + i * 3 + 1], test[i], test[4]);
            Vec3.cross(test[6 + i * 3 + 1], test[i], test[5]);
          }
          Vec3.subtract(min, aabb.center, aabb.halfExtents);
          Vec3.add(max, aabb.center, aabb.halfExtents);
          getAABBVertices(min, max, vertices);
          getOBBVertices(obb.center, obb.halfExtents, test[3], test[4], test[5], vertices2);
          for (let j = 0; j < 15; ++j) {
            const a = getInterval(vertices, test[j]);
            const b = getInterval(vertices2, test[j]);
            if (b[0] > a[1] || a[0] > b[1]) {
              return 0;
            }
          }
          return 1;
        };
      }();
      const aabbPlane = function (aabb, plane) {
        const r = aabb.halfExtents.x * Math.abs(plane.n.x) + aabb.halfExtents.y * Math.abs(plane.n.y) + aabb.halfExtents.z * Math.abs(plane.n.z);
        const dot = Vec3.dot(plane.n, aabb.center);
        if (dot + r < plane.d) {
          return -1;
        } else if (dot - r > plane.d) {
          return 0;
        }
        return 1;
      };
      const aabbFrustum = function (aabb, frustum) {
        for (let i = 0; i < frustum.planes.length; i++) {
          if (aabbPlane(aabb, frustum.planes[i]) === -1) {
            return 0;
          }
        }
        return 1;
      };
      const aabbFrustumCompletelyInside = function (aabb, frustum) {
        for (let i = 0; i < frustum.planes.length; i++) {
          if (aabbPlane(aabb, frustum.planes[i]) !== 0) {
            return 0;
          }
        }
        return 1;
      };
      const aabbFrustumAccurate = function () {
        const tmp = new Array(8);
        let out1 = 0;
        let out2 = 0;
        for (let i = 0; i < tmp.length; i++) {
          tmp[i] = new Vec3(0, 0, 0);
        }
        return function (aabb, frustum) {
          let result = 0;
          let intersects = false;
          for (let i = 0; i < frustum.planes.length; i++) {
            result = aabbPlane(aabb, frustum.planes[i]);
            if (result === -1) return 0;else if (result === 1) {
              intersects = true;
            }
          }
          if (!intersects) {
            return 1;
          }
          for (let i = 0; i < frustum.vertices.length; i++) {
            Vec3.subtract(tmp[i], frustum.vertices[i], aabb.center);
          }
          out1 = 0, out2 = 0;
          for (let i = 0; i < frustum.vertices.length; i++) {
            if (tmp[i].x > aabb.halfExtents.x) {
              out1++;
            } else if (tmp[i].x < -aabb.halfExtents.x) {
              out2++;
            }
          }
          if (out1 === frustum.vertices.length || out2 === frustum.vertices.length) {
            return 0;
          }
          out1 = 0;
          out2 = 0;
          for (let i = 0; i < frustum.vertices.length; i++) {
            if (tmp[i].y > aabb.halfExtents.y) {
              out1++;
            } else if (tmp[i].y < -aabb.halfExtents.y) {
              out2++;
            }
          }
          if (out1 === frustum.vertices.length || out2 === frustum.vertices.length) {
            return 0;
          }
          out1 = 0;
          out2 = 0;
          for (let i = 0; i < frustum.vertices.length; i++) {
            if (tmp[i].z > aabb.halfExtents.z) {
              out1++;
            } else if (tmp[i].z < -aabb.halfExtents.z) {
              out2++;
            }
          }
          if (out1 === frustum.vertices.length || out2 === frustum.vertices.length) {
            return 0;
          }
          return 1;
        };
      }();
      const obbPoint = function () {
        const tmp = new Vec3(0, 0, 0);
        const m3 = new Mat3();
        const lessThan = function (a, b) {
          return Math.abs(a.x) < b.x && Math.abs(a.y) < b.y && Math.abs(a.z) < b.z;
        };
        return function (obb, point) {
          Vec3.subtract(tmp, point, obb.center);
          Vec3.transformMat3(tmp, tmp, Mat3.transpose(m3, obb.orientation));
          return lessThan(tmp, obb.halfExtents);
        };
      }();
      const obbPlane = function () {
        const absDot = function (n, x, y, z) {
          return Math.abs(n.x * x + n.y * y + n.z * z);
        };
        return function (obb, plane) {
          const r = obb.halfExtents.x * absDot(plane.n, obb.orientation.m00, obb.orientation.m01, obb.orientation.m02) + obb.halfExtents.y * absDot(plane.n, obb.orientation.m03, obb.orientation.m04, obb.orientation.m05) + obb.halfExtents.z * absDot(plane.n, obb.orientation.m06, obb.orientation.m07, obb.orientation.m08);
          const dot = Vec3.dot(plane.n, obb.center);
          if (dot + r < plane.d) {
            return -1;
          } else if (dot - r > plane.d) {
            return 0;
          }
          return 1;
        };
      }();
      const obbFrustum = function (obb, frustum) {
        for (let i = 0; i < frustum.planes.length; i++) {
          if (obbPlane(obb, frustum.planes[i]) === -1) {
            return 0;
          }
        }
        return 1;
      };
      const obbFrustumAccurate = function () {
        const tmp = new Array(8);
        let dist = 0;
        let out1 = 0;
        let out2 = 0;
        for (let i = 0; i < tmp.length; i++) {
          tmp[i] = new Vec3(0, 0, 0);
        }
        const dot = function (n, x, y, z) {
          return n.x * x + n.y * y + n.z * z;
        };
        return function (obb, frustum) {
          let result = 0;
          let intersects = false;
          for (let i = 0; i < frustum.planes.length; i++) {
            result = obbPlane(obb, frustum.planes[i]);
            if (result === -1) return 0;else if (result === 1) {
              intersects = true;
            }
          }
          if (!intersects) {
            return 1;
          }
          for (let i = 0; i < frustum.vertices.length; i++) {
            Vec3.subtract(tmp[i], frustum.vertices[i], obb.center);
          }
          out1 = 0, out2 = 0;
          for (let i = 0; i < frustum.vertices.length; i++) {
            dist = dot(tmp[i], obb.orientation.m00, obb.orientation.m01, obb.orientation.m02);
            if (dist > obb.halfExtents.x) {
              out1++;
            } else if (dist < -obb.halfExtents.x) {
              out2++;
            }
          }
          if (out1 === frustum.vertices.length || out2 === frustum.vertices.length) {
            return 0;
          }
          out1 = 0;
          out2 = 0;
          for (let i = 0; i < frustum.vertices.length; i++) {
            dist = dot(tmp[i], obb.orientation.m03, obb.orientation.m04, obb.orientation.m05);
            if (dist > obb.halfExtents.y) {
              out1++;
            } else if (dist < -obb.halfExtents.y) {
              out2++;
            }
          }
          if (out1 === frustum.vertices.length || out2 === frustum.vertices.length) {
            return 0;
          }
          out1 = 0;
          out2 = 0;
          for (let i = 0; i < frustum.vertices.length; i++) {
            dist = dot(tmp[i], obb.orientation.m06, obb.orientation.m07, obb.orientation.m08);
            if (dist > obb.halfExtents.z) {
              out1++;
            } else if (dist < -obb.halfExtents.z) {
              out2++;
            }
          }
          if (out1 === frustum.vertices.length || out2 === frustum.vertices.length) {
            return 0;
          }
          return 1;
        };
      }();
      const obbWithOBB = function () {
        const test = new Array(15);
        for (let i = 0; i < 15; i++) {
          test[i] = new Vec3(0, 0, 0);
        }
        const vertices = new Array(8);
        const vertices2 = new Array(8);
        for (let i = 0; i < 8; i++) {
          vertices[i] = new Vec3(0, 0, 0);
          vertices2[i] = new Vec3(0, 0, 0);
        }
        return function (obb1, obb2) {
          Vec3.set(test[0], obb1.orientation.m00, obb1.orientation.m01, obb1.orientation.m02);
          Vec3.set(test[1], obb1.orientation.m03, obb1.orientation.m04, obb1.orientation.m05);
          Vec3.set(test[2], obb1.orientation.m06, obb1.orientation.m07, obb1.orientation.m08);
          Vec3.set(test[3], obb2.orientation.m00, obb2.orientation.m01, obb2.orientation.m02);
          Vec3.set(test[4], obb2.orientation.m03, obb2.orientation.m04, obb2.orientation.m05);
          Vec3.set(test[5], obb2.orientation.m06, obb2.orientation.m07, obb2.orientation.m08);
          for (let i = 0; i < 3; ++i) {
            Vec3.cross(test[6 + i * 3 + 0], test[i], test[3]);
            Vec3.cross(test[6 + i * 3 + 1], test[i], test[4]);
            Vec3.cross(test[6 + i * 3 + 2], test[i], test[5]);
          }
          getOBBVertices(obb1.center, obb1.halfExtents, test[0], test[1], test[2], vertices);
          getOBBVertices(obb2.center, obb2.halfExtents, test[3], test[4], test[5], vertices2);
          for (let i = 0; i < 15; ++i) {
            const a = getInterval(vertices, test[i]);
            const b = getInterval(vertices2, test[i]);
            if (b[0] > a[1] || a[0] > b[1]) {
              return 0;
            }
          }
          return 1;
        };
      }();
      const obbCapsule = function () {
        const sphere_0 = new Sphere();
        const v3_0 = new Vec3();
        const v3_1 = new Vec3();
        const v3_2 = new Vec3();
        const v3_verts8 = new Array(8);
        for (let i = 0; i < 8; i++) {
          v3_verts8[i] = new Vec3();
        }
        const v3_axis8 = new Array(8);
        for (let i = 0; i < 8; i++) {
          v3_axis8[i] = new Vec3();
        }
        return function (obb, capsule) {
          const h = Vec3.squaredDistance(capsule.ellipseCenter0, capsule.ellipseCenter1);
          if (h === 0) {
            sphere_0.radius = capsule.radius;
            sphere_0.center.set(capsule.ellipseCenter0);
            return intersect.sphereOBB(sphere_0, obb);
          } else {
            v3_0.x = obb.orientation.m00;
            v3_0.y = obb.orientation.m01;
            v3_0.z = obb.orientation.m02;
            v3_1.x = obb.orientation.m03;
            v3_1.y = obb.orientation.m04;
            v3_1.z = obb.orientation.m05;
            v3_2.x = obb.orientation.m06;
            v3_2.y = obb.orientation.m07;
            v3_2.z = obb.orientation.m08;
            getOBBVertices(obb.center, obb.halfExtents, v3_0, v3_1, v3_2, v3_verts8);
            const axes = v3_axis8;
            const a0 = Vec3.copy(axes[0], v3_0);
            const a1 = Vec3.copy(axes[1], v3_1);
            const a2 = Vec3.copy(axes[2], v3_2);
            const C = Vec3.subtract(axes[3], capsule.center, obb.center);
            C.normalize();
            const B = Vec3.subtract(axes[4], capsule.ellipseCenter0, capsule.ellipseCenter1);
            B.normalize();
            Vec3.cross(axes[5], a0, B);
            Vec3.cross(axes[6], a1, B);
            Vec3.cross(axes[7], a2, B);
            for (let i = 0; i < 8; ++i) {
              const a = getInterval(v3_verts8, axes[i]);
              const d0 = Vec3.dot(axes[i], capsule.ellipseCenter0);
              const d1 = Vec3.dot(axes[i], capsule.ellipseCenter1);
              const max_d = Math.max(d0, d1);
              const min_d = Math.min(d0, d1);
              const d_min = min_d - capsule.radius;
              const d_max = max_d + capsule.radius;
              if (d_min > a[1] || a[0] > d_max) {
                return 0;
              }
            }
            return 1;
          }
        };
      }();
      const spherePlane = function (sphere, plane) {
        const dot = Vec3.dot(plane.n, sphere.center);
        const r = sphere.radius * plane.n.length();
        if (dot + r < plane.d) {
          return -1;
        } else if (dot - r > plane.d) {
          return 0;
        }
        return 1;
      };
      const sphereFrustum = function (sphere, frustum) {
        for (let i = 0; i < frustum.planes.length; i++) {
          if (spherePlane(sphere, frustum.planes[i]) === -1) {
            return 0;
          }
        }
        return 1;
      };
      const sphereFrustumAccurate = function () {
        const pt = new Vec3(0, 0, 0);
        const map = [1, -1, 1, -1, 1, -1];
        return function (sphere, frustum) {
          for (let i = 0; i < 6; i++) {
            const plane = frustum.planes[i];
            const r = sphere.radius;
            const c = sphere.center;
            const n = plane.n;
            const d = plane.d;
            const dot = Vec3.dot(n, c);
            if (dot + r < d) return 0;else if (dot - r > d) {
              continue;
            }
            Vec3.add(pt, c, Vec3.multiplyScalar(pt, n, r));
            for (let j = 0; j < 6; j++) {
              if (j === i || j === i + map[i]) {
                continue;
              }
              const test = frustum.planes[j];
              if (Vec3.dot(test.n, pt) < test.d) {
                return 0;
              }
            }
          }
          return 1;
        };
      }();
      const sphereWithSphere = function (sphere0, sphere1) {
        const r = sphere0.radius + sphere1.radius;
        return Vec3.squaredDistance(sphere0.center, sphere1.center) < r * r;
      };
      const sphereAABB = function () {
        const pt = new Vec3();
        return function (sphere, aabb) {
          pt_point_aabb(pt, sphere.center, aabb);
          return Vec3.squaredDistance(sphere.center, pt) < sphere.radius * sphere.radius;
        };
      }();
      const sphereOBB = function () {
        const pt = new Vec3();
        return function (sphere, obb) {
          pt_point_obb(pt, sphere.center, obb);
          return Vec3.squaredDistance(sphere.center, pt) < sphere.radius * sphere.radius;
        };
      }();
      const sphereCapsule = function () {
        const v3_0 = new Vec3();
        const v3_1 = new Vec3();
        return function (sphere, capsule) {
          const r = sphere.radius + capsule.radius;
          const squaredR = r * r;
          const h = Vec3.squaredDistance(capsule.ellipseCenter0, capsule.ellipseCenter1);
          if (h === 0) {
            return Vec3.squaredDistance(sphere.center, capsule.center) < squaredR;
          } else {
            Vec3.subtract(v3_0, sphere.center, capsule.ellipseCenter0);
            Vec3.subtract(v3_1, capsule.ellipseCenter1, capsule.ellipseCenter0);
            const t = Vec3.dot(v3_0, v3_1) / h;
            if (t < 0) {
              return Vec3.squaredDistance(sphere.center, capsule.ellipseCenter0) < squaredR;
            } else if (t > 1) {
              return Vec3.squaredDistance(sphere.center, capsule.ellipseCenter1) < squaredR;
            } else {
              Vec3.scaleAndAdd(v3_0, capsule.ellipseCenter0, v3_1, t);
              return Vec3.squaredDistance(sphere.center, v3_0) < squaredR;
            }
          }
        };
      }();
      const capsuleWithCapsule = function () {
        const v3_0 = new Vec3();
        const v3_1 = new Vec3();
        const v3_2 = new Vec3();
        const v3_3 = new Vec3();
        const v3_4 = new Vec3();
        const v3_5 = new Vec3();
        return function capsuleWithCapsule(capsuleA, capsuleB) {
          const u = Vec3.subtract(v3_0, capsuleA.ellipseCenter1, capsuleA.ellipseCenter0);
          const v = Vec3.subtract(v3_1, capsuleB.ellipseCenter1, capsuleB.ellipseCenter0);
          const w = Vec3.subtract(v3_2, capsuleA.ellipseCenter0, capsuleB.ellipseCenter0);
          const a = Vec3.dot(u, u);
          const b = Vec3.dot(u, v);
          const c = Vec3.dot(v, v);
          const d = Vec3.dot(u, w);
          const e = Vec3.dot(v, w);
          const D = a * c - b * b;
          let sN;
          let sD = D;
          let tN;
          let tD = D;
          if (D < EPSILON$2) {
            sN = 0.0;
            sD = 1.0;
            tN = e;
            tD = c;
          } else {
            sN = b * e - c * d;
            tN = a * e - b * d;
            if (sN < 0.0) {
              sN = 0.0;
              tN = e;
              tD = c;
            } else if (sN > sD) {
              sN = sD;
              tN = e + b;
              tD = c;
            }
          }
          if (tN < 0.0) {
            tN = 0.0;
            if (-d < 0.0) {
              sN = 0.0;
            } else if (-d > a) {
              sN = sD;
            } else {
              sN = -d;
              sD = a;
            }
          } else if (tN > tD) {
            tN = tD;
            if (-d + b < 0.0) {
              sN = 0;
            } else if (-d + b > a) {
              sN = sD;
            } else {
              sN = -d + b;
              sD = a;
            }
          }
          const sc = Math.abs(sN) < EPSILON$2 ? 0.0 : sN / sD;
          const tc = Math.abs(tN) < EPSILON$2 ? 0.0 : tN / tD;
          const dP = v3_3;
          dP.set(w);
          dP.add(Vec3.multiplyScalar(v3_4, u, sc));
          dP.subtract(Vec3.multiplyScalar(v3_5, v, tc));
          const radius = capsuleA.radius + capsuleB.radius;
          return dP.lengthSqr() < radius * radius;
        };
      }();
      const intersect = {
        raySphere,
        rayAABB,
        rayOBB,
        rayPlane,
        rayTriangle,
        rayCapsule,
        raySubMesh: null,
        rayMesh: null,
        rayModel: null,
        lineSphere,
        lineAABB,
        lineOBB,
        linePlane,
        lineTriangle,
        sphereWithSphere,
        sphereAABB,
        sphereOBB,
        spherePlane,
        sphereFrustum,
        sphereFrustumAccurate,
        sphereCapsule,
        aabbWithAABB,
        aabbWithOBB,
        aabbPlane,
        aabbFrustum,
        aabbFrustumAccurate,
        obbWithOBB,
        obbPlane,
        obbFrustum,
        obbFrustumAccurate,
        obbPoint,
        obbCapsule,
        aabbFrustumCompletelyInside,
        capsuleWithCapsule,
        resolve(g1, g2, outPt = null) {
          const type1 = g1._type;
          const type2 = g2._type;
          const resolver = this[type1 | type2];
          return type1 < type2 ? resolver(g1, g2, outPt) : resolver(g2, g1, outPt);
        }
      };
      intersect[enums.SHAPE_RAY | enums.SHAPE_SPHERE] = raySphere;
      intersect[enums.SHAPE_RAY | enums.SHAPE_AABB] = rayAABB;
      intersect[enums.SHAPE_RAY | enums.SHAPE_OBB] = rayOBB;
      intersect[enums.SHAPE_RAY | enums.SHAPE_PLANE] = rayPlane;
      intersect[enums.SHAPE_RAY | enums.SHAPE_TRIANGLE] = rayTriangle;
      intersect[enums.SHAPE_RAY | enums.SHAPE_CAPSULE] = rayCapsule;
      intersect[enums.SHAPE_LINE | enums.SHAPE_SPHERE] = lineSphere;
      intersect[enums.SHAPE_LINE | enums.SHAPE_AABB] = lineAABB;
      intersect[enums.SHAPE_LINE | enums.SHAPE_OBB] = lineOBB;
      intersect[enums.SHAPE_LINE | enums.SHAPE_PLANE] = linePlane;
      intersect[enums.SHAPE_LINE | enums.SHAPE_TRIANGLE] = lineTriangle;
      intersect[enums.SHAPE_SPHERE] = sphereWithSphere;
      intersect[enums.SHAPE_SPHERE | enums.SHAPE_AABB] = sphereAABB;
      intersect[enums.SHAPE_SPHERE | enums.SHAPE_OBB] = sphereOBB;
      intersect[enums.SHAPE_SPHERE | enums.SHAPE_PLANE] = spherePlane;
      intersect[enums.SHAPE_SPHERE | enums.SHAPE_FRUSTUM] = sphereFrustum;
      intersect[enums.SHAPE_SPHERE | enums.SHAPE_FRUSTUM_ACCURATE] = sphereFrustumAccurate;
      intersect[enums.SHAPE_SPHERE | enums.SHAPE_CAPSULE] = sphereCapsule;
      intersect[enums.SHAPE_AABB] = aabbWithAABB;
      intersect[enums.SHAPE_AABB | enums.SHAPE_OBB] = aabbWithOBB;
      intersect[enums.SHAPE_AABB | enums.SHAPE_PLANE] = aabbPlane;
      intersect[enums.SHAPE_AABB | enums.SHAPE_FRUSTUM] = aabbFrustum;
      intersect[enums.SHAPE_AABB | enums.SHAPE_FRUSTUM_ACCURATE] = aabbFrustumAccurate;
      intersect[enums.SHAPE_OBB] = obbWithOBB;
      intersect[enums.SHAPE_OBB | enums.SHAPE_PLANE] = obbPlane;
      intersect[enums.SHAPE_OBB | enums.SHAPE_FRUSTUM] = obbFrustum;
      intersect[enums.SHAPE_OBB | enums.SHAPE_FRUSTUM_ACCURATE] = obbFrustumAccurate;
      intersect[enums.SHAPE_OBB | enums.SHAPE_CAPSULE] = obbCapsule;
      intersect[enums.SHAPE_CAPSULE] = capsuleWithCapsule;

      replaceProperty(Line.prototype, 'line', [{
        name: 'mag',
        newName: 'len'
      }, {
        name: 'magnitude',
        newName: 'len'
      }]);
      removeProperty(intersect, 'intersect', [{
        name: 'line_quad'
      }]);

      const v1 = new Vec3(0, 0, 0);
      const v2 = new Vec3(0, 0, 0);
      const temp_mat = legacyCC.mat4();
      const temp_vec4 = legacyCC.v4();
      class Plane {
        static create(nx, ny, nz, d) {
          return new Plane(nx, ny, nz, d);
        }
        static clone(p) {
          return new Plane(p.n.x, p.n.y, p.n.z, p.d);
        }
        static copy(out, p) {
          Vec3.copy(out.n, p.n);
          out.d = p.d;
          return out;
        }
        static fromPoints(out, a, b, c) {
          Vec3.subtract(v1, b, a);
          Vec3.subtract(v2, c, a);
          Vec3.normalize(out.n, Vec3.cross(out.n, v1, v2));
          out.d = Vec3.dot(out.n, a);
          return out;
        }
        static set(out, nx, ny, nz, d) {
          out.n.x = nx;
          out.n.y = ny;
          out.n.z = nz;
          out.d = d;
          return out;
        }
        static fromNormalAndPoint(out, normal, point) {
          Vec3.copy(out.n, normal);
          out.d = Vec3.dot(normal, point);
          return out;
        }
        static normalize(out, a) {
          const len = a.n.length();
          Vec3.normalize(out.n, a.n);
          if (len > 0) {
            out.d = a.d / len;
          }
          return out;
        }
        get type() {
          return this._type;
        }
        set x(val) {
          this.n.x = val;
        }
        get x() {
          return this.n.x;
        }
        set y(val) {
          this.n.y = val;
        }
        get y() {
          return this.n.y;
        }
        set z(val) {
          this.n.z = val;
        }
        get z() {
          return this.n.z;
        }
        set w(val) {
          this.d = val;
        }
        get w() {
          return this.d;
        }
        constructor(nx = 0, ny = 1, nz = 0, d = 0) {
          this.n = void 0;
          this._type = enums.SHAPE_PLANE;
          this.n = new Vec3(nx, ny, nz);
          this.d = d;
        }
        transform(mat) {
          Mat4.invert(temp_mat, mat);
          Mat4.transpose(temp_mat, temp_mat);
          Vec4.set(temp_vec4, this.n.x, this.n.y, this.n.z, -this.d);
          Vec4.transformMat4(temp_vec4, temp_vec4, temp_mat);
          Vec3.set(this.n, temp_vec4.x, temp_vec4.y, temp_vec4.z);
          this.d = -temp_vec4.w;
        }
      }

      class Triangle {
        static create(ax = 1, ay = 0, az = 0, bx = 0, by = 0, bz = 0, cx = 0, cy = 0, cz = 1) {
          return new Triangle(ax, ay, az, bx, by, bz, cx, cy, cz);
        }
        static clone(t) {
          return new Triangle(t.a.x, t.a.y, t.a.z, t.b.x, t.b.y, t.b.z, t.c.x, t.c.y, t.c.z);
        }
        static copy(out, t) {
          Vec3.copy(out.a, t.a);
          Vec3.copy(out.b, t.b);
          Vec3.copy(out.c, t.c);
          return out;
        }
        static fromPoints(out, a, b, c) {
          Vec3.copy(out.a, a);
          Vec3.copy(out.b, b);
          Vec3.copy(out.c, c);
          return out;
        }
        static set(out, ax, ay, az, bx, by, bz, cx, cy, cz) {
          out.a.x = ax;
          out.a.y = ay;
          out.a.z = az;
          out.b.x = bx;
          out.b.y = by;
          out.b.z = bz;
          out.c.x = cx;
          out.c.y = cy;
          out.c.z = cz;
          return out;
        }
        get type() {
          return this._type;
        }
        constructor(ax = 0, ay = 0, az = 0, bx = 1, by = 0, bz = 0, cx = 0, cy = 1, cz = 0) {
          this.a = void 0;
          this.b = void 0;
          this.c = void 0;
          this._type = void 0;
          this._type = enums.SHAPE_TRIANGLE;
          this.a = new Vec3(ax, ay, az);
          this.b = new Vec3(bx, by, bz);
          this.c = new Vec3(cx, cy, cz);
        }
      }

      const _v3_tmp$1 = new Vec3();
      const _v3_tmp2$1 = new Vec3();
      const _v3_tmp3 = new Vec3();
      const _v3_tmp4 = new Vec3();
      const _m3_tmp$1 = new Mat3();
      const transform_extent_m4 = (out, extent, m4) => {
        _m3_tmp$1.m00 = Math.abs(m4.m00);
        _m3_tmp$1.m01 = Math.abs(m4.m01);
        _m3_tmp$1.m02 = Math.abs(m4.m02);
        _m3_tmp$1.m03 = Math.abs(m4.m04);
        _m3_tmp$1.m04 = Math.abs(m4.m05);
        _m3_tmp$1.m05 = Math.abs(m4.m06);
        _m3_tmp$1.m06 = Math.abs(m4.m08);
        _m3_tmp$1.m07 = Math.abs(m4.m09);
        _m3_tmp$1.m08 = Math.abs(m4.m10);
        Vec3.transformMat3(out, extent, _m3_tmp$1);
      };
      class AABB {
        static create(px, py, pz, hw, hh, hl) {
          return new AABB(px, py, pz, hw, hh, hl);
        }
        static clone(a) {
          return new AABB(a.center.x, a.center.y, a.center.z, a.halfExtents.x, a.halfExtents.y, a.halfExtents.z);
        }
        static copy(out, a) {
          Vec3.copy(out.center, a.center);
          Vec3.copy(out.halfExtents, a.halfExtents);
          return out;
        }
        static fromPoints(out, minPos, maxPos) {
          Vec3.add(_v3_tmp$1, maxPos, minPos);
          Vec3.subtract(_v3_tmp2$1, maxPos, minPos);
          Vec3.multiplyScalar(out.center, _v3_tmp$1, 0.5);
          Vec3.multiplyScalar(out.halfExtents, _v3_tmp2$1, 0.5);
          return out;
        }
        static set(out, px, py, pz, hw, hh, hl) {
          out.center.set(px, py, pz);
          out.halfExtents.set(hw, hh, hl);
          return out;
        }
        static merge(out, a, b) {
          Vec3.subtract(_v3_tmp$1, a.center, a.halfExtents);
          Vec3.subtract(_v3_tmp2$1, b.center, b.halfExtents);
          Vec3.add(_v3_tmp3, a.center, a.halfExtents);
          Vec3.add(_v3_tmp4, b.center, b.halfExtents);
          Vec3.max(_v3_tmp4, _v3_tmp3, _v3_tmp4);
          Vec3.min(_v3_tmp3, _v3_tmp$1, _v3_tmp2$1);
          return AABB.fromPoints(out, _v3_tmp3, _v3_tmp4);
        }
        static toBoundingSphere(out, a) {
          out.center.set(a.center);
          out.radius = a.halfExtents.length();
          return out;
        }
        static transform(out, a, matrix) {
          Vec3.transformMat4(out.center, a.center, matrix);
          transform_extent_m4(out.halfExtents, a.halfExtents, matrix);
          return out;
        }
        get type() {
          return this._type;
        }
        constructor(px = 0, py = 0, pz = 0, hw = 1, hh = 1, hl = 1) {
          this.center = void 0;
          this.halfExtents = void 0;
          this._type = void 0;
          this._type = enums.SHAPE_AABB;
          this.center = new Vec3(px, py, pz);
          this.halfExtents = new Vec3(hw, hh, hl);
        }
        getBoundary(minPos, maxPos) {
          Vec3.subtract(minPos, this.center, this.halfExtents);
          Vec3.add(maxPos, this.center, this.halfExtents);
        }
        transform(m, pos, rot, scale, out) {
          Vec3.transformMat4(out.center, this.center, m);
          transform_extent_m4(out.halfExtents, this.halfExtents, m);
        }
        clone() {
          return AABB.clone(this);
        }
        copy(a) {
          return AABB.copy(this, a);
        }
        mergePoint(point) {
          this.getBoundary(_v3_tmp$1, _v3_tmp2$1);
          if (point.x < _v3_tmp$1.x) {
            _v3_tmp$1.x = point.x;
          }
          if (point.y < _v3_tmp$1.y) {
            _v3_tmp$1.y = point.y;
          }
          if (point.z < _v3_tmp$1.z) {
            _v3_tmp$1.z = point.z;
          }
          if (point.x > _v3_tmp2$1.x) {
            _v3_tmp2$1.x = point.x;
          }
          if (point.y > _v3_tmp2$1.y) {
            _v3_tmp2$1.y = point.y;
          }
          if (point.z > _v3_tmp2$1.z) {
            _v3_tmp2$1.z = point.z;
          }
          Vec3.add(_v3_tmp3, _v3_tmp$1, _v3_tmp2$1);
          this.center.set(Vec3.multiplyScalar(_v3_tmp3, _v3_tmp3, 0.5));
          this.halfExtents.set(_v3_tmp2$1.x - _v3_tmp3.x, _v3_tmp2$1.y - _v3_tmp3.y, _v3_tmp2$1.z - _v3_tmp3.z);
        }
        mergePoints(points) {
          if (points.length < 1) {
            return;
          }
          for (let i = 0; i < points.length; i++) {
            this.mergePoint(points[i]);
          }
        }
        mergeFrustum(frustum) {
          this.mergePoints(frustum.vertices);
        }
      }

      class Capsule {
        get type() {
          return this._type;
        }
        constructor(radius = 0.5, halfHeight = 0.5, axis = 1) {
          this._type = void 0;
          this.radius = void 0;
          this.halfHeight = void 0;
          this.axis = void 0;
          this.center = void 0;
          this.rotation = void 0;
          this.ellipseCenter0 = void 0;
          this.ellipseCenter1 = void 0;
          this._type = enums.SHAPE_CAPSULE;
          this.radius = radius;
          this.halfHeight = halfHeight;
          this.axis = axis;
          this.center = new Vec3();
          this.rotation = new Quat();
          this.ellipseCenter0 = new Vec3(0, halfHeight, 0);
          this.ellipseCenter1 = new Vec3(0, -halfHeight, 0);
          this.updateCache();
        }
        transform(m, pos, rot, scale, out) {
          const ws = scale;
          const s = absMaxComponent(ws);
          out.radius = this.radius * Math.abs(s);
          const halfTotalWorldHeight = (this.halfHeight + this.radius) * Math.abs(ws.y);
          let halfWorldHeight = halfTotalWorldHeight - out.radius;
          if (halfWorldHeight < 0) halfWorldHeight = 0;
          out.halfHeight = halfWorldHeight;
          Vec3.transformMat4(out.center, this.center, m);
          Quat.multiply(out.rotation, this.rotation, rot);
          out.updateCache();
        }
        updateCache() {
          this.updateLocalCenter();
          Vec3.transformQuat(this.ellipseCenter0, this.ellipseCenter0, this.rotation);
          Vec3.transformQuat(this.ellipseCenter1, this.ellipseCenter1, this.rotation);
          this.ellipseCenter0.add(this.center);
          this.ellipseCenter1.add(this.center);
        }
        updateLocalCenter() {
          const halfHeight = this.halfHeight;
          const axis = this.axis;
          switch (axis) {
            case 0:
              this.ellipseCenter0.set(halfHeight, 0, 0);
              this.ellipseCenter1.set(-halfHeight, 0, 0);
              break;
            case 1:
              this.ellipseCenter0.set(0, halfHeight, 0);
              this.ellipseCenter1.set(0, -halfHeight, 0);
              break;
            case 2:
              this.ellipseCenter0.set(0, 0, halfHeight);
              this.ellipseCenter1.set(0, 0, -halfHeight);
              break;
          }
        }
      }

      const _v = new Array(8);
      _v[0] = new Vec3(1, 1, 1);
      _v[1] = new Vec3(-1, 1, 1);
      _v[2] = new Vec3(-1, -1, 1);
      _v[3] = new Vec3(1, -1, 1);
      _v[4] = new Vec3(1, 1, -1);
      _v[5] = new Vec3(-1, 1, -1);
      _v[6] = new Vec3(-1, -1, -1);
      _v[7] = new Vec3(1, -1, -1);
      const _nearTemp = new Vec3();
      const _farTemp = new Vec3();
      const _temp_v3 = new Vec3();
      class Frustum {
        static createOrthographic(out, width, height, near, far, transform) {
          const halfWidth = width / 2;
          const halfHeight = height / 2;
          Vec3.set(_temp_v3, halfWidth, halfHeight, -near);
          Vec3.transformMat4(out.vertices[0], _temp_v3, transform);
          Vec3.set(_temp_v3, -halfWidth, halfHeight, -near);
          Vec3.transformMat4(out.vertices[1], _temp_v3, transform);
          Vec3.set(_temp_v3, -halfWidth, -halfHeight, -near);
          Vec3.transformMat4(out.vertices[2], _temp_v3, transform);
          Vec3.set(_temp_v3, halfWidth, -halfHeight, -near);
          Vec3.transformMat4(out.vertices[3], _temp_v3, transform);
          Vec3.set(_temp_v3, halfWidth, halfHeight, -far);
          Vec3.transformMat4(out.vertices[4], _temp_v3, transform);
          Vec3.set(_temp_v3, -halfWidth, halfHeight, -far);
          Vec3.transformMat4(out.vertices[5], _temp_v3, transform);
          Vec3.set(_temp_v3, -halfWidth, -halfHeight, -far);
          Vec3.transformMat4(out.vertices[6], _temp_v3, transform);
          Vec3.set(_temp_v3, halfWidth, -halfHeight, -far);
          Vec3.transformMat4(out.vertices[7], _temp_v3, transform);
          out.updatePlanes();
        }
        static createOrtho(out, width, height, near, far, transform) {
          return Frustum.createOrthographic(out, width, height, near, far, transform);
        }
        static createPerspective(out, aspect, fov, near, far, transform) {
          const h = Math.tan(fov * 0.5);
          const w = h * aspect;
          _nearTemp.set(near * w, near * h, near);
          _farTemp.set(far * w, far * h, far);
          const vertexes = out.vertices;
          _temp_v3.set(_nearTemp.x, _nearTemp.y, -_nearTemp.z);
          Vec3.transformMat4(vertexes[0], _temp_v3, transform);
          _temp_v3.set(-_nearTemp.x, _nearTemp.y, -_nearTemp.z);
          Vec3.transformMat4(vertexes[1], _temp_v3, transform);
          _temp_v3.set(-_nearTemp.x, -_nearTemp.y, -_nearTemp.z);
          Vec3.transformMat4(vertexes[2], _temp_v3, transform);
          _temp_v3.set(_nearTemp.x, -_nearTemp.y, -_nearTemp.z);
          Vec3.transformMat4(vertexes[3], _temp_v3, transform);
          _temp_v3.set(_farTemp.x, _farTemp.y, -_farTemp.z);
          Vec3.transformMat4(vertexes[4], _temp_v3, transform);
          _temp_v3.set(-_farTemp.x, _farTemp.y, -_farTemp.z);
          Vec3.transformMat4(vertexes[5], _temp_v3, transform);
          _temp_v3.set(-_farTemp.x, -_farTemp.y, -_farTemp.z);
          Vec3.transformMat4(vertexes[6], _temp_v3, transform);
          _temp_v3.set(_farTemp.x, -_farTemp.y, -_farTemp.z);
          Vec3.transformMat4(vertexes[7], _temp_v3, transform);
          out.updatePlanes();
        }
        static createFromAABB(out, aabb) {
          const vec3_min = new Vec3();
          const vec3_max = new Vec3();
          Vec3.subtract(vec3_min, aabb.center, aabb.halfExtents);
          Vec3.add(vec3_max, aabb.center, aabb.halfExtents);
          out.vertices[0].set(vec3_max.x, vec3_max.y, -vec3_min.z);
          out.vertices[1].set(vec3_min.x, vec3_max.y, -vec3_min.z);
          out.vertices[2].set(vec3_min.x, vec3_min.y, -vec3_min.z);
          out.vertices[3].set(vec3_max.x, vec3_min.y, -vec3_min.z);
          out.vertices[4].set(vec3_max.x, vec3_max.y, -vec3_max.z);
          out.vertices[5].set(vec3_min.x, vec3_max.y, -vec3_max.z);
          out.vertices[6].set(vec3_min.x, vec3_min.y, -vec3_max.z);
          out.vertices[7].set(vec3_max.x, vec3_min.y, -vec3_max.z);
          out.updatePlanes();
          return out;
        }
        split(start, end, aspect, fov, m) {
          return Frustum.createPerspective(this, aspect, fov, start, end, m);
        }
        static create() {
          return new Frustum();
        }
        static clone(f) {
          return Frustum.copy(new Frustum(), f);
        }
        static copy(out, f) {
          out._type = f.type;
          for (let i = 0; i < 6; ++i) {
            Plane.copy(out.planes[i], f.planes[i]);
          }
          for (let i = 0; i < 8; ++i) {
            Vec3.copy(out.vertices[i], f.vertices[i]);
          }
          return out;
        }
        set accurate(b) {
          this._type = b ? enums.SHAPE_FRUSTUM_ACCURATE : enums.SHAPE_FRUSTUM;
        }
        get type() {
          return this._type;
        }
        constructor() {
          this.planes = void 0;
          this.vertices = void 0;
          this._type = void 0;
          this._type = enums.SHAPE_FRUSTUM;
          this.planes = new Array(6);
          for (let i = 0; i < 6; ++i) {
            this.planes[i] = Plane.create(0, 0, 0, 0);
          }
          this.vertices = new Array(8);
          for (let i = 0; i < 8; ++i) {
            this.vertices[i] = new Vec3();
          }
        }
        update(m, inv) {
          Vec3.set(this.planes[0].n, m.m03 + m.m00, m.m07 + m.m04, m.m11 + m.m08);
          this.planes[0].d = -(m.m15 + m.m12);
          Vec3.set(this.planes[1].n, m.m03 - m.m00, m.m07 - m.m04, m.m11 - m.m08);
          this.planes[1].d = -(m.m15 - m.m12);
          Vec3.set(this.planes[2].n, m.m03 + m.m01, m.m07 + m.m05, m.m11 + m.m09);
          this.planes[2].d = -(m.m15 + m.m13);
          Vec3.set(this.planes[3].n, m.m03 - m.m01, m.m07 - m.m05, m.m11 - m.m09);
          this.planes[3].d = -(m.m15 - m.m13);
          Vec3.set(this.planes[4].n, m.m03 + m.m02, m.m07 + m.m06, m.m11 + m.m10);
          this.planes[4].d = -(m.m15 + m.m14);
          Vec3.set(this.planes[5].n, m.m03 - m.m02, m.m07 - m.m06, m.m11 - m.m10);
          this.planes[5].d = -(m.m15 - m.m14);
          for (let i = 0; i < 6; i++) {
            const pl = this.planes[i];
            const invDist = 1 / pl.n.length();
            Vec3.multiplyScalar(pl.n, pl.n, invDist);
            pl.d *= invDist;
          }
          for (let i = 0; i < 8; i++) {
            Vec3.transformMat4(this.vertices[i], _v[i], inv);
          }
        }
        transform(mat) {
          for (let i = 0; i < 8; i++) {
            Vec3.transformMat4(this.vertices[i], this.vertices[i], mat);
          }
          this.updatePlanes();
        }
        zero() {
          for (let i = 0; i < 8; i++) {
            this.vertices[i].set(0.0, 0.0, 0.0);
          }
          for (let i = 0; i < 6; i++) {
            Plane.set(this.planes[i], 0, 0, 0, 0);
          }
        }
        updatePlanes() {
          Plane.fromPoints(this.planes[0], this.vertices[1], this.vertices[6], this.vertices[5]);
          Plane.fromPoints(this.planes[1], this.vertices[3], this.vertices[4], this.vertices[7]);
          Plane.fromPoints(this.planes[2], this.vertices[6], this.vertices[3], this.vertices[7]);
          Plane.fromPoints(this.planes[3], this.vertices[0], this.vertices[5], this.vertices[4]);
          Plane.fromPoints(this.planes[4], this.vertices[2], this.vertices[0], this.vertices[3]);
          Plane.fromPoints(this.planes[5], this.vertices[7], this.vertices[5], this.vertices[6]);
        }
      }

      function cacheProperty(ctor, property) {
        const propDesc = Object.getOwnPropertyDescriptor(ctor.prototype, property);
        const propCacheKey = `_$cache_${property}`;
        const propRealKey = `_$_${property}`;
        Object.defineProperty(ctor.prototype, propRealKey, propDesc);
        Object.defineProperty(ctor.prototype, property, {
          get() {
            if (this[propCacheKey] === undefined) {
              this[propCacheKey] = this[propRealKey];
            }
            return this[propCacheKey];
          },
          set(value) {
            this[propRealKey] = value;
          },
          configurable: true,
          enumerable: true
        });
      }
      function cacheUnderlyingData(ctor) {
        ctor.prototype._arraybuffer = function () {
          if (!this.__data) {
            this.__data = this.underlyingData();
          }
          return this.__data;
        };
      }
      const defineAttrFloat = (kls, attr) => {
        const desc = kls.__nativeFields__[attr];
        const cacheKey = `_$_${attr}`;
        if (!window.oh) {
          console.assert(desc.fieldSize === 4, `field ${attr} size ${desc.fieldSize}`);
        }
        Object.defineProperty(kls.prototype, desc.fieldName, {
          configurable: true,
          enumerable: true,
          get() {
            if (this[cacheKey] === undefined) {
              this[cacheKey] = new Float32Array(this._arraybuffer(), desc.fieldOffset, 1);
            }
            return this[cacheKey][0];
          },
          set(v) {
            if (this[cacheKey] === undefined) {
              this[cacheKey] = new Float32Array(this._arraybuffer(), desc.fieldOffset, 1);
            }
            this[cacheKey][0] = v;
          }
        });
      };
      const defineAttrInt = (kls, attr) => {
        const desc = kls.__nativeFields__[attr];
        if (!desc) {
          console.error(`attr ${attr} not defined in class ${kls.toString()}`);
        }
        const cacheKey = `_$_${attr}`;
        if (!window.oh) {
          console.assert(desc.fieldSize === 4, `field ${attr} size ${desc.fieldSize}`);
        }
        Object.defineProperty(kls.prototype, desc.fieldName, {
          configurable: true,
          enumerable: true,
          get() {
            if (this[cacheKey] === undefined) {
              this[cacheKey] = new Int32Array(this._arraybuffer(), desc.fieldOffset, 1);
            }
            return this[cacheKey][0];
          },
          set(v) {
            if (this[cacheKey] === undefined) {
              this[cacheKey] = new Int32Array(this._arraybuffer(), desc.fieldOffset, 1);
            }
            this[cacheKey][0] = v;
          }
        });
      };
      {
        cacheProperty(ns.Line, 's');
        cacheProperty(ns.Line, 'e');
        Object.setPrototypeOf(ns.Line.prototype, Line.prototype);
        cacheUnderlyingData(ns.Plane);
        cacheProperty(ns.Plane, 'n');
        defineAttrFloat(ns.Plane, 'd');
        Object.setPrototypeOf(ns.Plane.prototype, Plane.prototype);
        cacheUnderlyingData(ns.Ray);
        cacheProperty(ns.Ray, 'o');
        cacheProperty(ns.Ray, 'd');
        Object.setPrototypeOf(ns.Ray.prototype, Ray.prototype);
        cacheUnderlyingData(ns.Triangle);
        cacheProperty(ns.Triangle, 'a');
        cacheProperty(ns.Triangle, 'b');
        cacheProperty(ns.Triangle, 'c');
        Object.setPrototypeOf(ns.Triangle.prototype, Triangle.prototype);
        cacheUnderlyingData(ns.Sphere);
        cacheProperty(ns.Sphere, '_center');
        defineAttrFloat(ns.Sphere, '_radius');
        Object.setPrototypeOf(ns.Sphere.prototype, Sphere.prototype);
        cacheUnderlyingData(ns.AABB);
        cacheProperty(ns.AABB, 'center');
        cacheProperty(ns.AABB, 'halfExtents');
        Object.setPrototypeOf(ns.AABB.prototype, AABB.prototype);
        cacheUnderlyingData(ns.Capsule);
        defineAttrFloat(ns.Capsule, 'radius');
        defineAttrFloat(ns.Capsule, 'halfHeight');
        defineAttrInt(ns.Capsule, 'axis');
        cacheProperty(ns.Capsule, 'center');
        cacheProperty(ns.Capsule, 'rotation');
        cacheProperty(ns.Capsule, 'ellipseCenter0');
        cacheProperty(ns.Capsule, 'ellipseCenter1');
        Object.setPrototypeOf(ns.Capsule.prototype, Capsule.prototype);
        cacheProperty(ns.Frustum, 'vertices');
        cacheProperty(ns.Frustum, 'planes');
        Object.setPrototypeOf(ns.Frustum.prototype, Frustum.prototype);
        const descOf_type = Object.getOwnPropertyDescriptor(ns.ShapeBase.prototype, '_type');
        for (const kls of [ns.Line, ns.Plane, ns.Ray, ns.Triangle, ns.Sphere, ns.AABB, ns.Capsule, ns.Frustum]) {
          Object.defineProperty(kls.prototype, '_type', descOf_type);
        }
      }

      const _v3_tmp = new Vec3();
      const _v3_tmp2 = new Vec3();
      const _m3_tmp = new Mat3();
      const transform_extent_m3 = (out, extent, m3) => {
        _m3_tmp.m00 = Math.abs(m3.m00);
        _m3_tmp.m01 = Math.abs(m3.m01);
        _m3_tmp.m02 = Math.abs(m3.m02);
        _m3_tmp.m03 = Math.abs(m3.m03);
        _m3_tmp.m04 = Math.abs(m3.m04);
        _m3_tmp.m05 = Math.abs(m3.m05);
        _m3_tmp.m06 = Math.abs(m3.m06);
        _m3_tmp.m07 = Math.abs(m3.m07);
        _m3_tmp.m08 = Math.abs(m3.m08);
        Vec3.transformMat3(out, extent, _m3_tmp);
      };
      class OBB {
        static create(cx, cy, cz, hw, hh, hl, ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3) {
          return new OBB(cx, cy, cz, hw, hh, hl, ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3);
        }
        static clone(a) {
          return new OBB(a.center.x, a.center.y, a.center.z, a.halfExtents.x, a.halfExtents.y, a.halfExtents.z, a.orientation.m00, a.orientation.m01, a.orientation.m02, a.orientation.m03, a.orientation.m04, a.orientation.m05, a.orientation.m06, a.orientation.m07, a.orientation.m08);
        }
        static copy(out, a) {
          Vec3.copy(out.center, a.center);
          Vec3.copy(out.halfExtents, a.halfExtents);
          Mat3.copy(out.orientation, a.orientation);
          return out;
        }
        static fromPoints(out, minPos, maxPos) {
          Vec3.multiplyScalar(out.center, Vec3.add(_v3_tmp, minPos, maxPos), 0.5);
          Vec3.multiplyScalar(out.halfExtents, Vec3.subtract(_v3_tmp2, maxPos, minPos), 0.5);
          Mat3.identity(out.orientation);
          return out;
        }
        static set(out, cx, cy, cz, hw, hh, hl, ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3) {
          Vec3.set(out.center, cx, cy, cz);
          Vec3.set(out.halfExtents, hw, hh, hl);
          Mat3.set(out.orientation, ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3);
          return out;
        }
        get type() {
          return this._type;
        }
        constructor(cx = 0, cy = 0, cz = 0, hw = 1, hh = 1, hl = 1, ox_1 = 1, ox_2 = 0, ox_3 = 0, oy_1 = 0, oy_2 = 1, oy_3 = 0, oz_1 = 0, oz_2 = 0, oz_3 = 1) {
          this.center = void 0;
          this.halfExtents = void 0;
          this.orientation = void 0;
          this._type = void 0;
          this._type = enums.SHAPE_OBB;
          this.center = new Vec3(cx, cy, cz);
          this.halfExtents = new Vec3(hw, hh, hl);
          this.orientation = new Mat3(ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3);
        }
        getBoundary(minPos, maxPos) {
          transform_extent_m3(_v3_tmp, this.halfExtents, this.orientation);
          Vec3.subtract(minPos, this.center, _v3_tmp);
          Vec3.add(maxPos, this.center, _v3_tmp);
        }
        transform(m, pos, rot, scale, out) {
          Vec3.transformMat4(out.center, this.center, m);
          Mat3.fromQuat(out.orientation, rot);
          Vec3.multiply(out.halfExtents, this.halfExtents, scale);
        }
        translateAndRotate(m, rot, out) {
          Vec3.transformMat4(out.center, this.center, m);
          Mat3.fromQuat(out.orientation, rot);
        }
        setScale(scale, out) {
          Vec3.multiply(out.halfExtents, this.halfExtents, scale);
        }
      }

      function binarySearch(array, value) {
        return binarySearchEpsilon(array, value, 0);
      }
      function binarySearchEpsilon(array, value, EPSILON = 1e-6) {
        let low = 0;
        let high = array.length - 1;
        let middle = high >>> 1;
        for (; low <= high; middle = low + high >>> 1) {
          const test = array[middle];
          if (test > value + EPSILON) {
            high = middle - 1;
          } else if (test < value - EPSILON) {
            low = middle + 1;
          } else {
            return middle;
          }
        }
        return ~low;
      }
      function binarySearchBy(array, value, lessThan) {
        let low = 0;
        let high = array.length - 1;
        let middle = high >>> 1;
        for (; low <= high; middle = low + high >>> 1) {
          const test = array[middle];
          if (lessThan(test, value) < 0) {
            high = middle - 1;
          } else if (lessThan(test, value) > 0) {
            low = middle + 1;
          } else {
            return middle;
          }
        }
        return ~low;
      }

      let _Symbol$iterator;
      _Symbol$iterator = Symbol.iterator;
      class KeyframeCurve {
        constructor() {
          this._times = [];
          this._values = [];
        }
        get keyFramesCount() {
          return this._times.length;
        }
        get rangeMin() {
          return this._times[0];
        }
        get rangeMax() {
          return this._times[this._values.length - 1];
        }
        [_Symbol$iterator]() {
          let index = 0;
          return {
            next: () => {
              if (index >= this._times.length) {
                return {
                  done: true,
                  value: undefined
                };
              } else {
                const value = [this._times[index], this._values[index]];
                ++index;
                return {
                  done: false,
                  value
                };
              }
            }
          };
        }
        keyframes() {
          return this;
        }
        times() {
          return this._times;
        }
        values() {
          return this._values;
        }
        getKeyframeTime(index) {
          return this._times[index];
        }
        getKeyframeValue(index) {
          return this._values[index];
        }
        addKeyFrame(time, keyframeValue) {
          return this._insertNewKeyframe(time, keyframeValue);
        }
        removeKeyframe(index) {
          this._times.splice(index, 1);
          this._values.splice(index, 1);
        }
        indexOfKeyframe(time) {
          return binarySearchEpsilon(this._times, time);
        }
        updateTime(index, time) {
          const value = this._values[index];
          this.removeKeyframe(index);
          this._insertNewKeyframe(time, value);
        }
        assignSorted(times, values) {
          if (values !== undefined) {
            assertIsTrue(Array.isArray(times));
            this.setKeyframes(times.slice(), values.slice());
          } else {
            const keyframes = Array.from(times);
            this.setKeyframes(keyframes.map(([time]) => time), keyframes.map(([, value]) => value));
          }
        }
        clear() {
          this._times.length = 0;
          this._values.length = 0;
        }
        searchKeyframe(time) {
          return binarySearchEpsilon(this._times, time);
        }
        setKeyframes(times, values) {
          assertIsTrue(times.length === values.length);
          assertIsTrue(isSorted(times));
          this._times = times;
          this._values = values;
        }
        _insertNewKeyframe(time, value) {
          const times = this._times;
          const values = this._values;
          const nFrames = times.length;
          const index = binarySearchEpsilon(times, time);
          if (index >= 0) {
            return index;
          }
          const iNext = ~index;
          if (iNext === 0) {
            times.unshift(time);
            values.unshift(value);
          } else if (iNext === nFrames) {
            times.push(time);
            values.push(value);
          } else {
            assertIsTrue(nFrames > 1);
            times.splice(iNext - 1, 0, time);
            values.splice(iNext - 1, 0, value);
          }
          return iNext;
        }
      }
      CCClass.fastDefine('cc.KeyframeCurve', KeyframeCurve, {
        _times: [],
        _values: []
      });
      function isSorted(values) {
        return values.every((value, index, array) => index === 0 || value > array[index - 1] || approx(value, array[index - 1], 1e-6));
      }

      let RealInterpolationMode; exports('RealInterpolationMode', RealInterpolationMode);
      (function (RealInterpolationMode) {
        RealInterpolationMode[RealInterpolationMode["LINEAR"] = 0] = "LINEAR";
        RealInterpolationMode[RealInterpolationMode["CONSTANT"] = 1] = "CONSTANT";
        RealInterpolationMode[RealInterpolationMode["CUBIC"] = 2] = "CUBIC";
      })(RealInterpolationMode || (exports('RealInterpolationMode', RealInterpolationMode = {})));
      let ExtrapolationMode; exports('ExtrapolationMode', ExtrapolationMode);
      (function (ExtrapolationMode) {
        ExtrapolationMode[ExtrapolationMode["LINEAR"] = 0] = "LINEAR";
        ExtrapolationMode[ExtrapolationMode["CLAMP"] = 1] = "CLAMP";
        ExtrapolationMode[ExtrapolationMode["LOOP"] = 2] = "LOOP";
        ExtrapolationMode[ExtrapolationMode["PING_PONG"] = 3] = "PING_PONG";
      })(ExtrapolationMode || (exports('ExtrapolationMode', ExtrapolationMode = {})));
      let TangentWeightMode; exports('TangentWeightMode', TangentWeightMode);
      (function (TangentWeightMode) {
        TangentWeightMode[TangentWeightMode["NONE"] = 0] = "NONE";
        TangentWeightMode[TangentWeightMode["LEFT"] = 1] = "LEFT";
        TangentWeightMode[TangentWeightMode["RIGHT"] = 2] = "RIGHT";
        TangentWeightMode[TangentWeightMode["BOTH"] = 3] = "BOTH";
      })(TangentWeightMode || (exports('TangentWeightMode', TangentWeightMode = {})));

      function solveCubic(coeff0, coeff1, coeff2, coeff3, solutions) {
        const a = coeff2 / coeff3;
        const b = coeff1 / coeff3;
        const c = coeff0 / coeff3;
        const sqrA = a * a;
        const p = 1.0 / 3.0 * (-1.0 / 3 * sqrA + b);
        const q = 1.0 / 2.0 * (2.0 / 27.0 * a * sqrA - 1.0 / 3 * a * b + c);
        const cubicP = p * p * p;
        const d = q * q + cubicP;
        let nSolutions = 0;
        if (isZero(d)) {
          if (isZero(q)) {
            solutions[0] = 0;
            return 1;
          } else {
            const u = Math.cbrt(-q);
            solutions[0] = 2 * u;
            solutions[1] = -u;
            return 2;
          }
        } else if (d < 0) {
          const phi = 1.0 / 3 * Math.acos(-q / Math.sqrt(-cubicP));
          const t = 2 * Math.sqrt(-p);
          solutions[0] = t * Math.cos(phi);
          solutions[1] = -t * Math.cos(phi + Math.PI / 3);
          solutions[2] = -t * Math.cos(phi - Math.PI / 3);
          nSolutions = 3;
        } else {
          const sqrtD = Math.sqrt(d);
          const u = Math.cbrt(sqrtD - q);
          const v = -Math.cbrt(sqrtD + q);
          solutions[0] = u + v;
          nSolutions = 1;
        }
        const sub = 1.0 / 3 * a;
        for (let i = 0; i < nSolutions; ++i) {
          solutions[i] -= sub;
        }
        return nSolutions;
      }
      const EQN_EPS = 1e-9;
      function isZero(x) {
        return x > -EQN_EPS && x < EQN_EPS;
      }

      function applyDecoratedInitializer(target, property, decorators, initializer) {
        return decorators.slice().reverse().reduce(function (decoratedInitializer, decorator) {
          return decorator(target, property, decoratedInitializer) || decoratedInitializer;
        }, initializer);
      }

      const emptyDecorator = () => {};
      const emptyDecoratorFn = () => emptyDecorator;
      const emptySmartClassDecorator = makeSmartClassDecorator(() => {});
      function makeSmartClassDecorator(decorate) {
        return proxyFn;
        function proxyFn(target) {
          if (typeof target === 'function') {
            return decorate(target);
          } else {
            return function (constructor) {
              return decorate(constructor, target);
            };
          }
        }
      }
      function writeEditorClassProperty(constructor, propertyName, value) {
        const cache = getClassCache(constructor);
        if (cache) {
          const proto = getSubDict(cache, 'proto');
          getSubDict(proto, 'editor')[propertyName] = value;
        }
      }
      function makeEditorClassDecoratorFn(propertyName) {
        return value => constructor => {
          writeEditorClassProperty(constructor, propertyName, value);
        };
      }
      const CACHE_KEY = '__ccclassCache__';
      function getClassCache(ctor, decoratorName) {
        return getSubDict(ctor, CACHE_KEY);
      }
      function getSubDict(obj, key) {
        return obj[key] || (obj[key] = {});
      }

      const ccclass$3 = makeSmartClassDecorator((constructor, name) => {
        let base = getSuper(constructor);
        if (base === Object) {
          base = null;
        }
        const proto = {
          name,
          extends: base,
          ctor: constructor
        };
        const cache = constructor[CACHE_KEY];
        if (cache) {
          const decoratedProto = cache.proto;
          if (decoratedProto) {
            mixin(proto, decoratedProto);
          }
          constructor[CACHE_KEY] = undefined;
        }
        const res = CCClass(proto);
        return res;
      });

      const requireComponent = makeEditorClassDecoratorFn('requireComponent');
      const executionOrder = makeEditorClassDecoratorFn('executionOrder');
      const disallowMultiple$1 = emptySmartClassDecorator;

      function property(target, propertyKey, descriptorOrInitializer) {
        let options = null;
        function normalized(target, propertyKey, descriptorOrInitializer) {
          const classStash = getOrCreateClassStash(target);
          const propertyStash = getOrCreateEmptyPropertyStash(target, propertyKey);
          const classConstructor = target.constructor;
          mergePropertyOptions(classStash, propertyStash, classConstructor, propertyKey, options, descriptorOrInitializer);
        }
        if (target === undefined) {
          return property({
            type: undefined
          });
        } else if (typeof propertyKey === 'undefined') {
          options = target;
          return normalized;
        } else {
          normalized(target, propertyKey, descriptorOrInitializer);
          return undefined;
        }
      }
      function getDefaultFromInitializer(initializer) {
        let value;
        try {
          value = initializer();
        } catch (e) {
          return initializer;
        }
        if (typeof value !== 'object' || value === null) {
          return value;
        } else {
          return initializer;
        }
      }
      function extractActualDefaultValues(classConstructor) {
        let dummyObj;
        try {
          dummyObj = new classConstructor();
        } catch (e) {
          return {};
        }
        return dummyObj;
      }
      function getOrCreateClassStash(target) {
        const cache = getClassCache(target.constructor);
        return cache;
      }
      function getOrCreateEmptyPropertyStash(target, propertyKey) {
        var _ref, _properties$_ref;
        const classStash = getClassCache(target.constructor);
        const ccclassProto = getSubDict(classStash, 'proto');
        const properties = getSubDict(ccclassProto, 'properties');
        const propertyStash = (_properties$_ref = properties[_ref = propertyKey]) !== null && _properties$_ref !== void 0 ? _properties$_ref : properties[_ref] = {};
        return propertyStash;
      }
      function getOrCreatePropertyStash(target, propertyKey, descriptorOrInitializer) {
        var _ref2, _properties$_ref2;
        const classStash = getClassCache(target.constructor);
        const ccclassProto = getSubDict(classStash, 'proto');
        const properties = getSubDict(ccclassProto, 'properties');
        const propertyStash = (_properties$_ref2 = properties[_ref2 = propertyKey]) !== null && _properties$_ref2 !== void 0 ? _properties$_ref2 : properties[_ref2] = {};
        propertyStash.__internalFlags |= PropertyStashInternalFlag.STANDALONE;
        if (descriptorOrInitializer && typeof descriptorOrInitializer !== 'function' && (descriptorOrInitializer.get || descriptorOrInitializer.set)) {
          if (descriptorOrInitializer.get) {
            propertyStash.get = descriptorOrInitializer.get;
          }
          if (descriptorOrInitializer.set) {
            propertyStash.set = descriptorOrInitializer.set;
          }
        } else {
          setDefaultValue(classStash, propertyStash, target.constructor, propertyKey, descriptorOrInitializer);
        }
        return propertyStash;
      }
      function mergePropertyOptions(cache, propertyStash, ctor, propertyKey, options, descriptorOrInitializer) {
        let fullOptions;
        const isGetset = descriptorOrInitializer && typeof descriptorOrInitializer !== 'function' && (descriptorOrInitializer.get || descriptorOrInitializer.set);
        if (options) {
          fullOptions = getFullFormOfProperty(options, isGetset);
        }
        const propertyRecord = mixin(propertyStash, fullOptions || options || {});
        if (isGetset) {
          if (descriptorOrInitializer.get) {
            propertyRecord.get = descriptorOrInitializer.get;
          }
          if (descriptorOrInitializer.set) {
            propertyRecord.set = descriptorOrInitializer.set;
          }
        } else {
          setDefaultValue(cache, propertyRecord, ctor, propertyKey, descriptorOrInitializer);
        }
      }
      function setDefaultValue(classStash, propertyStash, classConstructor, propertyKey, descriptorOrInitializer) {
        if (descriptorOrInitializer !== undefined) {
          if (typeof descriptorOrInitializer === 'function') {
            propertyStash.default = getDefaultFromInitializer(descriptorOrInitializer);
          } else if (descriptorOrInitializer === null) ; else if (descriptorOrInitializer.initializer) {
            propertyStash.default = getDefaultFromInitializer(descriptorOrInitializer.initializer);
          }
        } else {
          const actualDefaultValues = classStash.default || (classStash.default = extractActualDefaultValues(classConstructor));
          if (actualDefaultValues.hasOwnProperty(propertyKey)) {
            propertyStash.default = actualDefaultValues[propertyKey];
          }
        }
      }

      const sMetadataTag = Symbol('cc:SerializationMetadata');
      function getSerializationMetadata(constructor) {
        return constructor[sMetadataTag];
      }
      function getOrCreateSerializationMetadata(constructor) {
        var _ref, _ref$sMetadataTag;
        return (_ref$sMetadataTag = (_ref = constructor)[sMetadataTag]) !== null && _ref$sMetadataTag !== void 0 ? _ref$sMetadataTag : _ref[sMetadataTag] = {};
      }

      const serializable$3 = exports('serializable', (target, propertyKey, descriptorOrInitializer) => {
        const propertyStash = getOrCreatePropertyStash(target, propertyKey, descriptorOrInitializer);
        setImplicitSerializable(propertyStash);
      });
      function formerlySerializedAs(name) {
        return (target, propertyKey, descriptorOrInitializer) => {
          const propertyStash = getOrCreatePropertyStash(target, propertyKey, descriptorOrInitializer);
          propertyStash.formerlySerializedAs = name;
          setImplicitSerializable(propertyStash);
        };
      }
      const editorOnly = (target, propertyKey, descriptorOrInitializer) => {
        const propertyStash = getOrCreatePropertyStash(target, propertyKey, descriptorOrInitializer);
        propertyStash.editorOnly = true;
        setImplicitSerializable(propertyStash);
      };
      function setImplicitSerializable(propertyStash) {
        propertyStash.__internalFlags |= PropertyStashInternalFlag.IMPLICIT_SERIALIZABLE;
      }
      const uniquelyReferenced = emptyDecorator ;

      const executeInEditMode = emptySmartClassDecorator;
      const menu = emptyDecoratorFn;
      const playOnFocus = emptySmartClassDecorator;
      const inspector = emptyDecoratorFn;
      const icon = emptyDecoratorFn;
      const help = emptyDecoratorFn;
      const editable$1 = exports('editable', emptyDecorator );
      const visible$1 = exports('visible', emptyDecoratorFn );
      const readOnly = emptyDecorator ;
      const displayName$1 = exports('displayName', emptyDecoratorFn );
      const tooltip = exports('tooltip', emptyDecoratorFn );
      const range = exports('range', emptyDecoratorFn );
      const rangeMin = emptyDecoratorFn ;
      const rangeStep = exports('rangeStep', emptyDecoratorFn );
      const slide = exports('slide', emptyDecorator );
      const displayOrder$1 = exports('displayOrder', emptyDecoratorFn );
      const disallowAnimation = exports('disallowAnimation', emptyDecorator );

      const integer = type$2(CCInteger);
      const float = type$2(CCFloat);
      const boolean = type$2(CCBoolean);
      const string = type$2(CCString);
      function type$2(type) {
        return property({
          type
        });
      }

      const override = exports('override', (target, propertyKey, descriptorOrInitializer) => {
        const propertyStash = getOrCreatePropertyStash(target, propertyKey, descriptorOrInitializer);
        propertyStash.override = true;
      });

      const editorExtrasTag = exports('editorExtrasTag', '__editorExtras__');

      class Empty$1 {}
      const EditorExtendable = exports('EditorExtendable', editorExtendableInternal());
      assertIsTrue(editorExtrasTag === '__editorExtras__', 'editorExtrasTag needs to be updated.');
      function editorExtendableInternal(Base, className) {
        {
          return Base !== null && Base !== void 0 ? Base : Empty$1;
        }
      }

      var _decorator = /*#__PURE__*/Object.freeze({
        __proto__: null,
        uniquelyReferenced: uniquelyReferenced,
        ccclass: ccclass$3,
        property: property,
        requireComponent: requireComponent,
        executionOrder: executionOrder,
        disallowMultiple: disallowMultiple$1,
        executeInEditMode: executeInEditMode,
        menu: menu,
        playOnFocus: playOnFocus,
        inspector: inspector,
        icon: icon,
        help: help,
        type: type$2,
        integer: integer,
        float: float,
        boolean: boolean,
        string: string,
        editable: editable$1,
        tooltip: tooltip,
        visible: visible$1,
        displayName: displayName$1,
        displayOrder: displayOrder$1,
        range: range,
        rangeStep: rangeStep,
        slide: slide,
        disallowAnimation: disallowAnimation,
        override: override,
        formerlySerializedAs: formerlySerializedAs,
        serializable: serializable$3
      });
      exports('_decorator', _decorator);

      const Destroyed$2 = 1 << 0;
      const ToDestroy = 1 << 2;
      const DontSave$1 = 1 << 3;
      const EditorOnly = 1 << 4;
      const Dirty = 1 << 5;
      const DontDestroy = 1 << 6;
      const Destroying$1 = 1 << 7;
      const Deactivating$1 = 1 << 8;
      const LockedInEditor = 1 << 9;
      const HideInHierarchy$1 = 1 << 10;
      const IsOnEnableCalled$2 = 1 << 11;
      const IsEditorOnEnableCalled = 1 << 12;
      const IsPreloadStarted$1 = 1 << 13;
      const IsOnLoadCalled$2 = 1 << 14;
      const IsOnLoadStarted$1 = 1 << 15;
      const IsStartCalled$1 = 1 << 16;
      const IsRotationLocked = 1 << 17;
      const IsScaleLocked = 1 << 18;
      const IsAnchorLocked = 1 << 19;
      const IsSizeLocked = 1 << 20;
      const IsPositionLocked = 1 << 21;
      const PersistentMask$2 = ~(ToDestroy | Dirty | Destroying$1 | DontDestroy | Deactivating$1 | IsPreloadStarted$1 | IsOnLoadStarted$1 | IsOnLoadCalled$2 | IsStartCalled$1 | IsOnEnableCalled$2 | IsEditorOnEnableCalled | IsRotationLocked | IsScaleLocked | IsAnchorLocked | IsSizeLocked | IsPositionLocked);
      const AllHideMasks = DontSave$1 | EditorOnly | LockedInEditor | HideInHierarchy$1;
      const objectsToDestroy = [];
      function compileDestruct(obj, ctor) {
        const shouldSkipId = obj instanceof legacyCC.Node || obj instanceof legacyCC.Component;
        const idToSkip = shouldSkipId ? '_id' : null;
        let key;
        const propsToReset = {};
        for (key in obj) {
          if (obj.hasOwnProperty(key)) {
            if (key === idToSkip) {
              continue;
            }
            switch (typeof obj[key]) {
              case 'string':
                propsToReset[key] = '';
                break;
              case 'object':
              case 'function':
                propsToReset[key] = null;
                break;
            }
          }
        }
        if (CCClass._isCCClass(ctor)) {
          const attrs = legacyCC.Class.Attr.getClassAttrs(ctor);
          const propList = ctor.__props__;
          for (let i = 0; i < propList.length; i++) {
            key = propList[i];
            const attrKey = `${key}`;
            if (attrKey in attrs) {
              if (shouldSkipId && key === '_id') {
                continue;
              }
              switch (typeof attrs[attrKey]) {
                case 'string':
                  propsToReset[key] = '';
                  break;
                case 'object':
                case 'function':
                  propsToReset[key] = null;
                  break;
                case 'undefined':
                  propsToReset[key] = undefined;
                  break;
              }
            }
          }
        }
        {
          let func = '';
          for (key in propsToReset) {
            let statement;
            if (CCClass.IDENTIFIER_RE.test(key)) {
              statement = `o.${key}=`;
            } else {
              statement = `o[${CCClass.escapeForJS(key)}]=`;
            }
            let val = propsToReset[key];
            if (val === '') {
              val = '""';
            }
            func += `${statement + val};\n`;
          }
          return Function('o', func);
        }
      }
      class CCObject {
        static _deferredDestroy() {
          const deleteCount = objectsToDestroy.length;
          for (let i = 0; i < deleteCount; ++i) {
            const obj = objectsToDestroy[i];
            if (!(obj._objFlags & Destroyed$2)) {
              obj._destroyImmediate();
            }
          }
          if (deleteCount === objectsToDestroy.length) {
            objectsToDestroy.length = 0;
          } else {
            objectsToDestroy.splice(0, deleteCount);
          }
        }
        constructor(name = '') {
          this._objFlags = void 0;
          this._name = void 0;
          this._name = name;
          this._objFlags = 0;
        }
        get name() {
          return this._name;
        }
        set name(value) {
          this._name = value;
        }
        set hideFlags(hideFlags) {
          const flags = hideFlags & CCObject.Flags.AllHideMasks;
          this._objFlags = this._objFlags & ~CCObject.Flags.AllHideMasks | flags;
        }
        get hideFlags() {
          return this._objFlags & CCObject.Flags.AllHideMasks;
        }
        get isValid() {
          return !(this._objFlags & Destroyed$2);
        }
        destroy() {
          if (this._objFlags & Destroyed$2) {
            warnID(5000);
            return false;
          }
          if (this._objFlags & ToDestroy) {
            return false;
          }
          this._objFlags |= ToDestroy;
          objectsToDestroy.push(this);
          {
            this._destroy();
          }
          return true;
        }
        _destruct() {
          const ctor = this.constructor;
          let destruct = ctor.__destruct__;
          if (!destruct) {
            destruct = compileDestruct(this, ctor);
            value(ctor, '__destruct__', destruct, true);
          }
          destruct(this);
        }
        _destroyImmediate() {
          var _onPreDestroy, _ref;
          if (this._objFlags & Destroyed$2) {
            errorID(5000);
            return;
          }
          (_onPreDestroy = (_ref = this)._onPreDestroy) === null || _onPreDestroy === void 0 ? void 0 : _onPreDestroy.call(_ref);
          {
            if (this.destruct) {
              this.destruct();
            }
            this._destruct();
          }
          this._objFlags |= Destroyed$2;
        }
      } exports('CCObject', CCObject);
      const prototype = CCObject.prototype;
      prototype._deserialize = null;
      {
        CCClass.fastDefine('cc.Object', CCObject, {
          _name: '',
          _objFlags: 0
        });
      }
      value(CCObject, 'Flags', {
        Destroyed: Destroyed$2,
        DontSave: DontSave$1,
        EditorOnly,
        Dirty,
        DontDestroy,
        PersistentMask: PersistentMask$2,
        Destroying: Destroying$1,
        Deactivating: Deactivating$1,
        LockedInEditor,
        HideInHierarchy: HideInHierarchy$1,
        AllHideMasks,
        IsPreloadStarted: IsPreloadStarted$1,
        IsOnLoadStarted: IsOnLoadStarted$1,
        IsOnLoadCalled: IsOnLoadCalled$2,
        IsOnEnableCalled: IsOnEnableCalled$2,
        IsStartCalled: IsStartCalled$1,
        IsEditorOnEnableCalled,
        IsPositionLocked,
        IsRotationLocked,
        IsScaleLocked,
        IsAnchorLocked,
        IsSizeLocked
      });
      function isCCObject(object) {
        return object instanceof CCObject;
      }
      function isValid(value, strictMode) {
        if (typeof value === 'object') {
          return !!value && !(value._objFlags & (strictMode ? Destroyed$2 | ToDestroy : Destroyed$2));
        } else {
          return typeof value !== 'undefined';
        }
      }
      legacyCC.isValid = isValid;
      {
        copyAllProperties(CCObject, jsb.CCObject, ['prototype', 'length', 'name']);
        copyAllProperties(CCObject.prototype, jsb.CCObject.prototype, ['constructor', 'name', 'hideFlags', 'isValid']);
        exports('CCObject', CCObject = jsb.CCObject);
      }
      legacyCC.Object = CCObject;

      var _dec$$, _class$_, _class2$S, _initializer$N, _initializer2$C, _initializer3$w, _initializer4$r, _class3$v;
      let StorageUnit;
      (function (StorageUnit) {
        StorageUnit[StorageUnit["Uint8"] = 0] = "Uint8";
        StorageUnit[StorageUnit["Uint16"] = 1] = "Uint16";
        StorageUnit[StorageUnit["Uint32"] = 2] = "Uint32";
        StorageUnit[StorageUnit["Int8"] = 3] = "Int8";
        StorageUnit[StorageUnit["Int16"] = 4] = "Int16";
        StorageUnit[StorageUnit["Int32"] = 5] = "Int32";
        StorageUnit[StorageUnit["Float32"] = 6] = "Float32";
        StorageUnit[StorageUnit["Float64"] = 7] = "Float64";
      })(StorageUnit || (StorageUnit = {}));
      let ElementType;
      (function (ElementType) {
        ElementType[ElementType["Scalar"] = 0] = "Scalar";
        ElementType[ElementType["Vec2"] = 1] = "Vec2";
        ElementType[ElementType["Vec3"] = 2] = "Vec3";
        ElementType[ElementType["Vec4"] = 3] = "Vec4";
        ElementType[ElementType["Quat"] = 4] = "Quat";
        ElementType[ElementType["Mat4"] = 5] = "Mat4";
      })(ElementType || (ElementType = {}));
      const elementTypeBits = 3;
      function combineStorageUnitElementType(unit, elementType) {
        return (elementType << elementTypeBits) + unit;
      }
      function extractStorageUnitElementType(combined) {
        return {
          storageUnit: ~(-1 << elementTypeBits) & combined,
          elementType: combined >> elementTypeBits
        };
      }
      let CompactValueTypeArray = exports('CompactValueTypeArray', (_dec$$ = ccclass$3('cc.CompactValueTypeArray'), _dec$$(_class$_ = (_class2$S = (_class3$v = class CompactValueTypeArray {
        constructor() {
          this._byteOffset = _initializer$N && _initializer$N();
          this._unitCount = _initializer2$C && _initializer2$C();
          this._unitElement = _initializer3$w && _initializer3$w();
          this._length = _initializer4$r && _initializer4$r();
        }
        static lengthFor(values, elementType, unit) {
          const elementTraits = getElementTraits(elementType);
          return elementTraits.requiredUnits * values.length * getStorageConstructor(unit).BYTES_PER_ELEMENT;
        }
        static compress(values, elementType, unit, arrayBuffer, byteOffset, presumedByteOffset) {
          const elementTraits = getElementTraits(elementType);
          const storageConstructor = getStorageConstructor(unit);
          const unitCount = elementTraits.requiredUnits * values.length;
          const storage = new storageConstructor(arrayBuffer, byteOffset, unitCount);
          for (let i = 0; i < values.length; ++i) {
            elementTraits.compress(storage, i, values[i]);
          }
          const result = new CompactValueTypeArray();
          result._unitElement = combineStorageUnitElementType(unit, elementType);
          result._byteOffset = presumedByteOffset;
          result._unitCount = unitCount;
          result._length = values.length;
          return result;
        }
        decompress(arrayBuffer) {
          const {
            storageUnit,
            elementType
          } = extractStorageUnitElementType(this._unitElement);
          const elementTraits = getElementTraits(elementType);
          const storageConstructor = getStorageConstructor(storageUnit);
          const storage = new storageConstructor(arrayBuffer, this._byteOffset, this._unitCount);
          const result = new Array(this._length);
          for (let i = 0; i < this._length; ++i) {
            result[i] = elementTraits.decompress(storage, i);
          }
          return result;
        }
      }, _class3$v.StorageUnit = StorageUnit, _class3$v.ElementType = ElementType, _class3$v), (_initializer$N = applyDecoratedInitializer(_class2$S.prototype, "_byteOffset", [serializable$3], function () {
        return 0;
      }), _initializer2$C = applyDecoratedInitializer(_class2$S.prototype, "_unitCount", [serializable$3], function () {
        return 0;
      }), _initializer3$w = applyDecoratedInitializer(_class2$S.prototype, "_unitElement", [serializable$3], function () {
        return combineStorageUnitElementType(StorageUnit.Uint8, ElementType.Scalar);
      }), _initializer4$r = applyDecoratedInitializer(_class2$S.prototype, "_length", [serializable$3], function () {
        return 0;
      })), _class2$S)) || _class$_));
      function getElementTraits(elementType) {
        return BuiltinElementTypeTraits[elementType];
      }
      function getStorageConstructor(unit) {
        switch (unit) {
          case StorageUnit.Uint8:
            return Uint8Array;
          case StorageUnit.Uint16:
            return Uint16Array;
          case StorageUnit.Uint32:
            return Uint32Array;
          case StorageUnit.Int8:
            return Int8Array;
          case StorageUnit.Int16:
            return Int16Array;
          case StorageUnit.Int32:
            return Int32Array;
          case StorageUnit.Float32:
            return Float32Array;
          case StorageUnit.Float64:
            return Float64Array;
        }
      }
      const BuiltinElementTypeTraits = {
        [ElementType.Scalar]: {
          requiredUnits: 1,
          compress(storage, index, value) {
            storage[index] = value;
          },
          decompress(storage, index) {
            return storage[index];
          }
        },
        [ElementType.Vec2]: {
          requiredUnits: 2,
          compress(storage, index, value) {
            storage[index * 2] = value.x;
            storage[index * 2 + 1] = value.y;
          },
          decompress(storage, index) {
            return new Vec3(storage[index * 2], storage[index * 2 + 1]);
          }
        },
        [ElementType.Vec3]: {
          requiredUnits: 3,
          compress(storage, index, value) {
            storage[index * 3] = value.x;
            storage[index * 3 + 1] = value.y;
            storage[index * 3 + 2] = value.z;
          },
          decompress(storage, index) {
            return new Vec3(storage[index * 3], storage[index * 3 + 1], storage[index * 3 + 2]);
          }
        },
        [ElementType.Vec4]: {
          requiredUnits: 4,
          compress(storage, index, value) {
            storage[index * 4] = value.x;
            storage[index * 4 + 1] = value.y;
            storage[index * 4 + 2] = value.z;
            storage[index * 4 + 3] = value.w;
          },
          decompress(storage, index) {
            return new Vec4(storage[index * 4], storage[index * 4 + 1], storage[index * 4 + 2], storage[index * 4 + 3]);
          }
        },
        [ElementType.Quat]: {
          requiredUnits: 4,
          compress(storage, index, value) {
            storage[index * 4] = value.x;
            storage[index * 4 + 1] = value.y;
            storage[index * 4 + 2] = value.z;
            storage[index * 4 + 3] = value.w;
          },
          decompress(storage, index) {
            return new Quat(storage[index * 4], storage[index * 4 + 1], storage[index * 4 + 2], storage[index * 4 + 3]);
          }
        },
        [ElementType.Mat4]: {
          requiredUnits: 16,
          compress(storage, index, value) {
            Mat4.toArray(storage, value, index * 16);
          },
          decompress(storage, index) {
            return Mat4.fromArray(new Mat4(), storage, index * 16);
          }
        }
      };

      const serializeTag = exports('serializeTag', Symbol('[[Serialize]]'));
      const deserializeTag = exports('deserializeTag', Symbol('[[Deserialize]]'));

      legacyCC._decorator = _decorator;

      function constant() {
        return 0;
      }
      function linear(k) {
        return k;
      }
      function quadIn(k) {
        return k * k;
      }
      function quadOut(k) {
        return k * (2 - k);
      }
      function quadInOut(k) {
        k *= 2;
        if (k < 1) {
          return 0.5 * k * k;
        }
        return -0.5 * (--k * (k - 2) - 1);
      }
      function cubicIn(k) {
        return k * k * k;
      }
      function cubicOut(k) {
        return --k * k * k + 1;
      }
      function cubicInOut(k) {
        k *= 2;
        if (k < 1) {
          return 0.5 * k * k * k;
        }
        return 0.5 * ((k -= 2) * k * k + 2);
      }
      function quartIn(k) {
        return k * k * k * k;
      }
      function quartOut(k) {
        return 1 - --k * k * k * k;
      }
      function quartInOut(k) {
        k *= 2;
        if (k < 1) {
          return 0.5 * k * k * k * k;
        }
        return -0.5 * ((k -= 2) * k * k * k - 2);
      }
      function quintIn(k) {
        return k * k * k * k * k;
      }
      function quintOut(k) {
        return --k * k * k * k * k + 1;
      }
      function quintInOut(k) {
        k *= 2;
        if (k < 1) {
          return 0.5 * k * k * k * k * k;
        }
        return 0.5 * ((k -= 2) * k * k * k * k + 2);
      }
      function sineIn(k) {
        if (k === 1) {
          return 1;
        }
        return 1 - Math.cos(k * Math.PI / 2);
      }
      function sineOut(k) {
        return Math.sin(k * Math.PI / 2);
      }
      function sineInOut(k) {
        return 0.5 * (1 - Math.cos(Math.PI * k));
      }
      function expoIn(k) {
        return k === 0 ? 0 : Math.pow(1024, k - 1);
      }
      function expoOut(k) {
        return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
      }
      function expoInOut(k) {
        if (k === 0) {
          return 0;
        }
        if (k === 1) {
          return 1;
        }
        k *= 2;
        if (k < 1) {
          return 0.5 * Math.pow(1024, k - 1);
        }
        return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
      }
      function circIn(k) {
        return 1 - Math.sqrt(1 - k * k);
      }
      function circOut(k) {
        return Math.sqrt(1 - --k * k);
      }
      function circInOut(k) {
        k *= 2;
        if (k < 1) {
          return -0.5 * (Math.sqrt(1 - k * k) - 1);
        }
        return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
      }
      function elasticIn(k) {
        let s;
        let a = 0.1;
        const p = 0.4;
        if (k === 0) {
          return 0;
        }
        if (k === 1) {
          return 1;
        }
        if (!a || a < 1) {
          a = 1;
          s = p / 4;
        } else {
          s = p * Math.asin(1 / a) / (2 * Math.PI);
        }
        return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
      }
      function elasticOut(k) {
        let s;
        let a = 0.1;
        const p = 0.4;
        if (k === 0) {
          return 0;
        }
        if (k === 1) {
          return 1;
        }
        if (!a || a < 1) {
          a = 1;
          s = p / 4;
        } else {
          s = p * Math.asin(1 / a) / (2 * Math.PI);
        }
        return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;
      }
      function elasticInOut(k) {
        let s;
        let a = 0.1;
        const p = 0.4;
        if (k === 0) {
          return 0;
        }
        if (k === 1) {
          return 1;
        }
        if (!a || a < 1) {
          a = 1;
          s = p / 4;
        } else {
          s = p * Math.asin(1 / a) / (2 * Math.PI);
        }
        k *= 2;
        if (k < 1) {
          return -0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
        }
        return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;
      }
      function backIn(k) {
        if (k === 1) {
          return 1;
        }
        const s = 1.70158;
        return k * k * ((s + 1) * k - s);
      }
      function backOut(k) {
        if (k === 0) {
          return 0;
        }
        const s = 1.70158;
        return --k * k * ((s + 1) * k + s) + 1;
      }
      function backInOut(k) {
        const s = 1.70158 * 1.525;
        k *= 2;
        if (k < 1) {
          return 0.5 * (k * k * ((s + 1) * k - s));
        }
        return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
      }
      function bounceIn(k) {
        return 1 - bounceOut(1 - k);
      }
      function bounceOut(k) {
        if (k < 1 / 2.75) {
          return 7.5625 * k * k;
        } else if (k < 2 / 2.75) {
          return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;
        } else if (k < 2.5 / 2.75) {
          return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;
        } else {
          return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;
        }
      }
      function bounceInOut(k) {
        if (k < 0.5) {
          return bounceIn(k * 2) * 0.5;
        }
        return bounceOut(k * 2 - 1) * 0.5 + 0.5;
      }
      function smooth(k) {
        if (k <= 0) {
          return 0;
        }
        if (k >= 1) {
          return 1;
        }
        return k * k * (3 - 2 * k);
      }
      function fade(k) {
        if (k <= 0) {
          return 0;
        }
        if (k >= 1) {
          return 1;
        }
        return k * k * k * (k * (k * 6 - 15) + 10);
      }
      const quadOutIn = _makeOutIn(quadIn, quadOut);
      const cubicOutIn = _makeOutIn(cubicIn, cubicOut);
      const quartOutIn = _makeOutIn(quartIn, quartOut);
      const quintOutIn = _makeOutIn(quintIn, quintOut);
      const sineOutIn = _makeOutIn(sineIn, sineOut);
      const expoOutIn = _makeOutIn(expoIn, expoOut);
      const circOutIn = _makeOutIn(circIn, circOut);
      const elasticOutIn = _makeOutIn(elasticIn, elasticOut);
      const backOutIn = _makeOutIn(backIn, backOut);
      const bounceOutIn = _makeOutIn(bounceIn, bounceOut);
      function _makeOutIn(fnIn, fnOut) {
        return k => {
          if (k < 0.5) {
            return fnOut(k * 2) / 2;
          }
          return fnIn(2 * k - 1) / 2 + 0.5;
        };
      }

      var easing = /*#__PURE__*/Object.freeze({
        __proto__: null,
        constant: constant,
        linear: linear,
        quadIn: quadIn,
        quadOut: quadOut,
        quadInOut: quadInOut,
        cubicIn: cubicIn,
        cubicOut: cubicOut,
        cubicInOut: cubicInOut,
        quartIn: quartIn,
        quartOut: quartOut,
        quartInOut: quartInOut,
        quintIn: quintIn,
        quintOut: quintOut,
        quintInOut: quintInOut,
        sineIn: sineIn,
        sineOut: sineOut,
        sineInOut: sineInOut,
        expoIn: expoIn,
        expoOut: expoOut,
        expoInOut: expoInOut,
        circIn: circIn,
        circOut: circOut,
        circInOut: circInOut,
        elasticIn: elasticIn,
        elasticOut: elasticOut,
        elasticInOut: elasticInOut,
        backIn: backIn,
        backOut: backOut,
        backInOut: backInOut,
        bounceIn: bounceIn,
        bounceOut: bounceOut,
        bounceInOut: bounceInOut,
        smooth: smooth,
        fade: fade,
        quadOutIn: quadOutIn,
        cubicOutIn: cubicOutIn,
        quartOutIn: quartOutIn,
        quintOutIn: quintOutIn,
        sineOutIn: sineOutIn,
        expoOutIn: expoOutIn,
        circOutIn: circOutIn,
        elasticOutIn: elasticOutIn,
        backOutIn: backOutIn,
        bounceOutIn: bounceOutIn
      });
      exports('easing', easing);

      let EasingMethod; exports('EasingMethod', EasingMethod);
      (function (EasingMethod) {
        EasingMethod[EasingMethod["LINEAR"] = 0] = "LINEAR";
        EasingMethod[EasingMethod["CONSTANT"] = 1] = "CONSTANT";
        EasingMethod[EasingMethod["QUAD_IN"] = 2] = "QUAD_IN";
        EasingMethod[EasingMethod["QUAD_OUT"] = 3] = "QUAD_OUT";
        EasingMethod[EasingMethod["QUAD_IN_OUT"] = 4] = "QUAD_IN_OUT";
        EasingMethod[EasingMethod["QUAD_OUT_IN"] = 5] = "QUAD_OUT_IN";
        EasingMethod[EasingMethod["CUBIC_IN"] = 6] = "CUBIC_IN";
        EasingMethod[EasingMethod["CUBIC_OUT"] = 7] = "CUBIC_OUT";
        EasingMethod[EasingMethod["CUBIC_IN_OUT"] = 8] = "CUBIC_IN_OUT";
        EasingMethod[EasingMethod["CUBIC_OUT_IN"] = 9] = "CUBIC_OUT_IN";
        EasingMethod[EasingMethod["QUART_IN"] = 10] = "QUART_IN";
        EasingMethod[EasingMethod["QUART_OUT"] = 11] = "QUART_OUT";
        EasingMethod[EasingMethod["QUART_IN_OUT"] = 12] = "QUART_IN_OUT";
        EasingMethod[EasingMethod["QUART_OUT_IN"] = 13] = "QUART_OUT_IN";
        EasingMethod[EasingMethod["QUINT_IN"] = 14] = "QUINT_IN";
        EasingMethod[EasingMethod["QUINT_OUT"] = 15] = "QUINT_OUT";
        EasingMethod[EasingMethod["QUINT_IN_OUT"] = 16] = "QUINT_IN_OUT";
        EasingMethod[EasingMethod["QUINT_OUT_IN"] = 17] = "QUINT_OUT_IN";
        EasingMethod[EasingMethod["SINE_IN"] = 18] = "SINE_IN";
        EasingMethod[EasingMethod["SINE_OUT"] = 19] = "SINE_OUT";
        EasingMethod[EasingMethod["SINE_IN_OUT"] = 20] = "SINE_IN_OUT";
        EasingMethod[EasingMethod["SINE_OUT_IN"] = 21] = "SINE_OUT_IN";
        EasingMethod[EasingMethod["EXPO_IN"] = 22] = "EXPO_IN";
        EasingMethod[EasingMethod["EXPO_OUT"] = 23] = "EXPO_OUT";
        EasingMethod[EasingMethod["EXPO_IN_OUT"] = 24] = "EXPO_IN_OUT";
        EasingMethod[EasingMethod["EXPO_OUT_IN"] = 25] = "EXPO_OUT_IN";
        EasingMethod[EasingMethod["CIRC_IN"] = 26] = "CIRC_IN";
        EasingMethod[EasingMethod["CIRC_OUT"] = 27] = "CIRC_OUT";
        EasingMethod[EasingMethod["CIRC_IN_OUT"] = 28] = "CIRC_IN_OUT";
        EasingMethod[EasingMethod["CIRC_OUT_IN"] = 29] = "CIRC_OUT_IN";
        EasingMethod[EasingMethod["ELASTIC_IN"] = 30] = "ELASTIC_IN";
        EasingMethod[EasingMethod["ELASTIC_OUT"] = 31] = "ELASTIC_OUT";
        EasingMethod[EasingMethod["ELASTIC_IN_OUT"] = 32] = "ELASTIC_IN_OUT";
        EasingMethod[EasingMethod["ELASTIC_OUT_IN"] = 33] = "ELASTIC_OUT_IN";
        EasingMethod[EasingMethod["BACK_IN"] = 34] = "BACK_IN";
        EasingMethod[EasingMethod["BACK_OUT"] = 35] = "BACK_OUT";
        EasingMethod[EasingMethod["BACK_IN_OUT"] = 36] = "BACK_IN_OUT";
        EasingMethod[EasingMethod["BACK_OUT_IN"] = 37] = "BACK_OUT_IN";
        EasingMethod[EasingMethod["BOUNCE_IN"] = 38] = "BOUNCE_IN";
        EasingMethod[EasingMethod["BOUNCE_OUT"] = 39] = "BOUNCE_OUT";
        EasingMethod[EasingMethod["BOUNCE_IN_OUT"] = 40] = "BOUNCE_IN_OUT";
        EasingMethod[EasingMethod["BOUNCE_OUT_IN"] = 41] = "BOUNCE_OUT_IN";
        EasingMethod[EasingMethod["SMOOTH"] = 42] = "SMOOTH";
        EasingMethod[EasingMethod["FADE"] = 43] = "FADE";
      })(EasingMethod || (exports('EasingMethod', EasingMethod = {})));
      const easingMethodFnMap = {
        [EasingMethod.CONSTANT]: constant,
        [EasingMethod.LINEAR]: linear,
        [EasingMethod.QUAD_IN]: quadIn,
        [EasingMethod.QUAD_OUT]: quadOut,
        [EasingMethod.QUAD_IN_OUT]: quadInOut,
        [EasingMethod.QUAD_OUT_IN]: quadOutIn,
        [EasingMethod.CUBIC_IN]: cubicIn,
        [EasingMethod.CUBIC_OUT]: cubicOut,
        [EasingMethod.CUBIC_IN_OUT]: cubicInOut,
        [EasingMethod.CUBIC_OUT_IN]: cubicOutIn,
        [EasingMethod.QUART_IN]: quartIn,
        [EasingMethod.QUART_OUT]: quartOut,
        [EasingMethod.QUART_IN_OUT]: quartInOut,
        [EasingMethod.QUART_OUT_IN]: quartOutIn,
        [EasingMethod.QUINT_IN]: quintIn,
        [EasingMethod.QUINT_OUT]: quintOut,
        [EasingMethod.QUINT_IN_OUT]: quintInOut,
        [EasingMethod.QUINT_OUT_IN]: quintOutIn,
        [EasingMethod.SINE_IN]: sineIn,
        [EasingMethod.SINE_OUT]: sineOut,
        [EasingMethod.SINE_IN_OUT]: sineInOut,
        [EasingMethod.SINE_OUT_IN]: sineOutIn,
        [EasingMethod.EXPO_IN]: expoIn,
        [EasingMethod.EXPO_OUT]: expoOut,
        [EasingMethod.EXPO_IN_OUT]: expoInOut,
        [EasingMethod.EXPO_OUT_IN]: expoOutIn,
        [EasingMethod.CIRC_IN]: circIn,
        [EasingMethod.CIRC_OUT]: circOut,
        [EasingMethod.CIRC_IN_OUT]: circInOut,
        [EasingMethod.CIRC_OUT_IN]: circOutIn,
        [EasingMethod.ELASTIC_IN]: elasticIn,
        [EasingMethod.ELASTIC_OUT]: elasticOut,
        [EasingMethod.ELASTIC_IN_OUT]: elasticInOut,
        [EasingMethod.ELASTIC_OUT_IN]: elasticOutIn,
        [EasingMethod.BACK_IN]: backIn,
        [EasingMethod.BACK_OUT]: backOut,
        [EasingMethod.BACK_IN_OUT]: backInOut,
        [EasingMethod.BACK_OUT_IN]: backOutIn,
        [EasingMethod.BOUNCE_IN]: bounceIn,
        [EasingMethod.BOUNCE_OUT]: bounceOut,
        [EasingMethod.BOUNCE_IN_OUT]: bounceInOut,
        [EasingMethod.BOUNCE_OUT_IN]: bounceOutIn,
        [EasingMethod.SMOOTH]: smooth,
        [EasingMethod.FADE]: fade
      };
      function getEasingFn(easingMethod) {
        assertIsTrue(easingMethod in easingMethodFnMap);
        return easingMethodFnMap[easingMethod];
      }

      const REAL_KEYFRAME_VALUE_FLAGS_INTERPOLATION_MODE_START = 0;
      const REAL_KEYFRAME_VALUE_FLAGS_INTERPOLATION_MODE_MASK = 0xFF << REAL_KEYFRAME_VALUE_FLAGS_INTERPOLATION_MODE_START;
      const REAL_KEYFRAME_VALUE_FLAGS_TANGENT_WEIGHT_MODE_START = 8;
      const REAL_KEYFRAME_VALUE_FLAGS_TANGENT_WEIGHT_MODE_MASK = 0xFF << REAL_KEYFRAME_VALUE_FLAGS_TANGENT_WEIGHT_MODE_START;
      const REAL_KEYFRAME_VALUE_FLAGS_EASING_METHOD_START = 16;
      const REAL_KEYFRAME_VALUE_FLAGS_EASING_METHOD_MASK = 0xFF << REAL_KEYFRAME_VALUE_FLAGS_EASING_METHOD_START;
      assertIsTrue(REAL_KEYFRAME_VALUE_FLAGS_TANGENT_WEIGHT_MODE_START === REAL_KEYFRAME_VALUE_FLAGS_INTERPOLATION_MODE_START + popCount(REAL_KEYFRAME_VALUE_FLAGS_INTERPOLATION_MODE_MASK));
      assertIsTrue(REAL_KEYFRAME_VALUE_FLAGS_EASING_METHOD_START === REAL_KEYFRAME_VALUE_FLAGS_TANGENT_WEIGHT_MODE_START + popCount(REAL_KEYFRAME_VALUE_FLAGS_TANGENT_WEIGHT_MODE_MASK));
      const REAL_KEYFRAME_VALUE_DEFAULT_FLAGS = RealInterpolationMode.LINEAR << REAL_KEYFRAME_VALUE_FLAGS_INTERPOLATION_MODE_START | TangentWeightMode.NONE << REAL_KEYFRAME_VALUE_FLAGS_TANGENT_WEIGHT_MODE_START | EasingMethod.LINEAR << REAL_KEYFRAME_VALUE_FLAGS_EASING_METHOD_START;
      class RealKeyframeValue extends EditorExtendable {
        constructor(...args) {
          super(...args);
          this.value = 0.0;
          this.rightTangent = 0.0;
          this.rightTangentWeight = 0.0;
          this.leftTangent = 0.0;
          this.leftTangentWeight = 0.0;
          this._flags = REAL_KEYFRAME_VALUE_DEFAULT_FLAGS;
        }
        get interpolationMode() {
          return (this._flags & REAL_KEYFRAME_VALUE_FLAGS_INTERPOLATION_MODE_MASK) >> REAL_KEYFRAME_VALUE_FLAGS_INTERPOLATION_MODE_START;
        }
        set interpolationMode(value) {
          this._flags &= ~REAL_KEYFRAME_VALUE_FLAGS_INTERPOLATION_MODE_MASK;
          this._flags |= value << REAL_KEYFRAME_VALUE_FLAGS_INTERPOLATION_MODE_START;
        }
        get tangentWeightMode() {
          return (this._flags & REAL_KEYFRAME_VALUE_FLAGS_TANGENT_WEIGHT_MODE_MASK) >> REAL_KEYFRAME_VALUE_FLAGS_TANGENT_WEIGHT_MODE_START;
        }
        set tangentWeightMode(value) {
          this._flags &= ~REAL_KEYFRAME_VALUE_FLAGS_TANGENT_WEIGHT_MODE_MASK;
          this._flags |= value << REAL_KEYFRAME_VALUE_FLAGS_TANGENT_WEIGHT_MODE_START;
        }
        get easingMethod() {
          return (this._flags & REAL_KEYFRAME_VALUE_FLAGS_EASING_METHOD_MASK) >> REAL_KEYFRAME_VALUE_FLAGS_EASING_METHOD_START;
        }
        set easingMethod(value) {
          this._flags &= ~REAL_KEYFRAME_VALUE_FLAGS_EASING_METHOD_MASK;
          this._flags |= value << REAL_KEYFRAME_VALUE_FLAGS_EASING_METHOD_START;
        }
      }
      CCClass.fastDefine('cc.RealKeyframeValue', RealKeyframeValue, {
        interpolationMode: RealInterpolationMode.LINEAR,
        tangentWeightMode: TangentWeightMode.NONE,
        value: 0.0,
        rightTangent: 0.0,
        rightTangentWeight: 0.0,
        leftTangent: 0.0,
        leftTangentWeight: 0.0,
        easingMethod: EasingMethod.LINEAR,
        [editorExtrasTag]: undefined
      });
      CCClass.Attr.setClassAttr(RealKeyframeValue, editorExtrasTag, 'editorOnly', true);
      getOrCreateSerializationMetadata(RealKeyframeValue).uniquelyReferenced = true;
      function createRealKeyframeValue(params) {
        const realKeyframeValue = new RealKeyframeValue();
        if (typeof params === 'number') {
          realKeyframeValue.value = params;
        } else {
          const {
            interpolationMode,
            tangentWeightMode,
            value,
            rightTangent,
            rightTangentWeight,
            leftTangent,
            leftTangentWeight,
            easingMethod,
            [editorExtrasTag]: editorExtras
          } = params;
          realKeyframeValue.value = value !== null && value !== void 0 ? value : realKeyframeValue.value;
          realKeyframeValue.rightTangent = rightTangent !== null && rightTangent !== void 0 ? rightTangent : realKeyframeValue.rightTangent;
          realKeyframeValue.rightTangentWeight = rightTangentWeight !== null && rightTangentWeight !== void 0 ? rightTangentWeight : realKeyframeValue.rightTangentWeight;
          realKeyframeValue.leftTangent = leftTangent !== null && leftTangent !== void 0 ? leftTangent : realKeyframeValue.leftTangent;
          realKeyframeValue.leftTangentWeight = leftTangentWeight !== null && leftTangentWeight !== void 0 ? leftTangentWeight : realKeyframeValue.leftTangentWeight;
          realKeyframeValue.interpolationMode = interpolationMode !== null && interpolationMode !== void 0 ? interpolationMode : realKeyframeValue.interpolationMode;
          realKeyframeValue.tangentWeightMode = tangentWeightMode !== null && tangentWeightMode !== void 0 ? tangentWeightMode : realKeyframeValue.tangentWeightMode;
          realKeyframeValue.easingMethod = easingMethod !== null && easingMethod !== void 0 ? easingMethod : realKeyframeValue.easingMethod;
          if (editorExtras) {
            realKeyframeValue[editorExtrasTag] = editorExtras;
          }
        }
        return realKeyframeValue;
      }
      class RealCurve extends KeyframeCurve {
        constructor(...args) {
          super(...args);
          this.preExtrapolation = ExtrapolationMode.CLAMP;
          this.postExtrapolation = ExtrapolationMode.CLAMP;
        }
        evaluate(time) {
          const {
            _times: times,
            _values: values
          } = this;
          const nFrames = times.length;
          if (nFrames === 0) {
            return 0.0;
          }
          const firstTime = times[0];
          const lastTime = times[nFrames - 1];
          if (time < firstTime) {
            const {
              preExtrapolation
            } = this;
            const preValue = values[0];
            if (preExtrapolation === ExtrapolationMode.CLAMP || nFrames < 2) {
              return preValue.value;
            }
            switch (preExtrapolation) {
              case ExtrapolationMode.LINEAR:
                return linearTrend(firstTime, values[0].value, times[1], values[1].value, time);
              case ExtrapolationMode.LOOP:
                time = wrapRepeat(time, firstTime, lastTime);
                break;
              case ExtrapolationMode.PING_PONG:
                time = wrapPingPong(time, firstTime, lastTime);
                break;
              default:
                return preValue.value;
            }
          } else if (time > lastTime) {
            const {
              postExtrapolation
            } = this;
            const preFrame = values[nFrames - 1];
            if (postExtrapolation === ExtrapolationMode.CLAMP || nFrames < 2) {
              return preFrame.value;
            }
            switch (postExtrapolation) {
              case ExtrapolationMode.LINEAR:
                return linearTrend(lastTime, preFrame.value, times[nFrames - 2], values[nFrames - 2].value, time);
              case ExtrapolationMode.LOOP:
                time = wrapRepeat(time, firstTime, lastTime);
                break;
              case ExtrapolationMode.PING_PONG:
                time = wrapPingPong(time, firstTime, lastTime);
                break;
              default:
                return preFrame.value;
            }
          }
          const index = binarySearchEpsilon(times, time);
          if (index >= 0) {
            return values[index].value;
          }
          const iNext = ~index;
          {
            assertIsTrue(iNext !== 0 && iNext !== nFrames && nFrames > 1);
          }
          const iPre = iNext - 1;
          const preTime = times[iPre];
          const preValue = values[iPre];
          const nextTime = times[iNext];
          const nextValue = values[iNext];
          {
            assertIsTrue(nextTime > time && time > preTime);
          }
          const dt = nextTime - preTime;
          const ratio = (time - preTime) / dt;
          return evalBetweenTwoKeyFrames(preTime, preValue, nextTime, nextValue, ratio);
        }
        addKeyFrame(time, value) {
          return super.addKeyFrame(time, createRealKeyframeValue(value));
        }
        assignSorted(times, values) {
          if (values !== undefined) {
            assertIsTrue(Array.isArray(times));
            this.setKeyframes(times.slice(), values.map(value => createRealKeyframeValue(value)));
          } else {
            const keyframes = Array.from(times);
            this.setKeyframes(keyframes.map(([time]) => time), keyframes.map(([, value]) => createRealKeyframeValue(value)));
          }
        }
        isConstant(tolerance) {
          if (this._values.length <= 1) {
            return true;
          }
          const firstVal = this._values[0].value;
          return this._values.every(frame => approx(frame.value, firstVal, tolerance));
        }
        [serializeTag](output, context) {
          if (!context.toCCON) {
            output.writeThis();
            return;
          }
          const {
            _times: times,
            _values: keyframeValues
          } = this;
          const nKeyframes = times.length;
          const dataSize = 0 + OVERFLOW_BYTES + OVERFLOW_BYTES + FRAME_COUNT_BYTES$1 + TIME_BYTES$1 * nKeyframes + REAL_KEY_FRAME_VALUE_MAX_SIZE * nKeyframes;
          const dataView = new DataView(new ArrayBuffer(dataSize));
          let currentOffset = 0;
          dataView.setUint8(currentOffset, this.preExtrapolation);
          currentOffset += OVERFLOW_BYTES;
          dataView.setUint8(currentOffset, this.postExtrapolation);
          currentOffset += OVERFLOW_BYTES;
          dataView.setUint32(currentOffset, nKeyframes, true);
          currentOffset += FRAME_COUNT_BYTES$1;
          times.forEach((time, index) => dataView.setFloat32(currentOffset + TIME_BYTES$1 * index, time, true));
          currentOffset += TIME_BYTES$1 * nKeyframes;
          for (const keyframeValue of keyframeValues) {
            currentOffset = saveRealKeyFrameValue(dataView, keyframeValue, currentOffset);
          }
          const bytes = new Uint8Array(dataView.buffer, 0, currentOffset);
          output.writeProperty('bytes', bytes);
          const keyframeValueEditorExtras = keyframeValues.map(keyframeValue => keyframeValue[editorExtrasTag]);
          if (keyframeValueEditorExtras.some(extras => extras !== undefined)) {
            output.writeProperty(`keyframeValueEditorExtras`, keyframeValueEditorExtras);
          }
        }
        [deserializeTag](input, context) {
          if (!context.fromCCON) {
            input.readThis();
            return;
          }
          const bytes = input.readProperty('bytes');
          const dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
          let currentOffset = 0;
          this.preExtrapolation = dataView.getUint8(currentOffset);
          currentOffset += OVERFLOW_BYTES;
          this.postExtrapolation = dataView.getUint8(currentOffset);
          currentOffset += OVERFLOW_BYTES;
          const nKeyframes = dataView.getUint32(currentOffset, true);
          currentOffset += FRAME_COUNT_BYTES$1;
          const times = Array.from({
            length: nKeyframes
          }, (_, index) => dataView.getFloat32(currentOffset + TIME_BYTES$1 * index, true));
          currentOffset += TIME_BYTES$1 * nKeyframes;
          const keyframeValues = new Array(nKeyframes);
          for (let iKeyFrame = 0; iKeyFrame < nKeyframes; ++iKeyFrame) {
            const keyframeValue = createRealKeyframeValue({});
            currentOffset = loadRealKeyFrameValue(dataView, keyframeValue, currentOffset);
            keyframeValues[iKeyFrame] = keyframeValue;
          }
          assertIsTrue(currentOffset === bytes.byteLength);
          const keyframeValueEditorExtras = input.readProperty(`keyframeValueEditorExtras`);
          if (keyframeValueEditorExtras) {
            assertIsTrue(keyframeValueEditorExtras.length === nKeyframes);
            keyframeValueEditorExtras.forEach((extras, index) => keyframeValues[index][editorExtrasTag] = extras);
          }
          this._times = times;
          this._values = keyframeValues;
        }
      } exports('RealCurve', RealCurve);
      CCClass.fastDefine('cc.RealCurve', RealCurve, {
        _times: [],
        _values: [],
        preExtrapolation: ExtrapolationMode.CLAMP,
        postExtrapolation: ExtrapolationMode.CLAMP
      });
      const FLAGS_EASING_METHOD_BITS_START = 8;
      const FLAG_EASING_METHOD_MASK = 0xFF << FLAGS_EASING_METHOD_BITS_START;
      var KeyframeValueFlagMask$1;
      (function (KeyframeValueFlagMask) {
        KeyframeValueFlagMask[KeyframeValueFlagMask["VALUE"] = 1] = "VALUE";
        KeyframeValueFlagMask[KeyframeValueFlagMask["INTERPOLATION_MODE"] = 2] = "INTERPOLATION_MODE";
        KeyframeValueFlagMask[KeyframeValueFlagMask["TANGENT_WEIGHT_MODE"] = 4] = "TANGENT_WEIGHT_MODE";
        KeyframeValueFlagMask[KeyframeValueFlagMask["LEFT_TANGENT"] = 8] = "LEFT_TANGENT";
        KeyframeValueFlagMask[KeyframeValueFlagMask["LEFT_TANGENT_WEIGHT"] = 16] = "LEFT_TANGENT_WEIGHT";
        KeyframeValueFlagMask[KeyframeValueFlagMask["RIGHT_TANGENT"] = 32] = "RIGHT_TANGENT";
        KeyframeValueFlagMask[KeyframeValueFlagMask["RIGHT_TANGENT_WEIGHT"] = 64] = "RIGHT_TANGENT_WEIGHT";
      })(KeyframeValueFlagMask$1 || (KeyframeValueFlagMask$1 = {}));
      const OVERFLOW_BYTES = 1;
      const FRAME_COUNT_BYTES$1 = 4;
      const TIME_BYTES$1 = 4;
      const KEY_FRAME_VALUE_FLAGS_BYTES = 4;
      const VALUE_BYTES$1 = 4;
      const INTERPOLATION_MODE_BYTES$1 = 1;
      const TANGENT_WEIGHT_MODE_BYTES = 1;
      const LEFT_TANGENT_BYTES = 4;
      const LEFT_TANGENT_WEIGHT_BYTES = 4;
      const RIGHT_TANGENT_BYTES = 4;
      const RIGHT_TANGENT_WEIGHT_BYTES = 4;
      const {
        interpolationMode: DEFAULT_INTERPOLATION_MODE,
        tangentWeightMode: DEFAULT_TANGENT_WEIGHT_MODE,
        leftTangent: DEFAULT_LEFT_TANGENT,
        leftTangentWeight: DEFAULT_LEFT_TANGENT_WEIGHT,
        rightTangent: DEFAULT_RIGHT_TANGENT,
        rightTangentWeight: DEFAULT_RIGHT_TANGENT_WEIGHT
      } = createRealKeyframeValue({});
      const REAL_KEY_FRAME_VALUE_MAX_SIZE = KEY_FRAME_VALUE_FLAGS_BYTES + VALUE_BYTES$1 + INTERPOLATION_MODE_BYTES$1 + TANGENT_WEIGHT_MODE_BYTES + LEFT_TANGENT_BYTES + LEFT_TANGENT_WEIGHT_BYTES + RIGHT_TANGENT_BYTES + RIGHT_TANGENT_WEIGHT_BYTES + 0;
      function saveRealKeyFrameValue(dataView, keyframeValue, offset) {
        let flags = 0;
        let currentOffset = offset;
        const pFlags = currentOffset;
        currentOffset += KEY_FRAME_VALUE_FLAGS_BYTES;
        const {
          value,
          interpolationMode,
          tangentWeightMode,
          rightTangent,
          rightTangentWeight,
          leftTangent,
          leftTangentWeight,
          easingMethod
        } = keyframeValue;
        dataView.setFloat32(currentOffset, value, true);
        currentOffset += VALUE_BYTES$1;
        if (interpolationMode !== DEFAULT_INTERPOLATION_MODE) {
          flags |= KeyframeValueFlagMask$1.INTERPOLATION_MODE;
          dataView.setUint8(currentOffset, interpolationMode);
          currentOffset += INTERPOLATION_MODE_BYTES$1;
        }
        if (tangentWeightMode !== DEFAULT_TANGENT_WEIGHT_MODE) {
          flags |= KeyframeValueFlagMask$1.TANGENT_WEIGHT_MODE;
          dataView.setUint8(currentOffset, tangentWeightMode);
          currentOffset += TANGENT_WEIGHT_MODE_BYTES;
        }
        if (leftTangent !== DEFAULT_LEFT_TANGENT) {
          flags |= KeyframeValueFlagMask$1.LEFT_TANGENT;
          dataView.setFloat32(currentOffset, leftTangent, true);
          currentOffset += LEFT_TANGENT_BYTES;
        }
        if (leftTangentWeight !== DEFAULT_LEFT_TANGENT_WEIGHT) {
          flags |= KeyframeValueFlagMask$1.LEFT_TANGENT_WEIGHT;
          dataView.setFloat32(currentOffset, leftTangentWeight, true);
          currentOffset += LEFT_TANGENT_WEIGHT_BYTES;
        }
        if (rightTangent !== DEFAULT_RIGHT_TANGENT) {
          flags |= KeyframeValueFlagMask$1.RIGHT_TANGENT;
          dataView.setFloat32(currentOffset, rightTangent, true);
          currentOffset += RIGHT_TANGENT_BYTES;
        }
        if (rightTangentWeight !== DEFAULT_RIGHT_TANGENT_WEIGHT) {
          flags |= KeyframeValueFlagMask$1.RIGHT_TANGENT_WEIGHT;
          dataView.setFloat32(currentOffset, rightTangentWeight, true);
          currentOffset += RIGHT_TANGENT_WEIGHT_BYTES;
        }
        flags |= easingMethod << FLAGS_EASING_METHOD_BITS_START;
        dataView.setUint32(pFlags, flags, true);
        return currentOffset;
      }
      function loadRealKeyFrameValue(dataView, keyframeValue, offset) {
        let currentOffset = offset;
        const flags = dataView.getUint32(currentOffset, true);
        currentOffset += KEY_FRAME_VALUE_FLAGS_BYTES;
        keyframeValue.value = dataView.getFloat32(currentOffset, true);
        currentOffset += VALUE_BYTES$1;
        if (flags & KeyframeValueFlagMask$1.INTERPOLATION_MODE) {
          keyframeValue.interpolationMode = dataView.getUint8(currentOffset);
          currentOffset += INTERPOLATION_MODE_BYTES$1;
        }
        if (flags & KeyframeValueFlagMask$1.TANGENT_WEIGHT_MODE) {
          keyframeValue.tangentWeightMode = dataView.getUint8(currentOffset);
          currentOffset += TANGENT_WEIGHT_MODE_BYTES;
        }
        if (flags & KeyframeValueFlagMask$1.LEFT_TANGENT) {
          keyframeValue.leftTangent = dataView.getFloat32(currentOffset, true);
          currentOffset += LEFT_TANGENT_BYTES;
        }
        if (flags & KeyframeValueFlagMask$1.LEFT_TANGENT_WEIGHT) {
          keyframeValue.leftTangentWeight = dataView.getFloat32(currentOffset, true);
          currentOffset += LEFT_TANGENT_WEIGHT_BYTES;
        }
        if (flags & KeyframeValueFlagMask$1.RIGHT_TANGENT) {
          keyframeValue.rightTangent = dataView.getFloat32(currentOffset, true);
          currentOffset += RIGHT_TANGENT_BYTES;
        }
        if (flags & KeyframeValueFlagMask$1.RIGHT_TANGENT_WEIGHT) {
          keyframeValue.rightTangentWeight = dataView.getFloat32(currentOffset, true);
          currentOffset += RIGHT_TANGENT_WEIGHT_BYTES;
        }
        const easingMethod = (flags & FLAG_EASING_METHOD_MASK) >> FLAGS_EASING_METHOD_BITS_START;
        keyframeValue.easingMethod = easingMethod;
        return currentOffset;
      }
      function wrapRepeat(time, prevTime, nextTime) {
        return prevTime + repeat$1(time - prevTime, nextTime - prevTime);
      }
      function wrapPingPong(time, prevTime, nextTime) {
        return prevTime + pingPong(time - prevTime, nextTime - prevTime);
      }
      function linearTrend(prevTime, prevValue, nextTime, nextValue, time) {
        const slope = (nextValue - prevValue) / (nextTime - prevTime);
        return prevValue + (time - prevTime) * slope;
      }
      function evalBetweenTwoKeyFrames(prevTime, prevValue, nextTime, nextValue, ratio) {
        const dt = nextTime - prevTime;
        switch (prevValue.interpolationMode) {
          default:
          case RealInterpolationMode.CONSTANT:
            return prevValue.value;
          case RealInterpolationMode.LINEAR:
            {
              const transformedRatio = prevValue.easingMethod === EasingMethod.LINEAR ? ratio : getEasingFn(prevValue.easingMethod)(ratio);
              return lerp(prevValue.value, nextValue.value, transformedRatio);
            }
          case RealInterpolationMode.CUBIC:
            {
              const ONE_THIRD = 1.0 / 3.0;
              const {
                rightTangent: prevTangent,
                rightTangentWeight: prevTangentWeightSpecified
              } = prevValue;
              const prevTangentWeightEnabled = isRightTangentWeightEnabled(prevValue.tangentWeightMode);
              const {
                leftTangent: nextTangent,
                leftTangentWeight: nextTangentWeightSpecified
              } = nextValue;
              const nextTangentWeightEnabled = isLeftTangentWeightEnabled(nextValue.tangentWeightMode);
              if (!prevTangentWeightEnabled && !nextTangentWeightEnabled) {
                const p1 = prevValue.value + ONE_THIRD * prevTangent * dt;
                const p2 = nextValue.value - ONE_THIRD * nextTangent * dt;
                return bezierInterpolate(prevValue.value, p1, p2, nextValue.value, ratio);
              } else {
                let prevTangentWeight = 0.0;
                if (prevTangentWeightEnabled) {
                  prevTangentWeight = prevTangentWeightSpecified;
                } else {
                  const x = dt;
                  const y = dt * prevTangent;
                  prevTangentWeight = Math.sqrt(x * x + y * y) * ONE_THIRD;
                }
                const angle0 = Math.atan(prevTangent);
                const tx0 = Math.cos(angle0) * prevTangentWeight + prevTime;
                const ty0 = Math.sin(angle0) * prevTangentWeight + prevValue.value;
                let nextTangentWeight = 0.0;
                if (nextTangentWeightEnabled) {
                  nextTangentWeight = nextTangentWeightSpecified;
                } else {
                  const x = dt;
                  const y = dt * nextTangent;
                  nextTangentWeight = Math.sqrt(x * x + y * y) * ONE_THIRD;
                }
                const angle1 = Math.atan(nextTangent);
                const tx1 = -Math.cos(angle1) * nextTangentWeight + nextTime;
                const ty1 = -Math.sin(angle1) * nextTangentWeight + nextValue.value;
                const dx = dt;
                const u0x = (tx0 - prevTime) / dx;
                const u1x = (tx1 - prevTime) / dx;
                const u0y = ty0;
                const u1y = ty1;
                const coeff0 = 0.0;
                const coeff1 = 3.0 * u0x;
                const coeff2 = 3.0 * u1x - 6.0 * u0x;
                const coeff3 = 3.0 * (u0x - u1x) + 1.0;
                const solutions = [0.0, 0.0, 0.0];
                const nSolutions = solveCubic(coeff0 - ratio, coeff1, coeff2, coeff3, solutions);
                const param = getParamFromCubicSolution(solutions, nSolutions, ratio);
                const y = bezierInterpolate(prevValue.value, u0y, u1y, nextValue.value, param);
                return y;
              }
            }
        }
      }
      function isLeftTangentWeightEnabled(tangentWeightMode) {
        return (tangentWeightMode & TangentWeightMode.LEFT) !== 0;
      }
      function isRightTangentWeightEnabled(tangentWeightMode) {
        return (tangentWeightMode & TangentWeightMode.RIGHT) !== 0;
      }
      function bezierInterpolate(p0, p1, p2, p3, t) {
        const u = 1 - t;
        const coeff0 = u * u * u;
        const coeff1 = 3 * u * u * t;
        const coeff2 = 3 * u * t * t;
        const coeff3 = t * t * t;
        return coeff0 * p0 + coeff1 * p1 + coeff2 * p2 + coeff3 * p3;
      }
      function getParamFromCubicSolution(solutions, solutionsCount, x) {
        let param = x;
        if (solutionsCount === 1) {
          param = solutions[0];
        } else {
          param = -Infinity;
          for (let iSolution = 0; iSolution < solutionsCount; ++iSolution) {
            const solution = solutions[iSolution];
            if (solution >= 0.0 && solution <= 1.0) {
              if (solution > param) {
                param = solution;
              }
            }
          }
          if (param === -Infinity) {
            param = 0.0;
          }
        }
        return param;
      }

      function bezier(C1, C2, C3, C4, t) {
        const t1 = 1 - t;
        return t1 * (t1 * (C1 + (C2 * 3 - C1) * t) + C3 * 3 * t * t) + C4 * t * t * t;
      }
      legacyCC.bezier = bezier;
      const cos$2 = Math.cos;
      const acos$1 = Math.acos;
      const max$2 = Math.max;
      const pi = Math.PI;
      const tau = 2 * pi;
      const sqrt = Math.sqrt;
      function crt(v) {
        if (v < 0) {
          return -Math.pow(-v, 1 / 3);
        } else {
          return Math.pow(v, 1 / 3);
        }
      }
      function cardano(curve, x) {
        const pa = x - 0;
        const pb = x - curve[0];
        const pc = x - curve[2];
        const pd = x - 1;
        const pa3 = pa * 3;
        const pb3 = pb * 3;
        const pc3 = pc * 3;
        const d = -pa + pb3 - pc3 + pd;
        const rd = 1 / d;
        const r3 = 1 / 3;
        const a = (pa3 - 6 * pb + pc3) * rd;
        const a3 = a * r3;
        const b = (-pa3 + pb3) * rd;
        const c = pa * rd;
        const p = (3 * b - a * a) * r3;
        const p3 = p * r3;
        const q = (2 * a * a * a - 9 * a * b + 27 * c) / 27;
        const q2 = q / 2;
        const discriminant = q2 * q2 + p3 * p3 * p3;
        let u1;
        let v1;
        let x1;
        let x2;
        let x3;
        if (discriminant < 0) {
          const mp3 = -p * r3;
          const mp33 = mp3 * mp3 * mp3;
          const r = sqrt(mp33);
          const t = -q / (2 * r);
          const cosphi = t < -1 ? -1 : t > 1 ? 1 : t;
          const phi = acos$1(cosphi);
          const crtr = crt(r);
          const t1 = 2 * crtr;
          x1 = t1 * cos$2(phi * r3) - a3;
          x2 = t1 * cos$2((phi + tau) * r3) - a3;
          x3 = t1 * cos$2((phi + 2 * tau) * r3) - a3;
          if (x1 >= 0 && x1 <= 1) {
            if (x2 >= 0 && x2 <= 1) {
              if (x3 >= 0 && x3 <= 1) {
                return max$2(x1, x2, x3);
              } else {
                return max$2(x1, x2);
              }
            } else if (x3 >= 0 && x3 <= 1) {
              return max$2(x1, x3);
            } else {
              return x1;
            }
          } else if (x2 >= 0 && x2 <= 1) {
            if (x3 >= 0 && x3 <= 1) {
              return max$2(x2, x3);
            } else {
              return x2;
            }
          } else {
            return x3;
          }
        } else if (discriminant === 0) {
          u1 = q2 < 0 ? crt(-q2) : -crt(q2);
          x1 = 2 * u1 - a3;
          x2 = -u1 - a3;
          if (x1 >= 0 && x1 <= 1) {
            if (x2 >= 0 && x2 <= 1) {
              return max$2(x1, x2);
            } else {
              return x1;
            }
          } else {
            return x2;
          }
        } else {
          const sd = sqrt(discriminant);
          u1 = crt(-q2 + sd);
          v1 = crt(q2 + sd);
          x1 = u1 - v1 - a3;
          return x1;
        }
      }
      function bezierByTime(controlPoints, x) {
        const percent = cardano(controlPoints, x);
        const p1y = controlPoints[1];
        const p2y = controlPoints[3];
        return ((1 - percent) * (p1y + (p2y - p1y) * percent) * 3 + percent * percent) * percent;
      }
      legacyCC.bezierByTime = bezierByTime;

      var _dec$_, _class$Z, _class2$R, _initializer$M, _initializer2$B, _initializer3$v, _dec2$I, _class4$4, _class5$3, _initializer4$q, _initializer5$l;
      let QuatInterpolationMode; exports('QuatInterpolationMode', QuatInterpolationMode);
      (function (QuatInterpolationMode) {
        QuatInterpolationMode[QuatInterpolationMode["SLERP"] = 0] = "SLERP";
        QuatInterpolationMode[QuatInterpolationMode["CONSTANT"] = 1] = "CONSTANT";
      })(QuatInterpolationMode || (exports('QuatInterpolationMode', QuatInterpolationMode = {})));
      let QuatKeyframeValue = (_dec$_ = ccclass$3('cc.QuatKeyframeValue'), _dec$_(_class$Z = uniquelyReferenced(_class$Z = (_class2$R = class QuatKeyframeValue {
        constructor({
          value,
          interpolationMode,
          easingMethod
        } = {}) {
          this.interpolationMode = _initializer$M && _initializer$M();
          this.value = _initializer2$B && _initializer2$B();
          this.easingMethod = _initializer3$v && _initializer3$v();
          this.value = value ? Quat.clone(value) : this.value;
          this.interpolationMode = interpolationMode !== null && interpolationMode !== void 0 ? interpolationMode : this.interpolationMode;
          this.easingMethod = easingMethod !== null && easingMethod !== void 0 ? easingMethod : this.easingMethod;
        }
      }, (_initializer$M = applyDecoratedInitializer(_class2$R.prototype, "interpolationMode", [serializable$3], function () {
        return QuatInterpolationMode.SLERP;
      }), _initializer2$B = applyDecoratedInitializer(_class2$R.prototype, "value", [serializable$3], function () {
        return Quat.clone(Quat.IDENTITY);
      }), _initializer3$v = applyDecoratedInitializer(_class2$R.prototype, "easingMethod", [serializable$3], function () {
        return EasingMethod.LINEAR;
      })), _class2$R)) || _class$Z) || _class$Z);
      function createQuatKeyframeValue(params) {
        return new QuatKeyframeValue(params);
      }
      let QuatCurve = exports('QuatCurve', (_dec2$I = ccclass$3('cc.QuatCurve'), _dec2$I(_class4$4 = (_class5$3 = class QuatCurve extends KeyframeCurve {
        constructor(...args) {
          super(...args);
          this.preExtrapolation = _initializer4$q && _initializer4$q();
          this.postExtrapolation = _initializer5$l && _initializer5$l();
        }
        evaluate(time, quat) {
          var _quat;
          (_quat = quat) !== null && _quat !== void 0 ? _quat : quat = new Quat();
          const {
            _times: times,
            _values: values,
            postExtrapolation,
            preExtrapolation
          } = this;
          const nFrames = times.length;
          if (nFrames === 0) {
            return quat;
          }
          const firstTime = times[0];
          const lastTime = times[nFrames - 1];
          if (time < firstTime) {
            const preValue = values[0];
            switch (preExtrapolation) {
              case ExtrapolationMode.LOOP:
                time = firstTime + repeat$1(time - firstTime, lastTime - firstTime);
                break;
              case ExtrapolationMode.PING_PONG:
                time = firstTime + pingPong(time - firstTime, lastTime - firstTime);
                break;
              case ExtrapolationMode.CLAMP:
              default:
                return Quat.copy(quat, preValue.value);
            }
          } else if (time > lastTime) {
            const preValue = values[nFrames - 1];
            switch (postExtrapolation) {
              case ExtrapolationMode.LOOP:
                time = firstTime + repeat$1(time - firstTime, lastTime - firstTime);
                break;
              case ExtrapolationMode.PING_PONG:
                time = firstTime + pingPong(time - firstTime, lastTime - firstTime);
                break;
              case ExtrapolationMode.CLAMP:
              default:
                return Quat.copy(quat, preValue.value);
            }
          }
          const index = binarySearchEpsilon(times, time);
          if (index >= 0) {
            return Quat.copy(quat, values[index].value);
          }
          const iNext = ~index;
          assertIsTrue(iNext !== 0 && iNext !== nFrames && nFrames > 1);
          const iPre = iNext - 1;
          const preTime = times[iPre];
          const preValue = values[iPre];
          const nextTime = times[iNext];
          const nextValue = values[iNext];
          assertIsTrue(nextTime > time && time > preTime);
          const dt = nextTime - preTime;
          const ratio = (time - preTime) / dt;
          switch (preValue.interpolationMode) {
            default:
            case QuatInterpolationMode.CONSTANT:
              return Quat.copy(quat, preValue.value);
            case QuatInterpolationMode.SLERP:
              {
                const {
                  easingMethod
                } = preValue;
                const transformedRatio = easingMethod === EasingMethod.LINEAR ? ratio : Array.isArray(easingMethod) ? bezierByTime(easingMethod, ratio) : getEasingFn(easingMethod)(ratio);
                return Quat.slerp(quat, preValue.value, nextValue.value, transformedRatio);
              }
          }
        }
        addKeyFrame(time, value) {
          const keyframeValue = new QuatKeyframeValue(value);
          return super.addKeyFrame(time, keyframeValue);
        }
        assignSorted(times, values) {
          if (values !== undefined) {
            assertIsTrue(Array.isArray(times));
            this.setKeyframes(times.slice(), values.map(value => createQuatKeyframeValue(value)));
          } else {
            const keyframes = Array.from(times);
            this.setKeyframes(keyframes.map(([time]) => time), keyframes.map(([, value]) => createQuatKeyframeValue(value)));
          }
        }
        [serializeTag](output, context) {
          if (!context.toCCON) {
            output.writeThis();
            return;
          }
          const {
            _times: times,
            _values: keyframeValues
          } = this;
          let interpolationModeRepeated = true;
          keyframeValues.forEach((keyframeValue, _index, [firstKeyframeValue]) => {
            if (interpolationModeRepeated && keyframeValue.interpolationMode !== firstKeyframeValue.interpolationMode) {
              interpolationModeRepeated = false;
            }
          });
          const nKeyframes = times.length;
          const nFrames = nKeyframes;
          const interpolationModesSize = INTERPOLATION_MODE_BYTES * (interpolationModeRepeated ? 1 : nFrames);
          const easingMethodsSize = keyframeValues.reduce((result, {
            easingMethod
          }) => result += Array.isArray(easingMethod) ? EASING_METHOD_BYTES + EASING_METHOD_BEZIER_COMPONENT_BYTES * 4 : EASING_METHOD_BYTES, 0);
          let dataSize = 0;
          dataSize += FLAGS_BYTES + FRAME_COUNT_BYTES + TIME_BYTES * nFrames + VALUE_BYTES * 4 * nFrames + easingMethodsSize + interpolationModesSize + 0;
          const dataView = new DataView(new ArrayBuffer(dataSize));
          let P = 0;
          let flags = 0;
          if (interpolationModeRepeated) {
            flags |= KeyframeValueFlagMask.INTERPOLATION_MODE;
          }
          dataView.setUint32(P, flags, true);
          P += FLAGS_BYTES;
          dataView.setUint32(P, nFrames, true);
          P += FRAME_COUNT_BYTES;
          times.forEach((time, index) => dataView.setFloat32(P + TIME_BYTES * index, time, true));
          P += TIME_BYTES * nFrames;
          keyframeValues.forEach(({
            value: {
              x,
              y,
              z,
              w
            }
          }, index) => {
            const pQuat = P + VALUE_BYTES * 4 * index;
            dataView.setFloat32(pQuat + VALUE_BYTES * 0, x, true);
            dataView.setFloat32(pQuat + VALUE_BYTES * 1, y, true);
            dataView.setFloat32(pQuat + VALUE_BYTES * 2, z, true);
            dataView.setFloat32(pQuat + VALUE_BYTES * 3, w, true);
          });
          P += VALUE_BYTES * 4 * nFrames;
          keyframeValues.forEach(({
            easingMethod
          }, index) => {
            if (!Array.isArray(easingMethod)) {
              dataView.setUint8(P, easingMethod);
              ++P;
            } else {
              dataView.setUint8(P, EASING_METHOD_BEZIER_TAG);
              ++P;
              dataView.setFloat32(P + EASING_METHOD_BEZIER_COMPONENT_BYTES * 0, easingMethod[0], true);
              dataView.setFloat32(P + EASING_METHOD_BEZIER_COMPONENT_BYTES * 1, easingMethod[1], true);
              dataView.setFloat32(P + EASING_METHOD_BEZIER_COMPONENT_BYTES * 2, easingMethod[2], true);
              dataView.setFloat32(P + EASING_METHOD_BEZIER_COMPONENT_BYTES * 3, easingMethod[3], true);
              P += EASING_METHOD_BEZIER_COMPONENT_BYTES * 4;
            }
          });
          const INTERPOLATION_MODES_START = P;
          P += interpolationModesSize;
          let pInterpolationMode = INTERPOLATION_MODES_START;
          keyframeValues.forEach(({
            interpolationMode
          }) => {
            dataView.setUint8(pInterpolationMode, interpolationMode);
            if (!interpolationModeRepeated) {
              pInterpolationMode += INTERPOLATION_MODE_BYTES;
            }
          });
          const bytes = new Uint8Array(dataView.buffer);
          output.writeProperty('bytes', bytes);
        }
        [deserializeTag](input, context) {
          if (!context.fromCCON) {
            input.readThis();
            return;
          }
          const bytes = input.readProperty('bytes');
          const dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
          let P = 0;
          const flags = dataView.getUint32(P, true);
          P += FLAGS_BYTES;
          const interpolationModeRepeated = flags & KeyframeValueFlagMask.INTERPOLATION_MODE;
          const nFrames = dataView.getUint32(P, true);
          P += FRAME_COUNT_BYTES;
          const times = Array.from({
            length: nFrames
          }, (_, index) => dataView.getFloat32(P + TIME_BYTES * index, true));
          P += TIME_BYTES * nFrames;
          const P_VALUES = P;
          P += VALUE_BYTES * 4 * nFrames;
          const keyframeValues = Array.from({
            length: nFrames
          }, (_, index) => {
            const pQuat = P_VALUES + VALUE_BYTES * 4 * index;
            const x = dataView.getFloat32(pQuat + VALUE_BYTES * 0, true);
            const y = dataView.getFloat32(pQuat + VALUE_BYTES * 1, true);
            const z = dataView.getFloat32(pQuat + VALUE_BYTES * 2, true);
            const w = dataView.getFloat32(pQuat + VALUE_BYTES * 3, true);
            const easingMethod = dataView.getUint8(P);
            ++P;
            const keyframeValue = createQuatKeyframeValue({
              value: {
                x,
                y,
                z,
                w
              }
            });
            if (easingMethod !== EASING_METHOD_BEZIER_TAG) {
              keyframeValue.easingMethod = easingMethod;
            } else {
              keyframeValue.easingMethod = [dataView.getFloat32(P + EASING_METHOD_BEZIER_COMPONENT_BYTES * 0, true), dataView.getFloat32(P + EASING_METHOD_BEZIER_COMPONENT_BYTES * 1, true), dataView.getFloat32(P + EASING_METHOD_BEZIER_COMPONENT_BYTES * 2, true), dataView.getFloat32(P + EASING_METHOD_BEZIER_COMPONENT_BYTES * 3, true)];
              P += EASING_METHOD_BEZIER_COMPONENT_BYTES * 4;
            }
            return keyframeValue;
          });
          if (interpolationModeRepeated) {
            const interpolationMode = dataView.getUint8(P);
            ++P;
            for (let iKeyframe = 0; iKeyframe < nFrames; ++iKeyframe) {
              keyframeValues[iKeyframe].interpolationMode = interpolationMode;
            }
          } else {
            for (let iKeyframe = 0; iKeyframe < nFrames; ++iKeyframe) {
              const interpolationMode = dataView.getUint8(P + iKeyframe);
              keyframeValues[iKeyframe].interpolationMode = interpolationMode;
            }
            P += nFrames;
          }
          this._times = times;
          this._values = keyframeValues;
        }
      }, (_initializer4$q = applyDecoratedInitializer(_class5$3.prototype, "preExtrapolation", [serializable$3], function () {
        return ExtrapolationMode.CLAMP;
      }), _initializer5$l = applyDecoratedInitializer(_class5$3.prototype, "postExtrapolation", [serializable$3], function () {
        return ExtrapolationMode.CLAMP;
      })), _class5$3)) || _class4$4));
      var KeyframeValueFlagMask;
      (function (KeyframeValueFlagMask) {
        KeyframeValueFlagMask[KeyframeValueFlagMask["INTERPOLATION_MODE"] = 1] = "INTERPOLATION_MODE";
      })(KeyframeValueFlagMask || (KeyframeValueFlagMask = {}));
      const FLAGS_BYTES = 1;
      const FRAME_COUNT_BYTES = 4;
      const TIME_BYTES = 4;
      const VALUE_BYTES = 4;
      const INTERPOLATION_MODE_BYTES = 1;
      const EASING_METHOD_BYTES = 1;
      const EASING_METHOD_BEZIER_TAG = 255;
      const EASING_METHOD_BEZIER_COMPONENT_BYTES = 4;

      var _dec$Z, _class$Y;
      let ObjectCurve = exports('ObjectCurve', (_dec$Z = ccclass$3('cc.ObjectCurve'), _dec$Z(_class$Y = class ObjectCurve extends KeyframeCurve {
        evaluate(time) {
          const iSearch = this.searchKeyframe(time);
          if (iSearch >= 0) {
            return this._values[iSearch];
          }
          const iPrev = clamp$1(~iSearch - 1, 0, this._values.length - 1);
          return this._values[iPrev];
        }
      }) || _class$Y));

      const Mode$1 = Enum({
        Blend: 0,
        Fixed: 1
      });
      class ColorKey {
        constructor() {
          this.color = Color$1.WHITE.clone();
          this.time = 0;
        }
      } exports('ColorKey', ColorKey);
      CCClass.fastDefine('cc.ColorKey', ColorKey, {
        color: Color$1.WHITE.clone(),
        time: 0
      });
      CCClass.Attr.setClassAttr(ColorKey, 'color', 'visible', true);
      CCClass.Attr.setClassAttr(ColorKey, 'time', 'visible', true);
      class AlphaKey {
        constructor() {
          this.alpha = 1;
          this.time = 0;
        }
      } exports('AlphaKey', AlphaKey);
      CCClass.fastDefine('cc.AlphaKey', AlphaKey, {
        alpha: 1,
        time: 0
      });
      CCClass.Attr.setClassAttr(AlphaKey, 'alpha', 'visible', true);
      CCClass.Attr.setClassAttr(AlphaKey, 'time', 'visible', true);
      class Gradient {
        constructor() {
          this.colorKeys = [];
          this.alphaKeys = [];
          this.mode = Mode$1.Blend;
        }
        setKeys(colorKeys, alphaKeys) {
          this.colorKeys = colorKeys;
          this.alphaKeys = alphaKeys;
        }
        sortKeys() {
          if (this.colorKeys.length > 1) {
            this.colorKeys.sort((a, b) => a.time - b.time);
          }
          if (this.alphaKeys.length > 1) {
            this.alphaKeys.sort((a, b) => a.time - b.time);
          }
        }
        evaluate(time) {
          return this.evaluateFast(new Color$1(), time);
        }
        evaluateFast(out, time) {
          this.getRGB(out, time);
          out._set_a_unsafe(this.getAlpha(time));
          return out;
        }
        randomColor() {
          return this.getRandomColor(new Color$1());
        }
        getRandomColor(out) {
          const c = this.colorKeys[Math.trunc(random() * this.colorKeys.length)];
          const a = this.alphaKeys[Math.trunc(random() * this.alphaKeys.length)];
          out.set(c.color);
          out._set_a_unsafe(a.alpha);
          return out;
        }
        getRGB(out, time) {
          const colorKeys = this.colorKeys;
          const length = colorKeys.length;
          if (length > 1) {
            time = repeat$1(time, 1.0 + EPSILON$2);
            for (let i = 1; i < length; ++i) {
              const preTime = colorKeys[i - 1].time;
              const curTime = colorKeys[i].time;
              if (time >= preTime && time < curTime) {
                if (this.mode === Mode$1.Fixed) {
                  Color$1.copy(out, colorKeys[i].color);
                  return out;
                }
                const factor = (time - preTime) / (curTime - preTime);
                Color$1.lerp(out, colorKeys[i - 1].color, colorKeys[i].color, factor);
                return out;
              }
            }
            const lastIndex = length - 1;
            if (approx(time, colorKeys[lastIndex].time, EPSILON$2)) {
              Color$1.copy(out, colorKeys[lastIndex].color);
            } else if (time < colorKeys[0].time) {
              Color$1.lerp(out, Color$1.BLACK, colorKeys[0].color, time / colorKeys[0].time);
            } else if (time > colorKeys[lastIndex].time) {
              Color$1.lerp(out, colorKeys[lastIndex].color, Color$1.BLACK, (time - colorKeys[lastIndex].time) / (1 - colorKeys[lastIndex].time));
            }
          } else if (length === 1) {
            Color$1.copy(out, colorKeys[0].color);
          } else {
            Color$1.copy(out, Color$1.WHITE);
          }
          return out;
        }
        getAlpha(time) {
          const basicAlpha = 0;
          const alphaKeys = this.alphaKeys;
          const length = alphaKeys.length;
          if (length > 1) {
            time = repeat$1(time, 1.0 + EPSILON$2);
            for (let i = 1; i < length; ++i) {
              const preTime = alphaKeys[i - 1].time;
              const curTime = alphaKeys[i].time;
              if (time >= preTime && time < curTime) {
                if (this.mode === Mode$1.Fixed) {
                  return alphaKeys[i].alpha;
                }
                const factor = (time - preTime) / (curTime - preTime);
                return lerp(alphaKeys[i - 1].alpha, alphaKeys[i].alpha, factor);
              }
            }
            const lastIndex = length - 1;
            if (approx(time, alphaKeys[lastIndex].time, EPSILON$2)) {
              return alphaKeys[lastIndex].alpha;
            } else if (time < alphaKeys[0].time) {
              return lerp(basicAlpha, alphaKeys[0].alpha, time / alphaKeys[0].time);
            } else if (time > alphaKeys[lastIndex].time) {
              return lerp(alphaKeys[lastIndex].alpha, basicAlpha, (time - alphaKeys[lastIndex].time) / (1 - alphaKeys[lastIndex].time));
            }
            return 255;
          } else if (length === 1) {
            return alphaKeys[0].alpha;
          } else {
            return 255;
          }
        }
      } exports('Gradient', Gradient);
      Gradient.Mode = Mode$1;
      CCClass.fastDefine('cc.Gradient', Gradient, {
        colorKeys: [],
        alphaKeys: [],
        mode: Mode$1.Blend
      });
      CCClass.Attr.setClassAttr(Gradient, 'colorKeys', 'visible', true);
      CCClass.Attr.setClassAttr(Gradient, 'alphaKeys', 'visible', true);
      CCClass.Attr.setClassAttr(Gradient, 'mode', 'visible', true);

      const LOOK_FORWARD = 3;
      class Keyframe {
        constructor() {
          this.time = 0;
          this.value = 0;
          this.inTangent = 0;
          this.outTangent = 0;
        }
      }
      CCClass.fastDefine('cc.Keyframe', Keyframe, {
        time: 0,
        value: 0,
        inTangent: 0,
        outTangent: 0
      });
      class OptimizedKey {
        constructor() {
          this.index = void 0;
          this.time = void 0;
          this.endTime = void 0;
          this.coefficient = void 0;
          this.index = -1;
          this.time = 0;
          this.endTime = 0;
          this.coefficient = new Float32Array(4);
        }
        evaluate(T) {
          const t = T - this.time;
          return evalOptCurve(t, this.coefficient);
        }
      }
      function evalOptCurve(t, coefs) {
        return t * (t * (t * coefs[0] + coefs[1]) + coefs[2]) + coefs[3];
      }
      class AnimationCurve {
        get _internalCurve() {
          return this._curve;
        }
        get keyFrames() {
          return Array.from(this._curve.keyframes()).map(([time, value]) => {
            const legacyKeyframe = new Keyframe();
            legacyKeyframe.time = time;
            legacyKeyframe.value = value.value;
            legacyKeyframe.inTangent = value.leftTangent;
            legacyKeyframe.outTangent = value.rightTangent;
            return legacyKeyframe;
          });
        }
        set keyFrames(value) {
          this._curve.assignSorted(value.map(legacyCurve => [legacyCurve.time, {
            interpolationMode: RealInterpolationMode.CUBIC,
            value: legacyCurve.value,
            leftTangent: legacyCurve.inTangent,
            rightTangent: legacyCurve.outTangent
          }]));
        }
        get preWrapMode() {
          return toLegacyWrapMode(this._curve.preExtrapolation);
        }
        set preWrapMode(value) {
          this._curve.preExtrapolation = fromLegacyWrapMode(value);
        }
        get postWrapMode() {
          return toLegacyWrapMode(this._curve.postExtrapolation);
        }
        set postWrapMode(value) {
          this._curve.postExtrapolation = fromLegacyWrapMode(value);
        }
        constructor(keyFrames = null) {
          this._curve = void 0;
          this.cachedKey = void 0;
          if (keyFrames instanceof RealCurve) {
            this._curve = keyFrames;
          } else {
            const curve = new RealCurve();
            this._curve = curve;
            curve.preExtrapolation = ExtrapolationMode.LOOP;
            curve.postExtrapolation = ExtrapolationMode.CLAMP;
            if (!keyFrames) {
              curve.assignSorted([[0.0, {
                interpolationMode: RealInterpolationMode.CUBIC,
                value: 1.0
              }], [1.0, {
                interpolationMode: RealInterpolationMode.CUBIC,
                value: 1.0
              }]]);
            } else {
              curve.assignSorted(keyFrames.map(legacyKeyframe => [legacyKeyframe.time, {
                interpolationMode: RealInterpolationMode.CUBIC,
                value: legacyKeyframe.value,
                leftTangent: legacyKeyframe.inTangent,
                rightTangent: legacyKeyframe.outTangent
              }]));
            }
          }
          this.cachedKey = new OptimizedKey();
        }
        addKey(keyFrame) {
          if (!keyFrame) {
            this._curve.clear();
          } else {
            this._curve.addKeyFrame(keyFrame.time, {
              interpolationMode: RealInterpolationMode.CUBIC,
              value: keyFrame.value,
              leftTangent: keyFrame.inTangent,
              rightTangent: keyFrame.outTangent
            });
          }
        }
        evaluate_slow(time) {
          return this._curve.evaluate(time);
        }
        evaluate(time) {
          const {
            cachedKey,
            _curve: curve
          } = this;
          const nKeyframes = curve.keyFramesCount;
          const lastKeyframeIndex = nKeyframes - 1;
          let wrappedTime = time;
          const extrapolationMode = time < 0 ? curve.preExtrapolation : curve.postExtrapolation;
          const startTime = curve.getKeyframeTime(0);
          const endTime = curve.getKeyframeTime(lastKeyframeIndex);
          switch (extrapolationMode) {
            case ExtrapolationMode.LOOP:
              wrappedTime = repeat$1(time - startTime, endTime - startTime) + startTime;
              break;
            case ExtrapolationMode.PING_PONG:
              wrappedTime = pingPong(time - startTime, endTime - startTime) + startTime;
              break;
            case ExtrapolationMode.CLAMP:
            default:
              wrappedTime = clamp$1(time, startTime, endTime);
              break;
          }
          if (wrappedTime >= cachedKey.time && wrappedTime < cachedKey.endTime) {
            return cachedKey.evaluate(wrappedTime);
          }
          const leftIndex = this.findIndex(cachedKey, wrappedTime);
          const rightIndex = Math.min(leftIndex + 1, lastKeyframeIndex);
          this.calcOptimizedKey(cachedKey, leftIndex, rightIndex);
          return cachedKey.evaluate(wrappedTime);
        }
        calcOptimizedKey(optKey, leftIndex, rightIndex) {
          const lhsTime = this._curve.getKeyframeTime(leftIndex);
          const rhsTime = this._curve.getKeyframeTime(rightIndex);
          const {
            value: lhsValue,
            leftTangent: lhsOutTangent
          } = this._curve.getKeyframeValue(leftIndex);
          const {
            value: rhsValue,
            rightTangent: rhsInTangent
          } = this._curve.getKeyframeValue(rightIndex);
          optKey.index = leftIndex;
          optKey.time = lhsTime;
          optKey.endTime = rhsTime;
          const dx = rhsTime - lhsTime;
          const dy = rhsValue - lhsValue;
          const length = 1 / (dx * dx);
          const d1 = lhsOutTangent * dx;
          const d2 = rhsInTangent * dx;
          optKey.coefficient[0] = (d1 + d2 - dy - dy) * length / dx;
          optKey.coefficient[1] = (dy + dy + dy - d1 - d1 - d2) * length;
          optKey.coefficient[2] = lhsOutTangent;
          optKey.coefficient[3] = lhsValue;
        }
        findIndex(optKey, t) {
          const {
            _curve: curve
          } = this;
          const nKeyframes = curve.keyFramesCount;
          const cachedIndex = optKey.index;
          if (cachedIndex !== -1) {
            const cachedTime = curve.getKeyframeTime(cachedIndex);
            if (t > cachedTime) {
              for (let i = 0; i < LOOK_FORWARD; i++) {
                const currIndex = cachedIndex + i;
                if (currIndex + 1 < nKeyframes && curve.getKeyframeTime(currIndex + 1) > t) {
                  return currIndex;
                }
              }
            } else {
              for (let i = 0; i < LOOK_FORWARD; i++) {
                const currIndex = cachedIndex - i;
                if (currIndex >= 0 && curve.getKeyframeTime(currIndex - 1) <= t) {
                  return currIndex - 1;
                }
              }
            }
          }
          let left = 0;
          let right = nKeyframes;
          let mid;
          while (right - left > 1) {
            mid = Math.floor((left + right) / 2);
            if (curve.getKeyframeTime(mid) >= t) {
              right = mid;
            } else {
              left = mid;
            }
          }
          return left;
        }
      }
      AnimationCurve.defaultKF = [{
        time: 0,
        value: 1,
        inTangent: 0,
        outTangent: 0
      }, {
        time: 1,
        value: 1,
        inTangent: 0,
        outTangent: 0
      }];
      CCClass.fastDefine('cc.AnimationCurve', AnimationCurve, {
        _curve: null
      });
      let WrapModeMask;
      (function (WrapModeMask) {
        WrapModeMask[WrapModeMask["Default"] = 0] = "Default";
        WrapModeMask[WrapModeMask["Normal"] = 1] = "Normal";
        WrapModeMask[WrapModeMask["Loop"] = 2] = "Loop";
        WrapModeMask[WrapModeMask["ShouldWrap"] = 4] = "ShouldWrap";
        WrapModeMask[WrapModeMask["Clamp"] = 8] = "Clamp";
        WrapModeMask[WrapModeMask["PingPong"] = 22] = "PingPong";
        WrapModeMask[WrapModeMask["Reverse"] = 36] = "Reverse";
      })(WrapModeMask || (WrapModeMask = {}));
      function fromLegacyWrapMode(legacyWrapMode) {
        switch (legacyWrapMode) {
          default:
          case WrapModeMask.Default:
          case WrapModeMask.Normal:
          case WrapModeMask.Clamp:
            return ExtrapolationMode.CLAMP;
          case WrapModeMask.PingPong:
            return ExtrapolationMode.PING_PONG;
          case WrapModeMask.Loop:
            return ExtrapolationMode.LOOP;
        }
      }
      function toLegacyWrapMode(extrapolationMode) {
        switch (extrapolationMode) {
          default:
          case ExtrapolationMode.LINEAR:
          case ExtrapolationMode.CLAMP:
            return WrapModeMask.Clamp;
          case ExtrapolationMode.PING_PONG:
            return WrapModeMask.PingPong;
          case ExtrapolationMode.LOOP:
            return WrapModeMask.Loop;
        }
      }
      function constructLegacyCurveAndConvert() {
        const curve = new RealCurve();
        curve.assignSorted([[0.0, {
          interpolationMode: RealInterpolationMode.CUBIC,
          value: 1.0
        }], [1.0, {
          interpolationMode: RealInterpolationMode.CUBIC,
          value: 1.0
        }]]);
        return curve;
      }

      let SplineMode;
      (function (SplineMode) {
        SplineMode[SplineMode["LINEAR"] = 0] = "LINEAR";
        SplineMode[SplineMode["BEZIER"] = 1] = "BEZIER";
        SplineMode[SplineMode["CATMULL_ROM"] = 2] = "CATMULL_ROM";
      })(SplineMode || (SplineMode = {}));
      const SPLINE_WHOLE_INDEX = 0xffffffff;
      const _v0 = new Vec3();
      const _v1 = new Vec3();
      const _v2 = new Vec3();
      const _v3 = new Vec3();
      class Spline {
        constructor(mode = SplineMode.CATMULL_ROM, knots = []) {
          this._type = void 0;
          this._mode = SplineMode.CATMULL_ROM;
          this._knots = [];
          this._type = enums.SHAPE_SPLINE;
          this._mode = mode;
          for (let i = 0; i < knots.length; i++) {
            this._knots[i] = new Vec3(knots[i]);
          }
        }
        static create(mode, knots = []) {
          return new Spline(mode, knots);
        }
        static clone(s) {
          return new Spline(s.mode, s.knots);
        }
        static copy(out, s) {
          out._mode = s.mode;
          out._knots.length = 0;
          const knots = s.knots;
          const length = knots.length;
          for (let i = 0; i < length; i++) {
            out._knots[i] = new Vec3(knots[i]);
          }
          return out;
        }
        get type() {
          return this._type;
        }
        get mode() {
          return this._mode;
        }
        get knots() {
          return this._knots;
        }
        setModeAndKnots(mode, knots) {
          this._mode = mode;
          this._knots.length = 0;
          for (let i = 0; i < knots.length; i++) {
            this._knots[i] = new Vec3(knots[i]);
          }
        }
        clearKnots() {
          this._knots.length = 0;
        }
        getKnotCount() {
          return this._knots.length;
        }
        addKnot(knot) {
          this._knots.push(new Vec3(knot));
        }
        insertKnot(index, knot) {
          const item = new Vec3(knot);
          if (index >= this._knots.length) {
            this._knots.push(item);
            return;
          }
          this._knots.splice(index, 0, item);
        }
        removeKnot(index) {
          assertIsTrue(index >= 0 && index < this._knots.length, 'Spline: invalid index');
          this._knots.splice(index, 1);
        }
        setKnot(index, knot) {
          assertIsTrue(index >= 0 && index < this._knots.length, 'Spline: invalid index');
          this._knots[index].set(knot);
        }
        getKnot(index) {
          assertIsTrue(index >= 0 && index < this._knots.length, 'Spline: invalid index');
          return this._knots[index];
        }
        getPoint(t, index = SPLINE_WHOLE_INDEX) {
          t = clamp$1(t, 0.0, 1.0);
          const segments = this.getSegments();
          if (segments === 0) {
            return new Vec3(0.0, 0.0, 0.0);
          }
          if (index === SPLINE_WHOLE_INDEX) {
            const deltaT = 1.0 / segments;
            index = Math.floor(t / deltaT);
            t = t % deltaT / deltaT;
          }
          if (index >= segments) {
            return new Vec3(this._knots[this._knots.length - 1]);
          }
          switch (this._mode) {
            case SplineMode.LINEAR:
              return Spline.calcLinear(this._knots[index], this._knots[index + 1], t);
            case SplineMode.BEZIER:
              return Spline.calcBezier(this._knots[index * 4], this._knots[index * 4 + 1], this._knots[index * 4 + 2], this._knots[index * 4 + 3], t);
            case SplineMode.CATMULL_ROM:
              {
                const v0 = index > 0 ? this._knots[index - 1] : this._knots[index];
                const v3 = index + 2 < this._knots.length ? this._knots[index + 2] : this._knots[index + 1];
                return Spline.calcCatmullRom(v0, this._knots[index], this._knots[index + 1], v3, t);
              }
            default:
              return new Vec3(0.0, 0.0, 0.0);
          }
        }
        getPoints(num, index = SPLINE_WHOLE_INDEX) {
          if (num === 0) {
            return [];
          }
          if (num === 1) {
            const point = this.getPoint(0.0, index);
            return [point];
          }
          const points = [];
          const deltaT = 1.0 / (num - 1.0);
          for (let i = 0; i < num; i++) {
            const t = i * deltaT;
            const point = this.getPoint(t, index);
            points.push(point);
          }
          return points;
        }
        getSegments() {
          const count = this._knots.length;
          switch (this._mode) {
            case SplineMode.LINEAR:
            case SplineMode.CATMULL_ROM:
              if (count < 2) {
                warnID(14300);
                return 0;
              }
              return count - 1;
            case SplineMode.BEZIER:
              if (count < 4 || count % 4 != 0) {
                warnID(14301);
                return 0;
              }
              return count / 4;
            default:
              assertIsTrue(false, 'Spline error: invalid mode');
          }
        }
        static calcLinear(v0, v1, t) {
          const result = new Vec3();
          Vec3.multiplyScalar(_v0, v0, 1.0 - t);
          Vec3.multiplyScalar(_v1, v1, t);
          Vec3.add(result, _v0, _v1);
          return result;
        }
        static calcBezier(v0, v1, v2, v3, t) {
          const result = new Vec3();
          const s = 1.0 - t;
          Vec3.multiplyScalar(_v0, v0, s * s * s);
          Vec3.multiplyScalar(_v1, v1, 3.0 * t * s * s);
          Vec3.multiplyScalar(_v2, v2, 3.0 * t * t * s);
          Vec3.multiplyScalar(_v3, v3, t * t * t);
          Vec3.add(_v0, _v0, _v1);
          Vec3.add(_v2, _v2, _v3);
          Vec3.add(result, _v0, _v2);
          return result;
        }
        static calcCatmullRom(v0, v1, v2, v3, t) {
          const result = new Vec3();
          const t2 = t * t;
          const t3 = t2 * t;
          Vec3.multiplyScalar(_v0, v0, -0.5 * t3 + t2 - 0.5 * t);
          Vec3.multiplyScalar(_v1, v1, 1.5 * t3 - 2.5 * t2 + 1.0);
          Vec3.multiplyScalar(_v2, v2, -1.5 * t3 + 2.0 * t2 + 0.5 * t);
          Vec3.multiplyScalar(_v3, v3, 0.5 * t3 - 0.5 * t2);
          Vec3.add(_v0, _v0, _v1);
          Vec3.add(_v2, _v2, _v3);
          Vec3.add(result, _v0, _v2);
          return result;
        }
      }

      let ERaycastMode;
      (function (ERaycastMode) {
        ERaycastMode[ERaycastMode["ALL"] = 0] = "ALL";
        ERaycastMode[ERaycastMode["CLOSEST"] = 1] = "CLOSEST";
        ERaycastMode[ERaycastMode["ANY"] = 2] = "ANY";
      })(ERaycastMode || (ERaycastMode = {}));

      replaceProperty(intersect, 'intersect', [{
        name: 'ray_aabb',
        newName: 'rayAABB'
      }, {
        name: 'ray_plane',
        newName: 'rayPlane'
      }, {
        name: 'ray_triangle',
        newName: 'rayTriangle'
      }, {
        name: 'ray_sphere',
        newName: 'raySphere'
      }, {
        name: 'ray_obb',
        newName: 'rayOBB'
      }, {
        name: 'ray_capsule',
        newName: 'rayCapsule'
      }, {
        name: 'ray_subMesh',
        newName: 'raySubMesh'
      }, {
        name: 'ray_mesh',
        newName: 'rayMesh'
      }, {
        name: 'ray_model',
        newName: 'rayModel'
      }, {
        name: 'line_plane',
        newName: 'linePlane'
      }, {
        name: 'line_triangle',
        newName: 'lineTriangle'
      }, {
        name: 'line_aabb',
        newName: 'lineAABB'
      }, {
        name: 'line_obb',
        newName: 'lineOBB'
      }, {
        name: 'line_sphere',
        newName: 'lineSphere'
      }, {
        name: 'aabb_aabb',
        newName: 'aabbWithAABB'
      }, {
        name: 'aabb_obb',
        newName: 'aabbWithOBB'
      }, {
        name: 'aabb_plane',
        newName: 'aabbPlane'
      }, {
        name: 'aabb_frustum',
        newName: 'aabbFrustum'
      }, {
        name: 'aabbFrustum_accurate',
        newName: 'aabbFrustumAccurate'
      }, {
        name: 'obb_point',
        newName: 'obbPoint'
      }, {
        name: 'obb_plane',
        newName: 'obbPlane'
      }, {
        name: 'obb_frustum',
        newName: 'obbFrustum'
      }, {
        name: 'obbFrustum_accurate',
        newName: 'obbFrustumAccurate'
      }, {
        name: 'obb_obb',
        newName: 'obbWithOBB'
      }, {
        name: 'obb_capsule',
        newName: 'obbCapsule'
      }, {
        name: 'sphere_plane',
        newName: 'spherePlane'
      }, {
        name: 'sphere_frustum',
        newName: 'sphereFrustum'
      }, {
        name: 'sphereFrustum_accurate',
        newName: 'sphereFrustumAccurate'
      }, {
        name: 'sphere_sphere',
        newName: 'sphereWithSphere'
      }, {
        name: 'sphere_aabb',
        newName: 'sphereAABB'
      }, {
        name: 'sphere_obb',
        newName: 'sphereOBB'
      }, {
        name: 'sphere_capsule',
        newName: 'sphereCapsule'
      }, {
        name: 'capsule_capsule',
        newName: 'capsuleWithCapsule'
      }]);
      function deprecatedClassMessage(oldClassName, newClassName) {
        console.warn(`${oldClassName} is deprecated, please use ${newClassName} instead.`);
      }
      class line extends Line {
        constructor() {
          super();
          deprecatedClassMessage('line', 'Line');
        }
      }
      class plane extends Plane {
        constructor() {
          super();
          deprecatedClassMessage('plane', 'Plane');
        }
      }
      class ray extends Ray {
        constructor() {
          super();
          deprecatedClassMessage('ray', 'Ray');
        }
      }
      class triangle extends Triangle {
        constructor() {
          super();
          deprecatedClassMessage('triangle', 'Triangle');
        }
      }
      class sphere extends Sphere {
        constructor() {
          super();
          deprecatedClassMessage('sphere', 'Sphere');
        }
      }
      class aabb extends AABB {
        constructor() {
          super();
          deprecatedClassMessage('aabb', 'AABB');
        }
      }
      class obb extends OBB {
        constructor() {
          super();
          deprecatedClassMessage('obb', 'OBB');
        }
      }
      class capsule extends Capsule {
        constructor() {
          super();
          deprecatedClassMessage('capsule', 'Capsule');
        }
      }
      class frustum extends Frustum {
        constructor() {
          super();
          deprecatedClassMessage('frustum', 'Frustum');
        }
      }

      var geometry = /*#__PURE__*/Object.freeze({
        __proto__: null,
        distance: distance,
        enums: enums,
        intersect: intersect,
        Line: Line,
        Plane: Plane,
        Ray: Ray,
        Triangle: Triangle,
        Sphere: Sphere,
        AABB: AABB,
        OBB: OBB,
        Capsule: Capsule,
        Frustum: Frustum,
        Keyframe: Keyframe,
        AnimationCurve: AnimationCurve,
        get WrapModeMask () { return WrapModeMask; },
        get SplineMode () { return SplineMode; },
        Spline: Spline,
        constructLegacyCurveAndConvert: constructLegacyCurveAndConvert,
        OptimizedKey: OptimizedKey,
        evalOptCurve: evalOptCurve,
        get ERaycastMode () { return ERaycastMode; },
        line: line,
        plane: plane,
        ray: ray,
        triangle: triangle,
        sphere: sphere,
        aabb: aabb,
        obb: obb,
        capsule: capsule,
        frustum: frustum
      });
      exports('geometry', geometry);

      class ScalableContainer {
        constructor() {
          this._poolHandle = -1;
          scalableContainerManager.addContainer(this);
        }
        destroy() {
          scalableContainerManager.removeContainer(this);
        }
      }
      class ScalableContainerManager {
        constructor() {
          this._pools = [];
          this._lastShrinkPassed = 0;
          this.shrinkTimeSpan = 5;
        }
        addContainer(pool) {
          if (pool._poolHandle !== -1) return;
          pool._poolHandle = this._pools.length;
          this._pools.push(pool);
        }
        removeContainer(pool) {
          if (pool._poolHandle === -1) return;
          this._pools[this._pools.length - 1]._poolHandle = pool._poolHandle;
          fastRemoveAt$2(this._pools, pool._poolHandle);
          pool._poolHandle = -1;
        }
        tryShrink() {
          for (let i = 0; i < this._pools.length; i++) {
            this._pools[i].tryShrink();
          }
        }
        update(dt) {
          this._lastShrinkPassed += dt;
          if (this._lastShrinkPassed > this.shrinkTimeSpan) {
            this.tryShrink();
            this._lastShrinkPassed -= this.shrinkTimeSpan;
          }
        }
      }
      const scalableContainerManager = new ScalableContainerManager();

      class Pool extends ScalableContainer {
        constructor(ctor, elementsPerBatch, dtor) {
          super();
          this._ctor = void 0;
          this._elementsPerBatch = void 0;
          this._nextAvail = void 0;
          this._freePool = [];
          this._dtor = void 0;
          this._ctor = ctor;
          this._dtor = dtor || null;
          this._elementsPerBatch = Math.max(elementsPerBatch, 1);
          this._nextAvail = this._elementsPerBatch - 1;
          for (let i = 0; i < this._elementsPerBatch; ++i) {
            this._freePool.push(ctor());
          }
        }
        alloc() {
          if (this._nextAvail < 0) {
            this._freePool.length = this._elementsPerBatch;
            for (let i = 0; i < this._elementsPerBatch; i++) {
              this._freePool[i] = this._ctor();
            }
            this._nextAvail = this._elementsPerBatch - 1;
          }
          return this._freePool[this._nextAvail--];
        }
        free(obj) {
          this._freePool[++this._nextAvail] = obj;
        }
        freeArray(objs) {
          this._freePool.length = this._nextAvail + 1;
          Array.prototype.push.apply(this._freePool, objs);
          this._nextAvail += objs.length;
        }
        tryShrink() {
          if (this._nextAvail >> 1 > this._elementsPerBatch) {
            if (this._dtor) {
              for (let i = this._nextAvail >> 1; i <= this._nextAvail; i++) {
                this._dtor(this._freePool[i]);
              }
            }
            this._freePool.length = this._nextAvail >> 1;
            this._nextAvail = this._freePool.length - 1;
          }
        }
        destroy() {
          const dtor = arguments.length > 0 ? arguments[0] : null;
          if (dtor) {
            warnID(14100);
          }
          const readDtor = dtor || this._dtor;
          if (readDtor) {
            for (let i = 0; i <= this._nextAvail; i++) {
              readDtor(this._freePool[i]);
            }
          }
          this._freePool.length = 0;
          this._nextAvail = -1;
          super.destroy();
        }
      } exports('Pool', Pool);

      class RecyclePool extends ScalableContainer {
        constructor(fn, size, dtor) {
          super();
          this._fn = void 0;
          this._dtor = null;
          this._count = 0;
          this._data = void 0;
          this._initSize = 0;
          this._fn = fn;
          this._dtor = dtor || null;
          this._data = new Array(size);
          this._initSize = size;
          for (let i = 0; i < size; ++i) {
            this._data[i] = fn();
          }
        }
        get length() {
          return this._count;
        }
        get data() {
          return this._data;
        }
        reset() {
          this._count = 0;
        }
        resize(size) {
          if (size > this._data.length) {
            for (let i = this._data.length; i < size; ++i) {
              this._data[i] = this._fn();
            }
          }
        }
        add() {
          if (this._count >= this._data.length) {
            this.resize(this._data.length << 1);
          }
          return this._data[this._count++];
        }
        destroy() {
          if (this._dtor) {
            for (let i = 0; i < this._data.length; i++) {
              this._dtor(this._data[i]);
            }
          }
          this._data.length = 0;
          this._count = 0;
          super.destroy();
        }
        tryShrink() {
          if (this._data.length >> 2 > this._count) {
            const length = Math.max(this._initSize, this._data.length >> 1);
            if (this._dtor) {
              for (let i = length; i < this._data.length; i++) {
                this._dtor(this._data[i]);
              }
            }
            this._data.length = length;
          }
        }
        removeAt(idx) {
          if (idx >= this._count) {
            return;
          }
          const last = this._count - 1;
          const tmp = this._data[idx];
          this._data[idx] = this._data[last];
          this._data[last] = tmp;
          this._count -= 1;
        }
      } exports('RecyclePool', RecyclePool);

      class CachedArray extends ScalableContainer {
        constructor(length, compareFn) {
          super();
          this.array = void 0;
          this.length = 0;
          this._compareFn = void 0;
          this._initSize = 0;
          this.array = new Array(length);
          this._initSize = length;
          this.length = 0;
          this._compareFn = compareFn;
        }
        push(item) {
          this.array[this.length++] = item;
        }
        pop() {
          return this.array[--this.length];
        }
        get(idx) {
          return this.array[idx];
        }
        clear() {
          this.length = 0;
        }
        destroy() {
          this.length = 0;
          this.array.length = 0;
          super.destroy();
        }
        tryShrink() {
          if (this.array.length >> 2 > this.length) {
            this.array.length = Math.max(this._initSize, this.array.length >> 1);
          }
        }
        sort() {
          this.array.length = this.length;
          this.array.sort(this._compareFn);
        }
        concat(array) {
          for (let i = 0; i < array.length; ++i) {
            this.array[this.length++] = array[i];
          }
        }
        fastRemove(idx) {
          if (idx >= this.length || idx < 0) {
            return;
          }
          const last = --this.length;
          this.array[idx] = this.array[last];
        }
        indexOf(val) {
          for (let i = 0, len = this.length; i < len; ++i) {
            if (this.array[i] === val) {
              return i;
            }
          }
          return -1;
        }
      } exports('CachedArray', CachedArray);

      var index$2 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        Pool: Pool,
        RecyclePool: RecyclePool,
        CachedArray: CachedArray
      });
      exports('memop', index$2);

      class System {
        constructor() {
          this._id = '';
          this._priority = 0;
          this._executeInEditMode = false;
        }
        set priority(value) {
          this._priority = value;
        }
        get priority() {
          return this._priority;
        }
        set id(id) {
          this._id = id;
        }
        get id() {
          return this._id;
        }
        static sortByPriority(a, b) {
          if (a._priority < b._priority) {
            return 1;
          } else if (a._priority > b.priority) {
            return -1;
          } else {
            return 0;
          }
        }
        init() {}
        update(dt) {}
        postUpdate(dt) {}
        destroy() {}
      } exports('System', System);
      System.Priority = Enum({
        LOW: 0,
        MEDIUM: 100,
        HIGH: 200,
        SCHEDULER: 1 << 31 >>> 0
      });

      const MAX_POOL_SIZE$1 = 20;
      const idGenerator$1 = new IDGenerator('Scheduler');
      class ListEntry {
        static get(target, priority, paused, markedForDeletion) {
          let result = ListEntry._listEntries.pop();
          if (result) {
            result.target = target;
            result.priority = priority;
            result.paused = paused;
            result.markedForDeletion = markedForDeletion;
          } else {
            result = new ListEntry(target, priority, paused, markedForDeletion);
          }
          return result;
        }
        static put(entry) {
          if (ListEntry._listEntries.length < MAX_POOL_SIZE$1) {
            entry.target = null;
            ListEntry._listEntries.push(entry);
          }
        }
        constructor(target, priority, paused, markedForDeletion) {
          this.target = void 0;
          this.priority = void 0;
          this.paused = void 0;
          this.markedForDeletion = void 0;
          this.target = target;
          this.priority = priority;
          this.paused = paused;
          this.markedForDeletion = markedForDeletion;
        }
      }
      ListEntry._listEntries = [];
      class HashUpdateEntry {
        static get(list, entry, target, callback) {
          let result = HashUpdateEntry._hashUpdateEntries.pop();
          if (result) {
            result.list = list;
            result.entry = entry;
            result.target = target;
            result.callback = callback;
          } else {
            result = new HashUpdateEntry(list, entry, target, callback);
          }
          return result;
        }
        static put(entry) {
          if (HashUpdateEntry._hashUpdateEntries.length < MAX_POOL_SIZE$1) {
            entry.list = entry.entry = entry.target = entry.callback = null;
            HashUpdateEntry._hashUpdateEntries.push(entry);
          }
        }
        constructor(list, entry, target, callback) {
          this.list = void 0;
          this.entry = void 0;
          this.target = void 0;
          this.callback = void 0;
          this.list = list;
          this.entry = entry;
          this.target = target;
          this.callback = callback;
        }
      }
      HashUpdateEntry._hashUpdateEntries = [];
      class HashTimerEntry {
        static get(timers, target, timerIndex, currentTimer, currentTimerSalvaged, paused) {
          let result = HashTimerEntry._hashTimerEntries.pop();
          if (result) {
            result.timers = timers;
            result.target = target;
            result.timerIndex = timerIndex;
            result.currentTimer = currentTimer;
            result.currentTimerSalvaged = currentTimerSalvaged;
            result.paused = paused;
          } else {
            result = new HashTimerEntry(timers, target, timerIndex, currentTimer, currentTimerSalvaged, paused);
          }
          return result;
        }
        static put(entry) {
          if (HashTimerEntry._hashTimerEntries.length < MAX_POOL_SIZE$1) {
            entry.timers = entry.target = entry.currentTimer = null;
            HashTimerEntry._hashTimerEntries.push(entry);
          }
        }
        constructor(timers, target, timerIndex, currentTimer, currentTimerSalvaged, paused) {
          this.timers = void 0;
          this.target = void 0;
          this.timerIndex = void 0;
          this.currentTimer = void 0;
          this.currentTimerSalvaged = void 0;
          this.paused = void 0;
          this.timers = timers;
          this.target = target;
          this.timerIndex = timerIndex;
          this.currentTimer = currentTimer;
          this.currentTimerSalvaged = currentTimerSalvaged;
          this.paused = paused;
        }
      }
      HashTimerEntry._hashTimerEntries = [];
      class CallbackTimer {
        static get() {
          return CallbackTimer._timers.pop() || new CallbackTimer();
        }
        static put(timer) {
          if (CallbackTimer._timers.length < MAX_POOL_SIZE$1 && !timer._lock) {
            timer._scheduler = timer._target = timer._callback = null;
            CallbackTimer._timers.push(timer);
          }
        }
        constructor() {
          this._lock = void 0;
          this._scheduler = void 0;
          this._elapsed = void 0;
          this._runForever = void 0;
          this._useDelay = void 0;
          this._timesExecuted = void 0;
          this._repeat = void 0;
          this._delay = void 0;
          this._interval = void 0;
          this._target = void 0;
          this._callback = void 0;
          this._lock = false;
          this._scheduler = null;
          this._elapsed = -1;
          this._runForever = false;
          this._useDelay = false;
          this._timesExecuted = 0;
          this._repeat = 0;
          this._delay = 0;
          this._interval = 0;
          this._target = null;
        }
        initWithCallback(scheduler, callback, target, seconds, repeat, delay) {
          this._lock = false;
          this._scheduler = scheduler;
          this._target = target;
          this._callback = callback;
          this._elapsed = -1;
          this._interval = seconds;
          this._delay = delay;
          this._useDelay = this._delay > 0;
          this._repeat = repeat;
          this._runForever = this._repeat === legacyCC.macro.REPEAT_FOREVER;
          return true;
        }
        getInterval() {
          return this._interval;
        }
        setInterval(interval) {
          this._interval = interval;
        }
        update(dt) {
          if (this._elapsed === -1) {
            this._elapsed = 0;
            this._timesExecuted = 0;
          } else {
            this._elapsed += dt;
            if (this._runForever && !this._useDelay) {
              if (this._elapsed >= this._interval) {
                this.trigger();
                this._elapsed = 0;
              }
            } else {
              if (this._useDelay) {
                if (this._elapsed >= this._delay) {
                  this.trigger();
                  this._elapsed -= this._delay;
                  this._timesExecuted += 1;
                  this._useDelay = false;
                }
              } else if (this._elapsed >= this._interval) {
                this.trigger();
                this._elapsed = 0;
                this._timesExecuted += 1;
              }
              if (this._callback && !this._runForever && this._timesExecuted > this._repeat) {
                this.cancel();
              }
            }
          }
        }
        getCallback() {
          return this._callback;
        }
        trigger() {
          if (this._target && this._callback) {
            this._lock = true;
            this._callback.call(this._target, this._elapsed);
            this._lock = false;
          }
        }
        cancel() {
          if (this._scheduler && this._callback && this._target) {
            this._scheduler.unschedule(this._callback, this._target);
          }
        }
      }
      CallbackTimer._timers = [];
      class Scheduler extends System {
        static enableForTarget(target) {
          let found = false;
          if (target.uuid) {
            found = true;
          } else if (target.id) {
            found = true;
          }
          if (!found) {
            target.id = idGenerator$1.getNewId();
          }
        }
        constructor() {
          super();
          this._timeScale = void 0;
          this._updatesNegList = void 0;
          this._updates0List = void 0;
          this._updatesPosList = void 0;
          this._hashForUpdates = void 0;
          this._hashForTimers = void 0;
          this._currentTarget = void 0;
          this._currentTargetSalvaged = void 0;
          this._updateHashLocked = void 0;
          this._arrayForTimers = void 0;
          this._timeScale = 1.0;
          this._updatesNegList = [];
          this._updates0List = [];
          this._updatesPosList = [];
          this._hashForUpdates = createMap(true);
          this._hashForTimers = createMap(true);
          this._currentTarget = null;
          this._currentTargetSalvaged = false;
          this._updateHashLocked = false;
          this._arrayForTimers = [];
        }
        setTimeScale(timeScale) {
          this._timeScale = timeScale;
        }
        getTimeScale() {
          return this._timeScale;
        }
        update(dt) {
          this._updateHashLocked = true;
          if (this._timeScale !== 1) {
            dt *= this._timeScale;
          }
          let i;
          let list;
          let len;
          let entry;
          for (i = 0, list = this._updatesNegList, len = list.length; i < len; i++) {
            entry = list[i];
            if (!entry.paused && !entry.markedForDeletion && entry.target) {
              var _entry$target$update, _entry$target;
              (_entry$target$update = (_entry$target = entry.target).update) === null || _entry$target$update === void 0 ? void 0 : _entry$target$update.call(_entry$target, dt);
            }
          }
          for (i = 0, list = this._updates0List, len = list.length; i < len; i++) {
            entry = list[i];
            if (!entry.paused && !entry.markedForDeletion && entry.target) {
              var _entry$target$update2, _entry$target2;
              (_entry$target$update2 = (_entry$target2 = entry.target).update) === null || _entry$target$update2 === void 0 ? void 0 : _entry$target$update2.call(_entry$target2, dt);
            }
          }
          for (i = 0, list = this._updatesPosList, len = list.length; i < len; i++) {
            entry = list[i];
            if (!entry.paused && !entry.markedForDeletion && entry.target) {
              var _entry$target$update3, _entry$target3;
              (_entry$target$update3 = (_entry$target3 = entry.target).update) === null || _entry$target$update3 === void 0 ? void 0 : _entry$target$update3.call(_entry$target3, dt);
            }
          }
          let elt;
          const arr = this._arrayForTimers;
          for (i = 0; i < arr.length; i++) {
            var _this$_currentTarget$;
            elt = arr[i];
            this._currentTarget = elt;
            this._currentTargetSalvaged = false;
            if (!elt.paused && elt.timers) {
              for (elt.timerIndex = 0; elt.timerIndex < elt.timers.length; ++elt.timerIndex) {
                elt.currentTimer = elt.timers[elt.timerIndex];
                elt.currentTimerSalvaged = false;
                elt.currentTimer.update(dt);
                elt.currentTimer = null;
              }
            }
            if (this._currentTargetSalvaged && ((_this$_currentTarget$ = this._currentTarget.timers) === null || _this$_currentTarget$ === void 0 ? void 0 : _this$_currentTarget$.length) === 0) {
              this._removeHashElement(this._currentTarget);
              --i;
            }
          }
          for (i = 0, list = this._updatesNegList; i < list.length;) {
            entry = list[i];
            if (entry.markedForDeletion) {
              this._removeUpdateFromHash(entry);
            } else {
              i++;
            }
          }
          for (i = 0, list = this._updates0List; i < list.length;) {
            entry = list[i];
            if (entry.markedForDeletion) {
              this._removeUpdateFromHash(entry);
            } else {
              i++;
            }
          }
          for (i = 0, list = this._updatesPosList; i < list.length;) {
            entry = list[i];
            if (entry.markedForDeletion) {
              this._removeUpdateFromHash(entry);
            } else {
              i++;
            }
          }
          this._updateHashLocked = false;
          this._currentTarget = null;
        }
        schedule(callbackTmp, targetTmp, interval, repeat, delay, paused) {
          var _repeat, _delay;
          let callback;
          let target;
          if (typeof callbackTmp !== 'function') {
            warnID(1514);
            callback = targetTmp;
            target = callbackTmp;
          } else {
            callback = callbackTmp;
            target = targetTmp;
          }
          if (arguments.length === 3 || arguments.length === 4 || arguments.length === 5) {
            paused = !!repeat;
            repeat = legacyCC.macro.REPEAT_FOREVER;
            delay = 0;
          }
          assertID(Boolean(target), 1502);
          const targetId = target.uuid || target.id;
          if (!targetId) {
            errorID(1510);
            return;
          }
          let element = this._hashForTimers[targetId];
          if (!element) {
            element = HashTimerEntry.get(null, target, 0, null, false, Boolean(paused));
            this._arrayForTimers.push(element);
            this._hashForTimers[targetId] = element;
          } else if (element.paused !== paused) {
            warnID(1511);
          }
          let timer;
          let i;
          if (element.timers == null) {
            element.timers = [];
          } else {
            for (i = 0; i < element.timers.length; ++i) {
              timer = element.timers[i];
              if (timer && callback === timer.getCallback()) {
                logID(1507, timer.getInterval(), interval);
                timer.setInterval(interval);
                return;
              }
            }
          }
          timer = CallbackTimer.get();
          timer.initWithCallback(this, callback, target, interval, (_repeat = repeat) !== null && _repeat !== void 0 ? _repeat : 0, (_delay = delay) !== null && _delay !== void 0 ? _delay : 0);
          element.timers.push(timer);
          if (this._currentTarget === element && this._currentTargetSalvaged) {
            this._currentTargetSalvaged = false;
          }
        }
        scheduleUpdate(target, priority, paused) {
          const targetId = target.uuid || target.id;
          if (!targetId) {
            errorID(1510);
            return;
          }
          const hashElement = this._hashForUpdates[targetId];
          if (hashElement && hashElement.entry) {
            if (hashElement.entry.priority !== priority) {
              if (this._updateHashLocked) {
                logID(1506);
                hashElement.entry.markedForDeletion = false;
                hashElement.entry.paused = paused;
                return;
              } else {
                this.unscheduleUpdate(target);
              }
            } else {
              hashElement.entry.markedForDeletion = false;
              hashElement.entry.paused = paused;
              return;
            }
          }
          const listElement = ListEntry.get(target, priority, paused, false);
          let ppList;
          if (priority === 0) {
            ppList = this._updates0List;
            this._appendIn(ppList, listElement);
          } else {
            ppList = priority < 0 ? this._updatesNegList : this._updatesPosList;
            this._priorityIn(ppList, listElement, priority);
          }
          this._hashForUpdates[targetId] = HashUpdateEntry.get(ppList, listElement, target, null);
        }
        unschedule(callback, target) {
          if (!target || !callback) {
            return;
          }
          const targetId = target.uuid || target.id;
          if (!targetId) {
            errorID(1510);
            return;
          }
          const element = this._hashForTimers[targetId];
          if (element) {
            const timers = element.timers;
            if (!timers) {
              return;
            }
            for (let i = 0, li = timers.length; i < li; i++) {
              const timer = timers[i];
              if (callback === timer.getCallback()) {
                if (timer === element.currentTimer && !element.currentTimerSalvaged) {
                  element.currentTimerSalvaged = true;
                }
                timers.splice(i, 1);
                CallbackTimer.put(timer);
                if (element.timerIndex >= i) {
                  element.timerIndex--;
                }
                if (timers.length === 0) {
                  if (this._currentTarget === element) {
                    this._currentTargetSalvaged = true;
                  } else {
                    this._removeHashElement(element);
                  }
                }
                return;
              }
            }
          }
        }
        unscheduleUpdate(target) {
          if (!target) {
            return;
          }
          const targetId = target.uuid || target.id;
          if (!targetId) {
            errorID(1510);
            return;
          }
          const element = this._hashForUpdates[targetId];
          if (element !== null && element !== void 0 && element.entry) {
            if (this._updateHashLocked) {
              element.entry.markedForDeletion = true;
            } else {
              this._removeUpdateFromHash(element.entry);
            }
          }
        }
        unscheduleAllForTarget(target) {
          if (!target) {
            return;
          }
          const targetId = target.uuid || target.id;
          if (!targetId) {
            errorID(1510);
            return;
          }
          const element = this._hashForTimers[targetId];
          if (element !== null && element !== void 0 && element.timers) {
            const timers = element.timers;
            if (element.currentTimer && timers.indexOf(element.currentTimer) > -1 && !element.currentTimerSalvaged) {
              element.currentTimerSalvaged = true;
            }
            for (let i = 0, l = timers.length; i < l; i++) {
              CallbackTimer.put(timers[i]);
            }
            timers.length = 0;
            if (this._currentTarget === element) {
              this._currentTargetSalvaged = true;
            } else {
              this._removeHashElement(element);
            }
          }
          this.unscheduleUpdate(target);
        }
        unscheduleAll() {
          this.unscheduleAllWithMinPriority(System.Priority.SCHEDULER);
        }
        unscheduleAllWithMinPriority(minPriority) {
          let i;
          let element;
          const arr = this._arrayForTimers;
          for (i = arr.length - 1; i >= 0; i--) {
            element = arr[i];
            if (element.target) {
              this.unscheduleAllForTarget(element.target);
            }
          }
          let entry;
          let temp_length = 0;
          if (minPriority < 0) {
            for (i = 0; i < this._updatesNegList.length;) {
              var _entry;
              temp_length = this._updatesNegList.length;
              entry = this._updatesNegList[i];
              if ((_entry = entry) !== null && _entry !== void 0 && _entry.target && entry.priority >= minPriority) {
                this.unscheduleUpdate(entry.target);
              }
              if (temp_length === this._updatesNegList.length) {
                i++;
              }
            }
          }
          if (minPriority <= 0) {
            for (i = 0; i < this._updates0List.length;) {
              var _entry2;
              temp_length = this._updates0List.length;
              entry = this._updates0List[i];
              if ((_entry2 = entry) !== null && _entry2 !== void 0 && _entry2.target) {
                this.unscheduleUpdate(entry.target);
              }
              if (temp_length === this._updates0List.length) {
                i++;
              }
            }
          }
          for (i = 0; i < this._updatesPosList.length;) {
            var _entry3;
            temp_length = this._updatesPosList.length;
            entry = this._updatesPosList[i];
            if ((_entry3 = entry) !== null && _entry3 !== void 0 && _entry3.target && entry.priority >= minPriority) {
              this.unscheduleUpdate(entry.target);
            }
            if (temp_length === this._updatesPosList.length) {
              i++;
            }
          }
        }
        isScheduled(callback, target) {
          assertID(Boolean(callback), 1508);
          assertID(Boolean(target), 1509);
          const targetId = target.uuid || target.id;
          if (!targetId) {
            errorID(1510);
            return false;
          }
          const element = this._hashForTimers[targetId];
          if (!element) {
            return false;
          }
          if (element.timers == null) {
            return false;
          } else {
            const timers = element.timers;
            for (let i = 0; i < timers.length; ++i) {
              const timer = timers[i];
              if (callback === timer.getCallback()) {
                return true;
              }
            }
            return false;
          }
        }
        pauseAllTargets() {
          return this.pauseAllTargetsWithMinPriority(System.Priority.SCHEDULER);
        }
        pauseAllTargetsWithMinPriority(minPriority) {
          const idsWithSelectors = [];
          let element;
          const locArrayForTimers = this._arrayForTimers;
          let i;
          let li;
          for (i = 0, li = locArrayForTimers.length; i < li; i++) {
            var _element;
            element = locArrayForTimers[i];
            if ((_element = element) !== null && _element !== void 0 && _element.target) {
              element.paused = true;
              idsWithSelectors.push(element.target);
            }
          }
          let entry;
          if (minPriority < 0) {
            for (i = 0; i < this._updatesNegList.length; i++) {
              var _entry4;
              entry = this._updatesNegList[i];
              if ((_entry4 = entry) !== null && _entry4 !== void 0 && _entry4.target) {
                if (entry.priority >= minPriority) {
                  entry.paused = true;
                  idsWithSelectors.push(entry.target);
                }
              }
            }
          }
          if (minPriority <= 0) {
            for (i = 0; i < this._updates0List.length; i++) {
              var _entry5;
              entry = this._updates0List[i];
              if ((_entry5 = entry) !== null && _entry5 !== void 0 && _entry5.target) {
                entry.paused = true;
                idsWithSelectors.push(entry.target);
              }
            }
          }
          for (i = 0; i < this._updatesPosList.length; i++) {
            var _entry6;
            entry = this._updatesPosList[i];
            if ((_entry6 = entry) !== null && _entry6 !== void 0 && _entry6.target) {
              if (entry.priority >= minPriority) {
                entry.paused = true;
                idsWithSelectors.push(entry.target);
              }
            }
          }
          return idsWithSelectors;
        }
        resumeTargets(targetsToResume) {
          if (!targetsToResume) {
            return;
          }
          for (let i = 0; i < targetsToResume.length; i++) {
            this.resumeTarget(targetsToResume[i]);
          }
        }
        pauseTarget(target) {
          assertID(Boolean(target), 1503);
          const targetId = target.uuid || target.id;
          if (!targetId) {
            errorID(1510);
            return;
          }
          const element = this._hashForTimers[targetId];
          if (element) {
            element.paused = true;
          }
          const elementUpdate = this._hashForUpdates[targetId];
          if (elementUpdate !== null && elementUpdate !== void 0 && elementUpdate.entry) {
            elementUpdate.entry.paused = true;
          }
        }
        resumeTarget(target) {
          assertID(Boolean(target), 1504);
          const targetId = target.uuid || target.id;
          if (!targetId) {
            errorID(1510);
            return;
          }
          const element = this._hashForTimers[targetId];
          if (element) {
            element.paused = false;
          }
          const elementUpdate = this._hashForUpdates[targetId];
          if (elementUpdate !== null && elementUpdate !== void 0 && elementUpdate.entry) {
            elementUpdate.entry.paused = false;
          }
        }
        isTargetPaused(target) {
          assertID(Boolean(target), 1505);
          const targetId = target.uuid || target.id;
          if (!targetId) {
            errorID(1510);
            return false;
          }
          const element = this._hashForTimers[targetId];
          if (element) {
            return element.paused;
          }
          const elementUpdate = this._hashForUpdates[targetId];
          if (elementUpdate !== null && elementUpdate !== void 0 && elementUpdate.entry) {
            return elementUpdate.entry.paused;
          }
          return false;
        }
        _removeHashElement(element) {
          if (!element.target) {
            return;
          }
          const targetId = element.target.uuid || element.target.id;
          if (typeof targetId === 'undefined') {
            return;
          }
          delete this._hashForTimers[targetId];
          const arr = this._arrayForTimers;
          for (let i = 0, l = arr.length; i < l; i++) {
            if (arr[i] === element) {
              arr.splice(i, 1);
              break;
            }
          }
          HashTimerEntry.put(element);
        }
        _removeUpdateFromHash(entry) {
          if (!entry.target) {
            return;
          }
          const targetId = entry.target.uuid || entry.target.id;
          if (typeof targetId === 'undefined') {
            return;
          }
          const element = this._hashForUpdates[targetId];
          if (element) {
            const list = element.list;
            const listEntry = element.entry;
            if (list) {
              for (let i = 0, l = list.length; i < l; i++) {
                if (list[i] === listEntry) {
                  list.splice(i, 1);
                  break;
                }
              }
            }
            delete this._hashForUpdates[targetId];
            if (listEntry) {
              ListEntry.put(listEntry);
            }
            HashUpdateEntry.put(element);
          }
        }
        _priorityIn(ppList, listElement, priority) {
          for (let i = 0; i < ppList.length; i++) {
            if (priority < ppList[i].priority) {
              ppList.splice(i, 0, listElement);
              return;
            }
          }
          ppList.push(listElement);
        }
        _appendIn(ppList, listElement) {
          ppList.push(listElement);
        }
      } exports('Scheduler', Scheduler);
      Scheduler.ID = 'scheduler';
      legacyCC.Scheduler = Scheduler;

      const vmath = {};
      replaceProperty(vmath, 'vmath', [{
        name: 'vec2',
        newName: 'Vec2',
        target: math,
        targetName: 'math'
      }, {
        name: 'vec3',
        newName: 'Vec3',
        target: math,
        targetName: 'math'
      }, {
        name: 'vec4',
        newName: 'Vec4',
        target: math,
        targetName: 'math'
      }, {
        name: 'quat',
        newName: 'Quat',
        target: math,
        targetName: 'math'
      }, {
        name: 'mat3',
        newName: 'Mat3',
        target: math,
        targetName: 'math'
      }, {
        name: 'mat4',
        newName: 'Mat4',
        target: math,
        targetName: 'math'
      }, {
        name: 'color4',
        newName: 'Color',
        target: math,
        targetName: 'math'
      }, {
        name: 'rect',
        newName: 'Rect',
        target: math,
        targetName: 'math'
      }, {
        name: 'approx',
        newName: 'approx',
        target: math,
        targetName: 'math'
      }, {
        name: 'EPSILON',
        newName: 'EPSILON',
        target: math,
        targetName: 'math'
      }, {
        name: 'equals',
        newName: 'equals',
        target: math,
        targetName: 'math'
      }, {
        name: 'clamp',
        newName: 'clamp',
        target: math,
        targetName: 'math'
      }, {
        name: 'clamp01',
        newName: 'clamp01',
        target: math,
        targetName: 'math'
      }, {
        name: 'lerp',
        newName: 'lerp',
        target: math,
        targetName: 'math'
      }, {
        name: 'toRadian',
        newName: 'toRadian',
        target: math,
        targetName: 'math'
      }, {
        name: 'toDegree',
        newName: 'toDegree',
        target: math,
        targetName: 'math'
      }, {
        name: 'random',
        newName: 'random',
        target: math,
        targetName: 'math'
      }, {
        name: 'randomRange',
        newName: 'randomRange',
        target: math,
        targetName: 'math'
      }, {
        name: 'randomRangeInt',
        newName: 'randomRangeInt',
        target: math,
        targetName: 'math'
      }, {
        name: 'pseudoRandom',
        newName: 'pseudoRandom',
        target: math,
        targetName: 'math'
      }, {
        name: 'pseudoRandomRangeInt',
        newName: 'pseudoRandomRangeInt',
        target: math,
        targetName: 'math'
      }, {
        name: 'nextPow2',
        newName: 'nextPow2',
        target: math,
        targetName: 'math'
      }, {
        name: 'repeat',
        newName: 'repeat',
        target: math,
        targetName: 'math'
      }, {
        name: 'pingPong',
        newName: 'pingPong',
        target: math,
        targetName: 'math'
      }, {
        name: 'inverseLerp',
        newName: 'inverseLerp',
        target: math,
        targetName: 'math'
      }]);
      legacyCC.vmath = vmath;
      replaceProperty(Scheduler.prototype, 'Scheduler.prototype', [{
        name: 'enableForTarget',
        newName: 'enableForTarget',
        target: Scheduler,
        targetName: 'Scheduler'
      }]);
      replaceProperty(Scheduler, 'Scheduler', [{
        name: 'PRIORITY_SYSTEM',
        newName: 'System.Priority.SCHEDULER',
        customGetter() {
          return System.Priority.SCHEDULER;
        }
      }]);
      removeProperty(Scheduler, 'Scheduler', [{
        name: 'PRIORITY_NON_SYSTEM',
        suggest: 'Use enum` System.Priority` instead'
      }]);

      deprecateModuleExportedName({
        replaceProperty: {
          since: '3.6.0',
          removed: false
        },
        removeProperty: {
          since: '3.6.0',
          removed: false
        },
        markAsWarning: {
          since: '3.6.0',
          removed: false
        },
        setDefaultLogTimes: {
          since: '3.6.0',
          removed: false
        }
      });

      const fastRemoveAt$1 = fastRemoveAt$2;
      function empty() {}
      class CallbackInfo {
        constructor() {
          this.callback = empty;
          this.target = undefined;
          this.once = false;
        }
        set(callback, target, once) {
          this.callback = callback || empty;
          this.target = target;
          this.once = !!once;
        }
        reset() {
          this.target = undefined;
          this.callback = empty;
          this.once = false;
        }
        check() {
          if (isCCObject(this.target) && !isValid(this.target, true)) {
            return false;
          } else {
            return true;
          }
        }
      }
      const callbackInfoPool = new Pool(() => new CallbackInfo(), 32);
      class CallbackList {
        constructor() {
          this.callbackInfos = [];
          this.isInvoking = false;
          this.containCanceled = false;
        }
        removeByCallback(cb) {
          for (let i = 0; i < this.callbackInfos.length; ++i) {
            const info = this.callbackInfos[i];
            if (info && info.callback === cb) {
              info.reset();
              callbackInfoPool.free(info);
              fastRemoveAt$1(this.callbackInfos, i);
              --i;
            }
          }
        }
        removeByTarget(target) {
          for (let i = 0; i < this.callbackInfos.length; ++i) {
            const info = this.callbackInfos[i];
            if (info && info.target === target) {
              info.reset();
              callbackInfoPool.free(info);
              fastRemoveAt$1(this.callbackInfos, i);
              --i;
            }
          }
        }
        cancel(index) {
          const info = this.callbackInfos[index];
          if (info) {
            info.reset();
            if (this.isInvoking) {
              this.callbackInfos[index] = null;
            } else {
              fastRemoveAt$1(this.callbackInfos, index);
            }
            callbackInfoPool.free(info);
          }
          this.containCanceled = true;
        }
        cancelAll() {
          for (let i = 0; i < this.callbackInfos.length; i++) {
            const info = this.callbackInfos[i];
            if (info) {
              info.reset();
              callbackInfoPool.free(info);
              this.callbackInfos[i] = null;
            }
          }
          this.containCanceled = true;
        }
        purgeCanceled() {
          for (let i = this.callbackInfos.length - 1; i >= 0; --i) {
            const info = this.callbackInfos[i];
            if (!info) {
              fastRemoveAt$1(this.callbackInfos, i);
            }
          }
          this.containCanceled = false;
        }
        clear() {
          this.cancelAll();
          this.callbackInfos.length = 0;
          this.isInvoking = false;
          this.containCanceled = false;
        }
      }
      const MAX_SIZE$1 = 16;
      const callbackListPool = new Pool(() => new CallbackList(), MAX_SIZE$1);
      class CallbacksInvoker {
        constructor() {
          this._callbackTable = createMap(true);
          this._offCallback = void 0;
        }
        on(key, callback, target, once) {
          if (!this.hasEventListener(key, callback, target)) {
            let list = this._callbackTable[key];
            if (!list) {
              list = this._callbackTable[key] = callbackListPool.alloc();
            }
            const info = callbackInfoPool.alloc();
            info.set(callback, target, once);
            list.callbackInfos.push(info);
          }
          return callback;
        }
        hasEventListener(key, callback, target) {
          const list = this._callbackTable && this._callbackTable[key];
          if (!list) {
            return false;
          }
          const infos = list.callbackInfos;
          if (!callback) {
            if (list.isInvoking) {
              for (let i = 0; i < infos.length; ++i) {
                if (infos[i]) {
                  return true;
                }
              }
              return false;
            } else {
              return infos.length > 0;
            }
          }
          for (let i = 0; i < infos.length; ++i) {
            const info = infos[i];
            if (info && info.check() && info.callback === callback && info.target === target) {
              return true;
            }
          }
          return false;
        }
        removeAll(keyOrTarget) {
          const type = typeof keyOrTarget;
          if (type === 'string' || type === 'number') {
            const list = this._callbackTable && this._callbackTable[keyOrTarget];
            if (list) {
              if (list.isInvoking) {
                list.cancelAll();
              } else {
                list.clear();
                callbackListPool.free(list);
                delete this._callbackTable[keyOrTarget];
              }
            }
          } else if (keyOrTarget) {
            for (const key in this._callbackTable) {
              const list = this._callbackTable[key];
              if (list.isInvoking) {
                const infos = list.callbackInfos;
                for (let i = 0; i < infos.length; ++i) {
                  const info = infos[i];
                  if (info && info.target === keyOrTarget) {
                    list.cancel(i);
                  }
                }
              } else {
                list.removeByTarget(keyOrTarget);
              }
            }
          }
        }
        off(key, callback, target) {
          var _this$_offCallback;
          const list = this._callbackTable && this._callbackTable[key];
          if (list) {
            const infos = list.callbackInfos;
            if (callback) {
              for (let i = 0; i < infos.length; ++i) {
                const info = infos[i];
                if (info && info.callback === callback && info.target === target) {
                  list.cancel(i);
                  break;
                }
              }
            } else {
              this.removeAll(key);
            }
          }
          (_this$_offCallback = this._offCallback) === null || _this$_offCallback === void 0 ? void 0 : _this$_offCallback.call(this);
        }
        emit(key, arg0, arg1, arg2, arg3, arg4) {
          const list = this._callbackTable && this._callbackTable[key];
          if (list) {
            const rootInvoker = !list.isInvoking;
            list.isInvoking = true;
            const infos = list.callbackInfos;
            for (let i = 0, len = infos.length; i < len; ++i) {
              const info = infos[i];
              if (info) {
                const callback = info.callback;
                const target = info.target;
                if (info.once) {
                  this.off(key, callback, target);
                }
                if (!info.check()) {
                  this.off(key, callback, target);
                } else if (target) {
                  callback.call(target, arg0, arg1, arg2, arg3, arg4);
                } else {
                  callback(arg0, arg1, arg2, arg3, arg4);
                }
              }
            }
            if (rootInvoker) {
              list.isInvoking = false;
              if (list.containCanceled) {
                list.purgeCanceled();
              }
            }
          }
        }
        clear() {
          for (const key in this._callbackTable) {
            const list = this._callbackTable[key];
            if (list) {
              list.clear();
              callbackListPool.free(list);
              delete this._callbackTable[key];
            }
          }
        }
        _registerOffCallback(cb) {
          this._offCallback = cb;
        }
      } exports('CallbacksInvoker', CallbacksInvoker);

      function Eventify(base) {
        class Eventified extends base {
          constructor(...args) {
            super(...args);
            this._callbackTable = createMap(true);
          }
          once(type, callback, target) {
            return this.on(type, callback, target, true);
          }
          targetOff(typeOrTarget) {
            this.removeAll(typeOrTarget);
          }
        }
        const callbacksInvokerPrototype = CallbacksInvoker.prototype;
        const propertyKeys = Object.getOwnPropertyNames(callbacksInvokerPrototype).concat(Object.getOwnPropertySymbols(callbacksInvokerPrototype));
        for (let iPropertyKey = 0; iPropertyKey < propertyKeys.length; ++iPropertyKey) {
          const propertyKey = propertyKeys[iPropertyKey];
          if (!(propertyKey in Eventified.prototype)) {
            const propertyDescriptor = Object.getOwnPropertyDescriptor(callbacksInvokerPrototype, propertyKey);
            if (propertyDescriptor) {
              Object.defineProperty(Eventified.prototype, propertyKey, propertyDescriptor);
            }
          }
        }
        return Eventified;
      }

      class Empty {}
      const EventTarget = exports('EventTarget', Eventify(Empty));
      legacyCC.EventTarget = EventTarget;

      class AsyncDelegate {
        constructor() {
          this._delegates = [];
        }
        add(callback) {
          if (!this._delegates.includes(callback)) {
            this._delegates.push(callback);
          }
        }
        hasListener(callback) {
          return this._delegates.includes(callback);
        }
        remove(callback) {
          fastRemove(this._delegates, callback);
        }
        dispatch(...args) {
          return Promise.all(this._delegates.map(func => func(...arguments)).filter(Boolean));
        }
      } exports('AsyncDelegate', AsyncDelegate);

      let BrowserType;
      (function (BrowserType) {
        BrowserType["UNKNOWN"] = "unknown";
        BrowserType["WECHAT"] = "wechat";
        BrowserType["ANDROID"] = "androidbrowser";
        BrowserType["IE"] = "ie";
        BrowserType["EDGE"] = "edge";
        BrowserType["QQ"] = "qqbrowser";
        BrowserType["MOBILE_QQ"] = "mqqbrowser";
        BrowserType["UC"] = "ucbrowser";
        BrowserType["UCBS"] = "ucbs";
        BrowserType["BROWSER_360"] = "360browser";
        BrowserType["BAIDU_APP"] = "baiduboxapp";
        BrowserType["BAIDU"] = "baidubrowser";
        BrowserType["MAXTHON"] = "maxthon";
        BrowserType["OPERA"] = "opera";
        BrowserType["OUPENG"] = "oupeng";
        BrowserType["MIUI"] = "miuibrowser";
        BrowserType["FIREFOX"] = "firefox";
        BrowserType["SAFARI"] = "safari";
        BrowserType["CHROME"] = "chrome";
        BrowserType["LIEBAO"] = "liebao";
        BrowserType["QZONE"] = "qzone";
        BrowserType["SOUGOU"] = "sogou";
        BrowserType["HUAWEI"] = "huawei";
      })(BrowserType || (BrowserType = {}));

      let Language;
      (function (Language) {
        Language["UNKNOWN"] = "unknown";
        Language["ENGLISH"] = "en";
        Language["CHINESE"] = "zh";
        Language["FRENCH"] = "fr";
        Language["ITALIAN"] = "it";
        Language["GERMAN"] = "de";
        Language["SPANISH"] = "es";
        Language["DUTCH"] = "du";
        Language["RUSSIAN"] = "ru";
        Language["KOREAN"] = "ko";
        Language["JAPANESE"] = "ja";
        Language["HUNGARIAN"] = "hu";
        Language["PORTUGUESE"] = "pt";
        Language["ARABIC"] = "ar";
        Language["NORWEGIAN"] = "no";
        Language["POLISH"] = "pl";
        Language["TURKISH"] = "tr";
        Language["UKRAINIAN"] = "uk";
        Language["ROMANIAN"] = "ro";
        Language["BULGARIAN"] = "bg";
        Language["HINDI"] = "hi";
      })(Language || (Language = {}));

      let NetworkType;
      (function (NetworkType) {
        NetworkType[NetworkType["NONE"] = 0] = "NONE";
        NetworkType[NetworkType["LAN"] = 1] = "LAN";
        NetworkType[NetworkType["WWAN"] = 2] = "WWAN";
      })(NetworkType || (NetworkType = {}));

      let OS;
      (function (OS) {
        OS["UNKNOWN"] = "Unknown";
        OS["IOS"] = "iOS";
        OS["ANDROID"] = "Android";
        OS["WINDOWS"] = "Windows";
        OS["LINUX"] = "Linux";
        OS["OSX"] = "OS X";
        OS["OHOS"] = "OHOS";
        OS["OPENHARMONY"] = "OpenHarmony";
      })(OS || (OS = {}));

      let Platform;
      (function (Platform) {
        Platform["UNKNOWN"] = "UNKNOWN";
        Platform["EDITOR_PAGE"] = "EDITOR_PAGE";
        Platform["EDITOR_CORE"] = "EDITOR_CORE";
        Platform["MOBILE_BROWSER"] = "MOBILE_BROWSER";
        Platform["DESKTOP_BROWSER"] = "DESKTOP_BROWSER";
        Platform["WIN32"] = "WIN32";
        Platform["ANDROID"] = "ANDROID";
        Platform["IOS"] = "IOS";
        Platform["MACOS"] = "MACOS";
        Platform["OHOS"] = "OHOS";
        Platform["OPENHARMONY"] = "OPENHARMONY";
        Platform["WECHAT_GAME"] = "WECHAT_GAME";
        Platform["WECHAT_MINI_PROGRAM"] = "WECHAT_MINI_PROGRAM";
        Platform["BAIDU_MINI_GAME"] = "BAIDU_MINI_GAME";
        Platform["XIAOMI_QUICK_GAME"] = "XIAOMI_QUICK_GAME";
        Platform["ALIPAY_MINI_GAME"] = "ALIPAY_MINI_GAME";
        Platform["TAOBAO_CREATIVE_APP"] = "TAOBAO_CREATIVE_APP";
        Platform["TAOBAO_MINI_GAME"] = "TAOBAO_MINI_GAME";
        Platform["BYTEDANCE_MINI_GAME"] = "BYTEDANCE_MINI_GAME";
        Platform["OPPO_MINI_GAME"] = "OPPO_MINI_GAME";
        Platform["VIVO_MINI_GAME"] = "VIVO_MINI_GAME";
        Platform["HUAWEI_QUICK_GAME"] = "HUAWEI_QUICK_GAME";
        Platform["COCOSPLAY"] = "COCOSPLAY";
        Platform["LINKSURE_MINI_GAME"] = "LINKSURE_MINI_GAME";
        Platform["QTT_MINI_GAME"] = "QTT_MINI_GAME";
      })(Platform || (Platform = {}));

      let Feature$1;
      (function (Feature) {
        Feature["WEBP"] = "WEBP";
        Feature["IMAGE_BITMAP"] = "IMAGE_BITMAP";
        Feature["WEB_VIEW"] = "WEB_VIEW";
        Feature["VIDEO_PLAYER"] = "VIDEO_PLAYER";
        Feature["SAFE_AREA"] = "SAFE_AREA";
        Feature["HPE"] = "HPE";
        Feature["INPUT_TOUCH"] = "INPUT_TOUCH";
        Feature["EVENT_KEYBOARD"] = "EVENT_KEYBOARD";
        Feature["EVENT_MOUSE"] = "EVENT_MOUSE";
        Feature["EVENT_TOUCH"] = "EVENT_TOUCH";
        Feature["EVENT_ACCELEROMETER"] = "EVENT_ACCELEROMETER";
        Feature["EVENT_GAMEPAD"] = "EVENT_GAMEPAD";
        Feature["EVENT_HANDLE"] = "EVENT_HANDLE";
        Feature["EVENT_HMD"] = "EVENT_HMD";
        Feature["EVENT_HANDHELD"] = "EVENT_HANDHELD";
        Feature["WASM"] = "WASM";
      })(Feature$1 || (Feature$1 = {}));

      const networkTypeMap = {
        0: NetworkType.NONE,
        1: NetworkType.LAN,
        2: NetworkType.WWAN
      };
      const platformMap = {
        0: Platform.WIN32,
        2: Platform.MACOS,
        3: Platform.ANDROID,
        4: Platform.IOS,
        5: Platform.IOS,
        6: Platform.OHOS,
        7: Platform.OPENHARMONY
      };
      class SystemInfo extends EventTarget {
        get networkType() {
          return networkTypeMap[jsb.device.getNetworkType()];
        }
        constructor() {
          super();
          this.isNative = void 0;
          this.isBrowser = void 0;
          this.isMobile = void 0;
          this.isLittleEndian = void 0;
          this.platform = void 0;
          this.language = void 0;
          this.nativeLanguage = void 0;
          this.os = void 0;
          this.osVersion = void 0;
          this.osMainVersion = void 0;
          this.browserType = void 0;
          this.browserVersion = void 0;
          this.isXR = void 0;
          this._featureMap = void 0;
          this._initPromise = void 0;
          this.isNative = true;
          this.isBrowser = false;
          this.platform = platformMap[__getPlatform()];
          this.isMobile = this.platform === Platform.ANDROID || this.platform === Platform.IOS || this.platform === Platform.OHOS || this.platform === Platform.OPENHARMONY;
          this.isLittleEndian = (() => {
            const buffer = new ArrayBuffer(2);
            new DataView(buffer).setInt16(0, 256, true);
            return new Int16Array(buffer)[0] === 256;
          })();
          const currLanguage = __getCurrentLanguageCode();
          this.nativeLanguage = currLanguage ? currLanguage.toLowerCase() : Language.UNKNOWN;
          this.language = __getCurrentLanguage();
          this.os = __getOS();
          this.osVersion = __getOSVersion();
          this.osMainVersion = parseInt(this.osVersion);
          this.browserType = BrowserType.UNKNOWN;
          this.browserVersion = '';
          this.isXR = typeof xr !== 'undefined' && typeof xr.XrEntry !== 'undefined';
          const isHPE = typeof __supportHPE === 'function' ? __supportHPE() : false;
          this._featureMap = {
            [Feature$1.WEBP]: true,
            [Feature$1.IMAGE_BITMAP]: false,
            [Feature$1.WEB_VIEW]: this.isMobile,
            [Feature$1.VIDEO_PLAYER]: this.isMobile,
            [Feature$1.SAFE_AREA]: this.isMobile,
            [Feature$1.HPE]: isHPE,
            [Feature$1.INPUT_TOUCH]: this.isMobile,
            [Feature$1.EVENT_KEYBOARD]: true,
            [Feature$1.EVENT_MOUSE]: isHPE || !this.isMobile,
            [Feature$1.EVENT_TOUCH]: true,
            [Feature$1.EVENT_ACCELEROMETER]: this.isMobile,
            [Feature$1.EVENT_GAMEPAD]: true,
            [Feature$1.EVENT_HANDLE]: this.isXR,
            [Feature$1.EVENT_HMD]: this.isXR,
            [Feature$1.EVENT_HANDHELD]: typeof xr !== 'undefined' && typeof xr.ARModule !== 'undefined',
            [Feature$1.WASM]: !OPEN_HARMONY
          };
          this._initPromise = [];
          this._registerEvent();
        }
        _registerEvent() {
          jsb.onPause = () => {
            this.emit('hide');
          };
          jsb.onResume = () => {
            this.emit('show');
          };
          jsb.onClose = () => {
            this.emit('close');
          };
        }
        _setFeature(feature, value) {
          return this._featureMap[feature] = value;
        }
        init() {
          return Promise.all(this._initPromise);
        }
        hasFeature(feature) {
          return this._featureMap[feature];
        }
        getBatteryLevel() {
          return jsb.device.getBatteryLevel();
        }
        triggerGC() {
          jsb.garbageCollect();
        }
        openURL(url) {
          jsb.openURL(url);
        }
        now() {
          if (Date.now) {
            return Date.now();
          }
          return +new Date();
        }
        restartJSVM() {
          __restartVM();
        }
        close() {
          __close();
        }
        exit() {
          __exit();
        }
      }
      const systemInfo = new SystemInfo();

      const EXTNAME_RE = /(\.[^\.\/\?\\]*)(\?.*)?$/;
      const DIRNAME_RE = /((.*)(\/|\\|\\\\))?(.*?\..*$)?/;
      const NORMALIZE_RE = /[^\.\/]+\/\.\.\//;
      function join(...segments) {
        let result = '';
        for (const segment of segments) {
          result = (result + (result === '' ? '' : '/') + segment).replace(/(\/|\\\\)$/, '');
        }
        return result;
      }
      function extname(path) {
        const temp = EXTNAME_RE.exec(path);
        return temp ? temp[1] : '';
      }
      function mainFileName(fileName) {
        if (fileName) {
          const idx = fileName.lastIndexOf('.');
          if (idx !== -1) {
            return fileName.substring(0, idx);
          }
        }
        return fileName;
      }
      function basename(path, extName) {
        const index = path.indexOf('?');
        if (index > 0) {
          path = path.substring(0, index);
        }
        const reg = /(\/|\\)([^\/\\]+)$/g;
        const result = reg.exec(path.replace(/(\/|\\)$/, ''));
        if (!result) {
          return path;
        }
        const baseName = result[2];
        if (extName && path.substring(path.length - extName.length).toLowerCase() === extName.toLowerCase()) {
          return baseName.substring(0, baseName.length - extName.length);
        }
        return baseName;
      }
      function dirname(path) {
        const temp = DIRNAME_RE.exec(path);
        return temp ? temp[2] : '';
      }
      function changeExtname(path, extName) {
        extName = extName || '';
        let index = path.indexOf('?');
        let tempStr = '';
        if (index > 0) {
          tempStr = path.substring(index);
          path = path.substring(0, index);
        }
        index = path.lastIndexOf('.');
        if (index < 0) {
          return path + extName + tempStr;
        }
        return path.substring(0, index) + extName + tempStr;
      }
      function changeBasename(path, newBaseName, keepExt) {
        if (newBaseName.indexOf('.') === 0) {
          return changeExtname(path, newBaseName);
        }
        let index = path.indexOf('?');
        let tempStr = '';
        const ext = keepExt ? extname(path) : '';
        if (index > 0) {
          tempStr = path.substring(index);
          path = path.substring(0, index);
        }
        index = path.lastIndexOf('/');
        index = index <= 0 ? 0 : index + 1;
        return path.substring(0, index) + newBaseName + ext + tempStr;
      }
      function _normalize(url) {
        let oldUrl = url = String(url);
        do {
          oldUrl = url;
          url = url.replace(NORMALIZE_RE, '');
        } while (oldUrl.length !== url.length);
        return url;
      }
      function stripSep(path) {
        return path.replace(/[\/\\]$/, '');
      }
      function getSeperator() {
        return systemInfo.os === OS.WINDOWS ? '\\' : '/';
      }

      var path = /*#__PURE__*/Object.freeze({
        __proto__: null,
        join: join,
        extname: extname,
        mainFileName: mainFileName,
        basename: basename,
        dirname: dirname,
        changeExtname: changeExtname,
        changeBasename: changeBasename,
        _normalize: _normalize,
        stripSep: stripSep,
        getSeperator: getSeperator
      });
      exports('path', path);

      const _vec3$1 = new Vec3();
      function WorldNode3DToLocalNodeUI(mainCamera, wpos, uiNode, out) {
        if (!out) {
          out = new Vec3();
        }
        mainCamera.convertToUINode(wpos, uiNode, out);
        const pos = uiNode.position;
        out.add(pos);
        return out;
      }
      function WorldNode3DToWorldNodeUI(mainCamera, wpos, out) {
        if (!out) {
          out = new Vec3();
        }
        mainCamera.worldToScreen(wpos, out);
        out.x /= legacyCC.view.getScaleX();
        out.y /= legacyCC.view.getScaleY();
        return out;
      }
      const convertUtils = exports('convertUtils', {
        WorldNode3DToLocalNodeUI,
        WorldNode3DToWorldNodeUI
      });
      legacyCC.pipelineUtils = convertUtils;
      replaceProperty(legacyCC.pipelineUtils, 'cc.pipelineUtils', [{
        name: 'WorldNode3DToLocalNodeUI',
        newName: 'convertToUINode',
        targetName: 'cc.Camera.prototype',
        customFunction(...args) {
          const camera = args[0];
          const out = args[3] || _vec3$1;
          camera.convertToUINode(args[1], args[2], out);
          out.add(args[2].position);
          return args[3] || out.clone();
        }
      }]);

      markAsWarning(js$1, 'js', [{
        name: 'js',
        suggest: `'js.js' is deprecated since v3.7.0, please access 'js' directly instead.`
      }]);

      const _PORTRAIT = 1;
      const _PORTRAIT_UPSIDE_DOWN = _PORTRAIT << 1;
      const _LEFT = _PORTRAIT << 2;
      const _RIGHT = _PORTRAIT << 3;
      const _LANDSCAPE = _LEFT | _RIGHT;
      const _AUTO = _PORTRAIT | _LANDSCAPE;
      let Orientation;
      (function (Orientation) {
        Orientation[Orientation["PORTRAIT"] = _PORTRAIT] = "PORTRAIT";
        Orientation[Orientation["PORTRAIT_UPSIDE_DOWN"] = _PORTRAIT_UPSIDE_DOWN] = "PORTRAIT_UPSIDE_DOWN";
        Orientation[Orientation["LANDSCAPE_LEFT"] = _LEFT] = "LANDSCAPE_LEFT";
        Orientation[Orientation["LANDSCAPE_RIGHT"] = _RIGHT] = "LANDSCAPE_RIGHT";
        Orientation[Orientation["LANDSCAPE"] = _LANDSCAPE] = "LANDSCAPE";
        Orientation[Orientation["AUTO"] = _AUTO] = "AUTO";
      })(Orientation || (Orientation = {}));

      const orientationMap$1 = {
        0: Orientation.PORTRAIT,
        '-90': Orientation.LANDSCAPE_LEFT,
        90: Orientation.LANDSCAPE_RIGHT,
        180: Orientation.PORTRAIT_UPSIDE_DOWN
      };
      class ScreenAdapter extends EventTarget {
        get supportFullScreen() {
          return false;
        }
        get isFullScreen() {
          return false;
        }
        get devicePixelRatio() {
          return jsb.device.getDevicePixelRatio() || 1;
        }
        get windowSize() {
          const dpr = this.devicePixelRatio;
          const width = globalThis.oh ? jsb.device.getInnerWidth() : jsb.window.innerWidth;
          const height = globalThis.oh ? jsb.device.getInnerHeight() : jsb.window.innerHeight;
          const roundWidth = Math.round(width);
          const roundHeight = Math.round(height);
          return new Size$1(roundWidth * dpr, roundHeight * dpr);
        }
        set windowSize(size) {
          console.warn('Setting window size is not supported yet.');
        }
        get resolution() {
          const windowSize = this.windowSize;
          const resolutionScale = this.resolutionScale;
          return new Size$1(windowSize.width * resolutionScale, windowSize.height * resolutionScale);
        }
        get resolutionScale() {
          return this._resolutionScale;
        }
        set resolutionScale(v) {
          var _this$_cbToUpdateFram;
          if (v === this._resolutionScale) {
            return;
          }
          this._resolutionScale = v;
          (_this$_cbToUpdateFram = this._cbToUpdateFrameBuffer) === null || _this$_cbToUpdateFram === void 0 ? void 0 : _this$_cbToUpdateFram.call(this);
        }
        get orientation() {
          return orientationMap$1[jsb.device.getDeviceOrientation()];
        }
        set orientation(value) {
          console.warn('Setting orientation is not supported yet.');
        }
        get safeAreaEdge() {
          const nativeSafeArea = jsb.device.getSafeAreaEdge();
          const dpr = this.devicePixelRatio;
          let topEdge = nativeSafeArea.x * dpr;
          let bottomEdge = nativeSafeArea.z * dpr;
          let leftEdge = nativeSafeArea.y * dpr;
          let rightEdge = nativeSafeArea.w * dpr;
          const orientation = this.orientation;
          if (orientation === Orientation.PORTRAIT) {
            if (topEdge < bottomEdge) {
              topEdge = bottomEdge;
            } else {
              bottomEdge = topEdge;
            }
          } else if (leftEdge < rightEdge) {
            leftEdge = rightEdge;
          } else {
            rightEdge = leftEdge;
          }
          return {
            top: topEdge,
            bottom: bottomEdge,
            left: leftEdge,
            right: rightEdge
          };
        }
        get isProportionalToFrame() {
          return this._isProportionalToFrame;
        }
        set isProportionalToFrame(v) {}
        constructor() {
          super();
          this.isFrameRotated = false;
          this.handleResizeEvent = true;
          this._cbToUpdateFrameBuffer = void 0;
          this._resolutionScale = 1;
          this._isProportionalToFrame = false;
          this._registerEvent();
        }
        init(options, cbToRebuildFrameBuffer) {
          this._cbToUpdateFrameBuffer = cbToRebuildFrameBuffer;
          {
            this._cbToUpdateFrameBuffer();
          }
        }
        requestFullScreen() {
          return Promise.reject(new Error('request fullscreen has not been supported yet on this platform.'));
        }
        exitFullScreen() {
          return Promise.reject(new Error('exit fullscreen has not been supported yet on this platform.'));
        }
        _registerEvent() {
          jsb.onResize = event => {
            if (event.width === 0 || event.height === 0) return;
            window.resize(event.width / this.devicePixelRatio, event.height / this.devicePixelRatio);
            this.emit('window-resize', event.width, event.height, event.windowId);
          };
          jsb.onOrientationChanged = event => {
            this.emit('orientation-change');
          };
        }
      }
      const screenAdapter = new ScreenAdapter();

      class Screen {
        init() {
          var _settings$querySettin, _settings$querySettin2;
          const exactFitScreen = (_settings$querySettin = settings.querySettings(Settings.Category.SCREEN, 'exactFitScreen')) !== null && _settings$querySettin !== void 0 ? _settings$querySettin : true;
          const orientation = (_settings$querySettin2 = settings.querySettings(Settings.Category.SCREEN, 'orientation')) !== null && _settings$querySettin2 !== void 0 ? _settings$querySettin2 : 'auto';
          const isHeadlessMode = settings.querySettings(Settings.Category.RENDERING, 'renderMode') === 3;
          screenAdapter.init({
            exactFitScreen,
            configOrientation: orientation,
            isHeadlessMode
          }, () => {
            var _director$root;
            const director = legacyCC.director;
            if (!((_director$root = director.root) !== null && _director$root !== void 0 && _director$root.pipeline)) {
              warnID(1220);
              return;
            }
            director.root.pipeline.shadingScale = screenAdapter.resolutionScale;
          });
        }
        get devicePixelRatio() {
          return screenAdapter.devicePixelRatio;
        }
        get windowSize() {
          return screenAdapter.windowSize;
        }
        set windowSize(size) {
          screenAdapter.windowSize = size;
        }
        get resolution() {
          return screenAdapter.resolution;
        }
        get supportsFullScreen() {
          return screenAdapter.supportFullScreen;
        }
        fullScreen() {
          return screenAdapter.isFullScreen;
        }
        requestFullScreen(element, onFullScreenChange, onFullScreenError) {
          if (arguments.length > 0) {
            warnID(1400, 'screen.requestFullScreen(element, onFullScreenChange?, onFullScreenError?)', 'screen.requestFullScreen(): Promise');
          }
          return screenAdapter.requestFullScreen().then(() => {
            onFullScreenChange === null || onFullScreenChange === void 0 ? void 0 : onFullScreenChange.call(document);
          }).catch(err => {
            error(err);
            onFullScreenError === null || onFullScreenError === void 0 ? void 0 : onFullScreenError.call(document);
          });
        }
        exitFullScreen() {
          return screenAdapter.exitFullScreen();
        }
        autoFullScreen(element, onFullScreenChange) {
          var _this$requestFullScre;
          (_this$requestFullScre = this.requestFullScreen(element, onFullScreenChange)) === null || _this$requestFullScre === void 0 ? void 0 : _this$requestFullScre.catch(e => {
            warn(e);
          });
        }
        disableAutoFullScreen(element) {}
        on(type, callback, target) {
          screenAdapter.on(type, callback, target);
        }
        once(type, callback, target) {
          screenAdapter.once(type, callback, target);
        }
        off(type, callback, target) {
          screenAdapter.off(type, callback, target);
        }
      }
      const screen = exports('screen', new Screen());
      legacyCC.screen = screen;

      const sys = exports('sys', {
        Feature: Feature$1,
        hasFeature(feature) {
          return systemInfo.hasFeature(feature);
        },
        NetworkType,
        Language,
        OS,
        Platform,
        BrowserType,
        isNative: systemInfo.isNative,
        isBrowser: systemInfo.isBrowser,
        isMobile: systemInfo.isMobile,
        isLittleEndian: systemInfo.isLittleEndian,
        platform: systemInfo.platform,
        language: systemInfo.language,
        languageCode: systemInfo.nativeLanguage,
        os: systemInfo.os,
        osVersion: systemInfo.osVersion,
        osMainVersion: systemInfo.osMainVersion,
        browserType: systemInfo.browserType,
        browserVersion: systemInfo.browserVersion,
        isXR: systemInfo.isXR,
        windowPixelResolution: screen.windowSize,
        capabilities: {
          canvas: true,
          opengl: true,
          webp: systemInfo.hasFeature(Feature$1.WEBP),
          imageBitmap: systemInfo.hasFeature(Feature$1.IMAGE_BITMAP),
          touches: systemInfo.hasFeature(Feature$1.INPUT_TOUCH),
          mouse: systemInfo.hasFeature(Feature$1.EVENT_MOUSE),
          keyboard: systemInfo.hasFeature(Feature$1.EVENT_KEYBOARD),
          accelerometer: systemInfo.hasFeature(Feature$1.EVENT_ACCELEROMETER)
        },
        localStorage: {},
        getNetworkType() {
          return systemInfo.networkType;
        },
        getBatteryLevel() {
          return systemInfo.getBatteryLevel();
        },
        garbageCollect() {
          systemInfo.triggerGC();
        },
        isObjectValid(obj) {
          if (obj === null || obj === undefined) {
            return false;
          }
          return true;
        },
        __isWebIOS14OrIPadOS14Env: false,
        dump() {
          let str = '';
          str += `isMobile : ${this.isMobile}\r\n`;
          str += `language : ${this.language}\r\n`;
          str += `browserType : ${this.browserType}\r\n`;
          str += `browserVersion : ${this.browserVersion}\r\n`;
          str += `supports webp: ${sys.hasFeature(Feature$1.WEBP)}\r\n`;
          str += `supports bitmap: ${sys.hasFeature(Feature$1.IMAGE_BITMAP)}\r\n`;
          str += `supports touches: ${sys.hasFeature(Feature$1.INPUT_TOUCH)}\r\n`;
          str += `supports mouse: ${sys.hasFeature(Feature$1.EVENT_MOUSE)}\r\n`;
          str += `supports keyboard: ${sys.hasFeature(Feature$1.EVENT_KEYBOARD)}\r\n`;
          str += `supports accelerometer: ${sys.hasFeature(Feature$1.EVENT_ACCELEROMETER)}\r\n`;
          str += `os : ${this.os}\r\n`;
          str += `osVersion : ${this.osVersion}\r\n`;
          str += `platform : ${this.platform}\r\n`;
          str += `Using ${legacyCC.game.renderType === legacyCC.game.RENDER_TYPE_WEBGL ? 'WEBGL' : 'CANVAS'} renderer.\r\n`;
          log(str);
        },
        openURL(url) {
          systemInfo.openURL(url);
        },
        init() {
          return Promise.resolve().then(() => systemInfo.init()).then(() => {
            try {
              let localStorage = sys.localStorage = window.localStorage;
              localStorage.setItem('storage', '');
              localStorage.removeItem('storage');
              localStorage = null;
            } catch (e) {
              const warn = function (...args) {
                warnID(5200);
              };
              this.localStorage = {
                getItem: warn,
                setItem: warn,
                clear: warn,
                removeItem: warn,
                key: warn,
                length: 0
              };
            }
            {
              this.__isWebIOS14OrIPadOS14Env = (sys.os === OS.IOS || sys.os === OS.OSX) && systemInfo.isBrowser && /(OS 14)|(Version\/14)/.test(window.navigator.userAgent);
            }
          });
        },
        now() {
          return systemInfo.now();
        },
        restartVM() {
          systemInfo.restartJSVM();
        },
        getSafeAreaRect() {
          const locView = legacyCC.view;
          const edge = screenAdapter.safeAreaEdge;
          const windowSize = screenAdapter.windowSize;
          const leftBottom = new Vec2(edge.left, edge.bottom);
          const rightTop = new Vec2(windowSize.width - edge.right, windowSize.height - edge.top);
          locView._convertToUISpace(leftBottom);
          locView._convertToUISpace(rightTop);
          const x = leftBottom.x;
          const y = leftBottom.y;
          const width = rightTop.x - leftBottom.x;
          const height = rightTop.y - leftBottom.y;
          return new Rect$1(x, y, width, height);
        }
      });
      legacyCC.sys = sys;

      markAsWarning(legacyCC, 'cc', [{
        name: 'winSize',
        suggest: 'please use view.getVisibleSize() instead.'
      }]);
      markAsWarning(sys, 'sys', [{
        name: 'capabilities',
        suggest: 'please use sys.hasFeature() method instead.'
      }]);
      replaceProperty(sys, 'sys', ['UNKNOWN', 'ENGLISH', 'CHINESE', 'FRENCH', 'ITALIAN', 'GERMAN', 'SPANISH', 'DUTCH', 'RUSSIAN', 'KOREAN', 'JAPANESE', 'HUNGARIAN', 'PORTUGUESE', 'ARABIC', 'NORWEGIAN', 'POLISH', 'TURKISH', 'UKRAINIAN', 'ROMANIAN', 'BULGARIAN'].map(item => ({
        name: `LANGUAGE_${item}`,
        newName: item,
        target: sys.Language,
        targetName: 'sys.Language'
      })));
      replaceProperty(sys, 'sys', ['UNKNOWN', 'IOS', 'ANDROID', 'WINDOWS', 'LINUX', 'OSX'].map(item => ({
        name: `OS_${item}`,
        newName: item,
        target: sys.OS,
        targetName: 'sys.OS'
      })));
      replaceProperty(sys, 'sys', ['UNKNOWN', 'WECHAT', 'ANDROID', 'IE', 'EDGE', 'QQ', 'MOBILE_QQ', 'UC', 'UCBS', 'BAIDU_APP', 'BAIDU', 'MAXTHON', 'OPERA', 'OUPENG', 'MIUI', 'FIREFOX', 'SAFARI', 'CHROME', 'LIEBAO', 'QZONE', 'SOUGOU', 'HUAWEI'].map(item => ({
        name: `BROWSER_TYPE_${item}`,
        newName: item,
        target: sys.BrowserType,
        targetName: 'sys.BrowserType'
      })));
      replaceProperty(sys, 'sys', [{
        name: 'BROWSER_TYPE_360',
        newName: 'BROWSER_360',
        target: sys.BrowserType,
        targetName: 'sys.BrowserType'
      }]);
      replaceProperty(sys, 'sys', ['UNKNOWN', 'EDITOR_PAGE', 'EDITOR_CORE', 'MOBILE_BROWSER', 'DESKTOP_BROWSER', 'WIN32', 'MACOS', 'IOS', 'ANDROID', 'OHOS', 'WECHAT_GAME', 'BAIDU_MINI_GAME', 'XIAOMI_QUICK_GAME', 'ALIPAY_MINI_GAME', 'BYTEDANCE_MINI_GAME', 'OPPO_MINI_GAME', 'VIVO_MINI_GAME', 'HUAWEI_QUICK_GAME', 'COCOSPLAY', 'LINKSURE_MINI_GAME', 'QTT_MINI_GAME'].map(item => ({
        name: item,
        target: sys.Platform,
        targetName: 'sys.Platform'
      })));
      replaceProperty(sys, 'sys', [{
        name: 'IPHONE',
        newName: 'IOS',
        target: sys.Platform,
        targetName: 'sys.Platform'
      }, {
        name: 'IPAD',
        newName: 'IOS',
        target: sys.Platform,
        targetName: 'sys.Platform'
      }]);
      removeProperty(sys, 'sys', ['LINUX', 'BLACKBERRY', 'NACL', 'EMSCRIPTEN', 'TIZEN', 'WINRT', 'WP8', 'QQ_PLAY', 'FB_PLAYABLE_ADS'].map(item => ({
        name: item
      })));
      replaceProperty(sys, 'sys', [{
        name: 'windowPixelResolution',
        target: screen,
        targetName: 'screen',
        newName: 'windowSize'
      }]);
      markAsWarning(screen, 'screen', [{
        name: 'autoFullScreen',
        suggest: 'please use screen.requestFullScreen() instead.'
      }, {
        name: 'disableAutoFullScreen'
      }]);

      const visibleRect = exports('visibleRect', {
        topLeft: legacyCC.v2(0, 0),
        topRight: legacyCC.v2(0, 0),
        top: legacyCC.v2(0, 0),
        bottomLeft: legacyCC.v2(0, 0),
        bottomRight: legacyCC.v2(0, 0),
        bottom: legacyCC.v2(0, 0),
        center: legacyCC.v2(0, 0),
        left: legacyCC.v2(0, 0),
        right: legacyCC.v2(0, 0),
        width: 0,
        height: 0,
        init(visibleRect_) {
          const w = this.width = visibleRect_.width;
          const h = this.height = visibleRect_.height;
          const l = visibleRect_.x;
          const b = visibleRect_.y;
          const t = b + h;
          const r = l + w;
          this.topLeft.x = l;
          this.topLeft.y = t;
          this.topRight.x = r;
          this.topRight.y = t;
          this.top.x = l + w / 2;
          this.top.y = t;
          this.bottomLeft.x = l;
          this.bottomLeft.y = b;
          this.bottomRight.x = r;
          this.bottomRight.y = b;
          this.bottom.x = l + w / 2;
          this.bottom.y = b;
          this.center.x = l + w / 2;
          this.center.y = b + h / 2;
          this.left.x = l;
          this.left.y = b + h / 2;
          this.right.x = r;
          this.right.y = b + h / 2;
        }
      });
      legacyCC.visibleRect = visibleRect;

      const getUint8ForString = String.prototype.charCodeAt;
      function getUint8ForArray(idx) {
        return this[idx];
      }
      function murmurhash2_32_gc(input, seed) {
        let l = input.length;
        let h = seed ^ l;
        let i = 0;
        const getUint8 = typeof input === 'string' ? getUint8ForString : getUint8ForArray;
        while (l >= 4) {
          let k = getUint8.call(input, i) & 0xff | (getUint8.call(input, ++i) & 0xff) << 8 | (getUint8.call(input, ++i) & 0xff) << 16 | (getUint8.call(input, ++i) & 0xff) << 24;
          k = (k & 0xffff) * 0x5bd1e995 + (((k >>> 16) * 0x5bd1e995 & 0xffff) << 16);
          k ^= k >>> 24;
          k = (k & 0xffff) * 0x5bd1e995 + (((k >>> 16) * 0x5bd1e995 & 0xffff) << 16);
          h = (h & 0xffff) * 0x5bd1e995 + (((h >>> 16) * 0x5bd1e995 & 0xffff) << 16) ^ k;
          l -= 4;
          ++i;
        }
        switch (l) {
          case 3:
            h ^= (getUint8.call(input, i + 2) & 0xff) << 16;
          case 2:
            h ^= (getUint8.call(input, i + 1) & 0xff) << 8;
          case 1:
            h ^= getUint8.call(input, i) & 0xff;
            h = (h & 0xffff) * 0x5bd1e995 + (((h >>> 16) * 0x5bd1e995 & 0xffff) << 16);
            break;
        }
        h ^= h >>> 13;
        h = (h & 0xffff) * 0x5bd1e995 + (((h >>> 16) * 0x5bd1e995 & 0xffff) << 16);
        h ^= h >>> 15;
        return h >>> 0;
      }

      legacyCC.easing = easing;

      function syncNodeValues(node) {
        const lpos = node._lpos;
        node.setPositionForJS(lpos.x, lpos.y, lpos.z);
        const lscale = node._lscale;
        node.setScaleForJS(lscale.x, lscale.y, lscale.z);
        const lrot = node._lrot;
        node.setRotationForJS(lrot.x, lrot.y, lrot.z, lrot.w);
        const euler = node._euler;
        node.setRotationFromEulerForJS(euler.x, euler.y, euler.z);
      }
      function updateChildrenForDeserialize(node) {
        if (!node) {
          return;
        }
        const children = node.children;
        if (!children) {
          return;
        }
        const len = children.length;
        if (!len) {
          return;
        }
        node._setChildren(children);
        for (let i = 0; i < len; ++i) {
          const child = children[i];
          updateChildrenForDeserialize(child);
        }
      }
      function ExtraEventMethods() {}
      ExtraEventMethods.prototype.once = function once(type, callback, target) {
        return this.on(type, callback, target, true);
      };
      ExtraEventMethods.prototype.targetOff = function targetOff(typeOrTarget) {
        this.removeAll(typeOrTarget);
      };

      var jsbUtils = /*#__PURE__*/Object.freeze({
        __proto__: null,
        syncNodeValues: syncNodeValues,
        updateChildrenForDeserialize: updateChildrenForDeserialize,
        ExtraEventMethods: ExtraEventMethods
      });
      exports('jsbUtils', jsbUtils);

      function shift(array, first, last) {
        assertsArrayIndex(array, first);
        assertsArrayIndex(array, last);
        if (first === last) {
          return array;
        }
        const element = array[first];
        if (first < last) {
          for (let iElement = first + 1; iElement <= last; ++iElement) {
            array[iElement - 1] = array[iElement];
          }
        } else {
          for (let iElement = first; iElement !== last; --iElement) {
            array[iElement] = array[iElement - 1];
          }
        }
        array[last] = element;
        return array;
      }

      class GarbageCollectionManager {
        constructor() {
          this._finalizationRegistry = null;
          this._gcObjects = new WeakMap();
        }
        registerGCObject(gcObject) {
          {
            return gcObject;
          }
        }
        init() {}
        finalizationRegistryCallback(token) {
          const gcObject = this._gcObjects.get(token);
          if (gcObject) {
            this._gcObjects.delete(token);
            gcObject.destroy();
          }
          this._finalizationRegistry.unregister(token);
        }
        destroy() {}
      }
      const garbageCollectionManager = exports('garbageCollectionManager', new GarbageCollectionManager());

      class GCObject {
        constructor() {
          return garbageCollectionManager.registerGCObject(this);
        }
        destroy() {}
      } exports('GCObject', GCObject);

      function deepFlatten(strList, array) {
        for (const item of array) {
          if (Array.isArray(item)) {
            deepFlatten(strList, item);
          } else {
            strList.push(item);
          }
        }
      }
      function flattenCodeArray(array) {
        const separator = '';
        const strList = [];
        deepFlatten(strList, array);
        return strList.join(separator);
      }

      function applyMixins(derivedCtor, baseCtors) {
        baseCtors.forEach(baseCtor => {
          Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {
            if (name !== 'constructor') {
              Object.defineProperty(derivedCtor.prototype, name, Object.getOwnPropertyDescriptor(baseCtor.prototype, name));
            }
          });
        });
      }

      legacyCC.math = math;
      legacyCC.geometry = geometry;

      const deepCopy = (target, source, Ctor) => {
        for (let i = 0; i < source.length; ++i) {
          if (target.length <= i) target.push(new Ctor());
          target[i].copy(source[i]);
        }
        target.length = source.length;
      };
      let ObjectType;
      (function (ObjectType) {
        ObjectType[ObjectType["UNKNOWN"] = 0] = "UNKNOWN";
        ObjectType[ObjectType["SWAPCHAIN"] = 1] = "SWAPCHAIN";
        ObjectType[ObjectType["BUFFER"] = 2] = "BUFFER";
        ObjectType[ObjectType["TEXTURE"] = 3] = "TEXTURE";
        ObjectType[ObjectType["RENDER_PASS"] = 4] = "RENDER_PASS";
        ObjectType[ObjectType["FRAMEBUFFER"] = 5] = "FRAMEBUFFER";
        ObjectType[ObjectType["SAMPLER"] = 6] = "SAMPLER";
        ObjectType[ObjectType["SHADER"] = 7] = "SHADER";
        ObjectType[ObjectType["DESCRIPTOR_SET_LAYOUT"] = 8] = "DESCRIPTOR_SET_LAYOUT";
        ObjectType[ObjectType["PIPELINE_LAYOUT"] = 9] = "PIPELINE_LAYOUT";
        ObjectType[ObjectType["PIPELINE_STATE"] = 10] = "PIPELINE_STATE";
        ObjectType[ObjectType["DESCRIPTOR_SET"] = 11] = "DESCRIPTOR_SET";
        ObjectType[ObjectType["INPUT_ASSEMBLER"] = 12] = "INPUT_ASSEMBLER";
        ObjectType[ObjectType["COMMAND_BUFFER"] = 13] = "COMMAND_BUFFER";
        ObjectType[ObjectType["QUEUE"] = 14] = "QUEUE";
        ObjectType[ObjectType["QUERY_POOL"] = 15] = "QUERY_POOL";
        ObjectType[ObjectType["GLOBAL_BARRIER"] = 16] = "GLOBAL_BARRIER";
        ObjectType[ObjectType["TEXTURE_BARRIER"] = 17] = "TEXTURE_BARRIER";
        ObjectType[ObjectType["BUFFER_BARRIER"] = 18] = "BUFFER_BARRIER";
        ObjectType[ObjectType["COUNT"] = 19] = "COUNT";
      })(ObjectType || (ObjectType = {}));
      let Status;
      (function (Status) {
        Status[Status["UNREADY"] = 0] = "UNREADY";
        Status[Status["FAILED"] = 1] = "FAILED";
        Status[Status["SUCCESS"] = 2] = "SUCCESS";
      })(Status || (Status = {}));
      let API;
      (function (API) {
        API[API["UNKNOWN"] = 0] = "UNKNOWN";
        API[API["GLES2"] = 1] = "GLES2";
        API[API["GLES3"] = 2] = "GLES3";
        API[API["METAL"] = 3] = "METAL";
        API[API["VULKAN"] = 4] = "VULKAN";
        API[API["NVN"] = 5] = "NVN";
        API[API["WEBGL"] = 6] = "WEBGL";
        API[API["WEBGL2"] = 7] = "WEBGL2";
        API[API["WEBGPU"] = 8] = "WEBGPU";
      })(API || (API = {}));
      let SurfaceTransform;
      (function (SurfaceTransform) {
        SurfaceTransform[SurfaceTransform["IDENTITY"] = 0] = "IDENTITY";
        SurfaceTransform[SurfaceTransform["ROTATE_90"] = 1] = "ROTATE_90";
        SurfaceTransform[SurfaceTransform["ROTATE_180"] = 2] = "ROTATE_180";
        SurfaceTransform[SurfaceTransform["ROTATE_270"] = 3] = "ROTATE_270";
      })(SurfaceTransform || (SurfaceTransform = {}));
      let Feature;
      (function (Feature) {
        Feature[Feature["ELEMENT_INDEX_UINT"] = 0] = "ELEMENT_INDEX_UINT";
        Feature[Feature["INSTANCED_ARRAYS"] = 1] = "INSTANCED_ARRAYS";
        Feature[Feature["MULTIPLE_RENDER_TARGETS"] = 2] = "MULTIPLE_RENDER_TARGETS";
        Feature[Feature["BLEND_MINMAX"] = 3] = "BLEND_MINMAX";
        Feature[Feature["COMPUTE_SHADER"] = 4] = "COMPUTE_SHADER";
        Feature[Feature["INPUT_ATTACHMENT_BENEFIT"] = 5] = "INPUT_ATTACHMENT_BENEFIT";
        Feature[Feature["SUBPASS_COLOR_INPUT"] = 6] = "SUBPASS_COLOR_INPUT";
        Feature[Feature["SUBPASS_DEPTH_STENCIL_INPUT"] = 7] = "SUBPASS_DEPTH_STENCIL_INPUT";
        Feature[Feature["RASTERIZATION_ORDER_COHERENT"] = 8] = "RASTERIZATION_ORDER_COHERENT";
        Feature[Feature["MULTI_SAMPLE_RESOLVE_DEPTH_STENCIL"] = 9] = "MULTI_SAMPLE_RESOLVE_DEPTH_STENCIL";
        Feature[Feature["COUNT"] = 10] = "COUNT";
      })(Feature || (Feature = {}));
      let Format;
      (function (Format) {
        Format[Format["UNKNOWN"] = 0] = "UNKNOWN";
        Format[Format["A8"] = 1] = "A8";
        Format[Format["L8"] = 2] = "L8";
        Format[Format["LA8"] = 3] = "LA8";
        Format[Format["R8"] = 4] = "R8";
        Format[Format["R8SN"] = 5] = "R8SN";
        Format[Format["R8UI"] = 6] = "R8UI";
        Format[Format["R8I"] = 7] = "R8I";
        Format[Format["R16F"] = 8] = "R16F";
        Format[Format["R16UI"] = 9] = "R16UI";
        Format[Format["R16I"] = 10] = "R16I";
        Format[Format["R32F"] = 11] = "R32F";
        Format[Format["R32UI"] = 12] = "R32UI";
        Format[Format["R32I"] = 13] = "R32I";
        Format[Format["RG8"] = 14] = "RG8";
        Format[Format["RG8SN"] = 15] = "RG8SN";
        Format[Format["RG8UI"] = 16] = "RG8UI";
        Format[Format["RG8I"] = 17] = "RG8I";
        Format[Format["RG16F"] = 18] = "RG16F";
        Format[Format["RG16UI"] = 19] = "RG16UI";
        Format[Format["RG16I"] = 20] = "RG16I";
        Format[Format["RG32F"] = 21] = "RG32F";
        Format[Format["RG32UI"] = 22] = "RG32UI";
        Format[Format["RG32I"] = 23] = "RG32I";
        Format[Format["RGB8"] = 24] = "RGB8";
        Format[Format["SRGB8"] = 25] = "SRGB8";
        Format[Format["RGB8SN"] = 26] = "RGB8SN";
        Format[Format["RGB8UI"] = 27] = "RGB8UI";
        Format[Format["RGB8I"] = 28] = "RGB8I";
        Format[Format["RGB16F"] = 29] = "RGB16F";
        Format[Format["RGB16UI"] = 30] = "RGB16UI";
        Format[Format["RGB16I"] = 31] = "RGB16I";
        Format[Format["RGB32F"] = 32] = "RGB32F";
        Format[Format["RGB32UI"] = 33] = "RGB32UI";
        Format[Format["RGB32I"] = 34] = "RGB32I";
        Format[Format["RGBA8"] = 35] = "RGBA8";
        Format[Format["BGRA8"] = 36] = "BGRA8";
        Format[Format["SRGB8_A8"] = 37] = "SRGB8_A8";
        Format[Format["RGBA8SN"] = 38] = "RGBA8SN";
        Format[Format["RGBA8UI"] = 39] = "RGBA8UI";
        Format[Format["RGBA8I"] = 40] = "RGBA8I";
        Format[Format["RGBA16F"] = 41] = "RGBA16F";
        Format[Format["RGBA16UI"] = 42] = "RGBA16UI";
        Format[Format["RGBA16I"] = 43] = "RGBA16I";
        Format[Format["RGBA32F"] = 44] = "RGBA32F";
        Format[Format["RGBA32UI"] = 45] = "RGBA32UI";
        Format[Format["RGBA32I"] = 46] = "RGBA32I";
        Format[Format["R5G6B5"] = 47] = "R5G6B5";
        Format[Format["R11G11B10F"] = 48] = "R11G11B10F";
        Format[Format["RGB5A1"] = 49] = "RGB5A1";
        Format[Format["RGBA4"] = 50] = "RGBA4";
        Format[Format["RGB10A2"] = 51] = "RGB10A2";
        Format[Format["RGB10A2UI"] = 52] = "RGB10A2UI";
        Format[Format["RGB9E5"] = 53] = "RGB9E5";
        Format[Format["DEPTH"] = 54] = "DEPTH";
        Format[Format["DEPTH_STENCIL"] = 55] = "DEPTH_STENCIL";
        Format[Format["BC1"] = 56] = "BC1";
        Format[Format["BC1_ALPHA"] = 57] = "BC1_ALPHA";
        Format[Format["BC1_SRGB"] = 58] = "BC1_SRGB";
        Format[Format["BC1_SRGB_ALPHA"] = 59] = "BC1_SRGB_ALPHA";
        Format[Format["BC2"] = 60] = "BC2";
        Format[Format["BC2_SRGB"] = 61] = "BC2_SRGB";
        Format[Format["BC3"] = 62] = "BC3";
        Format[Format["BC3_SRGB"] = 63] = "BC3_SRGB";
        Format[Format["BC4"] = 64] = "BC4";
        Format[Format["BC4_SNORM"] = 65] = "BC4_SNORM";
        Format[Format["BC5"] = 66] = "BC5";
        Format[Format["BC5_SNORM"] = 67] = "BC5_SNORM";
        Format[Format["BC6H_UF16"] = 68] = "BC6H_UF16";
        Format[Format["BC6H_SF16"] = 69] = "BC6H_SF16";
        Format[Format["BC7"] = 70] = "BC7";
        Format[Format["BC7_SRGB"] = 71] = "BC7_SRGB";
        Format[Format["ETC_RGB8"] = 72] = "ETC_RGB8";
        Format[Format["ETC2_RGB8"] = 73] = "ETC2_RGB8";
        Format[Format["ETC2_SRGB8"] = 74] = "ETC2_SRGB8";
        Format[Format["ETC2_RGB8_A1"] = 75] = "ETC2_RGB8_A1";
        Format[Format["ETC2_SRGB8_A1"] = 76] = "ETC2_SRGB8_A1";
        Format[Format["ETC2_RGBA8"] = 77] = "ETC2_RGBA8";
        Format[Format["ETC2_SRGB8_A8"] = 78] = "ETC2_SRGB8_A8";
        Format[Format["EAC_R11"] = 79] = "EAC_R11";
        Format[Format["EAC_R11SN"] = 80] = "EAC_R11SN";
        Format[Format["EAC_RG11"] = 81] = "EAC_RG11";
        Format[Format["EAC_RG11SN"] = 82] = "EAC_RG11SN";
        Format[Format["PVRTC_RGB2"] = 83] = "PVRTC_RGB2";
        Format[Format["PVRTC_RGBA2"] = 84] = "PVRTC_RGBA2";
        Format[Format["PVRTC_RGB4"] = 85] = "PVRTC_RGB4";
        Format[Format["PVRTC_RGBA4"] = 86] = "PVRTC_RGBA4";
        Format[Format["PVRTC2_2BPP"] = 87] = "PVRTC2_2BPP";
        Format[Format["PVRTC2_4BPP"] = 88] = "PVRTC2_4BPP";
        Format[Format["ASTC_RGBA_4X4"] = 89] = "ASTC_RGBA_4X4";
        Format[Format["ASTC_RGBA_5X4"] = 90] = "ASTC_RGBA_5X4";
        Format[Format["ASTC_RGBA_5X5"] = 91] = "ASTC_RGBA_5X5";
        Format[Format["ASTC_RGBA_6X5"] = 92] = "ASTC_RGBA_6X5";
        Format[Format["ASTC_RGBA_6X6"] = 93] = "ASTC_RGBA_6X6";
        Format[Format["ASTC_RGBA_8X5"] = 94] = "ASTC_RGBA_8X5";
        Format[Format["ASTC_RGBA_8X6"] = 95] = "ASTC_RGBA_8X6";
        Format[Format["ASTC_RGBA_8X8"] = 96] = "ASTC_RGBA_8X8";
        Format[Format["ASTC_RGBA_10X5"] = 97] = "ASTC_RGBA_10X5";
        Format[Format["ASTC_RGBA_10X6"] = 98] = "ASTC_RGBA_10X6";
        Format[Format["ASTC_RGBA_10X8"] = 99] = "ASTC_RGBA_10X8";
        Format[Format["ASTC_RGBA_10X10"] = 100] = "ASTC_RGBA_10X10";
        Format[Format["ASTC_RGBA_12X10"] = 101] = "ASTC_RGBA_12X10";
        Format[Format["ASTC_RGBA_12X12"] = 102] = "ASTC_RGBA_12X12";
        Format[Format["ASTC_SRGBA_4X4"] = 103] = "ASTC_SRGBA_4X4";
        Format[Format["ASTC_SRGBA_5X4"] = 104] = "ASTC_SRGBA_5X4";
        Format[Format["ASTC_SRGBA_5X5"] = 105] = "ASTC_SRGBA_5X5";
        Format[Format["ASTC_SRGBA_6X5"] = 106] = "ASTC_SRGBA_6X5";
        Format[Format["ASTC_SRGBA_6X6"] = 107] = "ASTC_SRGBA_6X6";
        Format[Format["ASTC_SRGBA_8X5"] = 108] = "ASTC_SRGBA_8X5";
        Format[Format["ASTC_SRGBA_8X6"] = 109] = "ASTC_SRGBA_8X6";
        Format[Format["ASTC_SRGBA_8X8"] = 110] = "ASTC_SRGBA_8X8";
        Format[Format["ASTC_SRGBA_10X5"] = 111] = "ASTC_SRGBA_10X5";
        Format[Format["ASTC_SRGBA_10X6"] = 112] = "ASTC_SRGBA_10X6";
        Format[Format["ASTC_SRGBA_10X8"] = 113] = "ASTC_SRGBA_10X8";
        Format[Format["ASTC_SRGBA_10X10"] = 114] = "ASTC_SRGBA_10X10";
        Format[Format["ASTC_SRGBA_12X10"] = 115] = "ASTC_SRGBA_12X10";
        Format[Format["ASTC_SRGBA_12X12"] = 116] = "ASTC_SRGBA_12X12";
        Format[Format["COUNT"] = 117] = "COUNT";
      })(Format || (Format = {}));
      let FormatType;
      (function (FormatType) {
        FormatType[FormatType["NONE"] = 0] = "NONE";
        FormatType[FormatType["UNORM"] = 1] = "UNORM";
        FormatType[FormatType["SNORM"] = 2] = "SNORM";
        FormatType[FormatType["UINT"] = 3] = "UINT";
        FormatType[FormatType["INT"] = 4] = "INT";
        FormatType[FormatType["UFLOAT"] = 5] = "UFLOAT";
        FormatType[FormatType["FLOAT"] = 6] = "FLOAT";
      })(FormatType || (FormatType = {}));
      let Type$1;
      (function (Type) {
        Type[Type["UNKNOWN"] = 0] = "UNKNOWN";
        Type[Type["BOOL"] = 1] = "BOOL";
        Type[Type["BOOL2"] = 2] = "BOOL2";
        Type[Type["BOOL3"] = 3] = "BOOL3";
        Type[Type["BOOL4"] = 4] = "BOOL4";
        Type[Type["INT"] = 5] = "INT";
        Type[Type["INT2"] = 6] = "INT2";
        Type[Type["INT3"] = 7] = "INT3";
        Type[Type["INT4"] = 8] = "INT4";
        Type[Type["UINT"] = 9] = "UINT";
        Type[Type["UINT2"] = 10] = "UINT2";
        Type[Type["UINT3"] = 11] = "UINT3";
        Type[Type["UINT4"] = 12] = "UINT4";
        Type[Type["FLOAT"] = 13] = "FLOAT";
        Type[Type["FLOAT2"] = 14] = "FLOAT2";
        Type[Type["FLOAT3"] = 15] = "FLOAT3";
        Type[Type["FLOAT4"] = 16] = "FLOAT4";
        Type[Type["MAT2"] = 17] = "MAT2";
        Type[Type["MAT2X3"] = 18] = "MAT2X3";
        Type[Type["MAT2X4"] = 19] = "MAT2X4";
        Type[Type["MAT3X2"] = 20] = "MAT3X2";
        Type[Type["MAT3"] = 21] = "MAT3";
        Type[Type["MAT3X4"] = 22] = "MAT3X4";
        Type[Type["MAT4X2"] = 23] = "MAT4X2";
        Type[Type["MAT4X3"] = 24] = "MAT4X3";
        Type[Type["MAT4"] = 25] = "MAT4";
        Type[Type["SAMPLER1D"] = 26] = "SAMPLER1D";
        Type[Type["SAMPLER1D_ARRAY"] = 27] = "SAMPLER1D_ARRAY";
        Type[Type["SAMPLER2D"] = 28] = "SAMPLER2D";
        Type[Type["SAMPLER2D_ARRAY"] = 29] = "SAMPLER2D_ARRAY";
        Type[Type["SAMPLER3D"] = 30] = "SAMPLER3D";
        Type[Type["SAMPLER_CUBE"] = 31] = "SAMPLER_CUBE";
        Type[Type["SAMPLER"] = 32] = "SAMPLER";
        Type[Type["TEXTURE1D"] = 33] = "TEXTURE1D";
        Type[Type["TEXTURE1D_ARRAY"] = 34] = "TEXTURE1D_ARRAY";
        Type[Type["TEXTURE2D"] = 35] = "TEXTURE2D";
        Type[Type["TEXTURE2D_ARRAY"] = 36] = "TEXTURE2D_ARRAY";
        Type[Type["TEXTURE3D"] = 37] = "TEXTURE3D";
        Type[Type["TEXTURE_CUBE"] = 38] = "TEXTURE_CUBE";
        Type[Type["IMAGE1D"] = 39] = "IMAGE1D";
        Type[Type["IMAGE1D_ARRAY"] = 40] = "IMAGE1D_ARRAY";
        Type[Type["IMAGE2D"] = 41] = "IMAGE2D";
        Type[Type["IMAGE2D_ARRAY"] = 42] = "IMAGE2D_ARRAY";
        Type[Type["IMAGE3D"] = 43] = "IMAGE3D";
        Type[Type["IMAGE_CUBE"] = 44] = "IMAGE_CUBE";
        Type[Type["SUBPASS_INPUT"] = 45] = "SUBPASS_INPUT";
        Type[Type["COUNT"] = 46] = "COUNT";
      })(Type$1 || (Type$1 = {}));
      let BufferUsageBit;
      (function (BufferUsageBit) {
        BufferUsageBit[BufferUsageBit["NONE"] = 0] = "NONE";
        BufferUsageBit[BufferUsageBit["TRANSFER_SRC"] = 1] = "TRANSFER_SRC";
        BufferUsageBit[BufferUsageBit["TRANSFER_DST"] = 2] = "TRANSFER_DST";
        BufferUsageBit[BufferUsageBit["INDEX"] = 4] = "INDEX";
        BufferUsageBit[BufferUsageBit["VERTEX"] = 8] = "VERTEX";
        BufferUsageBit[BufferUsageBit["UNIFORM"] = 16] = "UNIFORM";
        BufferUsageBit[BufferUsageBit["STORAGE"] = 32] = "STORAGE";
        BufferUsageBit[BufferUsageBit["INDIRECT"] = 64] = "INDIRECT";
      })(BufferUsageBit || (BufferUsageBit = {}));
      let BufferFlagBit;
      (function (BufferFlagBit) {
        BufferFlagBit[BufferFlagBit["NONE"] = 0] = "NONE";
      })(BufferFlagBit || (BufferFlagBit = {}));
      let MemoryAccessBit;
      (function (MemoryAccessBit) {
        MemoryAccessBit[MemoryAccessBit["NONE"] = 0] = "NONE";
        MemoryAccessBit[MemoryAccessBit["READ_ONLY"] = 1] = "READ_ONLY";
        MemoryAccessBit[MemoryAccessBit["WRITE_ONLY"] = 2] = "WRITE_ONLY";
        MemoryAccessBit[MemoryAccessBit["READ_WRITE"] = 3] = "READ_WRITE";
      })(MemoryAccessBit || (MemoryAccessBit = {}));
      let MemoryUsageBit;
      (function (MemoryUsageBit) {
        MemoryUsageBit[MemoryUsageBit["NONE"] = 0] = "NONE";
        MemoryUsageBit[MemoryUsageBit["DEVICE"] = 1] = "DEVICE";
        MemoryUsageBit[MemoryUsageBit["HOST"] = 2] = "HOST";
      })(MemoryUsageBit || (MemoryUsageBit = {}));
      let TextureType;
      (function (TextureType) {
        TextureType[TextureType["TEX1D"] = 0] = "TEX1D";
        TextureType[TextureType["TEX2D"] = 1] = "TEX2D";
        TextureType[TextureType["TEX3D"] = 2] = "TEX3D";
        TextureType[TextureType["CUBE"] = 3] = "CUBE";
        TextureType[TextureType["TEX1D_ARRAY"] = 4] = "TEX1D_ARRAY";
        TextureType[TextureType["TEX2D_ARRAY"] = 5] = "TEX2D_ARRAY";
      })(TextureType || (TextureType = {}));
      let TextureUsageBit;
      (function (TextureUsageBit) {
        TextureUsageBit[TextureUsageBit["NONE"] = 0] = "NONE";
        TextureUsageBit[TextureUsageBit["TRANSFER_SRC"] = 1] = "TRANSFER_SRC";
        TextureUsageBit[TextureUsageBit["TRANSFER_DST"] = 2] = "TRANSFER_DST";
        TextureUsageBit[TextureUsageBit["SAMPLED"] = 4] = "SAMPLED";
        TextureUsageBit[TextureUsageBit["STORAGE"] = 8] = "STORAGE";
        TextureUsageBit[TextureUsageBit["COLOR_ATTACHMENT"] = 16] = "COLOR_ATTACHMENT";
        TextureUsageBit[TextureUsageBit["DEPTH_STENCIL_ATTACHMENT"] = 32] = "DEPTH_STENCIL_ATTACHMENT";
        TextureUsageBit[TextureUsageBit["INPUT_ATTACHMENT"] = 64] = "INPUT_ATTACHMENT";
      })(TextureUsageBit || (TextureUsageBit = {}));
      let TextureFlagBit;
      (function (TextureFlagBit) {
        TextureFlagBit[TextureFlagBit["NONE"] = 0] = "NONE";
        TextureFlagBit[TextureFlagBit["GEN_MIPMAP"] = 1] = "GEN_MIPMAP";
        TextureFlagBit[TextureFlagBit["GENERAL_LAYOUT"] = 2] = "GENERAL_LAYOUT";
        TextureFlagBit[TextureFlagBit["EXTERNAL_OES"] = 4] = "EXTERNAL_OES";
        TextureFlagBit[TextureFlagBit["EXTERNAL_NORMAL"] = 8] = "EXTERNAL_NORMAL";
        TextureFlagBit[TextureFlagBit["LAZILY_ALLOCATED"] = 16] = "LAZILY_ALLOCATED";
        TextureFlagBit[TextureFlagBit["MUTABLE_VIEW_FORMAT"] = 64] = "MUTABLE_VIEW_FORMAT";
      })(TextureFlagBit || (TextureFlagBit = {}));
      let FormatFeatureBit;
      (function (FormatFeatureBit) {
        FormatFeatureBit[FormatFeatureBit["NONE"] = 0] = "NONE";
        FormatFeatureBit[FormatFeatureBit["RENDER_TARGET"] = 1] = "RENDER_TARGET";
        FormatFeatureBit[FormatFeatureBit["SAMPLED_TEXTURE"] = 2] = "SAMPLED_TEXTURE";
        FormatFeatureBit[FormatFeatureBit["LINEAR_FILTER"] = 4] = "LINEAR_FILTER";
        FormatFeatureBit[FormatFeatureBit["STORAGE_TEXTURE"] = 8] = "STORAGE_TEXTURE";
        FormatFeatureBit[FormatFeatureBit["VERTEX_ATTRIBUTE"] = 16] = "VERTEX_ATTRIBUTE";
      })(FormatFeatureBit || (FormatFeatureBit = {}));
      let SampleCount;
      (function (SampleCount) {
        SampleCount[SampleCount["X1"] = 1] = "X1";
        SampleCount[SampleCount["X2"] = 2] = "X2";
        SampleCount[SampleCount["X4"] = 4] = "X4";
        SampleCount[SampleCount["X8"] = 8] = "X8";
        SampleCount[SampleCount["X16"] = 16] = "X16";
        SampleCount[SampleCount["X32"] = 32] = "X32";
        SampleCount[SampleCount["X64"] = 64] = "X64";
      })(SampleCount || (SampleCount = {}));
      let VsyncMode;
      (function (VsyncMode) {
        VsyncMode[VsyncMode["OFF"] = 0] = "OFF";
        VsyncMode[VsyncMode["ON"] = 1] = "ON";
        VsyncMode[VsyncMode["RELAXED"] = 2] = "RELAXED";
        VsyncMode[VsyncMode["MAILBOX"] = 3] = "MAILBOX";
        VsyncMode[VsyncMode["HALF"] = 4] = "HALF";
      })(VsyncMode || (VsyncMode = {}));
      let Filter$1;
      (function (Filter) {
        Filter[Filter["NONE"] = 0] = "NONE";
        Filter[Filter["POINT"] = 1] = "POINT";
        Filter[Filter["LINEAR"] = 2] = "LINEAR";
        Filter[Filter["ANISOTROPIC"] = 3] = "ANISOTROPIC";
      })(Filter$1 || (Filter$1 = {}));
      let Address;
      (function (Address) {
        Address[Address["WRAP"] = 0] = "WRAP";
        Address[Address["MIRROR"] = 1] = "MIRROR";
        Address[Address["CLAMP"] = 2] = "CLAMP";
        Address[Address["BORDER"] = 3] = "BORDER";
      })(Address || (Address = {}));
      let ComparisonFunc;
      (function (ComparisonFunc) {
        ComparisonFunc[ComparisonFunc["NEVER"] = 0] = "NEVER";
        ComparisonFunc[ComparisonFunc["LESS"] = 1] = "LESS";
        ComparisonFunc[ComparisonFunc["EQUAL"] = 2] = "EQUAL";
        ComparisonFunc[ComparisonFunc["LESS_EQUAL"] = 3] = "LESS_EQUAL";
        ComparisonFunc[ComparisonFunc["GREATER"] = 4] = "GREATER";
        ComparisonFunc[ComparisonFunc["NOT_EQUAL"] = 5] = "NOT_EQUAL";
        ComparisonFunc[ComparisonFunc["GREATER_EQUAL"] = 6] = "GREATER_EQUAL";
        ComparisonFunc[ComparisonFunc["ALWAYS"] = 7] = "ALWAYS";
      })(ComparisonFunc || (ComparisonFunc = {}));
      let StencilOp;
      (function (StencilOp) {
        StencilOp[StencilOp["ZERO"] = 0] = "ZERO";
        StencilOp[StencilOp["KEEP"] = 1] = "KEEP";
        StencilOp[StencilOp["REPLACE"] = 2] = "REPLACE";
        StencilOp[StencilOp["INCR"] = 3] = "INCR";
        StencilOp[StencilOp["DECR"] = 4] = "DECR";
        StencilOp[StencilOp["INVERT"] = 5] = "INVERT";
        StencilOp[StencilOp["INCR_WRAP"] = 6] = "INCR_WRAP";
        StencilOp[StencilOp["DECR_WRAP"] = 7] = "DECR_WRAP";
      })(StencilOp || (StencilOp = {}));
      let BlendFactor;
      (function (BlendFactor) {
        BlendFactor[BlendFactor["ZERO"] = 0] = "ZERO";
        BlendFactor[BlendFactor["ONE"] = 1] = "ONE";
        BlendFactor[BlendFactor["SRC_ALPHA"] = 2] = "SRC_ALPHA";
        BlendFactor[BlendFactor["DST_ALPHA"] = 3] = "DST_ALPHA";
        BlendFactor[BlendFactor["ONE_MINUS_SRC_ALPHA"] = 4] = "ONE_MINUS_SRC_ALPHA";
        BlendFactor[BlendFactor["ONE_MINUS_DST_ALPHA"] = 5] = "ONE_MINUS_DST_ALPHA";
        BlendFactor[BlendFactor["SRC_COLOR"] = 6] = "SRC_COLOR";
        BlendFactor[BlendFactor["DST_COLOR"] = 7] = "DST_COLOR";
        BlendFactor[BlendFactor["ONE_MINUS_SRC_COLOR"] = 8] = "ONE_MINUS_SRC_COLOR";
        BlendFactor[BlendFactor["ONE_MINUS_DST_COLOR"] = 9] = "ONE_MINUS_DST_COLOR";
        BlendFactor[BlendFactor["SRC_ALPHA_SATURATE"] = 10] = "SRC_ALPHA_SATURATE";
        BlendFactor[BlendFactor["CONSTANT_COLOR"] = 11] = "CONSTANT_COLOR";
        BlendFactor[BlendFactor["ONE_MINUS_CONSTANT_COLOR"] = 12] = "ONE_MINUS_CONSTANT_COLOR";
        BlendFactor[BlendFactor["CONSTANT_ALPHA"] = 13] = "CONSTANT_ALPHA";
        BlendFactor[BlendFactor["ONE_MINUS_CONSTANT_ALPHA"] = 14] = "ONE_MINUS_CONSTANT_ALPHA";
      })(BlendFactor || (BlendFactor = {}));
      let BlendOp;
      (function (BlendOp) {
        BlendOp[BlendOp["ADD"] = 0] = "ADD";
        BlendOp[BlendOp["SUB"] = 1] = "SUB";
        BlendOp[BlendOp["REV_SUB"] = 2] = "REV_SUB";
        BlendOp[BlendOp["MIN"] = 3] = "MIN";
        BlendOp[BlendOp["MAX"] = 4] = "MAX";
      })(BlendOp || (BlendOp = {}));
      let ColorMask;
      (function (ColorMask) {
        ColorMask[ColorMask["NONE"] = 0] = "NONE";
        ColorMask[ColorMask["R"] = 1] = "R";
        ColorMask[ColorMask["G"] = 2] = "G";
        ColorMask[ColorMask["B"] = 4] = "B";
        ColorMask[ColorMask["A"] = 8] = "A";
        ColorMask[ColorMask["ALL"] = 15] = "ALL";
      })(ColorMask || (ColorMask = {}));
      let ShaderStageFlagBit;
      (function (ShaderStageFlagBit) {
        ShaderStageFlagBit[ShaderStageFlagBit["NONE"] = 0] = "NONE";
        ShaderStageFlagBit[ShaderStageFlagBit["VERTEX"] = 1] = "VERTEX";
        ShaderStageFlagBit[ShaderStageFlagBit["CONTROL"] = 2] = "CONTROL";
        ShaderStageFlagBit[ShaderStageFlagBit["EVALUATION"] = 4] = "EVALUATION";
        ShaderStageFlagBit[ShaderStageFlagBit["GEOMETRY"] = 8] = "GEOMETRY";
        ShaderStageFlagBit[ShaderStageFlagBit["FRAGMENT"] = 16] = "FRAGMENT";
        ShaderStageFlagBit[ShaderStageFlagBit["COMPUTE"] = 32] = "COMPUTE";
        ShaderStageFlagBit[ShaderStageFlagBit["ALL"] = 63] = "ALL";
      })(ShaderStageFlagBit || (ShaderStageFlagBit = {}));
      let LoadOp;
      (function (LoadOp) {
        LoadOp[LoadOp["LOAD"] = 0] = "LOAD";
        LoadOp[LoadOp["CLEAR"] = 1] = "CLEAR";
        LoadOp[LoadOp["DISCARD"] = 2] = "DISCARD";
      })(LoadOp || (LoadOp = {}));
      let StoreOp;
      (function (StoreOp) {
        StoreOp[StoreOp["STORE"] = 0] = "STORE";
        StoreOp[StoreOp["DISCARD"] = 1] = "DISCARD";
      })(StoreOp || (StoreOp = {}));
      let AccessFlagBit;
      (function (AccessFlagBit) {
        AccessFlagBit[AccessFlagBit["NONE"] = 0] = "NONE";
        AccessFlagBit[AccessFlagBit["INDIRECT_BUFFER"] = 1] = "INDIRECT_BUFFER";
        AccessFlagBit[AccessFlagBit["INDEX_BUFFER"] = 2] = "INDEX_BUFFER";
        AccessFlagBit[AccessFlagBit["VERTEX_BUFFER"] = 4] = "VERTEX_BUFFER";
        AccessFlagBit[AccessFlagBit["VERTEX_SHADER_READ_UNIFORM_BUFFER"] = 8] = "VERTEX_SHADER_READ_UNIFORM_BUFFER";
        AccessFlagBit[AccessFlagBit["VERTEX_SHADER_READ_TEXTURE"] = 16] = "VERTEX_SHADER_READ_TEXTURE";
        AccessFlagBit[AccessFlagBit["VERTEX_SHADER_READ_OTHER"] = 32] = "VERTEX_SHADER_READ_OTHER";
        AccessFlagBit[AccessFlagBit["FRAGMENT_SHADER_READ_UNIFORM_BUFFER"] = 64] = "FRAGMENT_SHADER_READ_UNIFORM_BUFFER";
        AccessFlagBit[AccessFlagBit["FRAGMENT_SHADER_READ_TEXTURE"] = 128] = "FRAGMENT_SHADER_READ_TEXTURE";
        AccessFlagBit[AccessFlagBit["FRAGMENT_SHADER_READ_COLOR_INPUT_ATTACHMENT"] = 256] = "FRAGMENT_SHADER_READ_COLOR_INPUT_ATTACHMENT";
        AccessFlagBit[AccessFlagBit["FRAGMENT_SHADER_READ_DEPTH_STENCIL_INPUT_ATTACHMENT"] = 512] = "FRAGMENT_SHADER_READ_DEPTH_STENCIL_INPUT_ATTACHMENT";
        AccessFlagBit[AccessFlagBit["FRAGMENT_SHADER_READ_OTHER"] = 1024] = "FRAGMENT_SHADER_READ_OTHER";
        AccessFlagBit[AccessFlagBit["COLOR_ATTACHMENT_READ"] = 2048] = "COLOR_ATTACHMENT_READ";
        AccessFlagBit[AccessFlagBit["DEPTH_STENCIL_ATTACHMENT_READ"] = 4096] = "DEPTH_STENCIL_ATTACHMENT_READ";
        AccessFlagBit[AccessFlagBit["COMPUTE_SHADER_READ_UNIFORM_BUFFER"] = 8192] = "COMPUTE_SHADER_READ_UNIFORM_BUFFER";
        AccessFlagBit[AccessFlagBit["COMPUTE_SHADER_READ_TEXTURE"] = 16384] = "COMPUTE_SHADER_READ_TEXTURE";
        AccessFlagBit[AccessFlagBit["COMPUTE_SHADER_READ_OTHER"] = 32768] = "COMPUTE_SHADER_READ_OTHER";
        AccessFlagBit[AccessFlagBit["TRANSFER_READ"] = 65536] = "TRANSFER_READ";
        AccessFlagBit[AccessFlagBit["HOST_READ"] = 131072] = "HOST_READ";
        AccessFlagBit[AccessFlagBit["PRESENT"] = 262144] = "PRESENT";
        AccessFlagBit[AccessFlagBit["VERTEX_SHADER_WRITE"] = 524288] = "VERTEX_SHADER_WRITE";
        AccessFlagBit[AccessFlagBit["FRAGMENT_SHADER_WRITE"] = 1048576] = "FRAGMENT_SHADER_WRITE";
        AccessFlagBit[AccessFlagBit["COLOR_ATTACHMENT_WRITE"] = 2097152] = "COLOR_ATTACHMENT_WRITE";
        AccessFlagBit[AccessFlagBit["DEPTH_STENCIL_ATTACHMENT_WRITE"] = 4194304] = "DEPTH_STENCIL_ATTACHMENT_WRITE";
        AccessFlagBit[AccessFlagBit["COMPUTE_SHADER_WRITE"] = 8388608] = "COMPUTE_SHADER_WRITE";
        AccessFlagBit[AccessFlagBit["TRANSFER_WRITE"] = 16777216] = "TRANSFER_WRITE";
        AccessFlagBit[AccessFlagBit["HOST_PREINITIALIZED"] = 33554432] = "HOST_PREINITIALIZED";
        AccessFlagBit[AccessFlagBit["HOST_WRITE"] = 67108864] = "HOST_WRITE";
      })(AccessFlagBit || (AccessFlagBit = {}));
      let ResolveMode;
      (function (ResolveMode) {
        ResolveMode[ResolveMode["NONE"] = 0] = "NONE";
        ResolveMode[ResolveMode["SAMPLE_ZERO"] = 1] = "SAMPLE_ZERO";
        ResolveMode[ResolveMode["AVERAGE"] = 2] = "AVERAGE";
        ResolveMode[ResolveMode["MIN"] = 3] = "MIN";
        ResolveMode[ResolveMode["MAX"] = 4] = "MAX";
      })(ResolveMode || (ResolveMode = {}));
      let PipelineBindPoint;
      (function (PipelineBindPoint) {
        PipelineBindPoint[PipelineBindPoint["GRAPHICS"] = 0] = "GRAPHICS";
        PipelineBindPoint[PipelineBindPoint["COMPUTE"] = 1] = "COMPUTE";
        PipelineBindPoint[PipelineBindPoint["RAY_TRACING"] = 2] = "RAY_TRACING";
      })(PipelineBindPoint || (PipelineBindPoint = {}));
      let PrimitiveMode;
      (function (PrimitiveMode) {
        PrimitiveMode[PrimitiveMode["POINT_LIST"] = 0] = "POINT_LIST";
        PrimitiveMode[PrimitiveMode["LINE_LIST"] = 1] = "LINE_LIST";
        PrimitiveMode[PrimitiveMode["LINE_STRIP"] = 2] = "LINE_STRIP";
        PrimitiveMode[PrimitiveMode["LINE_LOOP"] = 3] = "LINE_LOOP";
        PrimitiveMode[PrimitiveMode["LINE_LIST_ADJACENCY"] = 4] = "LINE_LIST_ADJACENCY";
        PrimitiveMode[PrimitiveMode["LINE_STRIP_ADJACENCY"] = 5] = "LINE_STRIP_ADJACENCY";
        PrimitiveMode[PrimitiveMode["ISO_LINE_LIST"] = 6] = "ISO_LINE_LIST";
        PrimitiveMode[PrimitiveMode["TRIANGLE_LIST"] = 7] = "TRIANGLE_LIST";
        PrimitiveMode[PrimitiveMode["TRIANGLE_STRIP"] = 8] = "TRIANGLE_STRIP";
        PrimitiveMode[PrimitiveMode["TRIANGLE_FAN"] = 9] = "TRIANGLE_FAN";
        PrimitiveMode[PrimitiveMode["TRIANGLE_LIST_ADJACENCY"] = 10] = "TRIANGLE_LIST_ADJACENCY";
        PrimitiveMode[PrimitiveMode["TRIANGLE_STRIP_ADJACENCY"] = 11] = "TRIANGLE_STRIP_ADJACENCY";
        PrimitiveMode[PrimitiveMode["TRIANGLE_PATCH_ADJACENCY"] = 12] = "TRIANGLE_PATCH_ADJACENCY";
        PrimitiveMode[PrimitiveMode["QUAD_PATCH_LIST"] = 13] = "QUAD_PATCH_LIST";
      })(PrimitiveMode || (PrimitiveMode = {}));
      let PolygonMode;
      (function (PolygonMode) {
        PolygonMode[PolygonMode["FILL"] = 0] = "FILL";
        PolygonMode[PolygonMode["POINT"] = 1] = "POINT";
        PolygonMode[PolygonMode["LINE"] = 2] = "LINE";
      })(PolygonMode || (PolygonMode = {}));
      let ShadeModel;
      (function (ShadeModel) {
        ShadeModel[ShadeModel["GOURAND"] = 0] = "GOURAND";
        ShadeModel[ShadeModel["FLAT"] = 1] = "FLAT";
      })(ShadeModel || (ShadeModel = {}));
      let CullMode;
      (function (CullMode) {
        CullMode[CullMode["NONE"] = 0] = "NONE";
        CullMode[CullMode["FRONT"] = 1] = "FRONT";
        CullMode[CullMode["BACK"] = 2] = "BACK";
      })(CullMode || (CullMode = {}));
      let DynamicStateFlagBit;
      (function (DynamicStateFlagBit) {
        DynamicStateFlagBit[DynamicStateFlagBit["NONE"] = 0] = "NONE";
        DynamicStateFlagBit[DynamicStateFlagBit["LINE_WIDTH"] = 1] = "LINE_WIDTH";
        DynamicStateFlagBit[DynamicStateFlagBit["DEPTH_BIAS"] = 2] = "DEPTH_BIAS";
        DynamicStateFlagBit[DynamicStateFlagBit["BLEND_CONSTANTS"] = 4] = "BLEND_CONSTANTS";
        DynamicStateFlagBit[DynamicStateFlagBit["DEPTH_BOUNDS"] = 8] = "DEPTH_BOUNDS";
        DynamicStateFlagBit[DynamicStateFlagBit["STENCIL_WRITE_MASK"] = 16] = "STENCIL_WRITE_MASK";
        DynamicStateFlagBit[DynamicStateFlagBit["STENCIL_COMPARE_MASK"] = 32] = "STENCIL_COMPARE_MASK";
      })(DynamicStateFlagBit || (DynamicStateFlagBit = {}));
      let StencilFace;
      (function (StencilFace) {
        StencilFace[StencilFace["FRONT"] = 1] = "FRONT";
        StencilFace[StencilFace["BACK"] = 2] = "BACK";
        StencilFace[StencilFace["ALL"] = 3] = "ALL";
      })(StencilFace || (StencilFace = {}));
      let DescriptorType;
      (function (DescriptorType) {
        DescriptorType[DescriptorType["UNKNOWN"] = 0] = "UNKNOWN";
        DescriptorType[DescriptorType["UNIFORM_BUFFER"] = 1] = "UNIFORM_BUFFER";
        DescriptorType[DescriptorType["DYNAMIC_UNIFORM_BUFFER"] = 2] = "DYNAMIC_UNIFORM_BUFFER";
        DescriptorType[DescriptorType["STORAGE_BUFFER"] = 4] = "STORAGE_BUFFER";
        DescriptorType[DescriptorType["DYNAMIC_STORAGE_BUFFER"] = 8] = "DYNAMIC_STORAGE_BUFFER";
        DescriptorType[DescriptorType["SAMPLER_TEXTURE"] = 16] = "SAMPLER_TEXTURE";
        DescriptorType[DescriptorType["SAMPLER"] = 32] = "SAMPLER";
        DescriptorType[DescriptorType["TEXTURE"] = 64] = "TEXTURE";
        DescriptorType[DescriptorType["STORAGE_IMAGE"] = 128] = "STORAGE_IMAGE";
        DescriptorType[DescriptorType["INPUT_ATTACHMENT"] = 256] = "INPUT_ATTACHMENT";
      })(DescriptorType || (DescriptorType = {}));
      let QueueType;
      (function (QueueType) {
        QueueType[QueueType["GRAPHICS"] = 0] = "GRAPHICS";
        QueueType[QueueType["COMPUTE"] = 1] = "COMPUTE";
        QueueType[QueueType["TRANSFER"] = 2] = "TRANSFER";
      })(QueueType || (QueueType = {}));
      let QueryType;
      (function (QueryType) {
        QueryType[QueryType["OCCLUSION"] = 0] = "OCCLUSION";
        QueryType[QueryType["PIPELINE_STATISTICS"] = 1] = "PIPELINE_STATISTICS";
        QueryType[QueryType["TIMESTAMP"] = 2] = "TIMESTAMP";
      })(QueryType || (QueryType = {}));
      let CommandBufferType;
      (function (CommandBufferType) {
        CommandBufferType[CommandBufferType["PRIMARY"] = 0] = "PRIMARY";
        CommandBufferType[CommandBufferType["SECONDARY"] = 1] = "SECONDARY";
      })(CommandBufferType || (CommandBufferType = {}));
      let ClearFlagBit;
      (function (ClearFlagBit) {
        ClearFlagBit[ClearFlagBit["NONE"] = 0] = "NONE";
        ClearFlagBit[ClearFlagBit["COLOR"] = 1] = "COLOR";
        ClearFlagBit[ClearFlagBit["DEPTH"] = 2] = "DEPTH";
        ClearFlagBit[ClearFlagBit["STENCIL"] = 4] = "STENCIL";
        ClearFlagBit[ClearFlagBit["DEPTH_STENCIL"] = 6] = "DEPTH_STENCIL";
        ClearFlagBit[ClearFlagBit["ALL"] = 7] = "ALL";
      })(ClearFlagBit || (ClearFlagBit = {}));
      let BarrierType;
      (function (BarrierType) {
        BarrierType[BarrierType["FULL"] = 0] = "FULL";
        BarrierType[BarrierType["SPLIT_BEGIN"] = 1] = "SPLIT_BEGIN";
        BarrierType[BarrierType["SPLIT_END"] = 2] = "SPLIT_END";
      })(BarrierType || (BarrierType = {}));
      let PassType;
      (function (PassType) {
        PassType[PassType["RASTER"] = 0] = "RASTER";
        PassType[PassType["COMPUTE"] = 1] = "COMPUTE";
        PassType[PassType["COPY"] = 2] = "COPY";
        PassType[PassType["MOVE"] = 3] = "MOVE";
        PassType[PassType["RAYTRACE"] = 4] = "RAYTRACE";
        PassType[PassType["PRESENT"] = 5] = "PRESENT";
      })(PassType || (PassType = {}));
      class Size {
        constructor(x = 0, y = 0, z = 0) {
          this.x = x;
          this.y = y;
          this.z = z;
        }
        copy(info) {
          this.x = info.x;
          this.y = info.y;
          this.z = info.z;
          return this;
        }
      }
      class DeviceCaps {
        constructor(maxVertexAttributes = 0, maxVertexUniformVectors = 0, maxFragmentUniformVectors = 0, maxTextureUnits = 0, maxImageUnits = 0, maxVertexTextureUnits = 0, maxColorRenderTargets = 0, maxShaderStorageBufferBindings = 0, maxShaderStorageBlockSize = 0, maxUniformBufferBindings = 0, maxUniformBlockSize = 0, maxTextureSize = 0, maxCubeMapTextureSize = 0, maxArrayTextureLayers = 0, max3DTextureSize = 0, uboOffsetAlignment = 1, maxComputeSharedMemorySize = 0, maxComputeWorkGroupInvocations = 0, maxComputeWorkGroupSize = new Size(), maxComputeWorkGroupCount = new Size(), supportQuery = false, clipSpaceMinZ = -1, screenSpaceSignY = 1, clipSpaceSignY = 1) {
          this.maxVertexAttributes = maxVertexAttributes;
          this.maxVertexUniformVectors = maxVertexUniformVectors;
          this.maxFragmentUniformVectors = maxFragmentUniformVectors;
          this.maxTextureUnits = maxTextureUnits;
          this.maxImageUnits = maxImageUnits;
          this.maxVertexTextureUnits = maxVertexTextureUnits;
          this.maxColorRenderTargets = maxColorRenderTargets;
          this.maxShaderStorageBufferBindings = maxShaderStorageBufferBindings;
          this.maxShaderStorageBlockSize = maxShaderStorageBlockSize;
          this.maxUniformBufferBindings = maxUniformBufferBindings;
          this.maxUniformBlockSize = maxUniformBlockSize;
          this.maxTextureSize = maxTextureSize;
          this.maxCubeMapTextureSize = maxCubeMapTextureSize;
          this.maxArrayTextureLayers = maxArrayTextureLayers;
          this.max3DTextureSize = max3DTextureSize;
          this.uboOffsetAlignment = uboOffsetAlignment;
          this.maxComputeSharedMemorySize = maxComputeSharedMemorySize;
          this.maxComputeWorkGroupInvocations = maxComputeWorkGroupInvocations;
          this.maxComputeWorkGroupSize = maxComputeWorkGroupSize;
          this.maxComputeWorkGroupCount = maxComputeWorkGroupCount;
          this.supportQuery = supportQuery;
          this.clipSpaceMinZ = clipSpaceMinZ;
          this.screenSpaceSignY = screenSpaceSignY;
          this.clipSpaceSignY = clipSpaceSignY;
        }
        copy(info) {
          this.maxVertexAttributes = info.maxVertexAttributes;
          this.maxVertexUniformVectors = info.maxVertexUniformVectors;
          this.maxFragmentUniformVectors = info.maxFragmentUniformVectors;
          this.maxTextureUnits = info.maxTextureUnits;
          this.maxImageUnits = info.maxImageUnits;
          this.maxVertexTextureUnits = info.maxVertexTextureUnits;
          this.maxColorRenderTargets = info.maxColorRenderTargets;
          this.maxShaderStorageBufferBindings = info.maxShaderStorageBufferBindings;
          this.maxShaderStorageBlockSize = info.maxShaderStorageBlockSize;
          this.maxUniformBufferBindings = info.maxUniformBufferBindings;
          this.maxUniformBlockSize = info.maxUniformBlockSize;
          this.maxTextureSize = info.maxTextureSize;
          this.maxCubeMapTextureSize = info.maxCubeMapTextureSize;
          this.maxArrayTextureLayers = info.maxArrayTextureLayers;
          this.max3DTextureSize = info.max3DTextureSize;
          this.uboOffsetAlignment = info.uboOffsetAlignment;
          this.maxComputeSharedMemorySize = info.maxComputeSharedMemorySize;
          this.maxComputeWorkGroupInvocations = info.maxComputeWorkGroupInvocations;
          this.maxComputeWorkGroupSize.copy(info.maxComputeWorkGroupSize);
          this.maxComputeWorkGroupCount.copy(info.maxComputeWorkGroupCount);
          this.supportQuery = info.supportQuery;
          this.clipSpaceMinZ = info.clipSpaceMinZ;
          this.screenSpaceSignY = info.screenSpaceSignY;
          this.clipSpaceSignY = info.clipSpaceSignY;
          return this;
        }
      }
      class DeviceOptions {
        constructor(enableBarrierDeduce = true) {
          this.enableBarrierDeduce = enableBarrierDeduce;
        }
        copy(info) {
          this.enableBarrierDeduce = info.enableBarrierDeduce;
          return this;
        }
      }
      class Offset {
        constructor(x = 0, y = 0, z = 0) {
          this.x = x;
          this.y = y;
          this.z = z;
        }
        copy(info) {
          this.x = info.x;
          this.y = info.y;
          this.z = info.z;
          return this;
        }
      }
      class Rect {
        constructor(x = 0, y = 0, width = 0, height = 0) {
          this.x = x;
          this.y = y;
          this.width = width;
          this.height = height;
        }
        copy(info) {
          this.x = info.x;
          this.y = info.y;
          this.width = info.width;
          this.height = info.height;
          return this;
        }
      }
      class Extent {
        constructor(width = 0, height = 0, depth = 1) {
          this.width = width;
          this.height = height;
          this.depth = depth;
        }
        copy(info) {
          this.width = info.width;
          this.height = info.height;
          this.depth = info.depth;
          return this;
        }
      }
      class TextureSubresLayers {
        constructor(mipLevel = 0, baseArrayLayer = 0, layerCount = 1) {
          this.mipLevel = mipLevel;
          this.baseArrayLayer = baseArrayLayer;
          this.layerCount = layerCount;
        }
        copy(info) {
          this.mipLevel = info.mipLevel;
          this.baseArrayLayer = info.baseArrayLayer;
          this.layerCount = info.layerCount;
          return this;
        }
      }
      class TextureSubresRange {
        constructor(baseMipLevel = 0, levelCount = 1, baseArrayLayer = 0, layerCount = 1) {
          this.baseMipLevel = baseMipLevel;
          this.levelCount = levelCount;
          this.baseArrayLayer = baseArrayLayer;
          this.layerCount = layerCount;
        }
        copy(info) {
          this.baseMipLevel = info.baseMipLevel;
          this.levelCount = info.levelCount;
          this.baseArrayLayer = info.baseArrayLayer;
          this.layerCount = info.layerCount;
          return this;
        }
      }
      class TextureCopy {
        constructor(srcSubres = new TextureSubresLayers(), srcOffset = new Offset(), dstSubres = new TextureSubresLayers(), dstOffset = new Offset(), extent = new Extent()) {
          this.srcSubres = srcSubres;
          this.srcOffset = srcOffset;
          this.dstSubres = dstSubres;
          this.dstOffset = dstOffset;
          this.extent = extent;
        }
        copy(info) {
          this.srcSubres.copy(info.srcSubres);
          this.srcOffset.copy(info.srcOffset);
          this.dstSubres.copy(info.dstSubres);
          this.dstOffset.copy(info.dstOffset);
          this.extent.copy(info.extent);
          return this;
        }
      }
      class TextureBlit {
        constructor(srcSubres = new TextureSubresLayers(), srcOffset = new Offset(), srcExtent = new Extent(), dstSubres = new TextureSubresLayers(), dstOffset = new Offset(), dstExtent = new Extent()) {
          this.srcSubres = srcSubres;
          this.srcOffset = srcOffset;
          this.srcExtent = srcExtent;
          this.dstSubres = dstSubres;
          this.dstOffset = dstOffset;
          this.dstExtent = dstExtent;
        }
        copy(info) {
          this.srcSubres.copy(info.srcSubres);
          this.srcOffset.copy(info.srcOffset);
          this.srcExtent.copy(info.srcExtent);
          this.dstSubres.copy(info.dstSubres);
          this.dstOffset.copy(info.dstOffset);
          this.dstExtent.copy(info.dstExtent);
          return this;
        }
      }
      class BufferTextureCopy {
        constructor(buffOffset = 0, buffStride = 0, buffTexHeight = 0, texOffset = new Offset(), texExtent = new Extent(), texSubres = new TextureSubresLayers()) {
          this.buffOffset = buffOffset;
          this.buffStride = buffStride;
          this.buffTexHeight = buffTexHeight;
          this.texOffset = texOffset;
          this.texExtent = texExtent;
          this.texSubres = texSubres;
        }
        copy(info) {
          this.buffOffset = info.buffOffset;
          this.buffStride = info.buffStride;
          this.buffTexHeight = info.buffTexHeight;
          this.texOffset.copy(info.texOffset);
          this.texExtent.copy(info.texExtent);
          this.texSubres.copy(info.texSubres);
          return this;
        }
      }
      class Viewport {
        constructor(left = 0, top = 0, width = 0, height = 0, minDepth = 0, maxDepth = 1) {
          this.left = left;
          this.top = top;
          this.width = width;
          this.height = height;
          this.minDepth = minDepth;
          this.maxDepth = maxDepth;
        }
        copy(info) {
          this.left = info.left;
          this.top = info.top;
          this.width = info.width;
          this.height = info.height;
          this.minDepth = info.minDepth;
          this.maxDepth = info.maxDepth;
          return this;
        }
      }
      class Color {
        constructor(x = 0, y = 0, z = 0, w = 0) {
          this.x = x;
          this.y = y;
          this.z = z;
          this.w = w;
        }
        copy(info) {
          this.x = info.x;
          this.y = info.y;
          this.z = info.z;
          this.w = info.w;
          return this;
        }
        set(x, y, z, w) {
          this.x = x;
          this.y = y;
          this.z = z;
          this.w = w;
          return this;
        }
      }
      class BindingMappingInfo {
        constructor(maxBlockCounts = [0], maxSamplerTextureCounts = [0], maxSamplerCounts = [0], maxTextureCounts = [0], maxBufferCounts = [0], maxImageCounts = [0], maxSubpassInputCounts = [0], setIndices = [0]) {
          this.maxBlockCounts = maxBlockCounts;
          this.maxSamplerTextureCounts = maxSamplerTextureCounts;
          this.maxSamplerCounts = maxSamplerCounts;
          this.maxTextureCounts = maxTextureCounts;
          this.maxBufferCounts = maxBufferCounts;
          this.maxImageCounts = maxImageCounts;
          this.maxSubpassInputCounts = maxSubpassInputCounts;
          this.setIndices = setIndices;
        }
        copy(info) {
          this.maxBlockCounts = info.maxBlockCounts.slice();
          this.maxSamplerTextureCounts = info.maxSamplerTextureCounts.slice();
          this.maxSamplerCounts = info.maxSamplerCounts.slice();
          this.maxTextureCounts = info.maxTextureCounts.slice();
          this.maxBufferCounts = info.maxBufferCounts.slice();
          this.maxImageCounts = info.maxImageCounts.slice();
          this.maxSubpassInputCounts = info.maxSubpassInputCounts.slice();
          this.setIndices = info.setIndices.slice();
          return this;
        }
      }
      class SwapchainInfo {
        constructor(windowId = 0, windowHandle = null, vsyncMode = VsyncMode.ON, width = 0, height = 0) {
          this.windowId = windowId;
          this.windowHandle = windowHandle;
          this.vsyncMode = vsyncMode;
          this.width = width;
          this.height = height;
        }
        copy(info) {
          this.windowId = info.windowId;
          this.windowHandle = info.windowHandle;
          this.vsyncMode = info.vsyncMode;
          this.width = info.width;
          this.height = info.height;
          return this;
        }
      }
      class DeviceInfo {
        constructor(bindingMappingInfo = new BindingMappingInfo()) {
          this.bindingMappingInfo = bindingMappingInfo;
        }
        copy(info) {
          this.bindingMappingInfo.copy(info.bindingMappingInfo);
          return this;
        }
      }
      class BufferInfo {
        constructor(usage = BufferUsageBit.NONE, memUsage = MemoryUsageBit.NONE, size = 0, stride = 1, flags = BufferFlagBit.NONE) {
          this.usage = usage;
          this.memUsage = memUsage;
          this.size = size;
          this.stride = stride;
          this.flags = flags;
        }
        copy(info) {
          this.usage = info.usage;
          this.memUsage = info.memUsage;
          this.size = info.size;
          this.stride = info.stride;
          this.flags = info.flags;
          return this;
        }
      }
      class BufferViewInfo {
        constructor(buffer = null, offset = 0, range = 0) {
          this.buffer = buffer;
          this.offset = offset;
          this.range = range;
        }
        copy(info) {
          this.buffer = info.buffer;
          this.offset = info.offset;
          this.range = info.range;
          return this;
        }
      }
      class DrawInfo {
        constructor(vertexCount = 0, firstVertex = 0, indexCount = 0, firstIndex = 0, vertexOffset = 0, instanceCount = 0, firstInstance = 0) {
          this.vertexCount = vertexCount;
          this.firstVertex = firstVertex;
          this.indexCount = indexCount;
          this.firstIndex = firstIndex;
          this.vertexOffset = vertexOffset;
          this.instanceCount = instanceCount;
          this.firstInstance = firstInstance;
        }
        copy(info) {
          this.vertexCount = info.vertexCount;
          this.firstVertex = info.firstVertex;
          this.indexCount = info.indexCount;
          this.firstIndex = info.firstIndex;
          this.vertexOffset = info.vertexOffset;
          this.instanceCount = info.instanceCount;
          this.firstInstance = info.firstInstance;
          return this;
        }
      }
      class DispatchInfo {
        constructor(groupCountX = 0, groupCountY = 0, groupCountZ = 0, indirectBuffer = null, indirectOffset = 0) {
          this.groupCountX = groupCountX;
          this.groupCountY = groupCountY;
          this.groupCountZ = groupCountZ;
          this.indirectBuffer = indirectBuffer;
          this.indirectOffset = indirectOffset;
        }
        copy(info) {
          this.groupCountX = info.groupCountX;
          this.groupCountY = info.groupCountY;
          this.groupCountZ = info.groupCountZ;
          this.indirectBuffer = info.indirectBuffer;
          this.indirectOffset = info.indirectOffset;
          return this;
        }
      }
      class IndirectBuffer {
        constructor(drawInfos = []) {
          this.drawInfos = drawInfos;
        }
        copy(info) {
          deepCopy(this.drawInfos, info.drawInfos, DrawInfo);
          return this;
        }
      }
      class TextureInfo {
        constructor(type = TextureType.TEX2D, usage = TextureUsageBit.NONE, format = Format.UNKNOWN, width = 0, height = 0, flags = TextureFlagBit.NONE, layerCount = 1, levelCount = 1, samples = SampleCount.X1, depth = 1, externalRes = 0) {
          this.type = type;
          this.usage = usage;
          this.format = format;
          this.width = width;
          this.height = height;
          this.flags = flags;
          this.layerCount = layerCount;
          this.levelCount = levelCount;
          this.samples = samples;
          this.depth = depth;
          this.externalRes = externalRes;
        }
        copy(info) {
          this.type = info.type;
          this.usage = info.usage;
          this.format = info.format;
          this.width = info.width;
          this.height = info.height;
          this.flags = info.flags;
          this.layerCount = info.layerCount;
          this.levelCount = info.levelCount;
          this.samples = info.samples;
          this.depth = info.depth;
          this.externalRes = info.externalRes;
          return this;
        }
      }
      class TextureViewInfo {
        constructor(texture = null, type = TextureType.TEX2D, format = Format.UNKNOWN, baseLevel = 0, levelCount = 1, baseLayer = 0, layerCount = 1) {
          this.texture = texture;
          this.type = type;
          this.format = format;
          this.baseLevel = baseLevel;
          this.levelCount = levelCount;
          this.baseLayer = baseLayer;
          this.layerCount = layerCount;
        }
        copy(info) {
          this.texture = info.texture;
          this.type = info.type;
          this.format = info.format;
          this.baseLevel = info.baseLevel;
          this.levelCount = info.levelCount;
          this.baseLayer = info.baseLayer;
          this.layerCount = info.layerCount;
          return this;
        }
      }
      class SamplerInfo {
        constructor(minFilter = Filter$1.LINEAR, magFilter = Filter$1.LINEAR, mipFilter = Filter$1.NONE, addressU = Address.WRAP, addressV = Address.WRAP, addressW = Address.WRAP, maxAnisotropy = 0, cmpFunc = ComparisonFunc.ALWAYS) {
          this.minFilter = minFilter;
          this.magFilter = magFilter;
          this.mipFilter = mipFilter;
          this.addressU = addressU;
          this.addressV = addressV;
          this.addressW = addressW;
          this.maxAnisotropy = maxAnisotropy;
          this.cmpFunc = cmpFunc;
        }
        copy(info) {
          this.minFilter = info.minFilter;
          this.magFilter = info.magFilter;
          this.mipFilter = info.mipFilter;
          this.addressU = info.addressU;
          this.addressV = info.addressV;
          this.addressW = info.addressW;
          this.maxAnisotropy = info.maxAnisotropy;
          this.cmpFunc = info.cmpFunc;
          return this;
        }
      }
      class Uniform {
        constructor(name = '', type = Type$1.UNKNOWN, count = 0) {
          this.name = name;
          this.type = type;
          this.count = count;
        }
        copy(info) {
          this.name = info.name;
          this.type = info.type;
          this.count = info.count;
          return this;
        }
      }
      class UniformBlock {
        constructor(set = 0, binding = 0, name = '', members = [], count = 0, flattened = 0) {
          this.set = set;
          this.binding = binding;
          this.name = name;
          this.members = members;
          this.count = count;
          this.flattened = flattened;
        }
        copy(info) {
          this.set = info.set;
          this.binding = info.binding;
          this.name = info.name;
          deepCopy(this.members, info.members, Uniform);
          this.count = info.count;
          this.flattened = info.flattened;
          return this;
        }
      }
      class UniformSamplerTexture {
        constructor(set = 0, binding = 0, name = '', type = Type$1.UNKNOWN, count = 0, flattened = 0) {
          this.set = set;
          this.binding = binding;
          this.name = name;
          this.type = type;
          this.count = count;
          this.flattened = flattened;
        }
        copy(info) {
          this.set = info.set;
          this.binding = info.binding;
          this.name = info.name;
          this.type = info.type;
          this.count = info.count;
          this.flattened = info.flattened;
          return this;
        }
      }
      class UniformSampler {
        constructor(set = 0, binding = 0, name = '', count = 0, flattened = 0) {
          this.set = set;
          this.binding = binding;
          this.name = name;
          this.count = count;
          this.flattened = flattened;
        }
        copy(info) {
          this.set = info.set;
          this.binding = info.binding;
          this.name = info.name;
          this.count = info.count;
          this.flattened = info.flattened;
          return this;
        }
      }
      class UniformTexture {
        constructor(set = 0, binding = 0, name = '', type = Type$1.UNKNOWN, count = 0, flattened = 0) {
          this.set = set;
          this.binding = binding;
          this.name = name;
          this.type = type;
          this.count = count;
          this.flattened = flattened;
        }
        copy(info) {
          this.set = info.set;
          this.binding = info.binding;
          this.name = info.name;
          this.type = info.type;
          this.count = info.count;
          this.flattened = info.flattened;
          return this;
        }
      }
      class UniformStorageImage {
        constructor(set = 0, binding = 0, name = '', type = Type$1.UNKNOWN, count = 0, memoryAccess = MemoryAccessBit.READ_WRITE, flattened = 0) {
          this.set = set;
          this.binding = binding;
          this.name = name;
          this.type = type;
          this.count = count;
          this.memoryAccess = memoryAccess;
          this.flattened = flattened;
        }
        copy(info) {
          this.set = info.set;
          this.binding = info.binding;
          this.name = info.name;
          this.type = info.type;
          this.count = info.count;
          this.memoryAccess = info.memoryAccess;
          this.flattened = info.flattened;
          return this;
        }
      }
      class UniformStorageBuffer {
        constructor(set = 0, binding = 0, name = '', count = 0, memoryAccess = MemoryAccessBit.READ_WRITE, flattened = 0) {
          this.set = set;
          this.binding = binding;
          this.name = name;
          this.count = count;
          this.memoryAccess = memoryAccess;
          this.flattened = flattened;
        }
        copy(info) {
          this.set = info.set;
          this.binding = info.binding;
          this.name = info.name;
          this.count = info.count;
          this.memoryAccess = info.memoryAccess;
          this.flattened = info.flattened;
          return this;
        }
      }
      class UniformInputAttachment {
        constructor(set = 0, binding = 0, name = '', count = 0, flattened = 0) {
          this.set = set;
          this.binding = binding;
          this.name = name;
          this.count = count;
          this.flattened = flattened;
        }
        copy(info) {
          this.set = info.set;
          this.binding = info.binding;
          this.name = info.name;
          this.count = info.count;
          this.flattened = info.flattened;
          return this;
        }
      }
      class ShaderStage {
        constructor(stage = ShaderStageFlagBit.NONE, source = '') {
          this.stage = stage;
          this.source = source;
        }
        copy(info) {
          this.stage = info.stage;
          this.source = info.source;
          return this;
        }
      }
      class Attribute {
        constructor(name = '', format = Format.UNKNOWN, isNormalized = false, stream = 0, isInstanced = false, location = 0) {
          this.name = name;
          this.format = format;
          this.isNormalized = isNormalized;
          this.stream = stream;
          this.isInstanced = isInstanced;
          this.location = location;
        }
        copy(info) {
          this.name = info.name;
          this.format = info.format;
          this.isNormalized = info.isNormalized;
          this.stream = info.stream;
          this.isInstanced = info.isInstanced;
          this.location = info.location;
          return this;
        }
      }
      class ShaderInfo {
        constructor(name = '', stages = [], attributes = [], blocks = [], buffers = [], samplerTextures = [], samplers = [], textures = [], images = [], subpassInputs = []) {
          this.name = name;
          this.stages = stages;
          this.attributes = attributes;
          this.blocks = blocks;
          this.buffers = buffers;
          this.samplerTextures = samplerTextures;
          this.samplers = samplers;
          this.textures = textures;
          this.images = images;
          this.subpassInputs = subpassInputs;
        }
        copy(info) {
          this.name = info.name;
          deepCopy(this.stages, info.stages, ShaderStage);
          deepCopy(this.attributes, info.attributes, Attribute);
          deepCopy(this.blocks, info.blocks, UniformBlock);
          deepCopy(this.buffers, info.buffers, UniformStorageBuffer);
          deepCopy(this.samplerTextures, info.samplerTextures, UniformSamplerTexture);
          deepCopy(this.samplers, info.samplers, UniformSampler);
          deepCopy(this.textures, info.textures, UniformTexture);
          deepCopy(this.images, info.images, UniformStorageImage);
          deepCopy(this.subpassInputs, info.subpassInputs, UniformInputAttachment);
          return this;
        }
      }
      class InputAssemblerInfo {
        constructor(attributes = [], vertexBuffers = [], indexBuffer = null, indirectBuffer = null) {
          this.attributes = attributes;
          this.vertexBuffers = vertexBuffers;
          this.indexBuffer = indexBuffer;
          this.indirectBuffer = indirectBuffer;
        }
        copy(info) {
          deepCopy(this.attributes, info.attributes, Attribute);
          this.vertexBuffers = info.vertexBuffers.slice();
          this.indexBuffer = info.indexBuffer;
          this.indirectBuffer = info.indirectBuffer;
          return this;
        }
      }
      class ColorAttachment {
        constructor(format = Format.UNKNOWN, sampleCount = SampleCount.X1, loadOp = LoadOp.CLEAR, storeOp = StoreOp.STORE, barrier = null) {
          this.format = format;
          this.sampleCount = sampleCount;
          this.loadOp = loadOp;
          this.storeOp = storeOp;
          this.barrier = barrier;
        }
        copy(info) {
          this.format = info.format;
          this.sampleCount = info.sampleCount;
          this.loadOp = info.loadOp;
          this.storeOp = info.storeOp;
          this.barrier = info.barrier;
          return this;
        }
      }
      class DepthStencilAttachment {
        constructor(format = Format.UNKNOWN, sampleCount = SampleCount.X1, depthLoadOp = LoadOp.CLEAR, depthStoreOp = StoreOp.STORE, stencilLoadOp = LoadOp.CLEAR, stencilStoreOp = StoreOp.STORE, barrier = null) {
          this.format = format;
          this.sampleCount = sampleCount;
          this.depthLoadOp = depthLoadOp;
          this.depthStoreOp = depthStoreOp;
          this.stencilLoadOp = stencilLoadOp;
          this.stencilStoreOp = stencilStoreOp;
          this.barrier = barrier;
        }
        copy(info) {
          this.format = info.format;
          this.sampleCount = info.sampleCount;
          this.depthLoadOp = info.depthLoadOp;
          this.depthStoreOp = info.depthStoreOp;
          this.stencilLoadOp = info.stencilLoadOp;
          this.stencilStoreOp = info.stencilStoreOp;
          this.barrier = info.barrier;
          return this;
        }
      }
      class SubpassInfo {
        constructor(inputs = [], colors = [], resolves = [], preserves = [], depthStencil = -1, depthStencilResolve = -1, depthResolveMode = ResolveMode.NONE, stencilResolveMode = ResolveMode.NONE) {
          this.inputs = inputs;
          this.colors = colors;
          this.resolves = resolves;
          this.preserves = preserves;
          this.depthStencil = depthStencil;
          this.depthStencilResolve = depthStencilResolve;
          this.depthResolveMode = depthResolveMode;
          this.stencilResolveMode = stencilResolveMode;
        }
        copy(info) {
          this.inputs = info.inputs.slice();
          this.colors = info.colors.slice();
          this.resolves = info.resolves.slice();
          this.preserves = info.preserves.slice();
          this.depthStencil = info.depthStencil;
          this.depthStencilResolve = info.depthStencilResolve;
          this.depthResolveMode = info.depthResolveMode;
          this.stencilResolveMode = info.stencilResolveMode;
          return this;
        }
      }
      class SubpassDependency {
        constructor(srcSubpass = 0, dstSubpass = 0, generalBarrier = null, prevAccesses = [AccessFlagBit.NONE], nextAccesses = [AccessFlagBit.NONE]) {
          this.srcSubpass = srcSubpass;
          this.dstSubpass = dstSubpass;
          this.generalBarrier = generalBarrier;
          this.prevAccesses = prevAccesses;
          this.nextAccesses = nextAccesses;
        }
        copy(info) {
          this.srcSubpass = info.srcSubpass;
          this.dstSubpass = info.dstSubpass;
          this.generalBarrier = info.generalBarrier;
          this.prevAccesses = info.prevAccesses.slice();
          this.nextAccesses = info.nextAccesses.slice();
          return this;
        }
      }
      class RenderPassInfo {
        constructor(colorAttachments = [], depthStencilAttachment = new DepthStencilAttachment(), depthStencilResolveAttachment = new DepthStencilAttachment(), subpasses = [], dependencies = []) {
          this.colorAttachments = colorAttachments;
          this.depthStencilAttachment = depthStencilAttachment;
          this.depthStencilResolveAttachment = depthStencilResolveAttachment;
          this.subpasses = subpasses;
          this.dependencies = dependencies;
        }
        copy(info) {
          deepCopy(this.colorAttachments, info.colorAttachments, ColorAttachment);
          this.depthStencilAttachment.copy(info.depthStencilAttachment);
          this.depthStencilResolveAttachment.copy(info.depthStencilResolveAttachment);
          deepCopy(this.subpasses, info.subpasses, SubpassInfo);
          deepCopy(this.dependencies, info.dependencies, SubpassDependency);
          return this;
        }
      }
      class GeneralBarrierInfo {
        constructor(prevAccesses = AccessFlagBit.NONE, nextAccesses = AccessFlagBit.NONE, type = BarrierType.FULL) {
          this.prevAccesses = prevAccesses;
          this.nextAccesses = nextAccesses;
          this.type = type;
        }
        copy(info) {
          this.prevAccesses = info.prevAccesses;
          this.nextAccesses = info.nextAccesses;
          this.type = info.type;
          return this;
        }
      }
      class TextureBarrierInfo {
        constructor(prevAccesses = AccessFlagBit.NONE, nextAccesses = AccessFlagBit.NONE, type = BarrierType.FULL, baseMipLevel = 0, levelCount = 1, baseSlice = 0, sliceCount = 1, discardContents = false, srcQueue = null, dstQueue = null) {
          this.prevAccesses = prevAccesses;
          this.nextAccesses = nextAccesses;
          this.type = type;
          this.baseMipLevel = baseMipLevel;
          this.levelCount = levelCount;
          this.baseSlice = baseSlice;
          this.sliceCount = sliceCount;
          this.discardContents = discardContents;
          this.srcQueue = srcQueue;
          this.dstQueue = dstQueue;
        }
        copy(info) {
          this.prevAccesses = info.prevAccesses;
          this.nextAccesses = info.nextAccesses;
          this.type = info.type;
          this.baseMipLevel = info.baseMipLevel;
          this.levelCount = info.levelCount;
          this.baseSlice = info.baseSlice;
          this.sliceCount = info.sliceCount;
          this.discardContents = info.discardContents;
          this.srcQueue = info.srcQueue;
          this.dstQueue = info.dstQueue;
          return this;
        }
      }
      class BufferBarrierInfo {
        constructor(prevAccesses = AccessFlagBit.NONE, nextAccesses = AccessFlagBit.NONE, type = BarrierType.FULL, offset = 0, size = 0, discardContents = false, srcQueue = null, dstQueue = null) {
          this.prevAccesses = prevAccesses;
          this.nextAccesses = nextAccesses;
          this.type = type;
          this.offset = offset;
          this.size = size;
          this.discardContents = discardContents;
          this.srcQueue = srcQueue;
          this.dstQueue = dstQueue;
        }
        copy(info) {
          this.prevAccesses = info.prevAccesses;
          this.nextAccesses = info.nextAccesses;
          this.type = info.type;
          this.offset = info.offset;
          this.size = info.size;
          this.discardContents = info.discardContents;
          this.srcQueue = info.srcQueue;
          this.dstQueue = info.dstQueue;
          return this;
        }
      }
      class FramebufferInfo {
        constructor(renderPass = null, colorTextures = [], depthStencilTexture = null, depthStencilResolveTexture = null) {
          this.renderPass = renderPass;
          this.colorTextures = colorTextures;
          this.depthStencilTexture = depthStencilTexture;
          this.depthStencilResolveTexture = depthStencilResolveTexture;
        }
        copy(info) {
          this.renderPass = info.renderPass;
          this.colorTextures = info.colorTextures.slice();
          this.depthStencilTexture = info.depthStencilTexture;
          this.depthStencilResolveTexture = info.depthStencilResolveTexture;
          return this;
        }
      }
      class DescriptorSetLayoutBinding {
        constructor(binding = -1, descriptorType = DescriptorType.UNKNOWN, count = 0, stageFlags = ShaderStageFlagBit.NONE, immutableSamplers = []) {
          this.binding = binding;
          this.descriptorType = descriptorType;
          this.count = count;
          this.stageFlags = stageFlags;
          this.immutableSamplers = immutableSamplers;
        }
        copy(info) {
          this.binding = info.binding;
          this.descriptorType = info.descriptorType;
          this.count = info.count;
          this.stageFlags = info.stageFlags;
          this.immutableSamplers = info.immutableSamplers.slice();
          return this;
        }
      }
      class DescriptorSetLayoutInfo {
        constructor(bindings = []) {
          this.bindings = bindings;
        }
        copy(info) {
          deepCopy(this.bindings, info.bindings, DescriptorSetLayoutBinding);
          return this;
        }
      }
      class DescriptorSetInfo {
        constructor(layout = null) {
          this.layout = layout;
        }
        copy(info) {
          this.layout = info.layout;
          return this;
        }
      }
      class PipelineLayoutInfo {
        constructor(setLayouts = []) {
          this.setLayouts = setLayouts;
        }
        copy(info) {
          this.setLayouts = info.setLayouts.slice();
          return this;
        }
      }
      class InputState {
        constructor(attributes = []) {
          this.attributes = attributes;
        }
        copy(info) {
          deepCopy(this.attributes, info.attributes, Attribute);
          return this;
        }
      }
      class CommandBufferInfo {
        constructor(queue = null, type = CommandBufferType.PRIMARY) {
          this.queue = queue;
          this.type = type;
        }
        copy(info) {
          this.queue = info.queue;
          this.type = info.type;
          return this;
        }
      }
      class QueueInfo {
        constructor(type = QueueType.GRAPHICS) {
          this.type = type;
        }
        copy(info) {
          this.type = info.type;
          return this;
        }
      }
      class QueryPoolInfo {
        constructor(type = QueryType.OCCLUSION, maxQueryObjects = 32767, forceWait = true) {
          this.type = type;
          this.maxQueryObjects = maxQueryObjects;
          this.forceWait = forceWait;
        }
        copy(info) {
          this.type = info.type;
          this.maxQueryObjects = info.maxQueryObjects;
          this.forceWait = info.forceWait;
          return this;
        }
      }
      class FormatInfo {
        constructor(name = '', size = 0, count = 0, type = FormatType.NONE, hasAlpha = false, hasDepth = false, hasStencil = false, isCompressed = false) {
          this.name = name;
          this.size = size;
          this.count = count;
          this.type = type;
          this.hasAlpha = hasAlpha;
          this.hasDepth = hasDepth;
          this.hasStencil = hasStencil;
          this.isCompressed = isCompressed;
        }
      }
      class MemoryStatus {
        constructor(bufferSize = 0, textureSize = 0) {
          this.bufferSize = bufferSize;
          this.textureSize = textureSize;
        }
        copy(info) {
          this.bufferSize = info.bufferSize;
          this.textureSize = info.textureSize;
          return this;
        }
      }
      class DynamicStencilStates {
        constructor(writeMask = 0, compareMask = 0, reference = 0) {
          this.writeMask = writeMask;
          this.compareMask = compareMask;
          this.reference = reference;
        }
        copy(info) {
          this.writeMask = info.writeMask;
          this.compareMask = info.compareMask;
          this.reference = info.reference;
          return this;
        }
      }
      class DynamicStates {
        constructor(viewport = new Viewport(), scissor = new Rect(), blendConstant = new Color(), lineWidth = 1, depthBiasConstant = 0, depthBiasClamp = 0, depthBiasSlope = 0, depthMinBounds = 0, depthMaxBounds = 0, stencilStatesFront = new DynamicStencilStates(), stencilStatesBack = new DynamicStencilStates()) {
          this.viewport = viewport;
          this.scissor = scissor;
          this.blendConstant = blendConstant;
          this.lineWidth = lineWidth;
          this.depthBiasConstant = depthBiasConstant;
          this.depthBiasClamp = depthBiasClamp;
          this.depthBiasSlope = depthBiasSlope;
          this.depthMinBounds = depthMinBounds;
          this.depthMaxBounds = depthMaxBounds;
          this.stencilStatesFront = stencilStatesFront;
          this.stencilStatesBack = stencilStatesBack;
        }
        copy(info) {
          this.viewport.copy(info.viewport);
          this.scissor.copy(info.scissor);
          this.blendConstant.copy(info.blendConstant);
          this.lineWidth = info.lineWidth;
          this.depthBiasConstant = info.depthBiasConstant;
          this.depthBiasClamp = info.depthBiasClamp;
          this.depthBiasSlope = info.depthBiasSlope;
          this.depthMinBounds = info.depthMinBounds;
          this.depthMaxBounds = info.depthMaxBounds;
          this.stencilStatesFront.copy(info.stencilStatesFront);
          this.stencilStatesBack.copy(info.stencilStatesBack);
          return this;
        }
      }
      class GFXObject extends GCObject {
        get objectType() {
          return this._objectType;
        }
        get objectID() {
          return this._objectID;
        }
        get typedID() {
          return this._typedID;
        }
        constructor(objectType) {
          super();
          this._objectType = ObjectType.UNKNOWN;
          this._objectID = 0;
          this._typedID = 0;
          this._objectType = objectType;
          this._objectID = GFXObject._idTable[ObjectType.UNKNOWN]++;
          this._typedID = GFXObject._idTable[objectType]++;
        }
      }
      GFXObject._idTable = Array(ObjectType.COUNT).fill(1 << 16);
      let AttributeName;
      (function (AttributeName) {
        AttributeName["ATTR_POSITION"] = "a_position";
        AttributeName["ATTR_NORMAL"] = "a_normal";
        AttributeName["ATTR_TANGENT"] = "a_tangent";
        AttributeName["ATTR_BITANGENT"] = "a_bitangent";
        AttributeName["ATTR_WEIGHTS"] = "a_weights";
        AttributeName["ATTR_JOINTS"] = "a_joints";
        AttributeName["ATTR_COLOR"] = "a_color";
        AttributeName["ATTR_COLOR1"] = "a_color1";
        AttributeName["ATTR_COLOR2"] = "a_color2";
        AttributeName["ATTR_TEX_COORD"] = "a_texCoord";
        AttributeName["ATTR_TEX_COORD1"] = "a_texCoord1";
        AttributeName["ATTR_TEX_COORD2"] = "a_texCoord2";
        AttributeName["ATTR_TEX_COORD3"] = "a_texCoord3";
        AttributeName["ATTR_TEX_COORD4"] = "a_texCoord4";
        AttributeName["ATTR_TEX_COORD5"] = "a_texCoord5";
        AttributeName["ATTR_TEX_COORD6"] = "a_texCoord6";
        AttributeName["ATTR_TEX_COORD7"] = "a_texCoord7";
        AttributeName["ATTR_TEX_COORD8"] = "a_texCoord8";
        AttributeName["ATTR_BATCH_ID"] = "a_batch_id";
        AttributeName["ATTR_BATCH_UV"] = "a_batch_uv";
      })(AttributeName || (AttributeName = {}));
      const FormatInfos = Object.freeze([new FormatInfo('UNKNOWN', 0, 0, FormatType.NONE, false, false, false, false), new FormatInfo('A8', 1, 1, FormatType.UNORM, true, false, false, false), new FormatInfo('L8', 1, 1, FormatType.UNORM, false, false, false, false), new FormatInfo('LA8', 1, 2, FormatType.UNORM, true, false, false, false), new FormatInfo('R8', 1, 1, FormatType.UNORM, false, false, false, false), new FormatInfo('R8SN', 1, 1, FormatType.SNORM, false, false, false, false), new FormatInfo('R8UI', 1, 1, FormatType.UINT, false, false, false, false), new FormatInfo('R8I', 1, 1, FormatType.INT, false, false, false, false), new FormatInfo('R16F', 2, 1, FormatType.FLOAT, false, false, false, false), new FormatInfo('R16UI', 2, 1, FormatType.UINT, false, false, false, false), new FormatInfo('R16I', 2, 1, FormatType.INT, false, false, false, false), new FormatInfo('R32F', 4, 1, FormatType.FLOAT, false, false, false, false), new FormatInfo('R32UI', 4, 1, FormatType.UINT, false, false, false, false), new FormatInfo('R32I', 4, 1, FormatType.INT, false, false, false, false), new FormatInfo('RG8', 2, 2, FormatType.UNORM, false, false, false, false), new FormatInfo('RG8SN', 2, 2, FormatType.SNORM, false, false, false, false), new FormatInfo('RG8UI', 2, 2, FormatType.UINT, false, false, false, false), new FormatInfo('RG8I', 2, 2, FormatType.INT, false, false, false, false), new FormatInfo('RG16F', 4, 2, FormatType.FLOAT, false, false, false, false), new FormatInfo('RG16UI', 4, 2, FormatType.UINT, false, false, false, false), new FormatInfo('RG16I', 4, 2, FormatType.INT, false, false, false, false), new FormatInfo('RG32F', 8, 2, FormatType.FLOAT, false, false, false, false), new FormatInfo('RG32UI', 8, 2, FormatType.UINT, false, false, false, false), new FormatInfo('RG32I', 8, 2, FormatType.INT, false, false, false, false), new FormatInfo('RGB8', 3, 3, FormatType.UNORM, false, false, false, false), new FormatInfo('SRGB8', 3, 3, FormatType.UNORM, false, false, false, false), new FormatInfo('RGB8SN', 3, 3, FormatType.SNORM, false, false, false, false), new FormatInfo('RGB8UI', 3, 3, FormatType.UINT, false, false, false, false), new FormatInfo('RGB8I', 3, 3, FormatType.INT, false, false, false, false), new FormatInfo('RGB16F', 6, 3, FormatType.FLOAT, false, false, false, false), new FormatInfo('RGB16UI', 6, 3, FormatType.UINT, false, false, false, false), new FormatInfo('RGB16I', 6, 3, FormatType.INT, false, false, false, false), new FormatInfo('RGB32F', 12, 3, FormatType.FLOAT, false, false, false, false), new FormatInfo('RGB32UI', 12, 3, FormatType.UINT, false, false, false, false), new FormatInfo('RGB32I', 12, 3, FormatType.INT, false, false, false, false), new FormatInfo('RGBA8', 4, 4, FormatType.UNORM, true, false, false, false), new FormatInfo('BGRA8', 4, 4, FormatType.UNORM, true, false, false, false), new FormatInfo('SRGB8_A8', 4, 4, FormatType.UNORM, true, false, false, false), new FormatInfo('RGBA8SN', 4, 4, FormatType.SNORM, true, false, false, false), new FormatInfo('RGBA8UI', 4, 4, FormatType.UINT, true, false, false, false), new FormatInfo('RGBA8I', 4, 4, FormatType.INT, true, false, false, false), new FormatInfo('RGBA16F', 8, 4, FormatType.FLOAT, true, false, false, false), new FormatInfo('RGBA16UI', 8, 4, FormatType.UINT, true, false, false, false), new FormatInfo('RGBA16I', 8, 4, FormatType.INT, true, false, false, false), new FormatInfo('RGBA32F', 16, 4, FormatType.FLOAT, true, false, false, false), new FormatInfo('RGBA32UI', 16, 4, FormatType.UINT, true, false, false, false), new FormatInfo('RGBA32I', 16, 4, FormatType.INT, true, false, false, false), new FormatInfo('R5G6B5', 2, 3, FormatType.UNORM, false, false, false, false), new FormatInfo('R11G11B10F', 4, 3, FormatType.FLOAT, false, false, false, false), new FormatInfo('RGB5A1', 2, 4, FormatType.UNORM, true, false, false, false), new FormatInfo('RGBA4', 2, 4, FormatType.UNORM, true, false, false, false), new FormatInfo('RGB10A2', 2, 4, FormatType.UNORM, true, false, false, false), new FormatInfo('RGB10A2UI', 2, 4, FormatType.UINT, true, false, false, false), new FormatInfo('RGB9E5', 2, 4, FormatType.FLOAT, true, false, false, false), new FormatInfo('DEPTH', 4, 1, FormatType.FLOAT, false, true, false, false), new FormatInfo('DEPTH_STENCIL', 5, 2, FormatType.FLOAT, false, true, true, false), new FormatInfo('BC1', 1, 3, FormatType.UNORM, false, false, false, true), new FormatInfo('BC1_ALPHA', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('BC1_SRGB', 1, 3, FormatType.UNORM, false, false, false, true), new FormatInfo('BC1_SRGB_ALPHA', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('BC2', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('BC2_SRGB', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('BC3', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('BC3_SRGB', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('BC4', 1, 1, FormatType.UNORM, false, false, false, true), new FormatInfo('BC4_SNORM', 1, 1, FormatType.SNORM, false, false, false, true), new FormatInfo('BC5', 1, 2, FormatType.UNORM, false, false, false, true), new FormatInfo('BC5_SNORM', 1, 2, FormatType.SNORM, false, false, false, true), new FormatInfo('BC6H_UF16', 1, 3, FormatType.UFLOAT, false, false, false, true), new FormatInfo('BC6H_SF16', 1, 3, FormatType.FLOAT, false, false, false, true), new FormatInfo('BC7', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('BC7_SRGB', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ETC_RGB8', 1, 3, FormatType.UNORM, false, false, false, true), new FormatInfo('ETC2_RGB8', 1, 3, FormatType.UNORM, false, false, false, true), new FormatInfo('ETC2_SRGB8', 1, 3, FormatType.UNORM, false, false, false, true), new FormatInfo('ETC2_RGB8_A1', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ETC2_SRGB8_A1', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ETC2_RGBA8', 2, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ETC2_SRGB8_A8', 2, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('EAC_R11', 1, 1, FormatType.UNORM, false, false, false, true), new FormatInfo('EAC_R11SN', 1, 1, FormatType.SNORM, false, false, false, true), new FormatInfo('EAC_RG11', 2, 2, FormatType.UNORM, false, false, false, true), new FormatInfo('EAC_RG11SN', 2, 2, FormatType.SNORM, false, false, false, true), new FormatInfo('PVRTC_RGB2', 2, 3, FormatType.UNORM, false, false, false, true), new FormatInfo('PVRTC_RGBA2', 2, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('PVRTC_RGB4', 2, 3, FormatType.UNORM, false, false, false, true), new FormatInfo('PVRTC_RGBA4', 2, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('PVRTC2_2BPP', 2, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('PVRTC2_4BPP', 2, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_4x4', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_5x4', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_5x5', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_6x5', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_6x6', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_8x5', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_8x6', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_8x8', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_10x5', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_10x6', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_10x8', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_10x10', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_12x10', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_12x12', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_4x4', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_5x4', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_5x5', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_6x5', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_6x6', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_8x5', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_8x6', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_8x8', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_10x5', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_10x6', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_10x8', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_10x10', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_12x10', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_12x12', 1, 4, FormatType.UNORM, true, false, false, true)]);
      const DESCRIPTOR_BUFFER_TYPE = DescriptorType.UNIFORM_BUFFER | DescriptorType.DYNAMIC_UNIFORM_BUFFER | DescriptorType.STORAGE_BUFFER | DescriptorType.DYNAMIC_STORAGE_BUFFER;
      const DESCRIPTOR_SAMPLER_TYPE = DescriptorType.SAMPLER_TEXTURE | DescriptorType.SAMPLER | DescriptorType.TEXTURE | DescriptorType.STORAGE_IMAGE | DescriptorType.INPUT_ATTACHMENT;
      const DESCRIPTOR_DYNAMIC_TYPE = DescriptorType.DYNAMIC_STORAGE_BUFFER | DescriptorType.DYNAMIC_UNIFORM_BUFFER;
      const DRAW_INFO_SIZE = 28;
      function IsPowerOf2(x) {
        return x > 0 && (x & x - 1) === 0;
      }
      function FormatSize(format, width, height, depth) {
        if (!FormatInfos[format].isCompressed) {
          return width * height * depth * FormatInfos[format].size;
        } else {
          switch (format) {
            case Format.BC1:
            case Format.BC1_ALPHA:
            case Format.BC1_SRGB:
            case Format.BC1_SRGB_ALPHA:
              return Math.ceil(width / 4) * Math.ceil(height / 4) * 8 * depth;
            case Format.BC2:
            case Format.BC2_SRGB:
            case Format.BC3:
            case Format.BC3_SRGB:
            case Format.BC4:
            case Format.BC4_SNORM:
            case Format.BC6H_SF16:
            case Format.BC6H_UF16:
            case Format.BC7:
            case Format.BC7_SRGB:
              return Math.ceil(width / 4) * Math.ceil(height / 4) * 16 * depth;
            case Format.BC5:
            case Format.BC5_SNORM:
              return Math.ceil(width / 4) * Math.ceil(height / 4) * 32 * depth;
            case Format.ETC_RGB8:
            case Format.ETC2_RGB8:
            case Format.ETC2_SRGB8:
            case Format.ETC2_RGB8_A1:
            case Format.EAC_R11:
            case Format.EAC_R11SN:
              return Math.ceil(width / 4) * Math.ceil(height / 4) * 8 * depth;
            case Format.ETC2_RGBA8:
            case Format.ETC2_SRGB8_A1:
            case Format.EAC_RG11:
            case Format.EAC_RG11SN:
              return Math.ceil(width / 4) * Math.ceil(height / 4) * 16 * depth;
            case Format.PVRTC_RGB2:
            case Format.PVRTC_RGBA2:
            case Format.PVRTC2_2BPP:
              return Math.ceil(width / 8) * Math.ceil(height / 4) * 8 * depth;
            case Format.PVRTC_RGB4:
            case Format.PVRTC_RGBA4:
            case Format.PVRTC2_4BPP:
              return Math.ceil(width / 4) * Math.ceil(height / 4) * 8 * depth;
            case Format.ASTC_RGBA_4X4:
            case Format.ASTC_SRGBA_4X4:
              return Math.ceil(width / 4) * Math.ceil(height / 4) * 16 * depth;
            case Format.ASTC_RGBA_5X4:
            case Format.ASTC_SRGBA_5X4:
              return Math.ceil(width / 5) * Math.ceil(height / 4) * 16 * depth;
            case Format.ASTC_RGBA_5X5:
            case Format.ASTC_SRGBA_5X5:
              return Math.ceil(width / 5) * Math.ceil(height / 5) * 16 * depth;
            case Format.ASTC_RGBA_6X5:
            case Format.ASTC_SRGBA_6X5:
              return Math.ceil(width / 6) * Math.ceil(height / 5) * 16 * depth;
            case Format.ASTC_RGBA_6X6:
            case Format.ASTC_SRGBA_6X6:
              return Math.ceil(width / 6) * Math.ceil(height / 6) * 16 * depth;
            case Format.ASTC_RGBA_8X5:
            case Format.ASTC_SRGBA_8X5:
              return Math.ceil(width / 8) * Math.ceil(height / 5) * 16 * depth;
            case Format.ASTC_RGBA_8X6:
            case Format.ASTC_SRGBA_8X6:
              return Math.ceil(width / 8) * Math.ceil(height / 6) * 16 * depth;
            case Format.ASTC_RGBA_8X8:
            case Format.ASTC_SRGBA_8X8:
              return Math.ceil(width / 8) * Math.ceil(height / 8) * 16 * depth;
            case Format.ASTC_RGBA_10X5:
            case Format.ASTC_SRGBA_10X5:
              return Math.ceil(width / 10) * Math.ceil(height / 5) * 16 * depth;
            case Format.ASTC_RGBA_10X6:
            case Format.ASTC_SRGBA_10X6:
              return Math.ceil(width / 10) * Math.ceil(height / 6) * 16 * depth;
            case Format.ASTC_RGBA_10X8:
            case Format.ASTC_SRGBA_10X8:
              return Math.ceil(width / 10) * Math.ceil(height / 8) * 16 * depth;
            case Format.ASTC_RGBA_10X10:
            case Format.ASTC_SRGBA_10X10:
              return Math.ceil(width / 10) * Math.ceil(height / 10) * 16 * depth;
            case Format.ASTC_RGBA_12X10:
            case Format.ASTC_SRGBA_12X10:
              return Math.ceil(width / 12) * Math.ceil(height / 10) * 16 * depth;
            case Format.ASTC_RGBA_12X12:
            case Format.ASTC_SRGBA_12X12:
              return Math.ceil(width / 12) * Math.ceil(height / 12) * 16 * depth;
            default:
              {
                return 0;
              }
          }
        }
      }
      function FormatSurfaceSize(format, width, height, depth, mips) {
        let size = 0;
        for (let i = 0; i < mips; ++i) {
          size += FormatSize(format, width, height, depth);
          width = Math.max(width >> 1, 1);
          height = Math.max(height >> 1, 1);
        }
        return size;
      }
      const _type2size = [0, 4, 8, 12, 16, 4, 8, 12, 16, 4, 8, 12, 16, 4, 8, 12, 16, 16, 24, 32, 24, 36, 48, 32, 48, 64, 4, 4, 4, 4, 4, 4];
      function GetTypeSize(type) {
        return _type2size[type] || 0;
      }
      function getTypedArrayConstructor(info) {
        if (info.isCompressed) {
          return Uint8Array;
        }
        const stride = info.size / info.count;
        switch (info.type) {
          case FormatType.UNORM:
          case FormatType.UINT:
            {
              switch (stride) {
                case 1:
                  return Uint8Array;
                case 2:
                  return Uint16Array;
                case 4:
                  return Uint32Array;
                default:
                  return Uint8Array;
              }
            }
          case FormatType.SNORM:
          case FormatType.INT:
            {
              switch (stride) {
                case 1:
                  return Int8Array;
                case 2:
                  return Int16Array;
                case 4:
                  return Int32Array;
                default:
                  return Int8Array;
              }
            }
          case FormatType.FLOAT:
            {
              switch (stride) {
                case 2:
                  return Uint16Array;
                case 4:
                  return Float32Array;
                default:
                  return Float32Array;
              }
            }
        }
        return Float32Array;
      }
      function formatAlignment(format) {
        switch (format) {
          case Format.BC1:
          case Format.BC1_ALPHA:
          case Format.BC1_SRGB:
          case Format.BC1_SRGB_ALPHA:
          case Format.BC2:
          case Format.BC2_SRGB:
          case Format.BC3:
          case Format.BC3_SRGB:
          case Format.BC4:
          case Format.BC4_SNORM:
          case Format.BC6H_SF16:
          case Format.BC6H_UF16:
          case Format.BC7:
          case Format.BC7_SRGB:
          case Format.BC5:
          case Format.BC5_SNORM:
          case Format.ETC_RGB8:
          case Format.ETC2_RGB8:
          case Format.ETC2_SRGB8:
          case Format.ETC2_RGB8_A1:
          case Format.EAC_R11:
          case Format.EAC_R11SN:
          case Format.ETC2_RGBA8:
          case Format.ETC2_SRGB8_A1:
          case Format.EAC_RG11:
          case Format.EAC_RG11SN:
            return {
              width: 4,
              height: 4
            };
          case Format.PVRTC_RGB2:
          case Format.PVRTC_RGBA2:
          case Format.PVRTC2_2BPP:
            return {
              width: 8,
              height: 4
            };
          case Format.PVRTC_RGB4:
          case Format.PVRTC_RGBA4:
          case Format.PVRTC2_4BPP:
            return {
              width: 4,
              height: 4
            };
          case Format.ASTC_RGBA_4X4:
          case Format.ASTC_SRGBA_4X4:
            return {
              width: 4,
              height: 4
            };
          case Format.ASTC_RGBA_5X4:
          case Format.ASTC_SRGBA_5X4:
            return {
              width: 5,
              height: 4
            };
          case Format.ASTC_RGBA_5X5:
          case Format.ASTC_SRGBA_5X5:
            return {
              width: 5,
              height: 5
            };
          case Format.ASTC_RGBA_6X5:
          case Format.ASTC_SRGBA_6X5:
            return {
              width: 6,
              height: 5
            };
          case Format.ASTC_RGBA_6X6:
          case Format.ASTC_SRGBA_6X6:
            return {
              width: 6,
              height: 6
            };
          case Format.ASTC_RGBA_8X5:
          case Format.ASTC_SRGBA_8X5:
            return {
              width: 8,
              height: 5
            };
          case Format.ASTC_RGBA_8X6:
          case Format.ASTC_SRGBA_8X6:
            return {
              width: 8,
              height: 6
            };
          case Format.ASTC_RGBA_8X8:
          case Format.ASTC_SRGBA_8X8:
            return {
              width: 8,
              height: 8
            };
          case Format.ASTC_RGBA_10X5:
          case Format.ASTC_SRGBA_10X5:
            return {
              width: 10,
              height: 5
            };
          case Format.ASTC_RGBA_10X6:
          case Format.ASTC_SRGBA_10X6:
            return {
              width: 10,
              height: 6
            };
          case Format.ASTC_RGBA_10X8:
          case Format.ASTC_SRGBA_10X8:
            return {
              width: 10,
              height: 8
            };
          case Format.ASTC_RGBA_10X10:
          case Format.ASTC_SRGBA_10X10:
            return {
              width: 10,
              height: 10
            };
          case Format.ASTC_RGBA_12X10:
          case Format.ASTC_SRGBA_12X10:
            return {
              width: 12,
              height: 10
            };
          case Format.ASTC_RGBA_12X12:
          case Format.ASTC_SRGBA_12X12:
            return {
              width: 12,
              height: 12
            };
          default:
            return {
              width: 1,
              height: 1
            };
        }
      }
      function alignTo(size, alignment) {
        return Math.ceil(size / alignment) * alignment;
      }

      var defines = /*#__PURE__*/Object.freeze({
        __proto__: null,
        get ObjectType () { return ObjectType; },
        get Status () { return Status; },
        get API () { return API; },
        get SurfaceTransform () { return SurfaceTransform; },
        get Feature () { return Feature; },
        get Format () { return Format; },
        get FormatType () { return FormatType; },
        get Type () { return Type$1; },
        get BufferUsageBit () { return BufferUsageBit; },
        get BufferFlagBit () { return BufferFlagBit; },
        get MemoryAccessBit () { return MemoryAccessBit; },
        get MemoryUsageBit () { return MemoryUsageBit; },
        get TextureType () { return TextureType; },
        get TextureUsageBit () { return TextureUsageBit; },
        get TextureFlagBit () { return TextureFlagBit; },
        get FormatFeatureBit () { return FormatFeatureBit; },
        get SampleCount () { return SampleCount; },
        get VsyncMode () { return VsyncMode; },
        get Filter () { return Filter$1; },
        get Address () { return Address; },
        get ComparisonFunc () { return ComparisonFunc; },
        get StencilOp () { return StencilOp; },
        get BlendFactor () { return BlendFactor; },
        get BlendOp () { return BlendOp; },
        get ColorMask () { return ColorMask; },
        get ShaderStageFlagBit () { return ShaderStageFlagBit; },
        get LoadOp () { return LoadOp; },
        get StoreOp () { return StoreOp; },
        get AccessFlagBit () { return AccessFlagBit; },
        get ResolveMode () { return ResolveMode; },
        get PipelineBindPoint () { return PipelineBindPoint; },
        get PrimitiveMode () { return PrimitiveMode; },
        get PolygonMode () { return PolygonMode; },
        get ShadeModel () { return ShadeModel; },
        get CullMode () { return CullMode; },
        get DynamicStateFlagBit () { return DynamicStateFlagBit; },
        get StencilFace () { return StencilFace; },
        get DescriptorType () { return DescriptorType; },
        get QueueType () { return QueueType; },
        get QueryType () { return QueryType; },
        get CommandBufferType () { return CommandBufferType; },
        get ClearFlagBit () { return ClearFlagBit; },
        get BarrierType () { return BarrierType; },
        get PassType () { return PassType; },
        Size: Size,
        DeviceCaps: DeviceCaps,
        DeviceOptions: DeviceOptions,
        Offset: Offset,
        Rect: Rect,
        Extent: Extent,
        TextureSubresLayers: TextureSubresLayers,
        TextureSubresRange: TextureSubresRange,
        TextureCopy: TextureCopy,
        TextureBlit: TextureBlit,
        BufferTextureCopy: BufferTextureCopy,
        Viewport: Viewport,
        Color: Color,
        BindingMappingInfo: BindingMappingInfo,
        SwapchainInfo: SwapchainInfo,
        DeviceInfo: DeviceInfo,
        BufferInfo: BufferInfo,
        BufferViewInfo: BufferViewInfo,
        DrawInfo: DrawInfo,
        DispatchInfo: DispatchInfo,
        IndirectBuffer: IndirectBuffer,
        TextureInfo: TextureInfo,
        TextureViewInfo: TextureViewInfo,
        SamplerInfo: SamplerInfo,
        Uniform: Uniform,
        UniformBlock: UniformBlock,
        UniformSamplerTexture: UniformSamplerTexture,
        UniformSampler: UniformSampler,
        UniformTexture: UniformTexture,
        UniformStorageImage: UniformStorageImage,
        UniformStorageBuffer: UniformStorageBuffer,
        UniformInputAttachment: UniformInputAttachment,
        ShaderStage: ShaderStage,
        Attribute: Attribute,
        ShaderInfo: ShaderInfo,
        InputAssemblerInfo: InputAssemblerInfo,
        ColorAttachment: ColorAttachment,
        DepthStencilAttachment: DepthStencilAttachment,
        SubpassInfo: SubpassInfo,
        SubpassDependency: SubpassDependency,
        RenderPassInfo: RenderPassInfo,
        GeneralBarrierInfo: GeneralBarrierInfo,
        TextureBarrierInfo: TextureBarrierInfo,
        BufferBarrierInfo: BufferBarrierInfo,
        FramebufferInfo: FramebufferInfo,
        DescriptorSetLayoutBinding: DescriptorSetLayoutBinding,
        DescriptorSetLayoutInfo: DescriptorSetLayoutInfo,
        DescriptorSetInfo: DescriptorSetInfo,
        PipelineLayoutInfo: PipelineLayoutInfo,
        InputState: InputState,
        CommandBufferInfo: CommandBufferInfo,
        QueueInfo: QueueInfo,
        QueryPoolInfo: QueryPoolInfo,
        FormatInfo: FormatInfo,
        MemoryStatus: MemoryStatus,
        DynamicStencilStates: DynamicStencilStates,
        DynamicStates: DynamicStates,
        GFXObject: GFXObject,
        get AttributeName () { return AttributeName; },
        FormatInfos: FormatInfos,
        DESCRIPTOR_BUFFER_TYPE: DESCRIPTOR_BUFFER_TYPE,
        DESCRIPTOR_SAMPLER_TYPE: DESCRIPTOR_SAMPLER_TYPE,
        DESCRIPTOR_DYNAMIC_TYPE: DESCRIPTOR_DYNAMIC_TYPE,
        DRAW_INFO_SIZE: DRAW_INFO_SIZE,
        IsPowerOf2: IsPowerOf2,
        FormatSize: FormatSize,
        FormatSurfaceSize: FormatSurfaceSize,
        GetTypeSize: GetTypeSize,
        getTypedArrayConstructor: getTypedArrayConstructor,
        formatAlignment: formatAlignment,
        alignTo: alignTo
      });

      function watchArrayElementsField(self, list, eleField, cachedFieldName, callback) {
        for (let i = 0, l = list.length; i < l; i++) {
          let ele = list[i];
          let originField = ele[eleField][cachedFieldName] || ele[eleField];
          ele[eleField] = new Proxy(originField, {
            get: (originTarget, key) => {
              if (key === cachedFieldName) {
                return originTarget;
              }
              return Reflect.get(originTarget, key);
            },
            set: (originTarget, prop, value) => {
              Reflect.set(originTarget, prop, value);
              callback(self, i, originTarget, prop, value);
              return true;
            }
          });
        }
      }
      class RasterizerState {
        constructor(isDiscard = false, polygonMode = PolygonMode.FILL, shadeModel = ShadeModel.GOURAND, cullMode = CullMode.BACK, isFrontFaceCCW = true, depthBiasEnabled = false, depthBias = 0, depthBiasClamp = 0.0, depthBiasSlop = 0.0, isDepthClip = true, isMultisample = false, lineWidth = 1.0) {
          this._nativeObj = void 0;
          this._isDiscard = false;
          this._polygonMode = PolygonMode.FILL;
          this._shadeModel = ShadeModel.GOURAND;
          this._cullMode = CullMode.BACK;
          this._isFrontFaceCCW = true;
          this._depthBiasEnabled = false;
          this._depthBias = 0;
          this._depthBiasClamp = 0.0;
          this._depthBiasSlop = 0.0;
          this._isDepthClip = true;
          this._isMultisample = false;
          this._lineWidth = 1.0;
          this._nativeObj = new gfx.RasterizerState();
          this.assignProperties(isDiscard, polygonMode, shadeModel, cullMode, isFrontFaceCCW, depthBiasEnabled, depthBias, depthBiasClamp, depthBiasSlop, isDepthClip, isMultisample, lineWidth);
        }
        get native() {
          return this._nativeObj;
        }
        get isDiscard() {
          return this._isDiscard;
        }
        set isDiscard(val) {
          this._isDiscard = val;
          this._nativeObj.isDiscard = val;
        }
        get polygonMode() {
          return this._polygonMode;
        }
        set polygonMode(val) {
          this._polygonMode = val;
          this._nativeObj.polygonMode = val;
        }
        get shadeModel() {
          return this._shadeModel;
        }
        set shadeModel(val) {
          this._shadeModel = val;
          this._nativeObj.shadeModel = val;
        }
        get cullMode() {
          return this._cullMode;
        }
        set cullMode(val) {
          this._cullMode = val;
          this._nativeObj.cullMode = val;
        }
        get isFrontFaceCCW() {
          return this._isFrontFaceCCW;
        }
        set isFrontFaceCCW(val) {
          this._isFrontFaceCCW = val;
          this._nativeObj.isFrontFaceCCW = val;
        }
        get depthBiasEnabled() {
          return this._depthBiasEnabled;
        }
        set depthBiasEnabled(val) {
          this._depthBiasEnabled = val;
          this._nativeObj.depthBiasEnabled = val;
        }
        get depthBias() {
          return this._depthBias;
        }
        set depthBias(val) {
          this._depthBias = val;
          this._nativeObj.depthBias = val;
        }
        get depthBiasClamp() {
          return this._depthBiasClamp;
        }
        set depthBiasClamp(val) {
          this._depthBiasClamp = val;
          this._nativeObj.depthBiasClamp = val;
        }
        get depthBiasSlop() {
          return this._depthBiasSlop;
        }
        set depthBiasSlop(val) {
          this._depthBiasSlop = val;
          this._nativeObj.depthBiasSlop = val;
        }
        get isDepthClip() {
          return this._isDepthClip;
        }
        set isDepthClip(val) {
          this._isDepthClip = val;
          this._nativeObj.isDepthClip = val;
        }
        get isMultisample() {
          return this._isMultisample;
        }
        set isMultisample(val) {
          this._isMultisample = val;
          this._nativeObj.isMultisample = val;
        }
        get lineWidth() {
          return this._lineWidth;
        }
        set lineWidth(val) {
          this._lineWidth = val;
          this._nativeObj.lineWidth = val;
        }
        reset() {
          this.assignProperties(false, PolygonMode.FILL, ShadeModel.GOURAND, CullMode.BACK, true, false, 0, 0.0, 0.0, true, false, 1.0);
        }
        assign(rs) {
          if (!rs) return;
          this.assignProperties(rs.isDiscard, rs.polygonMode, rs.shadeModel, rs.cullMode, rs.isFrontFaceCCW, rs.depthBiasEnabled, rs.depthBias, rs.depthBiasClamp, rs.depthBiasSlop, rs.isDepthClip, rs.isMultisample, rs.lineWidth);
        }
        destroy() {
          this._nativeObj = null;
        }
        assignProperties(isDiscard, polygonMode, shadeModel, cullMode, isFrontFaceCCW, depthBiasEnabled, depthBias, depthBiasClamp, depthBiasSlop, isDepthClip, isMultisample, lineWidth) {
          if (isDiscard !== undefined) this.isDiscard = isDiscard;
          if (polygonMode !== undefined) this.polygonMode = polygonMode;
          if (shadeModel !== undefined) this.shadeModel = shadeModel;
          if (cullMode !== undefined) this.cullMode = cullMode;
          if (isFrontFaceCCW !== undefined) this.isFrontFaceCCW = isFrontFaceCCW;
          if (depthBiasEnabled !== undefined) this.depthBiasEnabled = depthBiasEnabled;
          if (depthBias !== undefined) this.depthBias = depthBias;
          if (depthBiasClamp !== undefined) this.depthBiasClamp = depthBiasClamp;
          if (depthBiasSlop !== undefined) this.depthBiasSlop = depthBiasSlop;
          if (isDepthClip !== undefined) this.isDepthClip = isDepthClip;
          if (isMultisample !== undefined) this.isMultisample = isMultisample;
          if (lineWidth !== undefined) this.lineWidth = lineWidth;
        }
      }
      class DepthStencilState {
        constructor(depthTest = true, depthWrite = true, depthFunc = ComparisonFunc.LESS, stencilTestFront = false, stencilFuncFront = ComparisonFunc.ALWAYS, stencilReadMaskFront = 0xffff, stencilWriteMaskFront = 0xffff, stencilFailOpFront = StencilOp.KEEP, stencilZFailOpFront = StencilOp.KEEP, stencilPassOpFront = StencilOp.KEEP, stencilRefFront = 1, stencilTestBack = false, stencilFuncBack = ComparisonFunc.ALWAYS, stencilReadMaskBack = 0xffff, stencilWriteMaskBack = 0xffff, stencilFailOpBack = StencilOp.KEEP, stencilZFailOpBack = StencilOp.KEEP, stencilPassOpBack = StencilOp.KEEP, stencilRefBack = 1) {
          this._nativeObj = void 0;
          this._depthTest = true;
          this._depthWrite = true;
          this._depthFunc = ComparisonFunc.LESS;
          this._stencilTestFront = false;
          this._stencilFuncFront = ComparisonFunc.ALWAYS;
          this._stencilReadMaskFront = 0xffff;
          this._stencilWriteMaskFront = 0xffff;
          this._stencilFailOpFront = StencilOp.KEEP;
          this._stencilZFailOpFront = StencilOp.KEEP;
          this._stencilPassOpFront = StencilOp.KEEP;
          this._stencilRefFront = 1;
          this._stencilTestBack = false;
          this._stencilFuncBack = ComparisonFunc.ALWAYS;
          this._stencilReadMaskBack = 0xffff;
          this._stencilWriteMaskBack = 0xffff;
          this._stencilFailOpBack = StencilOp.KEEP;
          this._stencilZFailOpBack = StencilOp.KEEP;
          this._stencilPassOpBack = StencilOp.KEEP;
          this._stencilRefBack = 1;
          this._nativeObj = new gfx.DepthStencilState();
          this.assignProperties(depthTest, depthWrite, depthFunc, stencilTestFront, stencilFuncFront, stencilReadMaskFront, stencilWriteMaskFront, stencilFailOpFront, stencilZFailOpFront, stencilPassOpFront, stencilRefFront, stencilTestBack, stencilFuncBack, stencilReadMaskBack, stencilWriteMaskBack, stencilFailOpBack, stencilZFailOpBack, stencilPassOpBack, stencilRefBack);
        }
        get native() {
          return this._nativeObj;
        }
        get depthTest() {
          return this._depthTest;
        }
        set depthTest(val) {
          this._depthTest = val;
          this._nativeObj.depthTest = val;
        }
        get depthWrite() {
          return this._depthWrite;
        }
        set depthWrite(val) {
          this._depthWrite = val;
          this._nativeObj.depthWrite = val;
        }
        get depthFunc() {
          return this._depthFunc;
        }
        set depthFunc(val) {
          this._depthFunc = val;
          this._nativeObj.depthFunc = val;
        }
        get stencilTestFront() {
          return this._stencilTestFront;
        }
        set stencilTestFront(val) {
          this._stencilTestFront = val;
          this._nativeObj.stencilTestFront = val;
        }
        get stencilFuncFront() {
          return this._stencilFuncFront;
        }
        set stencilFuncFront(val) {
          this._stencilFuncFront = val;
          this._nativeObj.stencilFuncFront = val;
        }
        get stencilReadMaskFront() {
          return this._stencilReadMaskFront;
        }
        set stencilReadMaskFront(val) {
          this._stencilReadMaskFront = val;
          this._nativeObj.stencilReadMaskFront = val;
        }
        get stencilWriteMaskFront() {
          return this._stencilWriteMaskFront;
        }
        set stencilWriteMaskFront(val) {
          this._stencilWriteMaskFront = val;
          this._nativeObj.stencilWriteMaskFront = val;
        }
        get stencilFailOpFront() {
          return this._stencilFailOpFront;
        }
        set stencilFailOpFront(val) {
          this._stencilFailOpFront = val;
          this._nativeObj.stencilFailOpFront = val;
        }
        get stencilZFailOpFront() {
          return this._stencilZFailOpFront;
        }
        set stencilZFailOpFront(val) {
          this._stencilZFailOpFront = val;
          this._nativeObj.stencilZFailOpFront = val;
        }
        get stencilPassOpFront() {
          return this._stencilPassOpFront;
        }
        set stencilPassOpFront(val) {
          this._stencilPassOpFront = val;
          this._nativeObj.stencilPassOpFront = val;
        }
        get stencilRefFront() {
          return this._stencilRefFront;
        }
        set stencilRefFront(val) {
          this._stencilRefFront = val;
          this._nativeObj.stencilRefFront = val;
        }
        get stencilTestBack() {
          return this._stencilTestBack;
        }
        set stencilTestBack(val) {
          this._stencilTestBack = val;
          this._nativeObj.stencilTestBack = val;
        }
        get stencilFuncBack() {
          return this._stencilFuncBack;
        }
        set stencilFuncBack(val) {
          this._stencilFuncBack = val;
          this._nativeObj.stencilFuncBack = val;
        }
        get stencilReadMaskBack() {
          return this._stencilReadMaskBack;
        }
        set stencilReadMaskBack(val) {
          this._stencilReadMaskBack = val;
          this._nativeObj.stencilReadMaskBack = val;
        }
        get stencilWriteMaskBack() {
          return this._stencilWriteMaskBack;
        }
        set stencilWriteMaskBack(val) {
          this._stencilWriteMaskBack = val;
          this._nativeObj.stencilWriteMaskBack = val;
        }
        get stencilFailOpBack() {
          return this._stencilFailOpBack;
        }
        set stencilFailOpBack(val) {
          this._stencilFailOpBack = val;
          this._nativeObj.stencilFailOpBack = val;
        }
        get stencilZFailOpBack() {
          return this._stencilZFailOpBack;
        }
        set stencilZFailOpBack(val) {
          this._stencilZFailOpBack = val;
          this._nativeObj.stencilZFailOpBack = val;
        }
        get stencilPassOpBack() {
          return this._stencilPassOpBack;
        }
        set stencilPassOpBack(val) {
          this._stencilPassOpBack = val;
          this._nativeObj.stencilPassOpBack = val;
        }
        get stencilRefBack() {
          return this._stencilRefBack;
        }
        set stencilRefBack(val) {
          this._stencilRefBack = val;
          this._nativeObj.stencilRefBack = val;
        }
        reset() {
          this.assignProperties(true, true, ComparisonFunc.LESS, false, ComparisonFunc.ALWAYS, 0xffff, 0xffff, StencilOp.KEEP, StencilOp.KEEP, StencilOp.KEEP, 1, false, ComparisonFunc.ALWAYS, 0xffff, 0xffff, StencilOp.KEEP, StencilOp.KEEP, StencilOp.KEEP, 1);
        }
        assign(dss) {
          if (!dss) return;
          this.assignProperties(dss.depthTest, dss.depthWrite, dss.depthFunc, dss.stencilTestFront, dss.stencilFuncFront, dss.stencilReadMaskFront, dss.stencilWriteMaskFront, dss.stencilFailOpFront, dss.stencilZFailOpFront, dss.stencilPassOpFront, dss.stencilRefFront, dss.stencilTestBack, dss.stencilFuncBack, dss.stencilReadMaskBack, dss.stencilWriteMaskBack, dss.stencilFailOpBack, dss.stencilZFailOpBack, dss.stencilPassOpBack, dss.stencilRefBack);
        }
        destroy() {
          this._nativeObj = null;
        }
        assignProperties(depthTest, depthWrite, depthFunc, stencilTestFront, stencilFuncFront, stencilReadMaskFront, stencilWriteMaskFront, stencilFailOpFront, stencilZFailOpFront, stencilPassOpFront, stencilRefFront, stencilTestBack, stencilFuncBack, stencilReadMaskBack, stencilWriteMaskBack, stencilFailOpBack, stencilZFailOpBack, stencilPassOpBack, stencilRefBack) {
          if (depthTest !== undefined) this.depthTest = depthTest;
          if (depthWrite !== undefined) this.depthWrite = depthWrite;
          if (depthFunc !== undefined) this.depthFunc = depthFunc;
          if (stencilTestFront !== undefined) this.stencilTestFront = stencilTestFront;
          if (stencilFuncFront !== undefined) this.stencilFuncFront = stencilFuncFront;
          if (stencilReadMaskFront !== undefined) this.stencilReadMaskFront = stencilReadMaskFront;
          if (stencilWriteMaskFront !== undefined) this.stencilWriteMaskFront = stencilWriteMaskFront;
          if (stencilFailOpFront !== undefined) this.stencilFailOpFront = stencilFailOpFront;
          if (stencilZFailOpFront !== undefined) this.stencilZFailOpFront = stencilZFailOpFront;
          if (stencilPassOpFront !== undefined) this.stencilPassOpFront = stencilPassOpFront;
          if (stencilRefFront !== undefined) this.stencilRefFront = stencilRefFront;
          if (stencilTestBack !== undefined) this.stencilTestBack = stencilTestBack;
          if (stencilFuncBack !== undefined) this.stencilFuncBack = stencilFuncBack;
          if (stencilReadMaskBack !== undefined) this.stencilReadMaskBack = stencilReadMaskBack;
          if (stencilWriteMaskBack !== undefined) this.stencilWriteMaskBack = stencilWriteMaskBack;
          if (stencilFailOpBack !== undefined) this.stencilFailOpBack = stencilFailOpBack;
          if (stencilZFailOpBack !== undefined) this.stencilZFailOpBack = stencilZFailOpBack;
          if (stencilPassOpBack !== undefined) this.stencilPassOpBack = stencilPassOpBack;
          if (stencilRefBack !== undefined) this.stencilRefBack = stencilRefBack;
        }
      }
      class BlendTarget {
        get native() {
          return this._nativeObj;
        }
        constructor(blend = false, blendSrc = BlendFactor.ONE, blendDst = BlendFactor.ZERO, blendEq = BlendOp.ADD, blendSrcAlpha = BlendFactor.ONE, blendDstAlpha = BlendFactor.ZERO, blendAlphaEq = BlendOp.ADD, blendColorMask = ColorMask.ALL) {
          this._nativeObj = void 0;
          this._blend = false;
          this._blendSrc = BlendFactor.ONE;
          this._blendDst = BlendFactor.ZERO;
          this._blendEq = BlendOp.ADD;
          this._blendSrcAlpha = BlendFactor.ONE;
          this._blendDstAlpha = BlendFactor.ZERO;
          this._blendAlphaEq = BlendOp.ADD;
          this._blendColorMask = ColorMask.ALL;
          this._nativeObj = new gfx.BlendTarget();
          this.assignProperties(blend, blendSrc, blendDst, blendEq, blendSrcAlpha, blendDstAlpha, blendAlphaEq, blendColorMask);
        }
        get blend() {
          return this._blend;
        }
        set blend(val) {
          this._blend = val;
          this._nativeObj.blend = val;
        }
        get blendSrc() {
          return this._blendSrc;
        }
        set blendSrc(val) {
          this._blendSrc = val;
          this._nativeObj.blendSrc = val;
        }
        get blendDst() {
          return this._blendDst;
        }
        set blendDst(val) {
          this._blendDst = val;
          this._nativeObj.blendDst = val;
        }
        get blendEq() {
          return this._blendEq;
        }
        set blendEq(val) {
          this._blendEq = val;
          this._nativeObj.blendEq = val;
        }
        get blendSrcAlpha() {
          return this._blendSrcAlpha;
        }
        set blendSrcAlpha(val) {
          this._blendSrcAlpha = val;
          this._nativeObj.blendSrcAlpha = val;
        }
        get blendDstAlpha() {
          return this._blendDstAlpha;
        }
        set blendDstAlpha(val) {
          this._blendDstAlpha = val;
          this._nativeObj.blendDstAlpha = val;
        }
        get blendAlphaEq() {
          return this._blendAlphaEq;
        }
        set blendAlphaEq(val) {
          this._blendAlphaEq = val;
          this._nativeObj.blendAlphaEq = val;
        }
        get blendColorMask() {
          return this._blendColorMask;
        }
        set blendColorMask(val) {
          this._blendColorMask = val;
          this._nativeObj.blendColorMask = val;
        }
        reset() {
          this.assignProperties(false, BlendFactor.ONE, BlendFactor.ZERO, BlendOp.ADD, BlendFactor.ONE, BlendFactor.ZERO, BlendOp.ADD, ColorMask.ALL);
        }
        destroy() {
          this._nativeObj = null;
        }
        assign(target) {
          if (!target) return;
          this.assignProperties(target.blend, target.blendSrc, target.blendDst, target.blendEq, target.blendSrcAlpha, target.blendDstAlpha, target.blendAlphaEq, target.blendColorMask);
        }
        assignProperties(blend, blendSrc, blendDst, blendEq, blendSrcAlpha, blendDstAlpha, blendAlphaEq, blendColorMask) {
          if (blend !== undefined) this.blend = blend;
          if (blendSrc !== undefined) this.blendSrc = blendSrc;
          if (blendDst !== undefined) this.blendDst = blendDst;
          if (blendEq !== undefined) this.blendEq = blendEq;
          if (blendSrcAlpha !== undefined) this.blendSrcAlpha = blendSrcAlpha;
          if (blendDstAlpha !== undefined) this.blendDstAlpha = blendDstAlpha;
          if (blendAlphaEq !== undefined) this.blendAlphaEq = blendAlphaEq;
          if (blendColorMask !== undefined) this.blendColorMask = blendColorMask;
        }
      }
      class BlendState {
        _setTargets(targets) {
          this.targets = targets;
          const CACHED_FIELD_NAME = `$__nativeObj`;
          this._syncTargetsToNativeObj(CACHED_FIELD_NAME);
          watchArrayElementsField(this, this.targets, "_nativeObj", CACHED_FIELD_NAME, (self, _idx, _originTarget, _prop, _value) => {
            self._syncTargetsToNativeObj(CACHED_FIELD_NAME);
          });
        }
        _syncTargetsToNativeObj(cachedFieldName) {
          const nativeTars = this.targets.map(target => {
            return target.native[cachedFieldName] || target.native;
          });
          this._nativeObj.targets = nativeTars;
        }
        get native() {
          return this._nativeObj;
        }
        constructor(isA2C = false, isIndepend = false, blendColor = new Color(), targets = [new BlendTarget()]) {
          this.targets = void 0;
          this._blendColor = void 0;
          this._nativeObj = void 0;
          this._isA2C = false;
          this._isIndepend = false;
          this._nativeObj = new gfx.BlendState();
          this._setTargets(targets);
          this.blendColor = blendColor;
          this.isA2C = isA2C;
          this.isIndepend = isIndepend;
        }
        get isA2C() {
          return this._isA2C;
        }
        set isA2C(val) {
          this._isA2C = val;
          this._nativeObj.isA2C = val;
        }
        get isIndepend() {
          return this._isIndepend;
        }
        set isIndepend(val) {
          this._isIndepend = val;
          this._nativeObj.isIndepend = val;
        }
        get blendColor() {
          return this._blendColor;
        }
        set blendColor(color) {
          this._blendColor = color;
          this._nativeObj.blendColor = color;
        }
        setTarget(index, target) {
          let tg = this.targets[index];
          if (!tg) {
            tg = this.targets[index] = new BlendTarget();
          }
          tg.assign(target);
          this._setTargets(this.targets);
        }
        reset() {
          this.isA2C = false;
          this.isIndepend = false;
          this.blendColor = new Color(0, 0, 0, 0);
          const targets = this.targets;
          for (let i = 1, len = targets.length; i < len; ++i) {
            targets[i].destroy();
          }
          targets.length = 1;
          targets[0].reset();
          this._setTargets(targets);
        }
        destroy() {
          for (let i = 0, len = this.targets.length; i < len; ++i) {
            this.targets[i].destroy();
          }
          this.targets = null;
          this._nativeObj = null;
        }
      }

      const PipelineState = gfx.PipelineState;
      const PipelineStateInfo = gfx.PipelineStateInfo;

      class DescriptorSet extends GFXObject {
        get layout() {
          return this._layout;
        }
        constructor() {
          super(ObjectType.DESCRIPTOR_SET);
          this._layout = null;
          this._buffers = [];
          this._textures = [];
          this._samplers = [];
          this._isDirty = false;
        }
        bindBuffer(binding, buffer, index = 0) {
          const bindingIndex = this._layout.bindingIndices[binding];
          const info = this._layout.bindings[bindingIndex];
          if (!info) {
            return;
          }
          if (info.descriptorType & DESCRIPTOR_BUFFER_TYPE) {
            const descriptorIndex = this._layout.descriptorIndices[binding];
            if (this._buffers[descriptorIndex + index] !== buffer) {
              this._buffers[descriptorIndex + index] = buffer;
              this._isDirty = true;
            }
          }
        }
        bindSampler(binding, sampler, index = 0) {
          const bindingIndex = this._layout.bindingIndices[binding];
          const info = this._layout.bindings[bindingIndex];
          if (!info) {
            return;
          }
          if (info.descriptorType & DESCRIPTOR_SAMPLER_TYPE) {
            const descriptorIndex = this._layout.descriptorIndices[binding];
            if (this._samplers[descriptorIndex + index] !== sampler) {
              this._samplers[descriptorIndex + index] = sampler;
              this._isDirty = true;
            }
          }
        }
        bindTexture(binding, texture, index = 0, flags) {
          const bindingIndex = this._layout.bindingIndices[binding];
          const info = this._layout.bindings[bindingIndex];
          if (!info) {
            return;
          }
          if (info.descriptorType & DESCRIPTOR_SAMPLER_TYPE) {
            const descriptorIndex = this._layout.descriptorIndices[binding];
            if (this._textures[descriptorIndex + index] !== texture) {
              this._textures[descriptorIndex + index] = texture;
              this._isDirty = true;
            }
          }
        }
        getBuffer(binding, index = 0) {
          const descriptorIndex = this._layout.descriptorIndices[binding];
          return this._buffers[descriptorIndex + index];
        }
        getSampler(binding, index = 0) {
          const descriptorIndex = this._layout.descriptorIndices[binding];
          return this._samplers[descriptorIndex + index];
        }
        getTexture(binding, index = 0) {
          const descriptorIndex = this._layout.descriptorIndices[binding];
          return this._textures[descriptorIndex + index];
        }
      }

      class Buffer extends GFXObject {
        get usage() {
          return this._usage;
        }
        get memUsage() {
          return this._memUsage;
        }
        get size() {
          return this._size;
        }
        get stride() {
          return this._stride;
        }
        get count() {
          return this._count;
        }
        get flags() {
          return this._flags;
        }
        constructor() {
          super(ObjectType.BUFFER);
          this._usage = BufferUsageBit.NONE;
          this._memUsage = MemoryUsageBit.NONE;
          this._size = 0;
          this._stride = 1;
          this._count = 0;
          this._flags = BufferFlagBit.NONE;
          this._isBufferView = false;
        }
      }

      class CommandBuffer extends GFXObject {
        get type() {
          return this._type;
        }
        get queue() {
          return this._queue;
        }
        get numDrawCalls() {
          return this._numDrawCalls;
        }
        get numInstances() {
          return this._numInstances;
        }
        get numTris() {
          return this._numTris;
        }
        constructor() {
          super(ObjectType.COMMAND_BUFFER);
          this._queue = null;
          this._type = CommandBufferType.PRIMARY;
          this._numDrawCalls = 0;
          this._numInstances = 0;
          this._numTris = 0;
        }
      }

      class Device {
        constructor() {
          this._gfxAPI = API.UNKNOWN;
          this._renderer = '';
          this._vendor = '';
          this._features = new Array(Feature.COUNT);
          this._formatFeatures = new Array(Format.COUNT);
          this._queue = null;
          this._cmdBuff = null;
          this._numDrawCalls = 0;
          this._numInstances = 0;
          this._numTris = 0;
          this._memoryStatus = new MemoryStatus();
          this._caps = new DeviceCaps();
          this._bindingMappingInfo = new BindingMappingInfo();
          this._samplers = new Map();
          this._generalBarrierss = new Map();
          this._textureBarriers = new Map();
          this._bufferBarriers = new Map();
        }
        get gfxAPI() {
          return this._gfxAPI;
        }
        get queue() {
          return this._queue;
        }
        get commandBuffer() {
          return this._cmdBuff;
        }
        get renderer() {
          return this._renderer;
        }
        get vendor() {
          return this._vendor;
        }
        get numDrawCalls() {
          return this._numDrawCalls;
        }
        get numInstances() {
          return this._numInstances;
        }
        get numTris() {
          return this._numTris;
        }
        get memoryStatus() {
          return this._memoryStatus;
        }
        get capabilities() {
          return this._caps;
        }
        get bindingMappingInfo() {
          return this._bindingMappingInfo;
        }
        hasFeature(feature) {
          return this._features[feature];
        }
        getFormatFeatures(format) {
          return this._formatFeatures[format];
        }
        enableAutoBarrier(en) {}
        getMaxSampleCount(format, usage, flags) {
          return SampleCount.X1;
        }
      }
      Device.canvas = void 0;
      class DefaultResource {
        constructor(device) {
          this._texture2D = null;
          this._texture3D = null;
          this._textureCube = null;
          this._texture2DArray = null;
          const bufferSize = 64;
          const buffer = new Uint8Array(bufferSize);
          buffer.fill(255);
          if (device.capabilities.maxTextureSize >= 2) {
            this._texture2D = device.createTexture(new TextureInfo(TextureType.TEX2D, TextureUsageBit.STORAGE | TextureUsageBit.SAMPLED, Format.RGBA8, 2, 2, TextureFlagBit.NONE));
            const copyRegion = new BufferTextureCopy(0, 0, 0, new Offset(0, 0, 0), new Extent(2, 2, 1));
            device.copyBuffersToTexture([buffer], this._texture2D, [copyRegion]);
          }
          if (device.capabilities.maxTextureSize >= 2) {
            this._textureCube = device.createTexture(new TextureInfo(TextureType.CUBE, TextureUsageBit.STORAGE | TextureUsageBit.SAMPLED, Format.RGBA8, 2, 2, TextureFlagBit.NONE, 6));
            const copyRegion = new BufferTextureCopy(0, 0, 0, new Offset(0, 0, 0), new Extent(2, 2, 1));
            device.copyBuffersToTexture([buffer], this._textureCube, [copyRegion]);
            copyRegion.texSubres.baseArrayLayer = 1;
            device.copyBuffersToTexture([buffer], this._textureCube, [copyRegion]);
            copyRegion.texSubres.baseArrayLayer = 2;
            device.copyBuffersToTexture([buffer], this._textureCube, [copyRegion]);
            copyRegion.texSubres.baseArrayLayer = 3;
            device.copyBuffersToTexture([buffer], this._textureCube, [copyRegion]);
            copyRegion.texSubres.baseArrayLayer = 4;
            device.copyBuffersToTexture([buffer], this._textureCube, [copyRegion]);
            copyRegion.texSubres.baseArrayLayer = 5;
            device.copyBuffersToTexture([buffer], this._textureCube, [copyRegion]);
          }
          if (device.capabilities.max3DTextureSize >= 2) {
            this._texture3D = device.createTexture(new TextureInfo(TextureType.TEX3D, TextureUsageBit.STORAGE | TextureUsageBit.SAMPLED, Format.RGBA8, 2, 2, TextureFlagBit.NONE, 1, 1, SampleCount.X1, 2));
            const copyRegion = new BufferTextureCopy(0, 0, 0, new Offset(0, 0, 0), new Extent(2, 2, 2), new TextureSubresLayers(0, 0, 1));
            device.copyBuffersToTexture([buffer], this._texture3D, [copyRegion]);
          }
          if (device.capabilities.maxArrayTextureLayers >= 2) {
            this._texture2DArray = device.createTexture(new TextureInfo(TextureType.TEX2D_ARRAY, TextureUsageBit.STORAGE | TextureUsageBit.SAMPLED, Format.RGBA8, 2, 2, TextureFlagBit.NONE, 2));
            const copyRegion = new BufferTextureCopy(0, 0, 0, new Offset(0, 0, 0), new Extent(2, 2, 1), new TextureSubresLayers(0, 0, 1));
            device.copyBuffersToTexture([buffer], this._texture2DArray, [copyRegion]);
            copyRegion.texSubres.baseArrayLayer = 1;
            device.copyBuffersToTexture([buffer], this._texture2DArray, [copyRegion]);
          }
        }
        getTexture(type) {
          switch (type) {
            case TextureType.TEX2D:
              return this._texture2D;
            case TextureType.TEX3D:
              return this._texture3D;
            case TextureType.CUBE:
              return this._textureCube;
            case TextureType.TEX2D_ARRAY:
              return this._texture2DArray;
            default:
              return null;
          }
        }
      }

      class Swapchain extends GFXObject {
        get colorTexture() {
          return this._colorTexture;
        }
        get depthStencilTexture() {
          return this._depthStencilTexture;
        }
        get surfaceTransform() {
          return this._transform;
        }
        get width() {
          return this._colorTexture.width;
        }
        get height() {
          return this._colorTexture.height;
        }
        constructor() {
          super(ObjectType.SWAPCHAIN);
          this._transform = SurfaceTransform.IDENTITY;
          this._colorTexture = null;
          this._depthStencilTexture = null;
        }
      }

      class Framebuffer extends GFXObject {
        get renderPass() {
          return this._renderPass;
        }
        get colorTextures() {
          return this._colorTextures;
        }
        get depthStencilTexture() {
          return this._depthStencilTexture;
        }
        get width() {
          return this._width;
        }
        get height() {
          return this._height;
        }
        constructor() {
          super(ObjectType.FRAMEBUFFER);
          this._renderPass = null;
          this._colorTextures = [];
          this._depthStencilTexture = null;
          this._width = 0;
          this._height = 0;
        }
      }

      class InputAssembler extends GFXObject {
        get attributes() {
          return this._attributes;
        }
        get vertexBuffers() {
          return this._vertexBuffers;
        }
        get indexBuffer() {
          return this._indexBuffer;
        }
        get indirectBuffer() {
          return this._indirectBuffer;
        }
        get attributesHash() {
          return this._attributesHash;
        }
        set vertexCount(count) {
          this._drawInfo.vertexCount = count;
        }
        get vertexCount() {
          return this._drawInfo.vertexCount;
        }
        set firstVertex(first) {
          this._drawInfo.firstVertex = first;
        }
        get firstVertex() {
          return this._drawInfo.firstVertex;
        }
        set indexCount(count) {
          this._drawInfo.indexCount = count;
        }
        get indexCount() {
          return this._drawInfo.indexCount;
        }
        set firstIndex(first) {
          this._drawInfo.firstIndex = first;
        }
        get firstIndex() {
          return this._drawInfo.firstIndex;
        }
        set vertexOffset(offset) {
          this._drawInfo.vertexOffset = offset;
        }
        get vertexOffset() {
          return this._drawInfo.vertexOffset;
        }
        set instanceCount(count) {
          this._drawInfo.instanceCount = count;
        }
        get instanceCount() {
          return this._drawInfo.instanceCount;
        }
        set firstInstance(first) {
          this._drawInfo.firstInstance = first;
        }
        get firstInstance() {
          return this._drawInfo.firstInstance;
        }
        set drawInfo(info) {
          this._drawInfo = info;
        }
        get drawInfo() {
          return this._drawInfo;
        }
        constructor() {
          super(ObjectType.INPUT_ASSEMBLER);
          this._attributes = [];
          this._attributesHash = 0;
          this._vertexBuffers = [];
          this._indexBuffer = null;
          this._indirectBuffer = null;
          this._drawInfo = new DrawInfo();
        }
        getVertexBuffer(stream = 0) {
          if (stream < this._vertexBuffers.length) {
            return this._vertexBuffers[stream];
          } else {
            return null;
          }
        }
        computeAttributesHash() {
          let res = 'attrs';
          for (let i = 0; i < this.attributes.length; ++i) {
            const at = this.attributes[i];
            res += `,${at.name},${at.format},${at.isNormalized},${at.stream},${at.isInstanced},${at.location}`;
          }
          return murmurhash2_32_gc(res, 666);
        }
      }

      class DescriptorSetLayout extends GFXObject {
        get bindings() {
          return this._bindings;
        }
        get bindingIndices() {
          return this._bindingIndices;
        }
        get descriptorIndices() {
          return this._descriptorIndices;
        }
        constructor() {
          super(ObjectType.DESCRIPTOR_SET_LAYOUT);
          this._bindings = [];
          this._bindingIndices = [];
          this._descriptorIndices = [];
        }
      }

      class PipelineLayout extends GFXObject {
        get setLayouts() {
          return this._setLayouts;
        }
        constructor() {
          super(ObjectType.PIPELINE_LAYOUT);
          this._setLayouts = [];
        }
      }

      class Queue extends GFXObject {
        get type() {
          return this._type;
        }
        constructor() {
          super(ObjectType.QUEUE);
          this._type = QueueType.GRAPHICS;
        }
      }

      class RenderPass extends GFXObject {
        get colorAttachments() {
          return this._colorInfos;
        }
        get depthStencilAttachment() {
          return this._depthStencilInfo;
        }
        get subPasses() {
          return this._subpasses;
        }
        get hash() {
          return this._hash;
        }
        constructor() {
          super(ObjectType.RENDER_PASS);
          this._colorInfos = [];
          this._depthStencilInfo = null;
          this._subpasses = [];
          this._hash = 0;
        }
        computeHash() {
          let res = '';
          if (this._subpasses.length) {
            for (let i = 0; i < this._subpasses.length; ++i) {
              const subpass = this._subpasses[i];
              if (subpass.inputs.length) {
                res += 'ia';
                for (let j = 0; j < subpass.inputs.length; ++j) {
                  const ia = this._colorInfos[subpass.inputs[j]];
                  res += `,${ia.format},${ia.sampleCount}`;
                }
              }
              if (subpass.colors.length) {
                res += 'ca';
                for (let j = 0; j < subpass.inputs.length; ++j) {
                  const ca = this._colorInfos[subpass.inputs[j]];
                  res += `,${ca.format},${ca.sampleCount}`;
                }
              }
              if (subpass.depthStencil >= 0) {
                const ds = this._colorInfos[subpass.depthStencil];
                res += `ds,${ds.format},${ds.sampleCount}`;
              }
            }
          } else {
            res += 'ca';
            for (let i = 0; i < this._colorInfos.length; ++i) {
              const ca = this._colorInfos[i];
              res += `,${ca.format},${ca.sampleCount}`;
            }
            const ds = this._depthStencilInfo;
            if (ds) {
              res += `ds,${ds.format},${ds.sampleCount}`;
            }
          }
          return murmurhash2_32_gc(res, 666);
        }
      }

      class Shader extends GFXObject {
        get name() {
          return this._name;
        }
        get attributes() {
          return this._attributes;
        }
        get blocks() {
          return this._blocks;
        }
        get samplers() {
          return this._samplers;
        }
        constructor() {
          super(ObjectType.SHADER);
          this._name = '';
          this._stages = [];
          this._attributes = [];
          this._blocks = [];
          this._samplers = [];
        }
      }

      class Texture extends GFXObject {
        get type() {
          return this._info.type;
        }
        get usage() {
          return this._info.usage;
        }
        get format() {
          return this._info.format;
        }
        get width() {
          return this._info.width;
        }
        get height() {
          return this._info.height;
        }
        get depth() {
          return this._info.depth;
        }
        get layerCount() {
          return this._info.layerCount;
        }
        get levelCount() {
          return this._info.levelCount;
        }
        get samples() {
          return this._info.samples;
        }
        get flags() {
          return this._info.flags;
        }
        get size() {
          return this._size;
        }
        get info() {
          return this._info;
        }
        get viewInfo() {
          return this._viewInfo;
        }
        get isTextureView() {
          return this._isTextureView;
        }
        constructor() {
          super(ObjectType.TEXTURE);
          this._info = new TextureInfo();
          this._viewInfo = new TextureViewInfo();
          this._isPowerOf2 = false;
          this._isTextureView = false;
          this._size = 0;
        }
        static getLevelCount(width, height) {
          return Math.floor(Math.log2(Math.max(width, height)));
        }
      }

      class Sampler extends GFXObject {
        get info() {
          return this._info;
        }
        get hash() {
          return this._hash;
        }
        constructor(info, hash) {
          super(ObjectType.SAMPLER);
          this._info = new SamplerInfo();
          this._hash = 0;
          this._info.copy(info);
          this._hash = hash;
        }
        static computeHash(info) {
          let hash = info.minFilter;
          hash |= info.magFilter << 2;
          hash |= info.mipFilter << 4;
          hash |= info.addressU << 6;
          hash |= info.addressV << 8;
          hash |= info.addressW << 10;
          hash |= info.maxAnisotropy << 12;
          hash |= info.cmpFunc << 16;
          return hash;
        }
        static unpackFromHash(hash) {
          const info = new SamplerInfo();
          info.minFilter = (hash & (1 << 2) - 1) >> 0;
          info.magFilter = (hash & (1 << 2) - 1) >> 2;
          info.mipFilter = (hash & (1 << 2) - 1) >> 4;
          info.addressU = (hash & (1 << 2) - 1) >> 6;
          info.addressV = (hash & (1 << 2) - 1) >> 8;
          info.addressW = (hash & (1 << 2) - 1) >> 10;
          info.maxAnisotropy = (hash & (1 << 4) - 1) >> 12;
          info.cmpFunc = (hash & (1 << 3) - 1) >> 16;
          return info;
        }
      }

      class GeneralBarrier extends GFXObject {
        get info() {
          return this._info;
        }
        get hash() {
          return this._hash;
        }
        constructor(info, hash) {
          super(ObjectType.GLOBAL_BARRIER);
          this._info = new GeneralBarrierInfo();
          this._hash = 0;
          this._info.copy(info);
          this._hash = hash;
        }
        static computeHash(info) {
          return murmurhash2_32_gc(`${info.prevAccesses} ${info.nextAccesses} ${info.type}`, 666);
        }
      }

      class TextureBarrier extends GFXObject {
        get info() {
          return this._info;
        }
        get hash() {
          return this._hash;
        }
        constructor(info, hash) {
          super(ObjectType.TEXTURE_BARRIER);
          this._info = new TextureBarrierInfo();
          this._hash = 0;
          this._info.copy(info);
          this._hash = hash;
        }
        static computeHash(info) {
          let res = `${info.prevAccesses} ${info.nextAccesses}`;
          res += info.type;
          res += info.baseMipLevel;
          res += info.levelCount;
          res += info.baseSlice;
          res += info.sliceCount;
          res += info.discardContents;
          res += info.srcQueue ? info.srcQueue.type : 0;
          res += info.dstQueue ? info.dstQueue.type : 0;
          return murmurhash2_32_gc(res, 666);
        }
      }

      let LegacyRenderMode;
      (function (LegacyRenderMode) {
        LegacyRenderMode[LegacyRenderMode["AUTO"] = 0] = "AUTO";
        LegacyRenderMode[LegacyRenderMode["CANVAS"] = 1] = "CANVAS";
        LegacyRenderMode[LegacyRenderMode["WEBGL"] = 2] = "WEBGL";
        LegacyRenderMode[LegacyRenderMode["HEADLESS"] = 3] = "HEADLESS";
      })(LegacyRenderMode || (LegacyRenderMode = {}));
      let RenderType;
      (function (RenderType) {
        RenderType[RenderType["UNKNOWN"] = -1] = "UNKNOWN";
        RenderType[RenderType["CANVAS"] = 0] = "CANVAS";
        RenderType[RenderType["WEBGL"] = 1] = "WEBGL";
        RenderType[RenderType["OPENGL"] = 2] = "OPENGL";
        RenderType[RenderType["HEADLESS"] = 3] = "HEADLESS";
      })(RenderType || (RenderType = {}));
      class DeviceManager {
        constructor() {
          this.initialized = false;
          this._gfxDevice = void 0;
          this._canvas = null;
          this._swapchain = void 0;
          this._renderType = RenderType.UNKNOWN;
        }
        get gfxDevice() {
          return this._gfxDevice;
        }
        get swapchain() {
          return this._swapchain;
        }
        init(canvas, bindingMappingInfo) {
          if (this.initialized) {
            return;
          }
          const renderMode = settings.querySettings(Settings.Category.RENDERING, 'renderMode');
          this._canvas = canvas;
          this._renderType = this._determineRenderType(renderMode);
          if (this._renderType === RenderType.WEBGL) {
            const deviceInfo = new DeviceInfo(bindingMappingInfo);
            if (globalThis.gfx) {
              this._gfxDevice = gfx.DeviceManager.create(deviceInfo);
            } else {
              let useWebGL2 = !!globalThis.WebGL2RenderingContext;
              globalThis.navigator.userAgent.toLowerCase();
              if (sys.browserType === BrowserType.UC) {
                useWebGL2 = false;
              }
              const deviceCtors = [];
              if (useWebGL2 && legacyCC.WebGL2Device) {
                deviceCtors.push(legacyCC.WebGL2Device);
              }
              if (legacyCC.WebGLDevice) {
                deviceCtors.push(legacyCC.WebGLDevice);
              }
              if (legacyCC.EmptyDevice) {
                deviceCtors.push(legacyCC.EmptyDevice);
              }
              Device.canvas = canvas;
              for (let i = 0; i < deviceCtors.length; i++) {
                this._gfxDevice = new deviceCtors[i]();
                if (this._gfxDevice.initialize(deviceInfo)) {
                  break;
                }
              }
              this._initSwapchain();
            }
          } else if (this._renderType === RenderType.HEADLESS && legacyCC.EmptyDevice) {
            this._gfxDevice = new legacyCC.EmptyDevice();
            this._gfxDevice.initialize(new DeviceInfo(bindingMappingInfo));
            this._initSwapchain();
          }
          if (!this._gfxDevice) {
            error('can not support canvas rendering in 3D');
            this._renderType = RenderType.UNKNOWN;
            return;
          }
          if (this._canvas) {
            this._canvas.oncontextmenu = () => false;
          }
        }
        _initSwapchain() {
          const swapchainInfo = new SwapchainInfo(1, this._canvas);
          const windowSize = screen.windowSize;
          swapchainInfo.width = windowSize.width;
          swapchainInfo.height = windowSize.height;
          this._swapchain = this._gfxDevice.createSwapchain(swapchainInfo);
        }
        _determineRenderType(renderMode) {
          if (typeof renderMode !== 'number' || renderMode > RenderType.HEADLESS || renderMode < LegacyRenderMode.AUTO) {
            renderMode = LegacyRenderMode.AUTO;
          }
          let renderType = RenderType.CANVAS;
          let supportRender = false;
          if (renderMode === LegacyRenderMode.CANVAS) {
            renderType = RenderType.CANVAS;
            supportRender = true;
          } else if (renderMode === LegacyRenderMode.AUTO || renderMode === LegacyRenderMode.WEBGL) {
            renderType = RenderType.WEBGL;
            supportRender = true;
          } else if (renderMode === LegacyRenderMode.HEADLESS) {
            renderType = RenderType.HEADLESS;
            supportRender = true;
          }
          if (!supportRender) {
            throw new Error(getError(3820, renderMode));
          }
          return renderType;
        }
      }
      const deviceManager = new DeviceManager();

      const polyfills = {
        GFXDevice: true,
        GFXBuffer: true,
        GFXTexture: true,
        GFXSampler: true,
        GFXShader: true,
        GFXInputAssembler: true,
        GFXRenderPass: true,
        GFXFramebuffer: true,
        GFXPipelineState: true,
        GFXCommandBuffer: true,
        GFXQueue: true,
        GFXObjectType: true,
        GFXObject: false,
        GFXAttributeName: true,
        GFXType: true,
        GFXFormat: true,
        GFXBufferUsageBit: true,
        GFXMemoryUsageBit: true,
        GFXBufferFlagBit: true,
        GFXBufferAccessBit: 'MemoryAccessBit',
        GFXPrimitiveMode: true,
        GFXPolygonMode: true,
        GFXShadeModel: true,
        GFXCullMode: true,
        GFXComparisonFunc: true,
        GFXStencilOp: true,
        GFXBlendOp: true,
        GFXBlendFactor: true,
        GFXColorMask: true,
        GFXFilter: true,
        GFXAddress: true,
        GFXTextureType: true,
        GFXTextureUsageBit: true,
        GFXSampleCount: true,
        GFXTextureFlagBit: true,
        GFXShaderStageFlagBit: true,
        GFXDescriptorType: true,
        GFXCommandBufferType: true,
        GFXLoadOp: true,
        GFXStoreOp: true,
        GFXPipelineBindPoint: true,
        GFXDynamicStateFlagBit: true,
        GFXStencilFace: true,
        GFXQueueType: true,
        GFXRect: true,
        GFXViewport: true,
        GFXColor: true,
        GFXClearFlag: true,
        GFXOffset: true,
        GFXExtent: true,
        GFXTextureSubres: 'TextureSubresLayers',
        GFXTextureCopy: true,
        GFXBufferTextureCopy: true,
        GFXFormatType: true,
        GFXFormatInfo: true,
        GFXMemoryStatus: true,
        GFXFormatInfos: true,
        GFXFormatSize: true,
        GFXFormatSurfaceSize: true,
        GFXGetTypeSize: true,
        getTypedArrayConstructor: false
      };
      for (const name in polyfills) {
        let newName = polyfills[name];
        if (newName === true) {
          newName = name.slice(3);
        } else if (newName === false) {
          newName = name;
        }
        replaceProperty(legacyCC, 'cc', [{
          name,
          newName,
          target: legacyCC.gfx,
          targetName: 'cc.gfx'
        }]);
      }
      removeProperty(legacyCC, 'cc', [{
        name: 'GFX_MAX_VERTEX_ATTRIBUTES'
      }, {
        name: 'GFX_MAX_TEXTURE_UNITS'
      }, {
        name: 'GFX_MAX_ATTACHMENTS'
      }, {
        name: 'GFX_MAX_BUFFER_BINDINGS'
      }, {
        name: 'GFXTextureLayout'
      }]);

      const polyfillCC = Object.assign({}, defines);
      polyfillCC.Device = gfx.Device;
      polyfillCC.Swapchain = gfx.Swapchain;
      polyfillCC.Buffer = gfx.Buffer;
      polyfillCC.Texture = gfx.Texture;
      polyfillCC.Sampler = gfx.Sampler;
      polyfillCC.Shader = gfx.Shader;
      polyfillCC.InputAssembler = gfx.InputAssembler;
      polyfillCC.RenderPass = gfx.RenderPass;
      polyfillCC.Framebuffer = gfx.Framebuffer;
      polyfillCC.DescriptorSet = gfx.DescriptorSet;
      polyfillCC.DescriptorSetLayout = gfx.DescriptorSetLayout;
      polyfillCC.PipelineLayout = gfx.PipelineLayout;
      polyfillCC.PipelineState = gfx.PipelineState;
      polyfillCC.CommandBuffer = gfx.CommandBuffer;
      polyfillCC.Queue = gfx.Queue;
      legacyCC.gfx = polyfillCC;
      polyfillCC.BlendTarget = BlendTarget;
      polyfillCC.BlendState = BlendState;
      polyfillCC.RasterizerState = RasterizerState;
      polyfillCC.DepthStencilState = DepthStencilState;
      polyfillCC.PipelineStateInfo = PipelineStateInfo;

      var index$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        DescriptorSet: DescriptorSet,
        Buffer: Buffer,
        CommandBuffer: CommandBuffer,
        get ObjectType () { return ObjectType; },
        get Status () { return Status; },
        get API () { return API; },
        get SurfaceTransform () { return SurfaceTransform; },
        get Feature () { return Feature; },
        get Format () { return Format; },
        get FormatType () { return FormatType; },
        get Type () { return Type$1; },
        get BufferUsageBit () { return BufferUsageBit; },
        get BufferFlagBit () { return BufferFlagBit; },
        get MemoryAccessBit () { return MemoryAccessBit; },
        get MemoryUsageBit () { return MemoryUsageBit; },
        get TextureType () { return TextureType; },
        get TextureUsageBit () { return TextureUsageBit; },
        get TextureFlagBit () { return TextureFlagBit; },
        get FormatFeatureBit () { return FormatFeatureBit; },
        get SampleCount () { return SampleCount; },
        get VsyncMode () { return VsyncMode; },
        get Filter () { return Filter$1; },
        get Address () { return Address; },
        get ComparisonFunc () { return ComparisonFunc; },
        get StencilOp () { return StencilOp; },
        get BlendFactor () { return BlendFactor; },
        get BlendOp () { return BlendOp; },
        get ColorMask () { return ColorMask; },
        get ShaderStageFlagBit () { return ShaderStageFlagBit; },
        get LoadOp () { return LoadOp; },
        get StoreOp () { return StoreOp; },
        get AccessFlagBit () { return AccessFlagBit; },
        get ResolveMode () { return ResolveMode; },
        get PipelineBindPoint () { return PipelineBindPoint; },
        get PrimitiveMode () { return PrimitiveMode; },
        get PolygonMode () { return PolygonMode; },
        get ShadeModel () { return ShadeModel; },
        get CullMode () { return CullMode; },
        get DynamicStateFlagBit () { return DynamicStateFlagBit; },
        get StencilFace () { return StencilFace; },
        get DescriptorType () { return DescriptorType; },
        get QueueType () { return QueueType; },
        get QueryType () { return QueryType; },
        get CommandBufferType () { return CommandBufferType; },
        get ClearFlagBit () { return ClearFlagBit; },
        get BarrierType () { return BarrierType; },
        get PassType () { return PassType; },
        Size: Size,
        DeviceCaps: DeviceCaps,
        DeviceOptions: DeviceOptions,
        Offset: Offset,
        Rect: Rect,
        Extent: Extent,
        TextureSubresLayers: TextureSubresLayers,
        TextureSubresRange: TextureSubresRange,
        TextureCopy: TextureCopy,
        TextureBlit: TextureBlit,
        BufferTextureCopy: BufferTextureCopy,
        Viewport: Viewport,
        Color: Color,
        BindingMappingInfo: BindingMappingInfo,
        SwapchainInfo: SwapchainInfo,
        DeviceInfo: DeviceInfo,
        BufferInfo: BufferInfo,
        BufferViewInfo: BufferViewInfo,
        DrawInfo: DrawInfo,
        DispatchInfo: DispatchInfo,
        IndirectBuffer: IndirectBuffer,
        TextureInfo: TextureInfo,
        TextureViewInfo: TextureViewInfo,
        SamplerInfo: SamplerInfo,
        Uniform: Uniform,
        UniformBlock: UniformBlock,
        UniformSamplerTexture: UniformSamplerTexture,
        UniformSampler: UniformSampler,
        UniformTexture: UniformTexture,
        UniformStorageImage: UniformStorageImage,
        UniformStorageBuffer: UniformStorageBuffer,
        UniformInputAttachment: UniformInputAttachment,
        ShaderStage: ShaderStage,
        Attribute: Attribute,
        ShaderInfo: ShaderInfo,
        InputAssemblerInfo: InputAssemblerInfo,
        ColorAttachment: ColorAttachment,
        DepthStencilAttachment: DepthStencilAttachment,
        SubpassInfo: SubpassInfo,
        SubpassDependency: SubpassDependency,
        RenderPassInfo: RenderPassInfo,
        GeneralBarrierInfo: GeneralBarrierInfo,
        TextureBarrierInfo: TextureBarrierInfo,
        BufferBarrierInfo: BufferBarrierInfo,
        FramebufferInfo: FramebufferInfo,
        DescriptorSetLayoutBinding: DescriptorSetLayoutBinding,
        DescriptorSetLayoutInfo: DescriptorSetLayoutInfo,
        DescriptorSetInfo: DescriptorSetInfo,
        PipelineLayoutInfo: PipelineLayoutInfo,
        InputState: InputState,
        CommandBufferInfo: CommandBufferInfo,
        QueueInfo: QueueInfo,
        QueryPoolInfo: QueryPoolInfo,
        FormatInfo: FormatInfo,
        MemoryStatus: MemoryStatus,
        DynamicStencilStates: DynamicStencilStates,
        DynamicStates: DynamicStates,
        GFXObject: GFXObject,
        get AttributeName () { return AttributeName; },
        FormatInfos: FormatInfos,
        DESCRIPTOR_BUFFER_TYPE: DESCRIPTOR_BUFFER_TYPE,
        DESCRIPTOR_SAMPLER_TYPE: DESCRIPTOR_SAMPLER_TYPE,
        DESCRIPTOR_DYNAMIC_TYPE: DESCRIPTOR_DYNAMIC_TYPE,
        DRAW_INFO_SIZE: DRAW_INFO_SIZE,
        IsPowerOf2: IsPowerOf2,
        FormatSize: FormatSize,
        FormatSurfaceSize: FormatSurfaceSize,
        GetTypeSize: GetTypeSize,
        getTypedArrayConstructor: getTypedArrayConstructor,
        formatAlignment: formatAlignment,
        alignTo: alignTo,
        Device: Device,
        DefaultResource: DefaultResource,
        Swapchain: Swapchain,
        Framebuffer: Framebuffer,
        InputAssembler: InputAssembler,
        DescriptorSetLayout: DescriptorSetLayout,
        PipelineLayout: PipelineLayout,
        BlendState: BlendState,
        BlendTarget: BlendTarget,
        RasterizerState: RasterizerState,
        DepthStencilState: DepthStencilState,
        PipelineState: PipelineState,
        PipelineStateInfo: PipelineStateInfo,
        Queue: Queue,
        RenderPass: RenderPass,
        Shader: Shader,
        Texture: Texture,
        Sampler: Sampler,
        GeneralBarrier: GeneralBarrier,
        TextureBarrier: TextureBarrier,
        get LegacyRenderMode () { return LegacyRenderMode; },
        get RenderType () { return RenderType; },
        DeviceManager: DeviceManager,
        deviceManager: deviceManager
      });
      exports('gfx', index$1);

      const m$4 = new Mat4();
      function fillMeshVertices3D(node, renderer, renderData, color) {
        const chunk = renderData.chunk;
        const dataList = renderData.data;
        const vData = chunk.vb;
        const vertexCount = renderData.vertexCount;
        node.getWorldMatrix(m$4);
        let vertexOffset = 0;
        for (let i = 0; i < vertexCount; i++) {
          const vert = dataList[i];
          const x = vert.x;
          const y = vert.y;
          let rhw = m$4.m03 * x + m$4.m07 * y + m$4.m15;
          rhw = rhw ? 1 / rhw : 1;
          vData[vertexOffset + 0] = (m$4.m00 * x + m$4.m04 * y + m$4.m12) * rhw;
          vData[vertexOffset + 1] = (m$4.m01 * x + m$4.m05 * y + m$4.m13) * rhw;
          vData[vertexOffset + 2] = (m$4.m02 * x + m$4.m06 * y + m$4.m14) * rhw;
          Color$1.toArray(vData, color, vertexOffset + 5);
          vertexOffset += 9;
        }
        chunk.bufferId;
        const vid = chunk.vertexOffset;
        const meshBuffer = chunk.meshBuffer;
        const ib = chunk.meshBuffer.iData;
        let indexOffset = meshBuffer.indexOffset;
        for (let i = 0, count = vertexCount / 4; i < count; i++) {
          const start = vid + i * 4;
          ib[indexOffset++] = start;
          ib[indexOffset++] = start + 1;
          ib[indexOffset++] = start + 2;
          ib[indexOffset++] = start + 1;
          ib[indexOffset++] = start + 3;
          ib[indexOffset++] = start + 2;
        }
        meshBuffer.indexOffset += renderData.indexCount;
        meshBuffer.setDirty();
      }
      function updateOpacity(renderData, opacity) {
        const vfmt = renderData.vertexFormat;
        const vb = renderData.chunk.vb;
        let attr;
        let format;
        let stride;
        let offset = 0;
        for (let i = 0; i < vfmt.length; ++i) {
          attr = vfmt[i];
          format = FormatInfos[attr.format];
          if (format.hasAlpha) {
            stride = renderData.floatStride;
            if (format.size / format.count === 1) {
              const alpha = ~~clamp$1(Math.round(opacity * 255), 0, 255);
              for (let color = offset; color < vb.length; color += stride) {
                vb[color] = (vb[color] & 0xffffff00 | alpha) >>> 0;
              }
            } else if (format.size / format.count === 4) {
              for (let alpha = offset + 3; alpha < vb.length; alpha += stride) {
                vb[alpha] = opacity;
              }
            }
          }
          offset += format.size >> 2;
        }
      }

      const minigame = {};

      class Cache {
        get map() {
          return this._map;
        }
        constructor(map) {
          this._map = null;
          this._count = 0;
          if (map) {
            this._map = map;
            this._count = Object.keys(map).length;
          } else {
            this._map = createMap(true);
            this._count = 0;
          }
        }
        add(key, val) {
          if (!(key in this._map)) {
            this._count++;
          }
          return this._map[key] = val;
        }
        get(key) {
          return this._map[key];
        }
        has(key) {
          return key in this._map;
        }
        remove(key) {
          const out = this._map[key];
          if (key in this._map) {
            delete this._map[key];
            this._count--;
          }
          return out;
        }
        clear() {
          if (this._count !== 0) {
            this._map = createMap(true);
            this._count = 0;
          }
        }
        forEach(func) {
          for (const key in this._map) {
            func(this._map[key], key);
          }
        }
        find(predicate) {
          for (const key in this._map) {
            if (predicate(this._map[key], key)) {
              return this._map[key];
            }
          }
          return null;
        }
        get count() {
          return this._count;
        }
        destroy() {
          this._map = null;
        }
      }

      class Pipeline {
        constructor(name, funcs) {
          this.id = Pipeline._pipelineId++;
          this.name = '';
          this.pipes = [];
          this.name = name;
          for (let i = 0, l = funcs.length; i < l; i++) {
            this.pipes.push(funcs[i]);
          }
        }
        insert(func, index) {
          if (index > this.pipes.length) {
            warnID(4921);
            return this;
          }
          this.pipes.splice(index, 0, func);
          return this;
        }
        append(func) {
          this.pipes.push(func);
          return this;
        }
        remove(index) {
          this.pipes.splice(index, 1);
          return this;
        }
        sync(task) {
          const pipes = this.pipes;
          if (pipes.length === 0) {
            return null;
          }
          task.isFinished = false;
          for (let i = 0, l = pipes.length; i < l;) {
            const pipe = pipes[i];
            const result = pipe(task);
            if (result) {
              task.isFinished = true;
              return result;
            }
            i++;
            if (i !== l) {
              task.input = task.output;
              task.output = null;
            }
          }
          task.isFinished = true;
          return task.output;
        }
        async(task) {
          const pipes = this.pipes;
          if (pipes.length === 0) {
            return;
          }
          task.isFinished = false;
          this._flow(0, task);
        }
        _flow(index, task) {
          const pipe = this.pipes[index];
          pipe(task, result => {
            if (result) {
              task.isFinished = true;
              task.dispatch('complete', result);
            } else {
              index++;
              if (index < this.pipes.length) {
                task.input = task.output;
                task.output = null;
                this._flow(index, task);
              } else {
                task.isFinished = true;
                task.dispatch('complete', result, task.output);
              }
            }
          });
        }
      }
      Pipeline._pipelineId = 0;

      const assets = new Cache();
      const files = new Cache();
      const parsed = new Cache();
      const bundles = new Cache();
      const pipeline = new Pipeline('normal load', []);
      const fetchPipeline = new Pipeline('fetch', []);
      const transformPipeline = new Pipeline('transform url', []);
      const references = null;
      const assetsOverrideMap = new Map();
      let RequestType;
      (function (RequestType) {
        RequestType["UUID"] = "uuid";
        RequestType["PATH"] = "path";
        RequestType["DIR"] = "dir";
        RequestType["URL"] = "url";
        RequestType["SCENE"] = "scene";
      })(RequestType || (RequestType = {}));
      const presets = {
        default: {
          priority: 0
        },
        preload: {
          maxConcurrency: 6,
          maxRequestsPerFrame: 2,
          priority: -1
        },
        scene: {
          maxConcurrency: 20,
          maxRequestsPerFrame: 20,
          priority: 1
        },
        bundle: {
          maxConcurrency: 20,
          maxRequestsPerFrame: 20,
          priority: 2
        },
        remote: {
          maxRetryCount: 4
        }
      };
      let BuiltinBundleName;
      (function (BuiltinBundleName) {
        BuiltinBundleName["INTERNAL"] = "internal";
        BuiltinBundleName["RESOURCES"] = "resources";
        BuiltinBundleName["MAIN"] = "main";
        BuiltinBundleName["START_SCENE"] = "start-scene";
      })(BuiltinBundleName || (BuiltinBundleName = {}));

      class Task {
        static create(options) {
          let out;
          if (Task._deadPool.length !== 0) {
            out = Task._deadPool.pop();
            out.set(options);
          } else {
            out = new Task(options);
          }
          return out;
        }
        get isFinish() {
          return this.isFinished;
        }
        set isFinish(val) {
          this.isFinished = val;
        }
        constructor(options) {
          this.id = Task._taskId++;
          this.onComplete = null;
          this.onProgress = null;
          this.onError = null;
          this.source = null;
          this.output = null;
          this.input = null;
          this.progress = null;
          this.options = null;
          this.isFinished = true;
          this.set(options);
        }
        set(options = Object.create(null)) {
          this.onComplete = options.onComplete || null;
          this.onProgress = options.onProgress || null;
          this.onError = options.onError || null;
          this.source = this.input = options.input;
          this.output = null;
          this.progress = options.progress;
          this.options = options.options || Object.create(null);
        }
        dispatch(event, param1, param2, param3, param4) {
          switch (event) {
            case 'complete':
              if (this.onComplete) {
                this.onComplete(param1, param2);
              }
              break;
            case 'progress':
              if (this.onProgress) {
                this.onProgress(param1, param2, param3, param4);
              }
              break;
            case 'error':
              if (this.onError) {
                this.onError(param1, param2, param3, param4);
              }
              break;
            default:
              {
                const str = `on${event[0].toUpperCase()}${event.substr(1)}`;
                if (typeof this[str] === 'function') {
                  this[str](param1, param2, param3, param4);
                }
                break;
              }
          }
        }
        recycle() {
          if (Task._deadPool.length === Task.MAX_DEAD_NUM) {
            return;
          }
          this.onComplete = null;
          this.onProgress = null;
          this.onError = null;
          this.source = this.output = this.input = null;
          this.progress = null;
          this.options = null;
          Task._deadPool.push(this);
        }
      }
      Task.MAX_DEAD_NUM = 500;
      Task._taskId = 0;
      Task._deadPool = [];

      const separator = '@';
      const HexChars = '0123456789abcdef'.split('');
      const _t = ['', '', '', ''];
      const UuidTemplate = _t.concat(_t, '-', _t, '-', _t, '-', _t, '-', _t, _t, _t);
      const Indices = UuidTemplate.map((x, i) => x === '-' ? NaN : i).filter(Number.isFinite);
      function decodeUuid(base64) {
        const strs = base64.split(separator);
        const uuid = strs[0];
        if (uuid.length !== 22) {
          return base64;
        }
        UuidTemplate[0] = base64[0];
        UuidTemplate[1] = base64[1];
        for (let i = 2, j = 2; i < 22; i += 2) {
          const lhs = BASE64_VALUES$1[base64.charCodeAt(i)];
          const rhs = BASE64_VALUES$1[base64.charCodeAt(i + 1)];
          UuidTemplate[Indices[j++]] = HexChars[lhs >> 2];
          UuidTemplate[Indices[j++]] = HexChars[(lhs & 3) << 2 | rhs >> 4];
          UuidTemplate[Indices[j++]] = HexChars[rhs & 0xF];
        }
        return base64.replace(uuid, UuidTemplate.join(''));
      }

      const _uuidRegex = /.*[/\\][0-9a-fA-F]{2}[/\\]([0-9a-fA-F-@]{8,}).*/;
      function getUuidFromURL(url) {
        const matches = _uuidRegex.exec(url);
        if (matches) {
          return matches[1];
        }
        return '';
      }
      function getUrlWithUuid(uuid, options) {
        options = options || Object.create(null);
        options.__isNative__ = options.isNative;
        if (options.nativeExt) {
          options.ext = options.nativeExt;
        }
        const bundle = bundles.find(b => !!b.getAssetInfo(uuid));
        if (bundle) {
          options.bundle = bundle.name;
        }
        return transform(uuid, options);
      }
      function isScene(asset) {
        return !!asset && (asset instanceof legacyCC.SceneAsset || asset instanceof legacyCC.Scene);
      }
      function normalize(url) {
        if (url) {
          if (url.charCodeAt(0) === 46 && url.charCodeAt(1) === 47) {
            url = url.slice(2);
          } else if (url.charCodeAt(0) === 47) {
            url = url.slice(1);
          }
        }
        return url;
      }
      function transform(input, options) {
        const subTask = Task.create({
          input,
          options
        });
        const urls = [];
        try {
          const result = transformPipeline.sync(subTask);
          for (const requestItem of result) {
            const url = requestItem.url;
            requestItem.recycle();
            urls.push(url);
          }
        } catch (e) {
          for (const item of subTask.output) {
            item.recycle();
          }
          error(e.message, e.stack);
        }
        subTask.recycle();
        return urls.length > 1 ? urls : urls[0];
      }

      var helper = /*#__PURE__*/Object.freeze({
        __proto__: null,
        getUuidFromURL: getUuidFromURL,
        getUrlWithUuid: getUrlWithUuid,
        isScene: isScene,
        normalize: normalize,
        transform: transform,
        decodeUuid: decodeUuid
      });

      const defaultExec = (cb, decorator, attr) => {
        cb();
      };
      function patch_BloomStage(ctx, apply = defaultExec) {
        const {
          BloomStage,
          Material
        } = {
          ...ctx
        };
        apply(() => {
          displayOrder$1()(BloomStage.prototype, '_bloomMaterial', () => {
            return null;
          });
        }, 'displayOrder', '_bloomMaterial');
        apply(() => {
          serializable$3(BloomStage.prototype, '_bloomMaterial', () => {
            return null;
          });
        }, 'serializable', '_bloomMaterial');
        apply(() => {
          type$2(Material)(BloomStage.prototype, '_bloomMaterial', () => {
            return null;
          });
        }, 'type', '_bloomMaterial');
        apply(() => {
          ccclass$3('BloomStage')(BloomStage);
        }, 'ccclass', null);
      }
      function patch_cc_AmbientInfo(ctx, apply = defaultExec) {
        const {
          AmbientInfo,
          legacyCC,
          CCFloat,
          Vec4,
          Ambient
        } = {
          ...ctx
        };
        const skyLightingColorDescriptor = Object.getOwnPropertyDescriptor(AmbientInfo.prototype, 'skyLightingColor');
        const skyIllumDescriptor = Object.getOwnPropertyDescriptor(AmbientInfo.prototype, 'skyIllum');
        const groundLightingColorDescriptor = Object.getOwnPropertyDescriptor(AmbientInfo.prototype, 'groundLightingColor');
        apply(() => {
          tooltip()(AmbientInfo.prototype, 'skyLightingColor', skyLightingColorDescriptor);
        }, 'tooltip', 'skyLightingColor');
        apply(() => {
          editable$1(AmbientInfo.prototype);
        }, 'editable', 'skyLightingColor');
        apply(() => {
          visible$1()(AmbientInfo.prototype, 'skyLightingColor', skyLightingColorDescriptor);
        }, 'visible', 'skyLightingColor');
        apply(() => {
          range()(AmbientInfo.prototype, 'skyIllum', skyIllumDescriptor);
        }, 'range', 'skyIllum');
        apply(() => {
          tooltip()(AmbientInfo.prototype, 'skyIllum', skyIllumDescriptor);
        }, 'tooltip', 'skyIllum');
        apply(() => {
          type$2(CCFloat)(AmbientInfo.prototype, 'skyIllum', skyIllumDescriptor);
        }, 'type', 'skyIllum');
        apply(() => {
          editable$1(AmbientInfo.prototype);
        }, 'editable', 'skyIllum');
        apply(() => {
          tooltip()(AmbientInfo.prototype, 'groundLightingColor', groundLightingColorDescriptor);
        }, 'tooltip', 'groundLightingColor');
        apply(() => {
          editable$1(AmbientInfo.prototype);
        }, 'editable', 'groundLightingColor');
        apply(() => {
          visible$1()(AmbientInfo.prototype, 'groundLightingColor', groundLightingColorDescriptor);
        }, 'visible', 'groundLightingColor');
        apply(() => {
          formerlySerializedAs('_skyColor')(AmbientInfo.prototype, '_skyColorHDR', () => {
            return new Vec4(0.2, 0.5, 0.8, 1.0);
          });
        }, 'formerlySerializedAs', '_skyColorHDR');
        apply(() => {
          serializable$3(AmbientInfo.prototype, '_skyColorHDR', () => {
            return new Vec4(0.2, 0.5, 0.8, 1.0);
          });
        }, 'serializable', '_skyColorHDR');
        apply(() => {
          formerlySerializedAs('_skyIllum')(AmbientInfo.prototype, '_skyIllumHDR', () => {
            return Ambient.SKY_ILLUM;
          });
        }, 'formerlySerializedAs', '_skyIllumHDR');
        apply(() => {
          serializable$3(AmbientInfo.prototype, '_skyIllumHDR', () => {
            return Ambient.SKY_ILLUM;
          });
        }, 'serializable', '_skyIllumHDR');
        apply(() => {
          formerlySerializedAs('_groundAlbedo')(AmbientInfo.prototype, '_groundAlbedoHDR', () => {
            return new Vec4(0.2, 0.2, 0.2, 1.0);
          });
        }, 'formerlySerializedAs', '_groundAlbedoHDR');
        apply(() => {
          serializable$3(AmbientInfo.prototype, '_groundAlbedoHDR', () => {
            return new Vec4(0.2, 0.2, 0.2, 1.0);
          });
        }, 'serializable', '_groundAlbedoHDR');
        apply(() => {
          serializable$3(AmbientInfo.prototype, '_skyColorLDR', () => {
            return new Vec4(0.2, 0.5, 0.8, 1.0);
          });
        }, 'serializable', '_skyColorLDR');
        apply(() => {
          serializable$3(AmbientInfo.prototype, '_skyIllumLDR', () => {
            return Ambient.SKY_ILLUM;
          });
        }, 'serializable', '_skyIllumLDR');
        apply(() => {
          serializable$3(AmbientInfo.prototype, '_groundAlbedoLDR', () => {
            return new Vec4(0.2, 0.2, 0.2, 1.0);
          });
        }, 'serializable', '_groundAlbedoLDR');
        apply(() => {
          ccclass$3('cc.AmbientInfo')(AmbientInfo);
        }, 'ccclass', null);
      }
      function patch_cc_Asset(ctx, apply = defaultExec) {
        const {
          Asset
        } = {
          ...ctx
        };
        const _nativeAssetDescriptor = Object.getOwnPropertyDescriptor(Asset.prototype, '_nativeAsset');
        apply(() => {
          serializable$3(Asset.prototype, '_native', () => {
            return '';
          });
        }, 'serializable', '_native');
        apply(() => {
          property(Asset.prototype, '_nativeAsset', _nativeAssetDescriptor);
        }, 'property', '_nativeAsset');
        apply(() => {
          ccclass$3('cc.Asset')(Asset);
        }, 'ccclass', null);
      }
      function patch_cc_BufferAsset(ctx, apply = defaultExec) {
        const {
          BufferAsset
        } = {
          ...ctx
        };
        const _nativeAssetDescriptor = Object.getOwnPropertyDescriptor(BufferAsset.prototype, '_nativeAsset');
        apply(() => {
          override(BufferAsset.prototype, '_nativeAsset', _nativeAssetDescriptor);
        }, 'override', '_nativeAsset');
        apply(() => {
          ccclass$3('cc.BufferAsset')(BufferAsset);
        }, 'ccclass', null);
      }
      function patch_cc_EffectAsset(ctx, apply = defaultExec) {
        const {
          EffectAsset
        } = {
          ...ctx
        };
        apply(() => {
          editable$1(EffectAsset.prototype);
        }, 'editable', 'techniques');
        apply(() => {
          serializable$3(EffectAsset.prototype, 'techniques', () => {
            return [];
          });
        }, 'serializable', 'techniques');
        apply(() => {
          editable$1(EffectAsset.prototype);
        }, 'editable', 'shaders');
        apply(() => {
          serializable$3(EffectAsset.prototype, 'shaders', () => {
            return [];
          });
        }, 'serializable', 'shaders');
        apply(() => {
          editable$1(EffectAsset.prototype);
        }, 'editable', 'combinations');
        apply(() => {
          serializable$3(EffectAsset.prototype, 'combinations', () => {
            return [];
          });
        }, 'serializable', 'combinations');
        apply(() => {
          editorOnly(EffectAsset.prototype, 'hideInEditor', () => {
            return false;
          });
        }, 'editorOnly', 'hideInEditor');
        apply(() => {
          serializable$3(EffectAsset.prototype, 'hideInEditor', () => {
            return false;
          });
        }, 'serializable', 'hideInEditor');
        apply(() => {
          ccclass$3('cc.EffectAsset')(EffectAsset);
        }, 'ccclass', null);
      }
      function patch_cc_FogInfo(ctx, apply = defaultExec) {
        const {
          FogInfo,
          FogType,
          CCFloat,
          Color
        } = {
          ...ctx
        };
        const enabledDescriptor = Object.getOwnPropertyDescriptor(FogInfo.prototype, 'enabled');
        const accurateDescriptor = Object.getOwnPropertyDescriptor(FogInfo.prototype, 'accurate');
        const fogColorDescriptor = Object.getOwnPropertyDescriptor(FogInfo.prototype, 'fogColor');
        const typeDescriptor = Object.getOwnPropertyDescriptor(FogInfo.prototype, 'type');
        const fogDensityDescriptor = Object.getOwnPropertyDescriptor(FogInfo.prototype, 'fogDensity');
        const fogStartDescriptor = Object.getOwnPropertyDescriptor(FogInfo.prototype, 'fogStart');
        const fogEndDescriptor = Object.getOwnPropertyDescriptor(FogInfo.prototype, 'fogEnd');
        const fogAttenDescriptor = Object.getOwnPropertyDescriptor(FogInfo.prototype, 'fogAtten');
        const fogTopDescriptor = Object.getOwnPropertyDescriptor(FogInfo.prototype, 'fogTop');
        const fogRangeDescriptor = Object.getOwnPropertyDescriptor(FogInfo.prototype, 'fogRange');
        apply(() => {
          displayOrder$1()(FogInfo.prototype, 'enabled', enabledDescriptor);
        }, 'displayOrder', 'enabled');
        apply(() => {
          tooltip()(FogInfo.prototype, 'enabled', enabledDescriptor);
        }, 'tooltip', 'enabled');
        apply(() => {
          editable$1(FogInfo.prototype);
        }, 'editable', 'enabled');
        apply(() => {
          displayOrder$1()(FogInfo.prototype, 'accurate', accurateDescriptor);
        }, 'displayOrder', 'accurate');
        apply(() => {
          tooltip()(FogInfo.prototype, 'accurate', accurateDescriptor);
        }, 'tooltip', 'accurate');
        apply(() => {
          editable$1(FogInfo.prototype);
        }, 'editable', 'accurate');
        apply(() => {
          tooltip()(FogInfo.prototype, 'fogColor', fogColorDescriptor);
        }, 'tooltip', 'fogColor');
        apply(() => {
          editable$1(FogInfo.prototype);
        }, 'editable', 'fogColor');
        apply(() => {
          tooltip()(FogInfo.prototype, 'type', typeDescriptor);
        }, 'tooltip', 'type');
        apply(() => {
          displayOrder$1()(FogInfo.prototype, 'type', typeDescriptor);
        }, 'displayOrder', 'type');
        apply(() => {
          type$2(FogType)(FogInfo.prototype, 'type', typeDescriptor);
        }, 'type', 'type');
        apply(() => {
          editable$1(FogInfo.prototype);
        }, 'editable', 'type');
        apply(() => {
          tooltip()(FogInfo.prototype, 'fogDensity', fogDensityDescriptor);
        }, 'tooltip', 'fogDensity');
        apply(() => {
          slide(FogInfo.prototype);
        }, 'slide', 'fogDensity');
        apply(() => {
          range()(FogInfo.prototype, 'fogDensity', fogDensityDescriptor);
        }, 'range', 'fogDensity');
        apply(() => {
          type$2(CCFloat)(FogInfo.prototype, 'fogDensity', fogDensityDescriptor);
        }, 'type', 'fogDensity');
        apply(() => {
          visible$1()(FogInfo.prototype, 'fogDensity', fogDensityDescriptor);
        }, 'visible', 'fogDensity');
        apply(() => {
          tooltip()(FogInfo.prototype, 'fogStart', fogStartDescriptor);
        }, 'tooltip', 'fogStart');
        apply(() => {
          rangeStep()(FogInfo.prototype, 'fogStart', fogStartDescriptor);
        }, 'rangeStep', 'fogStart');
        apply(() => {
          type$2(CCFloat)(FogInfo.prototype, 'fogStart', fogStartDescriptor);
        }, 'type', 'fogStart');
        apply(() => {
          visible$1()(FogInfo.prototype, 'fogStart', fogStartDescriptor);
        }, 'visible', 'fogStart');
        apply(() => {
          tooltip()(FogInfo.prototype, 'fogEnd', fogEndDescriptor);
        }, 'tooltip', 'fogEnd');
        apply(() => {
          rangeStep()(FogInfo.prototype, 'fogEnd', fogEndDescriptor);
        }, 'rangeStep', 'fogEnd');
        apply(() => {
          type$2(CCFloat)(FogInfo.prototype, 'fogEnd', fogEndDescriptor);
        }, 'type', 'fogEnd');
        apply(() => {
          visible$1()(FogInfo.prototype, 'fogEnd', fogEndDescriptor);
        }, 'visible', 'fogEnd');
        apply(() => {
          tooltip()(FogInfo.prototype, 'fogAtten', fogAttenDescriptor);
        }, 'tooltip', 'fogAtten');
        apply(() => {
          rangeStep()(FogInfo.prototype, 'fogAtten', fogAttenDescriptor);
        }, 'rangeStep', 'fogAtten');
        apply(() => {
          rangeMin()(FogInfo.prototype, 'fogAtten', fogAttenDescriptor);
        }, 'rangeMin', 'fogAtten');
        apply(() => {
          type$2(CCFloat)(FogInfo.prototype, 'fogAtten', fogAttenDescriptor);
        }, 'type', 'fogAtten');
        apply(() => {
          visible$1()(FogInfo.prototype, 'fogAtten', fogAttenDescriptor);
        }, 'visible', 'fogAtten');
        apply(() => {
          tooltip()(FogInfo.prototype, 'fogTop', fogTopDescriptor);
        }, 'tooltip', 'fogTop');
        apply(() => {
          rangeStep()(FogInfo.prototype, 'fogTop', fogTopDescriptor);
        }, 'rangeStep', 'fogTop');
        apply(() => {
          type$2(CCFloat)(FogInfo.prototype, 'fogTop', fogTopDescriptor);
        }, 'type', 'fogTop');
        apply(() => {
          visible$1()(FogInfo.prototype, 'fogTop', fogTopDescriptor);
        }, 'visible', 'fogTop');
        apply(() => {
          tooltip()(FogInfo.prototype, 'fogRange', fogRangeDescriptor);
        }, 'tooltip', 'fogRange');
        apply(() => {
          rangeStep()(FogInfo.prototype, 'fogRange', fogRangeDescriptor);
        }, 'rangeStep', 'fogRange');
        apply(() => {
          type$2(CCFloat)(FogInfo.prototype, 'fogRange', fogRangeDescriptor);
        }, 'type', 'fogRange');
        apply(() => {
          visible$1()(FogInfo.prototype, 'fogRange', fogRangeDescriptor);
        }, 'visible', 'fogRange');
        apply(() => {
          serializable$3(FogInfo.prototype, '_type', () => {
            return FogType.LINEAR;
          });
        }, 'serializable', '_type');
        apply(() => {
          serializable$3(FogInfo.prototype, '_fogColor', () => {
            return new Color('#C8C8C8');
          });
        }, 'serializable', '_fogColor');
        apply(() => {
          serializable$3(FogInfo.prototype, '_enabled', () => {
            return false;
          });
        }, 'serializable', '_enabled');
        apply(() => {
          serializable$3(FogInfo.prototype, '_fogDensity', () => {
            return 0.3;
          });
        }, 'serializable', '_fogDensity');
        apply(() => {
          serializable$3(FogInfo.prototype, '_fogStart', () => {
            return 0.5;
          });
        }, 'serializable', '_fogStart');
        apply(() => {
          serializable$3(FogInfo.prototype, '_fogEnd', () => {
            return 300;
          });
        }, 'serializable', '_fogEnd');
        apply(() => {
          serializable$3(FogInfo.prototype, '_fogAtten', () => {
            return 5;
          });
        }, 'serializable', '_fogAtten');
        apply(() => {
          serializable$3(FogInfo.prototype, '_fogTop', () => {
            return 1.5;
          });
        }, 'serializable', '_fogTop');
        apply(() => {
          serializable$3(FogInfo.prototype, '_fogRange', () => {
            return 1.2;
          });
        }, 'serializable', '_fogRange');
        apply(() => {
          serializable$3(FogInfo.prototype, '_accurate', () => {
            return false;
          });
        }, 'serializable', '_accurate');
        apply(() => {
          ccclass$3('cc.FogInfo')(FogInfo);
        }, 'ccclass', null);
      }
      function patch_cc_ImageAsset(ctx, apply = defaultExec) {
        const {
          ImageAsset
        } = {
          ...ctx
        };
        const _nativeAssetDescriptor = Object.getOwnPropertyDescriptor(ImageAsset.prototype, '_nativeAsset');
        apply(() => {
          override(ImageAsset.prototype, '_nativeAsset', _nativeAssetDescriptor);
        }, 'override', '_nativeAsset');
        apply(() => {
          ccclass$3('cc.ImageAsset')(ImageAsset);
        }, 'ccclass', null);
      }
      function patch_cc_LightProbeInfo(ctx, apply = defaultExec) {
        const {
          LightProbeInfo,
          CCFloat,
          CCInteger
        } = {
          ...ctx
        };
        const giScaleDescriptor = Object.getOwnPropertyDescriptor(LightProbeInfo.prototype, 'giScale');
        const giSamplesDescriptor = Object.getOwnPropertyDescriptor(LightProbeInfo.prototype, 'giSamples');
        const bouncesDescriptor = Object.getOwnPropertyDescriptor(LightProbeInfo.prototype, 'bounces');
        const reduceRingingDescriptor = Object.getOwnPropertyDescriptor(LightProbeInfo.prototype, 'reduceRinging');
        const showWireframeDescriptor = Object.getOwnPropertyDescriptor(LightProbeInfo.prototype, 'showWireframe');
        const showConvexDescriptor = Object.getOwnPropertyDescriptor(LightProbeInfo.prototype, 'showConvex');
        const lightProbeSphereVolumeDescriptor = Object.getOwnPropertyDescriptor(LightProbeInfo.prototype, 'lightProbeSphereVolume');
        apply(() => {
          displayName$1()(LightProbeInfo.prototype, 'giScale', giScaleDescriptor);
        }, 'displayName', 'giScale');
        apply(() => {
          tooltip()(LightProbeInfo.prototype, 'giScale', giScaleDescriptor);
        }, 'tooltip', 'giScale');
        apply(() => {
          type$2(CCFloat)(LightProbeInfo.prototype, 'giScale', giScaleDescriptor);
        }, 'type', 'giScale');
        apply(() => {
          range()(LightProbeInfo.prototype, 'giScale', giScaleDescriptor);
        }, 'range', 'giScale');
        apply(() => {
          editable$1(LightProbeInfo.prototype);
        }, 'editable', 'giScale');
        apply(() => {
          displayName$1()(LightProbeInfo.prototype, 'giSamples', giSamplesDescriptor);
        }, 'displayName', 'giSamples');
        apply(() => {
          tooltip()(LightProbeInfo.prototype, 'giSamples', giSamplesDescriptor);
        }, 'tooltip', 'giSamples');
        apply(() => {
          type$2(CCInteger)(LightProbeInfo.prototype, 'giSamples', giSamplesDescriptor);
        }, 'type', 'giSamples');
        apply(() => {
          range()(LightProbeInfo.prototype, 'giSamples', giSamplesDescriptor);
        }, 'range', 'giSamples');
        apply(() => {
          editable$1(LightProbeInfo.prototype);
        }, 'editable', 'giSamples');
        apply(() => {
          tooltip()(LightProbeInfo.prototype, 'bounces', bouncesDescriptor);
        }, 'tooltip', 'bounces');
        apply(() => {
          type$2(CCInteger)(LightProbeInfo.prototype, 'bounces', bouncesDescriptor);
        }, 'type', 'bounces');
        apply(() => {
          range()(LightProbeInfo.prototype, 'bounces', bouncesDescriptor);
        }, 'range', 'bounces');
        apply(() => {
          editable$1(LightProbeInfo.prototype);
        }, 'editable', 'bounces');
        apply(() => {
          tooltip()(LightProbeInfo.prototype, 'reduceRinging', reduceRingingDescriptor);
        }, 'tooltip', 'reduceRinging');
        apply(() => {
          type$2(CCFloat)(LightProbeInfo.prototype, 'reduceRinging', reduceRingingDescriptor);
        }, 'type', 'reduceRinging');
        apply(() => {
          slide(LightProbeInfo.prototype);
        }, 'slide', 'reduceRinging');
        apply(() => {
          range()(LightProbeInfo.prototype, 'reduceRinging', reduceRingingDescriptor);
        }, 'range', 'reduceRinging');
        apply(() => {
          editable$1(LightProbeInfo.prototype);
        }, 'editable', 'reduceRinging');
        apply(() => {
          tooltip()(LightProbeInfo.prototype, 'showWireframe', showWireframeDescriptor);
        }, 'tooltip', 'showWireframe');
        apply(() => {
          editable$1(LightProbeInfo.prototype);
        }, 'editable', 'showWireframe');
        apply(() => {
          tooltip()(LightProbeInfo.prototype, 'showConvex', showConvexDescriptor);
        }, 'tooltip', 'showConvex');
        apply(() => {
          editable$1(LightProbeInfo.prototype);
        }, 'editable', 'showConvex');
        apply(() => {
          tooltip()(LightProbeInfo.prototype, 'lightProbeSphereVolume', lightProbeSphereVolumeDescriptor);
        }, 'tooltip', 'lightProbeSphereVolume');
        apply(() => {
          type$2(CCFloat)(LightProbeInfo.prototype, 'lightProbeSphereVolume', lightProbeSphereVolumeDescriptor);
        }, 'type', 'lightProbeSphereVolume');
        apply(() => {
          range()(LightProbeInfo.prototype, 'lightProbeSphereVolume', lightProbeSphereVolumeDescriptor);
        }, 'range', 'lightProbeSphereVolume');
        apply(() => {
          editable$1(LightProbeInfo.prototype);
        }, 'editable', 'lightProbeSphereVolume');
        apply(() => {
          serializable$3(LightProbeInfo.prototype, '_giScale', () => {
            return 1.0;
          });
        }, 'serializable', '_giScale');
        apply(() => {
          serializable$3(LightProbeInfo.prototype, '_giSamples', () => {
            return 1024;
          });
        }, 'serializable', '_giSamples');
        apply(() => {
          serializable$3(LightProbeInfo.prototype, '_bounces', () => {
            return 2;
          });
        }, 'serializable', '_bounces');
        apply(() => {
          serializable$3(LightProbeInfo.prototype, '_reduceRinging', () => {
            return 0.0;
          });
        }, 'serializable', '_reduceRinging');
        apply(() => {
          serializable$3(LightProbeInfo.prototype, '_showProbe', () => {
            return true;
          });
        }, 'serializable', '_showProbe');
        apply(() => {
          serializable$3(LightProbeInfo.prototype, '_showWireframe', () => {
            return true;
          });
        }, 'serializable', '_showWireframe');
        apply(() => {
          serializable$3(LightProbeInfo.prototype, '_showConvex', () => {
            return false;
          });
        }, 'serializable', '_showConvex');
        apply(() => {
          serializable$3(LightProbeInfo.prototype, '_data', () => {
            return null;
          });
        }, 'serializable', '_data');
        apply(() => {
          serializable$3(LightProbeInfo.prototype, '_lightProbeSphereVolume', () => {
            return 1.0;
          });
        }, 'serializable', '_lightProbeSphereVolume');
        apply(() => {
          ccclass$3('cc.LightProbeInfo')(LightProbeInfo);
        }, 'ccclass', null);
      }
      function patch_cc_Material(ctx, apply = defaultExec) {
        const {
          Material,
          EffectAsset
        } = {
          ...ctx
        };
        apply(() => {
          type$2(EffectAsset)(Material.prototype, '_effectAsset', () => {
            return null;
          });
        }, 'type', '_effectAsset');
        apply(() => {
          serializable$3(Material.prototype, '_techIdx', () => {
            return 0;
          });
        }, 'serializable', '_techIdx');
        apply(() => {
          serializable$3(Material.prototype, '_defines', () => {
            return [];
          });
        }, 'serializable', '_defines');
        apply(() => {
          serializable$3(Material.prototype, '_states', () => {
            return [];
          });
        }, 'serializable', '_states');
        apply(() => {
          serializable$3(Material.prototype, '_props', () => {
            return [];
          });
        }, 'serializable', '_props');
        apply(() => {
          ccclass$3('cc.Material')(Material);
        }, 'ccclass', null);
      }
      function patch_cc_Node(ctx, apply = defaultExec) {
        const {
          Node,
          Vec3,
          Quat,
          MobilityMode,
          Layers
        } = {
          ...ctx
        };
        const _persistNodeDescriptor = Object.getOwnPropertyDescriptor(Node.prototype, '_persistNode');
        Object.getOwnPropertyDescriptor(Node.prototype, 'name');
        Object.getOwnPropertyDescriptor(Node.prototype, 'children');
        Object.getOwnPropertyDescriptor(Node.prototype, 'active');
        Object.getOwnPropertyDescriptor(Node.prototype, 'activeInHierarchy');
        Object.getOwnPropertyDescriptor(Node.prototype, 'parent');
        const eulerAnglesDescriptor = Object.getOwnPropertyDescriptor(Node.prototype, 'eulerAngles');
        Object.getOwnPropertyDescriptor(Node.prototype, 'angle');
        const mobilityDescriptor = Object.getOwnPropertyDescriptor(Node.prototype, 'mobility');
        Object.getOwnPropertyDescriptor(Node.prototype, 'layer');
        apply(() => {
          property(Node.prototype, '_persistNode', _persistNodeDescriptor);
        }, 'property', '_persistNode');
        apply(() => {
          editable$1(Node.prototype);
        }, 'editable', 'name');
        apply(() => {
          editable$1(Node.prototype);
        }, 'editable', 'children');
        apply(() => {
          editable$1(Node.prototype);
        }, 'editable', 'active');
        apply(() => {
          editable$1(Node.prototype);
        }, 'editable', 'activeInHierarchy');
        apply(() => {
          editable$1(Node.prototype);
        }, 'editable', 'parent');
        apply(() => {
          serializable$3(Node.prototype, '_parent', () => {
            return null;
          });
        }, 'serializable', '_parent');
        apply(() => {
          serializable$3(Node.prototype, '_children', () => {
            return [];
          });
        }, 'serializable', '_children');
        apply(() => {
          serializable$3(Node.prototype, '_active', () => {
            return true;
          });
        }, 'serializable', '_active');
        apply(() => {
          serializable$3(Node.prototype, '_components', () => {
            return [];
          });
        }, 'serializable', '_components');
        apply(() => {
          serializable$3(Node.prototype, '_prefab', () => {
            return null;
          });
        }, 'serializable', '_prefab');
        apply(() => {
          serializable$3(Node.prototype, '_lpos', () => {
            return new Vec3();
          });
        }, 'serializable', '_lpos');
        apply(() => {
          serializable$3(Node.prototype, '_lrot', () => {
            return new Quat();
          });
        }, 'serializable', '_lrot');
        apply(() => {
          serializable$3(Node.prototype, '_lscale', () => {
            return new Vec3(1, 1, 1);
          });
        }, 'serializable', '_lscale');
        apply(() => {
          serializable$3(Node.prototype, '_mobility', () => {
            return MobilityMode.Static;
          });
        }, 'serializable', '_mobility');
        apply(() => {
          serializable$3(Node.prototype, '_layer', () => {
            return Layers.Enum.DEFAULT;
          });
        }, 'serializable', '_layer');
        apply(() => {
          serializable$3(Node.prototype, '_euler', () => {
            return new Vec3();
          });
        }, 'serializable', '_euler');
        apply(() => {
          type$2(Vec3)(Node.prototype, 'eulerAngles', eulerAnglesDescriptor);
        }, 'type', 'eulerAngles');
        apply(() => {
          editable$1(Node.prototype);
        }, 'editable', 'angle');
        apply(() => {
          type$2(MobilityMode)(Node.prototype, 'mobility', mobilityDescriptor);
        }, 'type', 'mobility');
        apply(() => {
          editable$1(Node.prototype);
        }, 'editable', 'mobility');
        apply(() => {
          editable$1(Node.prototype);
        }, 'editable', 'layer');
        apply(() => {
          ccclass$3('cc.Node')(Node);
        }, 'ccclass', null);
      }
      function patch_cc_OctreeInfo(ctx, apply = defaultExec) {
        const {
          OctreeInfo,
          CCInteger,
          Vec3,
          DEFAULT_WORLD_MIN_POS,
          DEFAULT_WORLD_MAX_POS,
          DEFAULT_OCTREE_DEPTH
        } = {
          ...ctx
        };
        const enabledDescriptor = Object.getOwnPropertyDescriptor(OctreeInfo.prototype, 'enabled');
        const minPosDescriptor = Object.getOwnPropertyDescriptor(OctreeInfo.prototype, 'minPos');
        const maxPosDescriptor = Object.getOwnPropertyDescriptor(OctreeInfo.prototype, 'maxPos');
        const depthDescriptor = Object.getOwnPropertyDescriptor(OctreeInfo.prototype, 'depth');
        apply(() => {
          tooltip()(OctreeInfo.prototype, 'enabled', enabledDescriptor);
        }, 'tooltip', 'enabled');
        apply(() => {
          editable$1(OctreeInfo.prototype);
        }, 'editable', 'enabled');
        apply(() => {
          displayName$1()(OctreeInfo.prototype, 'minPos', minPosDescriptor);
        }, 'displayName', 'minPos');
        apply(() => {
          tooltip()(OctreeInfo.prototype, 'minPos', minPosDescriptor);
        }, 'tooltip', 'minPos');
        apply(() => {
          editable$1(OctreeInfo.prototype);
        }, 'editable', 'minPos');
        apply(() => {
          displayName$1()(OctreeInfo.prototype, 'maxPos', maxPosDescriptor);
        }, 'displayName', 'maxPos');
        apply(() => {
          tooltip()(OctreeInfo.prototype, 'maxPos', maxPosDescriptor);
        }, 'tooltip', 'maxPos');
        apply(() => {
          editable$1(OctreeInfo.prototype);
        }, 'editable', 'maxPos');
        apply(() => {
          tooltip()(OctreeInfo.prototype, 'depth', depthDescriptor);
        }, 'tooltip', 'depth');
        apply(() => {
          type$2(CCInteger)(OctreeInfo.prototype, 'depth', depthDescriptor);
        }, 'type', 'depth');
        apply(() => {
          slide(OctreeInfo.prototype);
        }, 'slide', 'depth');
        apply(() => {
          range()(OctreeInfo.prototype, 'depth', depthDescriptor);
        }, 'range', 'depth');
        apply(() => {
          editable$1(OctreeInfo.prototype);
        }, 'editable', 'depth');
        apply(() => {
          serializable$3(OctreeInfo.prototype, '_enabled', () => {
            return false;
          });
        }, 'serializable', '_enabled');
        apply(() => {
          serializable$3(OctreeInfo.prototype, '_minPos', () => {
            return new Vec3(DEFAULT_WORLD_MIN_POS);
          });
        }, 'serializable', '_minPos');
        apply(() => {
          serializable$3(OctreeInfo.prototype, '_maxPos', () => {
            return new Vec3(DEFAULT_WORLD_MAX_POS);
          });
        }, 'serializable', '_maxPos');
        apply(() => {
          serializable$3(OctreeInfo.prototype, '_depth', () => {
            return DEFAULT_OCTREE_DEPTH;
          });
        }, 'serializable', '_depth');
        apply(() => {
          ccclass$3('cc.OctreeInfo')(OctreeInfo);
        }, 'ccclass', null);
      }
      function patch_cc_PostSettingsInfo(ctx, apply = defaultExec) {
        const {
          PostSettingsInfo,
          ToneMappingType
        } = {
          ...ctx
        };
        const toneMappingTypeDescriptor = Object.getOwnPropertyDescriptor(PostSettingsInfo.prototype, 'toneMappingType');
        apply(() => {
          tooltip()(PostSettingsInfo.prototype, 'toneMappingType', toneMappingTypeDescriptor);
        }, 'tooltip', 'toneMappingType');
        apply(() => {
          type$2(ToneMappingType)(PostSettingsInfo.prototype, 'toneMappingType', toneMappingTypeDescriptor);
        }, 'type', 'toneMappingType');
        apply(() => {
          editable$1(PostSettingsInfo.prototype);
        }, 'editable', 'toneMappingType');
        apply(() => {
          serializable$3(PostSettingsInfo.prototype, '_toneMappingType', () => {
            return ToneMappingType.DEFAULT;
          });
        }, 'serializable', '_toneMappingType');
        apply(() => {
          ccclass$3('cc.PostSettingsInfo')(PostSettingsInfo);
        }, 'ccclass', null);
      }
      function patch_cc_RenderPipeline(ctx, apply = defaultExec) {
        const {
          RenderPipeline,
          RenderFlow
        } = {
          ...ctx
        };
        apply(() => {
          serializable$3(RenderPipeline.prototype, '_tag', () => {
            return 0;
          });
        }, 'serializable', '_tag');
        apply(() => {
          displayOrder$1()(RenderPipeline.prototype, '_tag', () => {
            return 0;
          });
        }, 'displayOrder', '_tag');
        apply(() => {
          serializable$3(RenderPipeline.prototype, '_flows', () => {
            return [];
          });
        }, 'serializable', '_flows');
        apply(() => {
          type$2([RenderFlow])(RenderPipeline.prototype, '_flows', () => {
            return [];
          });
        }, 'type', '_flows');
        apply(() => {
          displayOrder$1()(RenderPipeline.prototype, '_flows', () => {
            return [];
          });
        }, 'displayOrder', '_flows');
        apply(() => {
          ccclass$3('cc.RenderPipeline')(RenderPipeline);
        }, 'ccclass', null);
      }
      function patch_cc_RenderTexture(ctx, apply = defaultExec) {
        const {
          RenderTexture
        } = {
          ...ctx
        };
        apply(() => {
          ccclass$3('cc.RenderTexture')(RenderTexture);
        }, 'ccclass', null);
      }
      function patch_cc_Scene(ctx, apply = defaultExec) {
        const {
          Scene,
          SceneGlobals
        } = {
          ...ctx
        };
        Object.getOwnPropertyDescriptor(Scene.prototype, 'globals');
        apply(() => {
          editable$1(Scene.prototype);
        }, 'editable', 'globals');
        apply(() => {
          editable$1(Scene.prototype);
        }, 'editable', 'autoReleaseAssets');
        apply(() => {
          serializable$3(Scene.prototype, 'autoReleaseAssets', () => {
            return false;
          });
        }, 'serializable', 'autoReleaseAssets');
        apply(() => {
          serializable$3(Scene.prototype, '_globals', () => {
            return new SceneGlobals();
          });
        }, 'serializable', '_globals');
        apply(() => {
          ccclass$3('cc.Scene')(Scene);
        }, 'ccclass', null);
      }
      function patch_cc_SceneAsset(ctx, apply = defaultExec) {
        const {
          SceneAsset
        } = {
          ...ctx
        };
        apply(() => {
          serializable$3(SceneAsset.prototype, 'scene', () => {
            return null;
          });
        }, 'serializable', 'scene');
        apply(() => {
          editable$1(SceneAsset.prototype);
        }, 'editable', 'scene');
        apply(() => {
          ccclass$3('cc.SceneAsset')(SceneAsset);
        }, 'ccclass', null);
      }
      function patch_cc_SceneGlobals(ctx, apply = defaultExec) {
        const {
          SceneGlobals,
          AmbientInfo,
          ShadowsInfo,
          SkyboxInfo,
          FogInfo,
          OctreeInfo,
          SkinInfo,
          LightProbeInfo,
          PostSettingsInfo
        } = {
          ...ctx
        };
        const skyboxDescriptor = Object.getOwnPropertyDescriptor(SceneGlobals.prototype, 'skybox');
        apply(() => {
          editable$1(SceneGlobals.prototype);
        }, 'editable', 'ambient');
        apply(() => {
          serializable$3(SceneGlobals.prototype, 'ambient', () => {
            return new AmbientInfo();
          });
        }, 'serializable', 'ambient');
        apply(() => {
          editable$1(SceneGlobals.prototype);
        }, 'editable', 'shadows');
        apply(() => {
          serializable$3(SceneGlobals.prototype, 'shadows', () => {
            return new ShadowsInfo();
          });
        }, 'serializable', 'shadows');
        apply(() => {
          serializable$3(SceneGlobals.prototype, '_skybox', () => {
            return new SkyboxInfo();
          });
        }, 'serializable', '_skybox');
        apply(() => {
          serializable$3(SceneGlobals.prototype, 'fog', () => {
            return new FogInfo();
          });
        }, 'serializable', 'fog');
        apply(() => {
          editable$1(SceneGlobals.prototype);
        }, 'editable', 'fog');
        apply(() => {
          type$2(SkyboxInfo)(SceneGlobals.prototype, 'skybox', skyboxDescriptor);
        }, 'type', 'skybox');
        apply(() => {
          editable$1(SceneGlobals.prototype);
        }, 'editable', 'skybox');
        apply(() => {
          serializable$3(SceneGlobals.prototype, 'octree', () => {
            return new OctreeInfo();
          });
        }, 'serializable', 'octree');
        apply(() => {
          editable$1(SceneGlobals.prototype);
        }, 'editable', 'octree');
        apply(() => {
          serializable$3(SceneGlobals.prototype, 'skin', () => {
            return new SkinInfo();
          });
        }, 'serializable', 'skin');
        apply(() => {
          editable$1(SceneGlobals.prototype);
        }, 'editable', 'skin');
        apply(() => {
          serializable$3(SceneGlobals.prototype, 'lightProbeInfo', () => {
            return new LightProbeInfo();
          });
        }, 'serializable', 'lightProbeInfo');
        apply(() => {
          editable$1(SceneGlobals.prototype);
        }, 'editable', 'lightProbeInfo');
        apply(() => {
          serializable$3(SceneGlobals.prototype, 'postSettings', () => {
            return new PostSettingsInfo();
          });
        }, 'serializable', 'postSettings');
        apply(() => {
          editable$1(SceneGlobals.prototype);
        }, 'editable', 'postSettings');
        apply(() => {
          serializable$3(SceneGlobals.prototype, 'bakedWithStationaryMainLight', () => {
            return false;
          });
        }, 'serializable', 'bakedWithStationaryMainLight');
        apply(() => {
          editable$1(SceneGlobals.prototype);
        }, 'editable', 'bakedWithStationaryMainLight');
        apply(() => {
          serializable$3(SceneGlobals.prototype, 'bakedWithHighpLightmap', () => {
            return false;
          });
        }, 'serializable', 'bakedWithHighpLightmap');
        apply(() => {
          editable$1(SceneGlobals.prototype);
        }, 'editable', 'bakedWithHighpLightmap');
        apply(() => {
          ccclass$3('cc.SceneGlobals')(SceneGlobals);
        }, 'ccclass', null);
      }
      function patch_cc_ShadowsInfo(ctx, apply = defaultExec) {
        const {
          ShadowsInfo,
          ShadowType,
          CCFloat,
          CCInteger,
          ShadowSize,
          Vec3,
          Color,
          Vec2
        } = {
          ...ctx
        };
        const enabledDescriptor = Object.getOwnPropertyDescriptor(ShadowsInfo.prototype, 'enabled');
        const typeDescriptor = Object.getOwnPropertyDescriptor(ShadowsInfo.prototype, 'type');
        const shadowColorDescriptor = Object.getOwnPropertyDescriptor(ShadowsInfo.prototype, 'shadowColor');
        const planeDirectionDescriptor = Object.getOwnPropertyDescriptor(ShadowsInfo.prototype, 'planeDirection');
        const planeHeightDescriptor = Object.getOwnPropertyDescriptor(ShadowsInfo.prototype, 'planeHeight');
        const maxReceivedDescriptor = Object.getOwnPropertyDescriptor(ShadowsInfo.prototype, 'maxReceived');
        const shadowMapSizeDescriptor = Object.getOwnPropertyDescriptor(ShadowsInfo.prototype, 'shadowMapSize');
        apply(() => {
          tooltip()(ShadowsInfo.prototype, 'enabled', enabledDescriptor);
        }, 'tooltip', 'enabled');
        apply(() => {
          editable$1(ShadowsInfo.prototype);
        }, 'editable', 'enabled');
        apply(() => {
          type$2(ShadowType)(ShadowsInfo.prototype, 'type', typeDescriptor);
        }, 'type', 'type');
        apply(() => {
          editable$1(ShadowsInfo.prototype);
        }, 'editable', 'type');
        apply(() => {
          tooltip()(ShadowsInfo.prototype, 'type', typeDescriptor);
        }, 'tooltip', 'type');
        apply(() => {
          visible$1()(ShadowsInfo.prototype, 'shadowColor', shadowColorDescriptor);
        }, 'visible', 'shadowColor');
        apply(() => {
          tooltip()(ShadowsInfo.prototype, 'shadowColor', shadowColorDescriptor);
        }, 'tooltip', 'shadowColor');
        apply(() => {
          visible$1()(ShadowsInfo.prototype, 'planeDirection', planeDirectionDescriptor);
        }, 'visible', 'planeDirection');
        apply(() => {
          tooltip()(ShadowsInfo.prototype, 'planeDirection', planeDirectionDescriptor);
        }, 'tooltip', 'planeDirection');
        apply(() => {
          visible$1()(ShadowsInfo.prototype, 'planeHeight', planeHeightDescriptor);
        }, 'visible', 'planeHeight');
        apply(() => {
          type$2(CCFloat)(ShadowsInfo.prototype, 'planeHeight', planeHeightDescriptor);
        }, 'type', 'planeHeight');
        apply(() => {
          editable$1(ShadowsInfo.prototype);
        }, 'editable', 'planeHeight');
        apply(() => {
          tooltip()(ShadowsInfo.prototype, 'planeHeight', planeHeightDescriptor);
        }, 'tooltip', 'planeHeight');
        apply(() => {
          visible$1()(ShadowsInfo.prototype, 'maxReceived', maxReceivedDescriptor);
        }, 'visible', 'maxReceived');
        apply(() => {
          type$2(CCInteger)(ShadowsInfo.prototype, 'maxReceived', maxReceivedDescriptor);
        }, 'type', 'maxReceived');
        apply(() => {
          tooltip()(ShadowsInfo.prototype, 'maxReceived', maxReceivedDescriptor);
        }, 'tooltip', 'maxReceived');
        apply(() => {
          visible$1()(ShadowsInfo.prototype, 'shadowMapSize', shadowMapSizeDescriptor);
        }, 'visible', 'shadowMapSize');
        apply(() => {
          type$2(ShadowSize)(ShadowsInfo.prototype, 'shadowMapSize', shadowMapSizeDescriptor);
        }, 'type', 'shadowMapSize');
        apply(() => {
          tooltip()(ShadowsInfo.prototype, 'shadowMapSize', shadowMapSizeDescriptor);
        }, 'tooltip', 'shadowMapSize');
        apply(() => {
          serializable$3(ShadowsInfo.prototype, '_enabled', () => {
            return false;
          });
        }, 'serializable', '_enabled');
        apply(() => {
          serializable$3(ShadowsInfo.prototype, '_type', () => {
            return ShadowType.Planar;
          });
        }, 'serializable', '_type');
        apply(() => {
          serializable$3(ShadowsInfo.prototype, '_normal', () => {
            return new Vec3(0, 1, 0);
          });
        }, 'serializable', '_normal');
        apply(() => {
          serializable$3(ShadowsInfo.prototype, '_distance', () => {
            return 0;
          });
        }, 'serializable', '_distance');
        apply(() => {
          serializable$3(ShadowsInfo.prototype, '_shadowColor', () => {
            return new Color(0, 0, 0, 76);
          });
        }, 'serializable', '_shadowColor');
        apply(() => {
          serializable$3(ShadowsInfo.prototype, '_maxReceived', () => {
            return 4;
          });
        }, 'serializable', '_maxReceived');
        apply(() => {
          serializable$3(ShadowsInfo.prototype, '_size', () => {
            return new Vec2(1024, 1024);
          });
        }, 'serializable', '_size');
        apply(() => {
          ccclass$3('cc.ShadowsInfo')(ShadowsInfo);
        }, 'ccclass', null);
      }
      function patch_cc_SimpleTexture(ctx, apply = defaultExec) {
        const {
          SimpleTexture
        } = {
          ...ctx
        };
        apply(() => {
          ccclass$3('cc.SimpleTexture')(SimpleTexture);
        }, 'ccclass', null);
      }
      function patch_cc_SkinInfo(ctx, apply = defaultExec) {
        const {
          SkinInfo,
          CCFloat
        } = {
          ...ctx
        };
        const enabledDescriptor = Object.getOwnPropertyDescriptor(SkinInfo.prototype, 'enabled');
        const blurRadiusDescriptor = Object.getOwnPropertyDescriptor(SkinInfo.prototype, 'blurRadius');
        const sssIntensityDescriptor = Object.getOwnPropertyDescriptor(SkinInfo.prototype, 'sssIntensity');
        apply(() => {
          tooltip()(SkinInfo.prototype, 'enabled', enabledDescriptor);
        }, 'tooltip', 'enabled');
        apply(() => {
          readOnly(SkinInfo.prototype);
        }, 'readOnly', 'enabled');
        apply(() => {
          editable$1(SkinInfo.prototype);
        }, 'editable', 'enabled');
        apply(() => {
          tooltip()(SkinInfo.prototype, 'blurRadius', blurRadiusDescriptor);
        }, 'tooltip', 'blurRadius');
        apply(() => {
          type$2(CCFloat)(SkinInfo.prototype, 'blurRadius', blurRadiusDescriptor);
        }, 'type', 'blurRadius');
        apply(() => {
          slide(SkinInfo.prototype);
        }, 'slide', 'blurRadius');
        apply(() => {
          range()(SkinInfo.prototype, 'blurRadius', blurRadiusDescriptor);
        }, 'range', 'blurRadius');
        apply(() => {
          editable$1(SkinInfo.prototype);
        }, 'editable', 'blurRadius');
        apply(() => {
          visible$1()(SkinInfo.prototype, 'blurRadius', blurRadiusDescriptor);
        }, 'visible', 'blurRadius');
        apply(() => {
          tooltip()(SkinInfo.prototype, 'sssIntensity', sssIntensityDescriptor);
        }, 'tooltip', 'sssIntensity');
        apply(() => {
          type$2(CCFloat)(SkinInfo.prototype, 'sssIntensity', sssIntensityDescriptor);
        }, 'type', 'sssIntensity');
        apply(() => {
          slide(SkinInfo.prototype);
        }, 'slide', 'sssIntensity');
        apply(() => {
          range()(SkinInfo.prototype, 'sssIntensity', sssIntensityDescriptor);
        }, 'range', 'sssIntensity');
        apply(() => {
          editable$1(SkinInfo.prototype);
        }, 'editable', 'sssIntensity');
        apply(() => {
          serializable$3(SkinInfo.prototype, '_enabled', () => {
            return true;
          });
        }, 'serializable', '_enabled');
        apply(() => {
          serializable$3(SkinInfo.prototype, '_blurRadius', () => {
            return 0.01;
          });
        }, 'serializable', '_blurRadius');
        apply(() => {
          serializable$3(SkinInfo.prototype, '_sssIntensity', () => {
            return 3.0;
          });
        }, 'serializable', '_sssIntensity');
        apply(() => {
          ccclass$3('cc.SkinInfo')(SkinInfo);
        }, 'ccclass', null);
      }
      function patch_cc_SkyboxInfo(ctx, apply = defaultExec) {
        const {
          SkyboxInfo,
          EnvironmentLightingType,
          TextureCube,
          CCFloat,
          Material
        } = {
          ...ctx
        };
        const enabledDescriptor = Object.getOwnPropertyDescriptor(SkyboxInfo.prototype, 'enabled');
        const envLightingTypeDescriptor = Object.getOwnPropertyDescriptor(SkyboxInfo.prototype, 'envLightingType');
        const useHDRDescriptor = Object.getOwnPropertyDescriptor(SkyboxInfo.prototype, 'useHDR');
        const envmapDescriptor = Object.getOwnPropertyDescriptor(SkyboxInfo.prototype, 'envmap');
        const rotationAngleDescriptor = Object.getOwnPropertyDescriptor(SkyboxInfo.prototype, 'rotationAngle');
        const diffuseMapDescriptor = Object.getOwnPropertyDescriptor(SkyboxInfo.prototype, 'diffuseMap');
        const reflectionMapDescriptor = Object.getOwnPropertyDescriptor(SkyboxInfo.prototype, 'reflectionMap');
        const skyboxMaterialDescriptor = Object.getOwnPropertyDescriptor(SkyboxInfo.prototype, 'skyboxMaterial');
        apply(() => {
          tooltip()(SkyboxInfo.prototype, 'enabled', enabledDescriptor);
        }, 'tooltip', 'enabled');
        apply(() => {
          editable$1(SkyboxInfo.prototype);
        }, 'editable', 'enabled');
        apply(() => {
          tooltip()(SkyboxInfo.prototype, 'envLightingType', envLightingTypeDescriptor);
        }, 'tooltip', 'envLightingType');
        apply(() => {
          type$2(EnvironmentLightingType)(SkyboxInfo.prototype, 'envLightingType', envLightingTypeDescriptor);
        }, 'type', 'envLightingType');
        apply(() => {
          editable$1(SkyboxInfo.prototype);
        }, 'editable', 'envLightingType');
        apply(() => {
          tooltip()(SkyboxInfo.prototype, 'useHDR', useHDRDescriptor);
        }, 'tooltip', 'useHDR');
        apply(() => {
          editable$1(SkyboxInfo.prototype);
        }, 'editable', 'useHDR');
        apply(() => {
          tooltip()(SkyboxInfo.prototype, 'envmap', envmapDescriptor);
        }, 'tooltip', 'envmap');
        apply(() => {
          type$2(TextureCube)(SkyboxInfo.prototype, 'envmap', envmapDescriptor);
        }, 'type', 'envmap');
        apply(() => {
          editable$1(SkyboxInfo.prototype);
        }, 'editable', 'envmap');
        apply(() => {
          tooltip()(SkyboxInfo.prototype, 'rotationAngle', rotationAngleDescriptor);
        }, 'tooltip', 'rotationAngle');
        apply(() => {
          slide(SkyboxInfo.prototype);
        }, 'slide', 'rotationAngle');
        apply(() => {
          range()(SkyboxInfo.prototype, 'rotationAngle', rotationAngleDescriptor);
        }, 'range', 'rotationAngle');
        apply(() => {
          type$2(CCFloat)(SkyboxInfo.prototype, 'rotationAngle', rotationAngleDescriptor);
        }, 'type', 'rotationAngle');
        apply(() => {
          displayOrder$1()(SkyboxInfo.prototype, 'diffuseMap', diffuseMapDescriptor);
        }, 'displayOrder', 'diffuseMap');
        apply(() => {
          type$2(TextureCube)(SkyboxInfo.prototype, 'diffuseMap', diffuseMapDescriptor);
        }, 'type', 'diffuseMap');
        apply(() => {
          readOnly(SkyboxInfo.prototype);
        }, 'readOnly', 'diffuseMap');
        apply(() => {
          editable$1(SkyboxInfo.prototype);
        }, 'editable', 'diffuseMap');
        apply(() => {
          visible$1()(SkyboxInfo.prototype, 'diffuseMap', diffuseMapDescriptor);
        }, 'visible', 'diffuseMap');
        apply(() => {
          displayOrder$1()(SkyboxInfo.prototype, 'reflectionMap', reflectionMapDescriptor);
        }, 'displayOrder', 'reflectionMap');
        apply(() => {
          type$2(TextureCube)(SkyboxInfo.prototype, 'reflectionMap', reflectionMapDescriptor);
        }, 'type', 'reflectionMap');
        apply(() => {
          readOnly(SkyboxInfo.prototype);
        }, 'readOnly', 'reflectionMap');
        apply(() => {
          editable$1(SkyboxInfo.prototype);
        }, 'editable', 'reflectionMap');
        apply(() => {
          visible$1()(SkyboxInfo.prototype, 'reflectionMap', reflectionMapDescriptor);
        }, 'visible', 'reflectionMap');
        apply(() => {
          tooltip()(SkyboxInfo.prototype, 'skyboxMaterial', skyboxMaterialDescriptor);
        }, 'tooltip', 'skyboxMaterial');
        apply(() => {
          type$2(Material)(SkyboxInfo.prototype, 'skyboxMaterial', skyboxMaterialDescriptor);
        }, 'type', 'skyboxMaterial');
        apply(() => {
          editable$1(SkyboxInfo.prototype);
        }, 'editable', 'skyboxMaterial');
        apply(() => {
          serializable$3(SkyboxInfo.prototype, '_envLightingType', () => {
            return EnvironmentLightingType.HEMISPHERE_DIFFUSE;
          });
        }, 'serializable', '_envLightingType');
        apply(() => {
          formerlySerializedAs('_envmap')(SkyboxInfo.prototype, '_envmapHDR', () => {
            return null;
          });
        }, 'formerlySerializedAs', '_envmapHDR');
        apply(() => {
          type$2(TextureCube)(SkyboxInfo.prototype, '_envmapHDR', () => {
            return null;
          });
        }, 'type', '_envmapHDR');
        apply(() => {
          serializable$3(SkyboxInfo.prototype, '_envmapHDR', () => {
            return null;
          });
        }, 'serializable', '_envmapHDR');
        apply(() => {
          type$2(TextureCube)(SkyboxInfo.prototype, '_envmapLDR', () => {
            return null;
          });
        }, 'type', '_envmapLDR');
        apply(() => {
          serializable$3(SkyboxInfo.prototype, '_envmapLDR', () => {
            return null;
          });
        }, 'serializable', '_envmapLDR');
        apply(() => {
          type$2(TextureCube)(SkyboxInfo.prototype, '_diffuseMapHDR', () => {
            return null;
          });
        }, 'type', '_diffuseMapHDR');
        apply(() => {
          serializable$3(SkyboxInfo.prototype, '_diffuseMapHDR', () => {
            return null;
          });
        }, 'serializable', '_diffuseMapHDR');
        apply(() => {
          type$2(TextureCube)(SkyboxInfo.prototype, '_diffuseMapLDR', () => {
            return null;
          });
        }, 'type', '_diffuseMapLDR');
        apply(() => {
          serializable$3(SkyboxInfo.prototype, '_diffuseMapLDR', () => {
            return null;
          });
        }, 'serializable', '_diffuseMapLDR');
        apply(() => {
          serializable$3(SkyboxInfo.prototype, '_enabled', () => {
            return false;
          });
        }, 'serializable', '_enabled');
        apply(() => {
          serializable$3(SkyboxInfo.prototype, '_useHDR', () => {
            return true;
          });
        }, 'serializable', '_useHDR');
        apply(() => {
          type$2(Material)(SkyboxInfo.prototype, '_editableMaterial', () => {
            return null;
          });
        }, 'type', '_editableMaterial');
        apply(() => {
          serializable$3(SkyboxInfo.prototype, '_editableMaterial', () => {
            return null;
          });
        }, 'serializable', '_editableMaterial');
        apply(() => {
          type$2(TextureCube)(SkyboxInfo.prototype, '_reflectionHDR', () => {
            return null;
          });
        }, 'type', '_reflectionHDR');
        apply(() => {
          serializable$3(SkyboxInfo.prototype, '_reflectionHDR', () => {
            return null;
          });
        }, 'serializable', '_reflectionHDR');
        apply(() => {
          type$2(TextureCube)(SkyboxInfo.prototype, '_reflectionLDR', () => {
            return null;
          });
        }, 'type', '_reflectionLDR');
        apply(() => {
          serializable$3(SkyboxInfo.prototype, '_reflectionLDR', () => {
            return null;
          });
        }, 'serializable', '_reflectionLDR');
        apply(() => {
          serializable$3(SkyboxInfo.prototype, '_rotationAngle', () => {
            return 0;
          });
        }, 'serializable', '_rotationAngle');
        apply(() => {
          ccclass$3('cc.SkyboxInfo')(SkyboxInfo);
        }, 'ccclass', null);
      }
      function patch_cc_Texture2D(ctx, apply = defaultExec) {
        const {
          Texture2D,
          ImageAsset
        } = {
          ...ctx
        };
        apply(() => {
          type$2([ImageAsset])(Texture2D.prototype, '_mipmaps', () => {
            return [];
          });
        }, 'type', '_mipmaps');
        apply(() => {
          ccclass$3('cc.Texture2D')(Texture2D);
        }, 'ccclass', null);
      }
      function patch_cc_TextureBase(ctx, apply = defaultExec) {
        const {
          TextureBase,
          PixelFormat,
          Filter,
          WrapMode
        } = {
          ...ctx
        };
        apply(() => {
          serializable$3(TextureBase.prototype, '_format', () => {
            return PixelFormat.RGBA8888;
          });
        }, 'serializable', '_format');
        apply(() => {
          serializable$3(TextureBase.prototype, '_minFilter', () => {
            return Filter.LINEAR;
          });
        }, 'serializable', '_minFilter');
        apply(() => {
          serializable$3(TextureBase.prototype, '_magFilter', () => {
            return Filter.LINEAR;
          });
        }, 'serializable', '_magFilter');
        apply(() => {
          serializable$3(TextureBase.prototype, '_mipFilter', () => {
            return Filter.NONE;
          });
        }, 'serializable', '_mipFilter');
        apply(() => {
          serializable$3(TextureBase.prototype, '_wrapS', () => {
            return WrapMode.REPEAT;
          });
        }, 'serializable', '_wrapS');
        apply(() => {
          serializable$3(TextureBase.prototype, '_wrapT', () => {
            return WrapMode.REPEAT;
          });
        }, 'serializable', '_wrapT');
        apply(() => {
          serializable$3(TextureBase.prototype, '_wrapR', () => {
            return WrapMode.REPEAT;
          });
        }, 'serializable', '_wrapR');
        apply(() => {
          serializable$3(TextureBase.prototype, '_anisotropy', () => {
            return 0;
          });
        }, 'serializable', '_anisotropy');
        apply(() => {
          ccclass$3('cc.TextureBase')(TextureBase);
        }, 'ccclass', null);
      }
      function patch_cc_TextureCube(ctx, apply = defaultExec) {
        const {
          TextureCube,
          MipmapMode
        } = {
          ...ctx
        };
        apply(() => {
          serializable$3(TextureCube.prototype, 'isRGBE', () => {
            return false;
          });
        }, 'serializable', 'isRGBE');
        apply(() => {
          serializable$3(TextureCube.prototype, '_mipmapAtlas', () => {
            return null;
          });
        }, 'serializable', '_mipmapAtlas');
        apply(() => {
          serializable$3(TextureCube.prototype, '_mipmapMode', () => {
            return MipmapMode.NONE;
          });
        }, 'serializable', '_mipmapMode');
        apply(() => {
          serializable$3(TextureCube.prototype, '_mipmaps', () => {
            return [];
          });
        }, 'serializable', '_mipmaps');
        apply(() => {
          ccclass$3('cc.TextureCube')(TextureCube);
        }, 'ccclass', null);
      }
      function patch_DeferredPipeline(ctx, apply = defaultExec) {
        const {
          DeferredPipeline,
          RenderTextureConfig
        } = {
          ...ctx
        };
        apply(() => {
          displayOrder$1()(DeferredPipeline.prototype, 'renderTextures', () => {
            return [];
          });
        }, 'displayOrder', 'renderTextures');
        apply(() => {
          serializable$3(DeferredPipeline.prototype, 'renderTextures', () => {
            return [];
          });
        }, 'serializable', 'renderTextures');
        apply(() => {
          type$2([RenderTextureConfig])(DeferredPipeline.prototype, 'renderTextures', () => {
            return [];
          });
        }, 'type', 'renderTextures');
        apply(() => {
          ccclass$3('DeferredPipeline')(DeferredPipeline);
        }, 'ccclass', null);
      }
      function patch_ForwardFlow(ctx, apply = defaultExec) {
        const {
          ForwardFlow
        } = {
          ...ctx
        };
        apply(() => {
          ccclass$3('ForwardFlow')(ForwardFlow);
        }, 'ccclass', null);
      }
      function patch_ForwardPipeline(ctx, apply = defaultExec) {
        const {
          ForwardPipeline,
          RenderTextureConfig
        } = {
          ...ctx
        };
        apply(() => {
          displayOrder$1()(ForwardPipeline.prototype, 'renderTextures', () => {
            return [];
          });
        }, 'displayOrder', 'renderTextures');
        apply(() => {
          serializable$3(ForwardPipeline.prototype, 'renderTextures', () => {
            return [];
          });
        }, 'serializable', 'renderTextures');
        apply(() => {
          type$2([RenderTextureConfig])(ForwardPipeline.prototype, 'renderTextures', () => {
            return [];
          });
        }, 'type', 'renderTextures');
        apply(() => {
          ccclass$3('ForwardPipeline')(ForwardPipeline);
        }, 'ccclass', null);
      }
      function patch_ForwardStage(ctx, apply = defaultExec) {
        const {
          ForwardStage,
          RenderQueueDesc
        } = {
          ...ctx
        };
        apply(() => {
          displayOrder$1()(ForwardStage.prototype, 'renderQueues', () => {
            return [];
          });
        }, 'displayOrder', 'renderQueues');
        apply(() => {
          serializable$3(ForwardStage.prototype, 'renderQueues', () => {
            return [];
          });
        }, 'serializable', 'renderQueues');
        apply(() => {
          type$2([RenderQueueDesc])(ForwardStage.prototype, 'renderQueues', () => {
            return [];
          });
        }, 'type', 'renderQueues');
        apply(() => {
          ccclass$3('ForwardStage')(ForwardStage);
        }, 'ccclass', null);
      }
      function patch_GbufferStage(ctx, apply = defaultExec) {
        const {
          GbufferStage,
          RenderQueueDesc
        } = {
          ...ctx
        };
        apply(() => {
          displayOrder$1()(GbufferStage.prototype, 'renderQueues', () => {
            return [];
          });
        }, 'displayOrder', 'renderQueues');
        apply(() => {
          serializable$3(GbufferStage.prototype, 'renderQueues', () => {
            return [];
          });
        }, 'serializable', 'renderQueues');
        apply(() => {
          type$2([RenderQueueDesc])(GbufferStage.prototype, 'renderQueues', () => {
            return [];
          });
        }, 'type', 'renderQueues');
        apply(() => {
          ccclass$3('GbufferStage')(GbufferStage);
        }, 'ccclass', null);
      }
      function patch_LightingStage(ctx, apply = defaultExec) {
        const {
          LightingStage,
          Material,
          RenderQueueDesc
        } = {
          ...ctx
        };
        apply(() => {
          displayOrder$1()(LightingStage.prototype, '_deferredMaterial', () => {
            return null;
          });
        }, 'displayOrder', '_deferredMaterial');
        apply(() => {
          serializable$3(LightingStage.prototype, '_deferredMaterial', () => {
            return null;
          });
        }, 'serializable', '_deferredMaterial');
        apply(() => {
          type$2(Material)(LightingStage.prototype, '_deferredMaterial', () => {
            return null;
          });
        }, 'type', '_deferredMaterial');
        apply(() => {
          displayOrder$1()(LightingStage.prototype, 'renderQueues', () => {
            return [];
          });
        }, 'displayOrder', 'renderQueues');
        apply(() => {
          serializable$3(LightingStage.prototype, 'renderQueues', () => {
            return [];
          });
        }, 'serializable', 'renderQueues');
        apply(() => {
          type$2([RenderQueueDesc])(LightingStage.prototype, 'renderQueues', () => {
            return [];
          });
        }, 'type', 'renderQueues');
        apply(() => {
          ccclass$3('LightingStage')(LightingStage);
        }, 'ccclass', null);
      }
      function patch_MainFlow(ctx, apply = defaultExec) {
        const {
          MainFlow
        } = {
          ...ctx
        };
        apply(() => {
          ccclass$3('MainFlow')(MainFlow);
        }, 'ccclass', null);
      }
      function patch_PostProcessStage(ctx, apply = defaultExec) {
        const {
          PostProcessStage,
          Material,
          RenderQueueDesc
        } = {
          ...ctx
        };
        apply(() => {
          displayOrder$1()(PostProcessStage.prototype, '_postProcessMaterial', () => {
            return null;
          });
        }, 'displayOrder', '_postProcessMaterial');
        apply(() => {
          serializable$3(PostProcessStage.prototype, '_postProcessMaterial', () => {
            return null;
          });
        }, 'serializable', '_postProcessMaterial');
        apply(() => {
          type$2(Material)(PostProcessStage.prototype, '_postProcessMaterial', () => {
            return null;
          });
        }, 'type', '_postProcessMaterial');
        apply(() => {
          displayOrder$1()(PostProcessStage.prototype, 'renderQueues', () => {
            return [];
          });
        }, 'displayOrder', 'renderQueues');
        apply(() => {
          serializable$3(PostProcessStage.prototype, 'renderQueues', () => {
            return [];
          });
        }, 'serializable', 'renderQueues');
        apply(() => {
          type$2([RenderQueueDesc])(PostProcessStage.prototype, 'renderQueues', () => {
            return [];
          });
        }, 'type', 'renderQueues');
        apply(() => {
          ccclass$3('PostProcessStage')(PostProcessStage);
        }, 'ccclass', null);
      }
      function patch_ReflectionProbeFlow(ctx, apply = defaultExec) {
        const {
          ReflectionProbeFlow
        } = {
          ...ctx
        };
        apply(() => {
          ccclass$3('ReflectionProbeFlow')(ReflectionProbeFlow);
        }, 'ccclass', null);
      }
      function patch_ReflectionProbeStage(ctx, apply = defaultExec) {
        const {
          ReflectionProbeStage
        } = {
          ...ctx
        };
        apply(() => {
          ccclass$3('ReflectionProbeStage')(ReflectionProbeStage);
        }, 'ccclass', null);
      }
      function patch_RenderFlow(ctx, apply = defaultExec) {
        const {
          RenderFlow,
          RenderStage
        } = {
          ...ctx
        };
        apply(() => {
          serializable$3(RenderFlow.prototype, '_name', () => {
            return '';
          });
        }, 'serializable', '_name');
        apply(() => {
          displayOrder$1()(RenderFlow.prototype, '_name', () => {
            return '';
          });
        }, 'displayOrder', '_name');
        apply(() => {
          serializable$3(RenderFlow.prototype, '_priority', () => {
            return 0;
          });
        }, 'serializable', '_priority');
        apply(() => {
          displayOrder$1()(RenderFlow.prototype, '_priority', () => {
            return 0;
          });
        }, 'displayOrder', '_priority');
        apply(() => {
          serializable$3(RenderFlow.prototype, '_tag', () => {
            return 0;
          });
        }, 'serializable', '_tag');
        apply(() => {
          displayOrder$1()(RenderFlow.prototype, '_tag', () => {
            return 0;
          });
        }, 'displayOrder', '_tag');
        apply(() => {
          serializable$3(RenderFlow.prototype, '_stages', () => {
            return [];
          });
        }, 'serializable', '_stages');
        apply(() => {
          type$2([RenderStage])(RenderFlow.prototype, '_stages', () => {
            return [];
          });
        }, 'type', '_stages');
        apply(() => {
          displayOrder$1()(RenderFlow.prototype, '_stages', () => {
            return [];
          });
        }, 'displayOrder', '_stages');
        apply(() => {
          ccclass$3('RenderFlow')(RenderFlow);
        }, 'ccclass', null);
      }
      function patch_RenderQueueDesc(ctx, apply = defaultExec) {
        const {
          RenderQueueDesc,
          RenderQueueSortMode,
          CCString
        } = {
          ...ctx
        };
        apply(() => {
          editable$1(RenderQueueDesc.prototype);
        }, 'editable', 'isTransparent');
        apply(() => {
          serializable$3(RenderQueueDesc.prototype, 'isTransparent', () => {
            return false;
          });
        }, 'serializable', 'isTransparent');
        apply(() => {
          type$2(RenderQueueSortMode)(RenderQueueDesc.prototype, 'sortMode', () => {
            return RenderQueueSortMode.FRONT_TO_BACK;
          });
        }, 'type', 'sortMode');
        apply(() => {
          type$2([CCString])(RenderQueueDesc.prototype, 'stages', () => {
            return [];
          });
        }, 'type', 'stages');
        apply(() => {
          ccclass$3('RenderQueueDesc')(RenderQueueDesc);
        }, 'ccclass', null);
      }
      function patch_RenderStage(ctx, apply = defaultExec) {
        const {
          RenderStage
        } = {
          ...ctx
        };
        apply(() => {
          serializable$3(RenderStage.prototype, '_name', () => {
            return '';
          });
        }, 'serializable', '_name');
        apply(() => {
          displayOrder$1()(RenderStage.prototype, '_name', () => {
            return '';
          });
        }, 'displayOrder', '_name');
        apply(() => {
          serializable$3(RenderStage.prototype, '_priority', () => {
            return 0;
          });
        }, 'serializable', '_priority');
        apply(() => {
          displayOrder$1()(RenderStage.prototype, '_priority', () => {
            return 0;
          });
        }, 'displayOrder', '_priority');
        apply(() => {
          serializable$3(RenderStage.prototype, '_tag', () => {
            return 0;
          });
        }, 'serializable', '_tag');
        apply(() => {
          displayOrder$1()(RenderStage.prototype, '_tag', () => {
            return 0;
          });
        }, 'displayOrder', '_tag');
        apply(() => {
          ccclass$3('RenderStage')(RenderStage);
        }, 'ccclass', null);
      }
      function patch_ShadowFlow(ctx, apply = defaultExec) {
        const {
          ShadowFlow
        } = {
          ...ctx
        };
        apply(() => {
          ccclass$3('ShadowFlow')(ShadowFlow);
        }, 'ccclass', null);
      }
      function patch_ShadowStage(ctx, apply = defaultExec) {
        const {
          ShadowStage
        } = {
          ...ctx
        };
        apply(() => {
          ccclass$3('ShadowStage')(ShadowStage);
        }, 'ccclass', null);
      }

      applyMixins(jsb.Asset, [CallbacksInvoker, ExtraEventMethods]);
      const assetProto = jsb.Asset.prototype;
      assetProto._ctor = function () {
        this.loaded = true;
        this._ref = 0;
        this.__nativeRefs = {};
        this.__jsb_ref_id = undefined;
        this._iN$t = null;
        this.__editorExtras__ = {
          editorOnly: true
        };
        this._callbackTable = createMap(true);
        this._file = null;
      };
      Object.defineProperty(assetProto, '_nativeAsset', {
        get() {
          return this._file;
        },
        set(obj) {
          this._file = obj;
        }
      });
      Object.defineProperty(assetProto, 'nativeUrl', {
        get() {
          if (!this._nativeUrl) {
            if (!this._native) return '';
            const name = this._native;
            if (name.charCodeAt(0) === 47) {
              return name.slice(1);
            }
            if (name.charCodeAt(0) === 46) {
              this._nativeUrl = getUrlWithUuid(this._uuid, {
                nativeExt: name,
                isNative: true
              });
            } else {
              this._nativeUrl = getUrlWithUuid(this._uuid, {
                __nativeName__: name,
                nativeExt: extname(name),
                isNative: true
              });
            }
          }
          return this._nativeUrl;
        }
      });
      Object.defineProperty(assetProto, 'refCount', {
        configurable: true,
        enumerable: true,
        get() {
          return this._ref;
        }
      });
      assetProto.addRef = function () {
        this._ref++;
        this.addAssetRef();
        return this;
      };
      assetProto.decRef = function (autoRelease = true) {
        this.decAssetRef();
        if (this._ref > 0) {
          this._ref--;
        }
        if (autoRelease) {
          legacyCC.assetManager._releaseManager.tryRelease(this);
        }
        return this;
      };
      assetProto.toString = function () {
        return this.nativeUrl;
      };
      assetProto.createNode = null;
      const Asset = exports('Asset', jsb.Asset);
      legacyCC.Asset = jsb.Asset;
      patch_cc_Asset({
        Asset
      });

      const CUSTOM_PIXEL_FORMAT = 1024;
      let PixelFormat;
      (function (PixelFormat) {
        PixelFormat[PixelFormat["RGB565"] = Format.R5G6B5] = "RGB565";
        PixelFormat[PixelFormat["RGB5A1"] = Format.RGB5A1] = "RGB5A1";
        PixelFormat[PixelFormat["RGBA4444"] = Format.RGBA4] = "RGBA4444";
        PixelFormat[PixelFormat["RGB888"] = Format.RGB8] = "RGB888";
        PixelFormat[PixelFormat["RGB32F"] = Format.RGB32F] = "RGB32F";
        PixelFormat[PixelFormat["RGBA8888"] = Format.RGBA8] = "RGBA8888";
        PixelFormat[PixelFormat["RGBA32F"] = Format.RGBA32F] = "RGBA32F";
        PixelFormat[PixelFormat["A8"] = Format.A8] = "A8";
        PixelFormat[PixelFormat["I8"] = Format.L8] = "I8";
        PixelFormat[PixelFormat["AI8"] = Format.LA8] = "AI8";
        PixelFormat[PixelFormat["RGB_PVRTC_2BPPV1"] = Format.PVRTC_RGB2] = "RGB_PVRTC_2BPPV1";
        PixelFormat[PixelFormat["RGBA_PVRTC_2BPPV1"] = Format.PVRTC_RGBA2] = "RGBA_PVRTC_2BPPV1";
        PixelFormat[PixelFormat["RGB_A_PVRTC_2BPPV1"] = CUSTOM_PIXEL_FORMAT] = "RGB_A_PVRTC_2BPPV1";
        PixelFormat[PixelFormat["RGB_PVRTC_4BPPV1"] = Format.PVRTC_RGB4] = "RGB_PVRTC_4BPPV1";
        PixelFormat[PixelFormat["RGBA_PVRTC_4BPPV1"] = Format.PVRTC_RGBA4] = "RGBA_PVRTC_4BPPV1";
        PixelFormat[PixelFormat["RGB_A_PVRTC_4BPPV1"] = CUSTOM_PIXEL_FORMAT + 1] = "RGB_A_PVRTC_4BPPV1";
        PixelFormat[PixelFormat["RGB_ETC1"] = Format.ETC_RGB8] = "RGB_ETC1";
        PixelFormat[PixelFormat["RGBA_ETC1"] = CUSTOM_PIXEL_FORMAT + 2] = "RGBA_ETC1";
        PixelFormat[PixelFormat["RGB_ETC2"] = Format.ETC2_RGB8] = "RGB_ETC2";
        PixelFormat[PixelFormat["RGBA_ETC2"] = Format.ETC2_RGBA8] = "RGBA_ETC2";
        PixelFormat[PixelFormat["RGBA_ASTC_4x4"] = Format.ASTC_RGBA_4X4] = "RGBA_ASTC_4x4";
        PixelFormat[PixelFormat["RGBA_ASTC_5x4"] = Format.ASTC_RGBA_5X4] = "RGBA_ASTC_5x4";
        PixelFormat[PixelFormat["RGBA_ASTC_5x5"] = Format.ASTC_RGBA_5X5] = "RGBA_ASTC_5x5";
        PixelFormat[PixelFormat["RGBA_ASTC_6x5"] = Format.ASTC_RGBA_6X5] = "RGBA_ASTC_6x5";
        PixelFormat[PixelFormat["RGBA_ASTC_6x6"] = Format.ASTC_RGBA_6X6] = "RGBA_ASTC_6x6";
        PixelFormat[PixelFormat["RGBA_ASTC_8x5"] = Format.ASTC_RGBA_8X5] = "RGBA_ASTC_8x5";
        PixelFormat[PixelFormat["RGBA_ASTC_8x6"] = Format.ASTC_RGBA_8X6] = "RGBA_ASTC_8x6";
        PixelFormat[PixelFormat["RGBA_ASTC_8x8"] = Format.ASTC_RGBA_8X8] = "RGBA_ASTC_8x8";
        PixelFormat[PixelFormat["RGBA_ASTC_10x5"] = Format.ASTC_RGBA_10X5] = "RGBA_ASTC_10x5";
        PixelFormat[PixelFormat["RGBA_ASTC_10x6"] = Format.ASTC_RGBA_10X6] = "RGBA_ASTC_10x6";
        PixelFormat[PixelFormat["RGBA_ASTC_10x8"] = Format.ASTC_RGBA_10X8] = "RGBA_ASTC_10x8";
        PixelFormat[PixelFormat["RGBA_ASTC_10x10"] = Format.ASTC_RGBA_10X10] = "RGBA_ASTC_10x10";
        PixelFormat[PixelFormat["RGBA_ASTC_12x10"] = Format.ASTC_RGBA_12X10] = "RGBA_ASTC_12x10";
        PixelFormat[PixelFormat["RGBA_ASTC_12x12"] = Format.ASTC_RGBA_12X12] = "RGBA_ASTC_12x12";
      })(PixelFormat || (PixelFormat = {}));
      let WrapMode;
      (function (WrapMode) {
        WrapMode[WrapMode["REPEAT"] = Address.WRAP] = "REPEAT";
        WrapMode[WrapMode["CLAMP_TO_EDGE"] = Address.CLAMP] = "CLAMP_TO_EDGE";
        WrapMode[WrapMode["MIRRORED_REPEAT"] = Address.MIRROR] = "MIRRORED_REPEAT";
        WrapMode[WrapMode["CLAMP_TO_BORDER"] = Address.BORDER] = "CLAMP_TO_BORDER";
      })(WrapMode || (WrapMode = {}));
      let Filter;
      (function (Filter) {
        Filter[Filter["NONE"] = Filter$1.NONE] = "NONE";
        Filter[Filter["LINEAR"] = Filter$1.LINEAR] = "LINEAR";
        Filter[Filter["NEAREST"] = Filter$1.POINT] = "NEAREST";
      })(Filter || (Filter = {}));

      const ImageAsset$1 = exports('ImageAsset', jsb.ImageAsset);
      const jsbWindow$1 = jsb.window;
      const extnames = ['.png', '.jpg', '.jpeg', '.bmp', '.webp', '.pvr', '.pkm', '.astc'];
      function isImageBitmap(imageSource) {
        return !!(sys.hasFeature(sys.Feature.IMAGE_BITMAP) && imageSource instanceof ImageBitmap);
      }
      function isNativeImage(imageSource) {
        if (imageSource._compressed === true) {
          return false;
        }
        return imageSource instanceof jsbWindow$1.HTMLImageElement || imageSource instanceof jsbWindow$1.HTMLCanvasElement || isImageBitmap(imageSource);
      }
      const imageAssetProto = ImageAsset$1.prototype;
      imageAssetProto._ctor = function (nativeAsset) {
        jsb.Asset.prototype._ctor.apply(this, arguments);
        this._width = 0;
        this._height = 0;
        this._nativeData = {
          _data: null,
          width: 0,
          height: 0,
          format: 0,
          _compressed: false,
          mipmapLevelDataSize: []
        };
        if (nativeAsset !== undefined) {
          this.reset(nativeAsset);
        }
      };
      Object.defineProperty(imageAssetProto, '_nativeAsset', {
        configurable: true,
        enumerable: true,
        get() {
          return this._nativeData;
        },
        set(value) {
          if (!(value instanceof jsbWindow$1.HTMLElement) && !isImageBitmap(value)) {
            value.format = value.format || this.format;
          }
          this.reset(value);
        }
      });
      Object.defineProperty(imageAssetProto, 'data', {
        configurable: true,
        enumerable: true,
        get() {
          if (this._nativeData && isNativeImage(this._nativeData)) {
            return this._nativeData;
          }
          return this._nativeData && this._nativeData._data;
        }
      });
      imageAssetProto._setRawAsset = function (filename, inLibrary = true) {
        if (inLibrary !== false) {
          this._native = filename || '';
        } else {
          this._native = `/${filename}`;
        }
      };
      imageAssetProto.reset = function (data) {
        this._nativeData = data;
        if (!(data instanceof jsbWindow$1.HTMLElement)) {
          if (data.format !== undefined) {
            this.format = data.format;
          }
        }
        this._syncDataToNative();
      };
      const superDestroy = jsb.Asset.prototype.destroy;
      imageAssetProto.destroy = function () {
        if (this.data && this.data instanceof jsbWindow$1.HTMLImageElement) {
          this.data.src = '';
          this._setRawAsset('');
          this.data.destroy();
        } else if (isImageBitmap(this.data)) {
          this.data.close && this.data.close();
        }
        return superDestroy.call(this);
      };
      Object.defineProperty(imageAssetProto, 'width', {
        configurable: true,
        enumerable: true,
        get() {
          return this._nativeData.width || this._width;
        }
      });
      Object.defineProperty(imageAssetProto, 'height', {
        configurable: true,
        enumerable: true,
        get() {
          return this._nativeData.height || this._height;
        }
      });
      imageAssetProto._syncDataToNative = function () {
        const data = this._nativeData;
        this._width = data.width;
        this._height = data.height;
        this.setWidth(this._width);
        this.setHeight(this._height);
        this.url = this.nativeUrl;
        if (data instanceof jsbWindow$1.HTMLCanvasElement) {
          this.setData(data._data.data);
        } else if (data instanceof jsbWindow$1.HTMLImageElement) {
          this.setData(data._data);
          if (data._mipmapLevelDataSize) {
            this.setMipmapLevelDataSize(data._mipmapLevelDataSize);
          }
        } else {
          if (!this._nativeData._data) {
            console.error(`[ImageAsset] setData bad argument ${this._nativeData}`);
            return;
          }
          this.setData(this._nativeData._data);
          if (this._nativeData.mipmapLevelDataSize) {
            this.setMipmapLevelDataSize(this._nativeData.mipmapLevelDataSize);
          }
        }
      };
      imageAssetProto._serialize = function () {
      };
      imageAssetProto._deserialize = function (data) {
        let fmtStr = '';
        if (typeof data === 'string') {
          fmtStr = data;
        } else {
          this._width = data.w;
          this._height = data.h;
          fmtStr = data.fmt;
        }
        const device = deviceManager.gfxDevice;
        const extensionIDs = fmtStr.split('_');
        let preferedExtensionIndex = Number.MAX_VALUE;
        let format = this.format;
        let ext = '';
        const SupportTextureFormats = macro.SUPPORT_TEXTURE_FORMATS;
        for (const extensionID of extensionIDs) {
          const extFormat = extensionID.split('@');
          const i = parseInt(extFormat[0], undefined);
          const tmpExt = extnames[i] || extFormat[0];
          const index = SupportTextureFormats.indexOf(tmpExt);
          if (index !== -1 && index < preferedExtensionIndex) {
            const fmt = extFormat[1] ? parseInt(extFormat[1]) : this.format;
            if (tmpExt === '.astc' && (!device || !(device.getFormatFeatures(Format.ASTC_RGBA_4X4) & FormatFeatureBit.SAMPLED_TEXTURE))) {
              continue;
            } else if (tmpExt === '.pvr' && (!device || !(device.getFormatFeatures(Format.PVRTC_RGBA4) & FormatFeatureBit.SAMPLED_TEXTURE))) {
              continue;
            } else if ((fmt === PixelFormat.RGB_ETC1 || fmt === PixelFormat.RGBA_ETC1) && (!device || !(device.getFormatFeatures(Format.ETC_RGB8) & FormatFeatureBit.SAMPLED_TEXTURE))) {
              continue;
            } else if ((fmt === PixelFormat.RGB_ETC2 || fmt === PixelFormat.RGBA_ETC2) && (!device || !(device.getFormatFeatures(Format.ETC2_RGB8) & FormatFeatureBit.SAMPLED_TEXTURE))) {
              continue;
            } else if (tmpExt === '.webp' && !sys.hasFeature(sys.Feature.WEBP)) {
              continue;
            }
            preferedExtensionIndex = index;
            ext = tmpExt;
            format = fmt;
          }
        }
        if (ext) {
          this._setRawAsset(ext);
          this.format = format;
        } else {
          warnID(3121);
        }
      };
      legacyCC.ImageAsset = jsb.ImageAsset;
      patch_cc_ImageAsset({
        ImageAsset: ImageAsset$1
      });

      var _dec$Y, _class$X, _dec2$H, _class2$Q, _dec3$x, _class3$u;
      let Script = exports('Script', (_dec$Y = ccclass$3('cc.Script'), _dec$Y(_class$X = class Script extends Asset {}) || _class$X));
      legacyCC._Script = Script;
      let JavaScript = exports('JavaScript', (_dec2$H = ccclass$3('cc.JavaScript'), _dec2$H(_class2$Q = class JavaScript extends Script {}) || _class2$Q));
      legacyCC._JavaScript = JavaScript;
      let TypeScript = exports('TypeScript', (_dec3$x = ccclass$3('cc.TypeScript'), _dec3$x(_class3$u = class TypeScript extends Script {}) || _class3$u));
      legacyCC._TypeScript = TypeScript;

      var _dec$X, _class$W, _class2$P, _initializer$L, _initializer2$A, _initializer3$u, _initializer4$p, _initializer5$k;
      let EventHandler = exports('EventHandler', (_dec$X = ccclass$3('cc.ClickEvent'), _dec$X(_class$W = (_class2$P = class EventHandler {
        constructor() {
          this.target = _initializer$L && _initializer$L();
          this.component = _initializer2$A && _initializer2$A();
          this._componentId = _initializer3$u && _initializer3$u();
          this.handler = _initializer4$p && _initializer4$p();
          this.customEventData = _initializer5$k && _initializer5$k();
        }
        get _componentName() {
          this._genCompIdIfNeeded();
          return this._compId2Name(this._componentId);
        }
        set _componentName(value) {
          this._componentId = this._compName2Id(value);
        }
        static emitEvents(events, ...args) {
          for (let i = 0, l = events.length; i < l; i++) {
            const event = events[i];
            if (!(event instanceof EventHandler)) {
              continue;
            }
            event.emit(args);
          }
        }
        emit(params) {
          const target = this.target;
          if (!legacyCC.isValid(target)) {
            return;
          }
          this._genCompIdIfNeeded();
          const compType = legacyCC.js.getClassById(this._componentId);
          const comp = target.getComponent(compType);
          if (!legacyCC.isValid(comp)) {
            return;
          }
          const handler = comp[this.handler];
          if (typeof handler !== 'function') {
            return;
          }
          if (this.customEventData != null && this.customEventData !== '') {
            params = params.slice();
            params.push(this.customEventData);
          }
          handler.apply(comp, params);
        }
        _compName2Id(compName) {
          const comp = legacyCC.js.getClassByName(compName);
          return legacyCC.js.getClassId(comp);
        }
        _compId2Name(compId) {
          const comp = legacyCC.js.getClassById(compId);
          return legacyCC.js.getClassName(comp);
        }
        _genCompIdIfNeeded() {
          if (!this._componentId) {
            this._componentName = this.component;
            this.component = '';
          }
        }
      }, (_initializer$L = applyDecoratedInitializer(_class2$P.prototype, "target", [serializable$3], function () {
        return null;
      }), _initializer2$A = applyDecoratedInitializer(_class2$P.prototype, "component", [serializable$3], function () {
        return '';
      }), _initializer3$u = applyDecoratedInitializer(_class2$P.prototype, "_componentId", [serializable$3], function () {
        return '';
      }), _initializer4$p = applyDecoratedInitializer(_class2$P.prototype, "handler", [serializable$3], function () {
        return '';
      }), _initializer5$k = applyDecoratedInitializer(_class2$P.prototype, "customEventData", [serializable$3], function () {
        return '';
      })), _class2$P)) || _class$W));

      var _dec$W, _dec2$G, _class$V, _class2$O, _initializer$K, _initializer2$z, _initializer3$t, _class3$t;
      const idGenerator = new IDGenerator('Comp');
      const IsOnLoadCalled$1 = CCObject.Flags.IsOnLoadCalled;
      const NullNode = null;
      let Component = exports('Component', (_dec$W = ccclass$3('cc.Component'), _dec2$G = type$2(Script), _dec$W(_class$V = (_class2$O = (_class3$t = class Component extends CCObject {
        constructor(...args) {
          super(...args);
          this.node = _initializer$K && _initializer$K();
          this._enabled = _initializer2$z && _initializer2$z();
          this.__prefab = _initializer3$t && _initializer3$t();
          this._sceneGetter = null;
          this._id = idGenerator.getNewId();
        }
        get name() {
          if (this._name) {
            return this._name;
          }
          let className = getClassName(this);
          const trimLeft = className.lastIndexOf('.');
          if (trimLeft >= 0) {
            className = className.slice(trimLeft + 1);
          }
          if (this.node) {
            return `${this.node.name}<${className}>`;
          } else {
            return className;
          }
        }
        set name(value) {
          this._name = value;
        }
        get uuid() {
          return this._id;
        }
        get __scriptAsset() {
          return null;
        }
        get enabled() {
          return this._enabled;
        }
        set enabled(value) {
          if (this._enabled !== value) {
            this._enabled = value;
            if (this.node.activeInHierarchy) {
              const compScheduler = legacyCC.director._compScheduler;
              if (value) {
                compScheduler.enableComp(this);
              } else {
                compScheduler.disableComp(this);
              }
            }
          }
        }
        get enabledInHierarchy() {
          return this._enabled && this.node && this.node.activeInHierarchy;
        }
        get _isOnLoadCalled() {
          return this._objFlags & IsOnLoadCalled$1;
        }
        _getRenderScene() {
          if (this._sceneGetter) {
            return this._sceneGetter();
          }
          return this.node.scene.renderScene;
        }
        addComponent(typeOrClassName) {
          return this.node.addComponent(typeOrClassName);
        }
        getComponent(typeOrClassName) {
          return this.node.getComponent(typeOrClassName);
        }
        getComponents(typeOrClassName) {
          return this.node.getComponents(typeOrClassName);
        }
        getComponentInChildren(typeOrClassName) {
          return this.node.getComponentInChildren(typeOrClassName);
        }
        getComponentsInChildren(typeOrClassName) {
          return this.node.getComponentsInChildren(typeOrClassName);
        }
        destroy() {
          if (super.destroy()) {
            if (this._enabled && this.node.activeInHierarchy) {
              legacyCC.director._compScheduler.disableComp(this);
            }
            return true;
          }
          return false;
        }
        _onPreDestroy() {
          this.unscheduleAllCallbacks();
          legacyCC.director._nodeActivator.destroyComp(this);
          this.node._removeComponent(this);
        }
        _instantiate(cloned) {
          if (!cloned) {
            cloned = legacyCC.instantiate._clone(this, this);
          }
          if (cloned) {
            cloned.node = NullNode;
          }
          return cloned;
        }
        schedule(callback, interval = 0, repeat = legacyCC.macro.REPEAT_FOREVER, delay = 0) {
          assertID(Boolean(callback), 1619);
          interval = interval || 0;
          assertID(interval >= 0, 1620);
          repeat = Number.isNaN(repeat) ? legacyCC.macro.REPEAT_FOREVER : repeat;
          delay = delay || 0;
          const scheduler = legacyCC.director.getScheduler();
          const paused = scheduler.isTargetPaused(this);
          scheduler.schedule(callback, this, interval, repeat, delay, paused);
        }
        scheduleOnce(callback, delay = 0) {
          this.schedule(callback, 0, 0, delay);
        }
        unschedule(callback_fn) {
          if (!callback_fn) {
            return;
          }
          legacyCC.director.getScheduler().unschedule(callback_fn, this);
        }
        unscheduleAllCallbacks() {
          legacyCC.director.getScheduler().unscheduleAllForTarget(this);
        }
        get internalUpdate() {
          return this.update;
        }
        get internalLateUpdate() {
          return this.lateUpdate;
        }
        get internalPreload() {
          return this.__preload;
        }
        get internalOnLoad() {
          return this.onLoad;
        }
        get internalStart() {
          return this.start;
        }
        get internalOnEnable() {
          return this.onEnable;
        }
        get internalOnDisable() {
          return this.onDisable;
        }
        get internalOnDestroy() {
          return this.onDestroy;
        }
      }, _class3$t.EventHandler = EventHandler, _class3$t._executionOrder = 0, _class3$t._requireComponent = null, _class3$t.system = null, _class3$t), (_applyDecoratedDescriptor(_class2$O.prototype, "__scriptAsset", [_dec2$G], Object.getOwnPropertyDescriptor(_class2$O.prototype, "__scriptAsset"), _class2$O.prototype), _initializer$K = applyDecoratedInitializer(_class2$O.prototype, "node", [serializable$3], function () {
        return NullNode;
      }), _initializer2$z = applyDecoratedInitializer(_class2$O.prototype, "_enabled", [serializable$3], function () {
        return true;
      }), _initializer3$t = applyDecoratedInitializer(_class2$O.prototype, "__prefab", [serializable$3], function () {
        return null;
      })), _class2$O)) || _class$V));
      value(Component, '_registerEditorProps', (cls, props) => {
        let reqComp = props.requireComponent;
        if (reqComp) {
          if (Array.isArray(reqComp)) {
            reqComp = reqComp.filter(Boolean);
          }
          cls._requireComponent = reqComp;
        }
        const order = props.executionOrder;
        if (order && typeof order === 'number') {
          cls._executionOrder = order;
        }
      });
      legacyCC.Component = Component;

      var _dec$V, _class$U, _class2$N, _initializer$J;
      let MissingScript = exports('MissingScript', (_dec$V = ccclass$3('cc.MissingScript'), _dec$V(_class$U = (_class2$N = class MissingScript extends Component {
        static safeFindClass(id) {
          const cls = getClassById(id);
          if (cls) {
            return cls;
          }
          legacyCC.deserialize.reportMissingClass(id);
          return undefined;
        }
        constructor() {
          super();
          this._$erialized = _initializer$J && _initializer$J();
        }
        onLoad() {
          warnID(4600, this.node.name);
        }
      }, (_initializer$J = applyDecoratedInitializer(_class2$N.prototype, "_$erialized", [serializable$3, editorOnly], function () {
        return null;
      })), _class2$N)) || _class$U));
      legacyCC._MissingScript = MissingScript;
      try {
        const props = MissingScript.__values__;
        if (props.length === 0 || props[props.length - 1] !== '_$erialized') {
          error(`The '_$erialized' prop in MissingScript is missing. Please contact jare.`);
          error(`    Error props: ['${props}']`);
        }
      } catch (e) {
        error(`Error when checking MissingScript 5, ${e}`);
      }

      const VERSION = 1;
      const MAGIC = 0x4E4F4343;
      const CHUNK_ALIGN_AS = 8;
      class CCON {
        constructor(document, chunks) {
          this._document = void 0;
          this._chunks = void 0;
          this._document = document;
          this._chunks = chunks;
        }
        get document() {
          return this._document;
        }
        get chunks() {
          return this._chunks;
        }
      }
      function parseCCONJson(json) {
        const cconPreface = json;
        return {
          chunks: cconPreface.chunks,
          document: cconPreface.document
        };
      }
      function decodeCCONBinary(bytes) {
        if (bytes.length < 16) {
          throw new InvalidCCONError(getError(13102));
        }
        const dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
        const magic = dataView.getUint32(0, true);
        if (magic !== MAGIC) {
          throw new InvalidCCONError(getError(13100));
        }
        const version = dataView.getUint32(4, true);
        if (version !== VERSION) {
          throw new InvalidCCONError(getError(13101, version));
        }
        const dataByteLength = dataView.getUint32(8, true);
        if (dataByteLength !== dataView.byteLength) {
          throw new InvalidCCONError(getError(13102));
        }
        let chunksStart = 12;
        const jsonDataLength = dataView.getUint32(chunksStart, true);
        chunksStart += 4;
        const jsonData = new Uint8Array(dataView.buffer, chunksStart + dataView.byteOffset, jsonDataLength);
        chunksStart += jsonDataLength;
        const jsonString = decodeJson(jsonData);
        let json;
        try {
          json = JSON.parse(jsonString);
        } catch (err) {
          throw new InvalidCCONError(err);
        }
        const chunks = [];
        while (chunksStart < dataView.byteLength) {
          if (chunksStart % CHUNK_ALIGN_AS !== 0) {
            const padding = CHUNK_ALIGN_AS - chunksStart % CHUNK_ALIGN_AS;
            chunksStart += padding;
          }
          const chunkDataLength = dataView.getUint32(chunksStart, true);
          chunksStart += 4;
          chunks.push(new Uint8Array(dataView.buffer, chunksStart + dataView.byteOffset, chunkDataLength));
          chunksStart += chunkDataLength;
        }
        if (chunksStart !== dataView.byteLength) {
          throw new InvalidCCONError(getError(13102));
        }
        return new CCON(json, chunks);
      }
      function decodeJson(data) {
        if (typeof TextDecoder !== 'undefined') {
          return new TextDecoder().decode(data);
        } else if ('Buffer' in globalThis) {
          const {
            Buffer
          } = globalThis;
          return Buffer.from(data.buffer, data.byteOffset, data.byteLength).toString();
        } else {
          throw new Error(getError(13104));
        }
      }
      class InvalidCCONError extends Error {}
      legacyCC.internal.parseCCONJson = parseCCONJson;
      legacyCC.internal.decodeCCONBinary = decodeCCONBinary;
      legacyCC.internal.CCON = CCON;

      function compileObjectTypeJit(sources, defaultValue, accessorToSet, propNameLiteralToSet, assumeHavePropIfIsValue) {
        if (defaultValue instanceof legacyCC.ValueType) {
          if (!assumeHavePropIfIsValue) {
            sources.push('if(prop){');
          }
          const ctorCode = getClassName(defaultValue);
          sources.push(`s._deserializeFastDefinedObject(o${accessorToSet},prop,${ctorCode});`);
          if (!assumeHavePropIfIsValue) {
            sources.push(`}else o${accessorToSet}=null;`);
          }
        } else {
          sources.push(`
if (prop) {
    s._deserializeAndAssignField(o, prop, ${propNameLiteralToSet});
} else {
    o${accessorToSet}=null;
}
`);
        }
      }
      const compileDeserialize = compileDeserializeJIT ;
      const DELIMITER = CCClass.Attr.DELIMETER;
      const POSTFIX_TYPE = `${DELIMITER}type`;
      const POSTFIX_DEFAULT = `${DELIMITER}default`;
      const POSTFIX_FORMERLY_SERIALIZED_AS = `${DELIMITER}formerlySerializedAs`;
      function compileDeserializeJIT(self, klass) {
        const attrs = CCClass.Attr.getClassAttrs(klass);
        const props = klass.__values__;
        const sources = ['var prop;'];
        const fastMode = canBeDeserializedInFastMode(klass);
        for (let p = 0; p < props.length; p++) {
          const propName = props[p];
          let accessorToSet;
          let propNameLiteralToSet;
          if (CCClass.IDENTIFIER_RE.test(propName)) {
            propNameLiteralToSet = `"${propName}"`;
            accessorToSet = `.${propName}`;
          } else {
            propNameLiteralToSet = CCClass.escapeForJS(propName);
            accessorToSet = `[${propNameLiteralToSet}]`;
          }
          let accessorToGet = accessorToSet;
          if (attrs[propName + POSTFIX_FORMERLY_SERIALIZED_AS]) {
            const propNameToRead = attrs[propName + POSTFIX_FORMERLY_SERIALIZED_AS];
            if (CCClass.IDENTIFIER_RE.test(propNameToRead)) {
              accessorToGet = `.${propNameToRead}`;
            } else {
              accessorToGet = `[${CCClass.escapeForJS(propNameToRead)}]`;
            }
          }
          sources.push(`prop=d${accessorToGet};`);
          sources.push(`if(typeof ${'(prop)' }!=="undefined"){`);
          const defaultValue = CCClass.getDefault(attrs[propName + POSTFIX_DEFAULT]);
          const userType = attrs[propName + POSTFIX_TYPE];
          if (fastMode && (defaultValue !== undefined || userType)) {
            const isPrimitiveTypeInFastMode = isPrimitivePropertyByDefaultOrType(defaultValue, userType);
            if (isPrimitiveTypeInFastMode) {
              sources.push(`o${accessorToSet}=prop;`);
            } else {
              compileObjectTypeJit(sources, defaultValue, accessorToSet, propNameLiteralToSet, true);
            }
          } else {
            sources.push(`${`if(typeof ${'(prop)' }!=="object"){` + 'o'}${accessorToSet}=prop;` + `}else{`);
            compileObjectTypeJit(sources, defaultValue, accessorToSet, propNameLiteralToSet, false);
            sources.push('}');
          }
          sources.push('}');
        }
        if (isChildClassOf(klass, legacyCC.Node) || isChildClassOf(klass, legacyCC.Component)) {
          {
            sources.push('d._id&&(o._id=d._id);');
          }
        }
        if (props[props.length - 1] === '_$erialized') {
          sources.push('o._$erialized=JSON.parse(JSON.stringify(d));');
          sources.push('s._fillPlainObject(o._$erialized,d);');
        }
        return Function('s', 'o', 'd', 'k', sources.join(''));
      }
      function canBeDeserializedInFastMode(klass) {
        return BUILTIN_CLASSID_RE.test(getClassId(klass));
      }
      function isPrimitivePropertyByDefaultOrType(defaultValue, userType) {
        if (defaultValue === undefined) {
          return userType instanceof CCClass.Attr.PrimitiveType || userType === ENUM_TAG || userType === BITMASK_TAG;
        } else {
          const defaultType = typeof defaultValue;
          return defaultType === 'string' || defaultType === 'number' || defaultType === 'boolean';
        }
      }
      class DeserializerPool extends Pool$1 {
        constructor() {
          super(deserializer => {
            deserializer.clear();
          }, 1);
        }
      }
      DeserializerPool.prototype.get = function (details, classFinder, reportMissingClass, customEnv, ignoreEditorOnly) {
        const cache = this._get();
        if (cache) {
          cache.reset(details, classFinder, reportMissingClass, customEnv, ignoreEditorOnly);
          return cache;
        } else {
          return new _Deserializer(details, classFinder, reportMissingClass, customEnv, ignoreEditorOnly);
        }
      };
      class _Deserializer {
        get ignoreEditorOnly() {
          return this._ignoreEditorOnly;
        }
        constructor(result, classFinder, reportMissingClass, customEnv, ignoreEditorOnly) {
          this.deserializedList = void 0;
          this.deserializedData = void 0;
          this._ignoreEditorOnly = void 0;
          this.result = result;
          this.customEnv = customEnv;
          this.deserializedList = [];
          this.deserializedData = null;
          this._classFinder = classFinder;
          this._reportMissingClass = reportMissingClass;
          this._onDereferenced = classFinder === null || classFinder === void 0 ? void 0 : classFinder.onDereferenced;
        }
        reset(result, classFinder, reportMissingClass, customEnv, ignoreEditorOnly) {
          this.result = result;
          this.customEnv = customEnv;
          this._classFinder = classFinder;
          this._reportMissingClass = reportMissingClass;
          this._onDereferenced = classFinder === null || classFinder === void 0 ? void 0 : classFinder.onDereferenced;
        }
        clear() {
          this.result = null;
          this.customEnv = null;
          this.deserializedList.length = 0;
          this.deserializedData = null;
          this._classFinder = null;
          this._reportMissingClass = null;
          this._onDereferenced = null;
        }
        deserialize(serializedData) {
          let fromCCON = false;
          let jsonObj;
          if (serializedData instanceof CCON) {
            fromCCON = true;
            jsonObj = serializedData.document;
            if (serializedData.chunks.length > 0) {
              assertIsTrue(serializedData.chunks.length === 1);
              this._mainBinChunk = serializedData.chunks[0];
            }
          } else {
            jsonObj = serializedData;
          }
          this._serializedData = jsonObj;
          this._context = {
            fromCCON
          };
          const serializedRootObject = Array.isArray(jsonObj) ? jsonObj[0] : jsonObj;
          {
            this.deserializedData = this._deserializeObject(serializedRootObject, 0);
          }
          this._serializedData = undefined;
          this._mainBinChunk = undefined;
          this._context = undefined;
          return this.deserializedData;
        }
        _deserializeObject(serialized, globalIndex, owner, propName) {
          switch (serialized.__type__) {
            case 'TypedArray':
              return this._deserializeTypedArrayView(serialized);
            case 'TypedArrayRef':
              return this._deserializeTypedArrayViewRef(serialized);
            default:
              if (serialized.__type__) {
                return this._deserializeTypeTaggedObject(serialized, globalIndex, owner, propName);
              } else if (!Array.isArray(serialized)) {
                return this._deserializePlainObject(serialized);
              } else {
                return this._deserializeArray(serialized);
              }
          }
        }
        _deserializeTypedArrayView(value) {
          return globalThis[value.ctor].from(value.array);
        }
        _deserializeTypedArrayViewRef(value) {
          const {
            offset,
            length,
            ctor: constructorName
          } = value;
          const obj = new globalThis[constructorName](this._mainBinChunk.buffer, this._mainBinChunk.byteOffset + offset, length);
          return obj;
        }
        _deserializeArray(value) {
          const obj = new Array(value.length);
          let prop;
          for (let i = 0; i < value.length; i++) {
            prop = value[i];
            if (typeof prop === 'object' && prop) {
              const isAssetType = this._deserializeAndAssignField(obj, prop, `${i}`);
              if (isAssetType) {
                obj[i] = null;
              }
            } else {
              obj[i] = prop;
            }
          }
          return obj;
        }
        _deserializePlainObject(value) {
          const obj = {};
          this._fillPlainObject(obj, value);
          return obj;
        }
        _deserializeTypeTaggedObject(value, globalIndex, owner, propName) {
          const type = value.__type__;
          const klass = this._classFinder(type, value, owner, propName);
          if (!klass) {
            const notReported = this._classFinder === getClassById;
            if (notReported) {
              this._reportMissingClass(type);
            }
            return null;
          }
          const createObject = constructor => {
            const obj = new constructor();
            if (globalIndex >= 0) {
              this.deserializedList[globalIndex] = obj;
            }
            return obj;
          };
          {
            const obj = createObject(klass);
            this._deserializeInto(value, obj, klass);
            return obj;
          }
        }
        _deserializeInto(value, object, constructor, skipCustomized = false) {
          if (!skipCustomized && object[deserializeTag]) {
            this._runCustomizedDeserialize(value, object, constructor);
            return;
          }
          if (object._deserialize) {
            object._deserialize(value.content, this);
            return;
          }
          if (legacyCC.Class._isCCClass(constructor)) {
            this._deserializeFireClass(object, value, constructor);
          } else {
            this._deserializeFastDefinedObject(object, value, constructor);
          }
        }
        _runCustomizedDeserialize(value, object, constructor) {
          const serializationInput = {
            readProperty: name => {
              const serializedField = value[name];
              if (typeof serializedField !== 'object' || !serializedField) {
                return serializedField;
              } else {
                return this._deserializeObjectField(serializedField);
              }
            },
            readThis: () => {
              this._deserializeInto(value, object, constructor, true);
            },
            readSuper: () => {
              const superConstructor = getSuper(constructor);
              if (superConstructor) {
                this._deserializeInto(value, object, superConstructor);
              }
            }
          };
          object[deserializeTag](serializationInput, this._context);
        }
        _deserializeFireClass(obj, serialized, klass) {
          let deserialize;
          if (klass.hasOwnProperty('__deserialize__')) {
            deserialize = klass.__deserialize__;
          } else {
            deserialize = compileDeserialize(this, klass);
            try {
              if (klass === MissingScript) {
                const props = klass.__values__;
                if (props.length === 0 || props[props.length - 1] !== '_$erialized') {
                  error(`The '_$erialized' prop of MissingScript is missing. Will force the raw data to be save.`);
                  error(`    Error props: ['${props}']. Please contact jare.`);
                }
                const rawDeserialize = deserialize;
                deserialize = function (deserializer, object, deserialized, constructor) {
                  rawDeserialize(deserializer, object, deserialized, constructor);
                  if (!object._$erialized) {
                    error(`Unable to stash previously serialized data. ${JSON.stringify(deserialized)}`);
                  }
                };
              }
            } catch (e) {
              error(`Error when checking MissingScript 6, ${e}`);
            }
            value(klass, '__deserialize__', deserialize, true);
          }
          deserialize(this, obj, serialized, klass);
        }
        _deserializeAndAssignField(obj, serializedField, propName) {
          const id = serializedField.__id__;
          if (typeof id === 'number') {
            const field = this.deserializedList[id];
            if (field) {
              obj[propName] = field;
            } else {
              var _this$_onDereferenced;
              const source = this._serializedData[id];
              {
                obj[propName] = this._deserializeObject(source, id, undefined, propName);
              }
              (_this$_onDereferenced = this._onDereferenced) === null || _this$_onDereferenced === void 0 ? void 0 : _this$_onDereferenced.call(this, this.deserializedList, id, obj, propName);
            }
          } else {
            const uuid = serializedField.__uuid__;
            if (uuid) {
              const expectedType = serializedField.__expectedType__;
              this.result.push(obj, propName, uuid, expectedType);
            } else {
              obj[propName] = this._deserializeObject(serializedField, -1);
            }
          }
          return false;
        }
        _deserializeObjectField(serializedField) {
          const id = serializedField.__id__;
          if (typeof id === 'number') {
            const field = this.deserializedList[id];
            if (field) {
              return field;
            } else {
              const source = this._serializedData[id];
              const field = this._deserializeObject(source, id, undefined, undefined);
              return field;
            }
          } else {
            const uuid = serializedField.__uuid__;
            if (uuid) {
              serializedField.__expectedType__;
              throw new Error(`Asset reference field serialization is currently not supported in custom serialization.`);
            } else {
              return this._deserializeObject(serializedField, -1);
            }
          }
        }
        _fillPlainObject(instance, serialized) {
          for (const propName in serialized) {
            if (!serialized.hasOwnProperty(propName)) {
              continue;
            }
            const prop = serialized[propName];
            if (typeof prop !== 'object') {
              if (propName !== '__type__') {
                instance[propName] = prop;
              }
            } else if (prop) {
              const isAssetType = this._deserializeAndAssignField(instance, prop, propName);
              if (isAssetType) {
                instance[propName] = null;
              }
            } else {
              instance[propName] = null;
            }
          }
        }
        _deserializeFastDefinedObject(instance, serialized, klass) {
          if (klass === legacyCC.Vec2) {
            instance.x = serialized.x || 0;
            instance.y = serialized.y || 0;
            return;
          } else if (klass === legacyCC.Vec3) {
            instance.x = serialized.x || 0;
            instance.y = serialized.y || 0;
            instance.z = serialized.z || 0;
            return;
          } else if (klass === legacyCC.Color) {
            instance.r = serialized.r || 0;
            instance.g = serialized.g || 0;
            instance.b = serialized.b || 0;
            const a = serialized.a;
            instance.a = a === undefined ? 255 : a;
            return;
          } else if (klass === legacyCC.Size) {
            instance.width = serialized.width || 0;
            instance.height = serialized.height || 0;
            return;
          }
          const attrs = CCClass.Attr.getClassAttrs(klass);
          const props = klass.__values__;
          if (!props) {
            error(`Unable to deserialize ${getClassName(klass)}. ` + 'For non-CCClass types, they can only be marked as serializable by `CCClass.fastDefine`.');
          }
          for (let i = 0; i < props.length; i++) {
            const propName = props[i];
            let value = serialized[propName];
            const exists = value !== undefined || serialized.hasOwnProperty(propName);
            if (!exists) {
              value = CCClass.getDefault(attrs[propName + POSTFIX_DEFAULT]);
            }
            if (typeof value !== 'object') {
              instance[propName] = value;
            } else if (value) {
              this._deserializeAndAssignField(instance, value, propName);
            } else {
              instance[propName] = null;
            }
          }
        }
      }
      _Deserializer.pool = new DeserializerPool();
      function deserializeDynamic(data, details, options) {
        var _options$reportMissin;
        options = options || {};
        const classFinder = options.classFinder || getClassById;
        const createAssetRefs = options.createAssetRefs || sys.platform === Platform.EDITOR_CORE;
        const customEnv = options.customEnv;
        const ignoreEditorOnly = options.ignoreEditorOnly;
        const reportMissingClass = (_options$reportMissin = options.reportMissingClass) !== null && _options$reportMissin !== void 0 ? _options$reportMissin : legacyCC.deserialize.reportMissingClass;
        details.init();
        const deserializer = _Deserializer.pool.get(details, classFinder, reportMissingClass, customEnv, ignoreEditorOnly);
        legacyCC.game._isCloning = true;
        const res = deserializer.deserialize(data);
        legacyCC.game._isCloning = false;
        _Deserializer.pool.put(deserializer);
        if (createAssetRefs) {
          details.assignAssetsBy((uuid, options) => EditorExtends.serialize.asAsset(uuid, options.type));
        }
        return res;
      }

      function reportMissingClass(id) {
        {
          errorID(5302, id);
        }
      }

      const constructorMap = [Vec2, Vec3, Vec4, Quat, Color$1, Size$1, Rect$1, Mat4];
      function vec4LikeSetter(obj, data) {
        obj.x = data[1];
        obj.y = data[2];
        obj.z = data[3];
        obj.w = data[4];
      }
      const setterMap = [(obj, data) => {
        obj.x = data[1];
        obj.y = data[2];
      }, (obj, data) => {
        obj.x = data[1];
        obj.y = data[2];
        obj.z = data[3];
      }, vec4LikeSetter, vec4LikeSetter, (obj, data) => {
        obj._val = data[1];
      }, (obj, data) => {
        obj.width = data[1];
        obj.height = data[2];
      }, (obj, data) => {
        obj.x = data[1];
        obj.y = data[2];
        obj.width = data[3];
        obj.height = data[4];
      }, (obj, data) => {
        Mat4.fromArray(obj, data, 1);
      }];
      function deserializeBuiltinValueType(data, owner, key, value) {
        const typeIndex = value[0];
        assertIsTrue(typeIndex >= 0 && typeIndex < constructorMap.length);
        const object = new constructorMap[typeIndex]();
        const setter = setterMap[typeIndex];
        setter(object, value);
        owner[key] = object;
      }
      function deserializeBuiltinValueTypeInto(data, owner, key, value) {
        const typeIndex = value[0];
        assertIsTrue(typeIndex >= 0 && typeIndex < constructorMap.length);
        {
          const tmp = owner[key];
          const setter = setterMap[typeIndex];
          setter(tmp, value);
          owner[key] = tmp;
        }
      }

      const SUPPORT_MIN_FORMAT_VERSION = 1;
      const EMPTY_PLACEHOLDER = 0;
      const DataTypeID = {
        SimpleType: 0,
        InstanceRef: 1,
        Array_InstanceRef: 2,
        Array_AssetRefByInnerObj: 3,
        Class: 4,
        ValueTypeCreated: 5,
        AssetRefByInnerObj: 6,
        TRS: 7,
        ValueType: 8,
        Array_Class: 9,
        CustomizedClass: 10,
        Dict: 11,
        Array: 12,
        ARRAY_LENGTH: 13
      };
      const CLASS_TYPE = 0;
      const CLASS_KEYS = 1;
      const CLASS_PROP_TYPE_OFFSET = 2;
      const MASK_CLASS = 0;
      const OBJ_DATA_MASK = 0;
      const CUSTOM_OBJ_DATA_CLASS = 0;
      const CUSTOM_OBJ_DATA_CONTENT = 1;
      const DICT_JSON_LAYOUT = 0;
      const ARRAY_ITEM_VALUES = 0;
      const Refs = {
        EACH_RECORD_LENGTH: 3,
        OWNER_OFFSET: 0,
        KEY_OFFSET: 1,
        TARGET_OFFSET: 2
      };
      const File = {
        Version: 0,
        Context: 0,
        SharedUuids: 1,
        SharedStrings: 2,
        SharedClasses: 3,
        SharedMasks: 4,
        Instances: 5,
        InstanceTypes: 6,
        Refs: 7,
        DependObjs: 8,
        DependKeys: 9,
        DependUuidIndices: 10,
        ARRAY_LENGTH: 11
      };
      const PACKED_SECTIONS = File.Instances;
      class Details {
        constructor() {
          this.uuidObjList = null;
          this.uuidPropList = null;
          this.uuidList = null;
          this.uuidTypeList = [];
        }
        init(data) {
          if (data) {
            this.uuidObjList = data[File.DependObjs];
            this.uuidPropList = data[File.DependKeys];
            this.uuidList = data[File.DependUuidIndices];
          } else {
            const used = this.uuidList;
            if (!used) {
              this.uuidList = [];
              this.uuidObjList = [];
              this.uuidPropList = [];
              this.uuidTypeList = [];
            }
          }
        }
        reset() {
          {
            const used = this.uuidList;
            if (used) {
              this.uuidList.length = 0;
              this.uuidObjList.length = 0;
              this.uuidPropList.length = 0;
              this.uuidTypeList.length = 0;
            }
          }
        }
        push(obj, propName, uuid, type) {
          this.uuidObjList.push(obj);
          this.uuidPropList.push(propName);
          this.uuidList.push(uuid);
          this.uuidTypeList.push(type || '');
        }
      } exports('Details', Details);
      Details.pool = new Pool$1(obj => {
        obj.reset();
      }, 5);
      Details.pool.get = function () {
        return this._get() || new Details();
      };
      function dereference(refs, instances, strings) {
        const dataLength = refs.length - 1;
        let i = 0;
        const instanceOffset = refs[dataLength] * Refs.EACH_RECORD_LENGTH;
        for (; i < instanceOffset; i += Refs.EACH_RECORD_LENGTH) {
          const owner = refs[i];
          const target = instances[refs[i + Refs.TARGET_OFFSET]];
          const keyIndex = refs[i + Refs.KEY_OFFSET];
          if (keyIndex >= 0) {
            owner[strings[keyIndex]] = target;
          } else {
            owner[~keyIndex] = target;
          }
        }
        for (; i < dataLength; i += Refs.EACH_RECORD_LENGTH) {
          const owner = instances[refs[i]];
          const target = instances[refs[i + Refs.TARGET_OFFSET]];
          const keyIndex = refs[i + Refs.KEY_OFFSET];
          if (keyIndex >= 0) {
            owner[strings[keyIndex]] = target;
          } else {
            owner[~keyIndex] = target;
          }
        }
      }
      function deserializeCCObject(data, objectData) {
        const mask = data[File.SharedMasks][objectData[OBJ_DATA_MASK]];
        const clazz = mask[MASK_CLASS];
        const ctor = clazz[CLASS_TYPE];
        const obj = new ctor();
        const keys = clazz[CLASS_KEYS];
        const classTypeOffset = clazz[CLASS_PROP_TYPE_OFFSET];
        const maskTypeOffset = mask[mask.length - 1];
        let i = MASK_CLASS + 1;
        for (; i < maskTypeOffset; ++i) {
          const key = keys[mask[i]];
          obj[key] = objectData[i];
        }
        for (; i < objectData.length; ++i) {
          const key = keys[mask[i]];
          const type = clazz[mask[i] + classTypeOffset];
          const op = ASSIGNMENTS[type];
          op(data, obj, key, objectData[i]);
        }
        return obj;
      }
      function deserializeCustomCCObject(data, ctor, value) {
        const obj = new ctor();
        if (obj._deserialize) {
          obj._deserialize(value, data[File.Context]);
        } else {
          errorID(5303, getClassName(ctor));
        }
        return obj;
      }
      function assignSimple(data, owner, key, value) {
        owner[key] = value;
      }
      function assignInstanceRef(data, owner, key, value) {
        if (value >= 0) {
          owner[key] = data[File.Instances][value];
        } else {
          data[File.Refs][~value * Refs.EACH_RECORD_LENGTH] = owner;
        }
      }
      function genArrayParser(parser) {
        return (data, owner, key, value) => {
          for (let i = 0; i < value.length; ++i) {
            parser(data, value, i, value[i]);
          }
          owner[key] = value;
        };
      }
      function parseAssetRefByInnerObj(data, owner, key, value) {
        owner[key] = null;
        data[File.DependObjs][value] = owner;
      }
      function parseClass(data, owner, key, value) {
        owner[key] = deserializeCCObject(data, value);
      }
      function parseCustomClass(data, owner, key, value) {
        const ctor = data[File.SharedClasses][value[CUSTOM_OBJ_DATA_CLASS]];
        owner[key] = deserializeCustomCCObject(data, ctor, value[CUSTOM_OBJ_DATA_CONTENT]);
      }
      function parseTRS(data, owner, key, value) {
        const typedArray = owner[key];
        typedArray.set(value);
      }
      function parseDict(data, owner, key, value) {
        const dict = value[DICT_JSON_LAYOUT];
        owner[key] = dict;
        for (let i = DICT_JSON_LAYOUT + 1; i < value.length; i += 3) {
          const subKey = value[i];
          const subType = value[i + 1];
          const subValue = value[i + 2];
          const op = ASSIGNMENTS[subType];
          op(data, dict, subKey, subValue);
        }
      }
      function parseArray(data, owner, key, value) {
        const array = value[ARRAY_ITEM_VALUES];
        for (let i = 0; i < array.length; ++i) {
          const subValue = array[i];
          const type = value[i + 1];
          if (type !== DataTypeID.SimpleType) {
            const op = ASSIGNMENTS[type];
            op(data, array, i, subValue);
          }
        }
        owner[key] = array;
      }
      const ASSIGNMENTS = new Array(DataTypeID.ARRAY_LENGTH);
      ASSIGNMENTS[DataTypeID.SimpleType] = assignSimple;
      ASSIGNMENTS[DataTypeID.InstanceRef] = assignInstanceRef;
      ASSIGNMENTS[DataTypeID.Array_InstanceRef] = genArrayParser(assignInstanceRef);
      ASSIGNMENTS[DataTypeID.Array_AssetRefByInnerObj] = genArrayParser(parseAssetRefByInnerObj);
      ASSIGNMENTS[DataTypeID.Class] = parseClass;
      ASSIGNMENTS[DataTypeID.ValueTypeCreated] = deserializeBuiltinValueTypeInto;
      ASSIGNMENTS[DataTypeID.AssetRefByInnerObj] = parseAssetRefByInnerObj;
      ASSIGNMENTS[DataTypeID.TRS] = parseTRS;
      ASSIGNMENTS[DataTypeID.ValueType] = deserializeBuiltinValueType;
      ASSIGNMENTS[DataTypeID.Array_Class] = genArrayParser(parseClass);
      ASSIGNMENTS[DataTypeID.CustomizedClass] = parseCustomClass;
      ASSIGNMENTS[DataTypeID.Dict] = parseDict;
      ASSIGNMENTS[DataTypeID.Array] = parseArray;
      function parseInstances(data) {
        const instances = data[File.Instances];
        const instanceTypes = data[File.InstanceTypes];
        const instanceTypesLen = instanceTypes === EMPTY_PLACEHOLDER ? 0 : instanceTypes.length;
        let rootIndex = instances[instances.length - 1];
        let normalObjectCount = instances.length - instanceTypesLen;
        if (typeof rootIndex !== 'number') {
          rootIndex = 0;
        } else {
          if (rootIndex < 0) {
            rootIndex = ~rootIndex;
          }
          --normalObjectCount;
        }
        let insIndex = 0;
        for (; insIndex < normalObjectCount; ++insIndex) {
          instances[insIndex] = deserializeCCObject(data, instances[insIndex]);
        }
        const classes = data[File.SharedClasses];
        for (let typeIndex = 0; typeIndex < instanceTypesLen; ++typeIndex, ++insIndex) {
          let type = instanceTypes[typeIndex];
          const eachData = instances[insIndex];
          if (type >= 0) {
            const ctor = classes[type];
            instances[insIndex] = deserializeCustomCCObject(data, ctor, eachData);
          } else {
            type = ~type;
            const op = ASSIGNMENTS[type];
            op(data, instances, insIndex, eachData);
          }
        }
        return rootIndex;
      }
      function getMissingClass(hasCustomFinder, type, reportMissingClass) {
        if (!hasCustomFinder) {
          reportMissingClass(type);
        }
        return Object;
      }
      function doLookupClass(classFinder, type, container, index, silent, hasCustomFinder, reportMissingClass) {
        let klass = classFinder(type);
        if (!klass) {
          if (silent) {
            container[index] = ((c, i, t) => function proxy() {
              const actualClass = classFinder(t) || getMissingClass(hasCustomFinder, t, reportMissingClass);
              c[i] = actualClass;
              return new actualClass();
            })(container, index, type);
            return;
          } else {
            klass = getMissingClass(hasCustomFinder, type, reportMissingClass);
          }
        }
        container[index] = klass;
      }
      function lookupClasses(data, silent, customFinder, reportMissingClass) {
        const classFinder = customFinder || getClassById;
        const classes = data[File.SharedClasses];
        for (let i = 0; i < classes.length; ++i) {
          const klassLayout = classes[i];
          if (typeof klassLayout !== 'string') {
            {
              if (typeof klassLayout[CLASS_TYPE] === 'function') {
                throw new Error('Can not deserialize the same JSON data again.');
              }
            }
            const type = klassLayout[CLASS_TYPE];
            doLookupClass(classFinder, type, klassLayout, CLASS_TYPE, silent, customFinder, reportMissingClass);
          } else {
            doLookupClass(classFinder, klassLayout, classes, i, silent, customFinder, reportMissingClass);
          }
        }
      }
      function cacheMasks(data) {
        const masks = data[File.SharedMasks];
        if (masks) {
          const classes = data[File.SharedClasses];
          for (let i = 0; i < masks.length; ++i) {
            const mask = masks[i];
            mask[MASK_CLASS] = classes[mask[MASK_CLASS]];
          }
        }
      }
      function parseResult(data) {
        const instances = data[File.Instances];
        const sharedStrings = data[File.SharedStrings];
        const dependSharedUuids = data[File.SharedUuids];
        const dependObjs = data[File.DependObjs];
        const dependKeys = data[File.DependKeys];
        const dependUuids = data[File.DependUuidIndices];
        for (let i = 0; i < dependObjs.length; ++i) {
          const obj = dependObjs[i];
          if (typeof obj === 'number') {
            dependObjs[i] = instances[obj];
          }
          let key = dependKeys[i];
          if (typeof key === 'number') {
            if (key >= 0) {
              key = sharedStrings[key];
            } else {
              key = ~key;
            }
            dependKeys[i] = key;
          }
          const uuid = dependUuids[i];
          if (typeof uuid === 'number') {
            dependUuids[i] = dependSharedUuids[uuid];
          }
        }
      }
      function isCompiledJson(json) {
        if (Array.isArray(json)) {
          const version = json[0];
          return typeof version === 'number' || version instanceof FileInfo;
        } else {
          return false;
        }
      }
      function initializeDeserializationContext(data, details, options) {
        var _options;
        details.init(data);
        (_options = options) !== null && _options !== void 0 ? _options : options = {};
        let version = data[File.Version];
        let preprocessed = false;
        if (typeof version === 'object') {
          preprocessed = version.preprocessed;
          version = version.version;
        }
        if (version < SUPPORT_MIN_FORMAT_VERSION) {
          throw new Error(getError(5304, version));
        }
        const context = options;
        context._version = version;
        context.result = details;
        data[File.Context] = context;
        if (!preprocessed) {
          var _options$reportMissin;
          lookupClasses(data, false, options.classFinder, (_options$reportMissin = options.reportMissingClass) !== null && _options$reportMissin !== void 0 ? _options$reportMissin : deserialize.reportMissingClass);
          cacheMasks(data);
        }
      }
      function deserialize(data, details, options) {
        if (typeof data === 'string') {
          data = JSON.parse(data);
        }
        let isBorrowedDetails = false;
        if (!details) {
          const borrowedDetails = Details.pool.get();
          assertIsTrue(borrowedDetails, `Can not allocate deserialization details`);
          details = borrowedDetails;
          isBorrowedDetails = true;
        }
        let res;
        if (!isCompiledJson(data)) {
          res = deserializeDynamic(data, details, options);
        } else {
          initializeDeserializationContext(data, details, options);
          const runtimeData = data;
          legacyCC.game._isCloning = true;
          const instances = runtimeData[File.Instances];
          const rootIndex = parseInstances(runtimeData);
          legacyCC.game._isCloning = false;
          if (runtimeData[File.Refs]) {
            dereference(runtimeData[File.Refs], instances, runtimeData[File.SharedStrings]);
          }
          parseResult(runtimeData);
          res = instances[rootIndex];
        }
        if (isBorrowedDetails) {
          Details.pool.put(details);
        }
        return res;
      }
      deserialize.Details = Details;
      deserialize.reportMissingClass = reportMissingClass;
      class FileInfo {
        constructor(version) {
          this.preprocessed = true;
          this.version = version;
        }
      }
      function unpackJSONs(data, classFinder, reportMissingClass) {
        if (data[File.Version] < SUPPORT_MIN_FORMAT_VERSION) {
          throw new Error(getError(5304, data[File.Version]));
        }
        lookupClasses(data, true, classFinder, reportMissingClass !== null && reportMissingClass !== void 0 ? reportMissingClass : deserialize.reportMissingClass);
        cacheMasks(data);
        const version = new FileInfo(data[File.Version]);
        const sharedUuids = data[File.SharedUuids];
        const sharedStrings = data[File.SharedStrings];
        const sharedClasses = data[File.SharedClasses];
        const sharedMasks = data[File.SharedMasks];
        const sections = data[PACKED_SECTIONS];
        for (let i = 0; i < sections.length; ++i) {
          const section = sections[i];
          section.unshift(version, sharedUuids, sharedStrings, sharedClasses, sharedMasks);
        }
        return sections;
      }
      function packCustomObjData(type, data, hasNativeDep) {
        return [SUPPORT_MIN_FORMAT_VERSION, EMPTY_PLACEHOLDER, EMPTY_PLACEHOLDER, [type], EMPTY_PLACEHOLDER, hasNativeDep ? [data, ~0] : [data], [0], EMPTY_PLACEHOLDER, [], [], []];
      }
      function hasNativeDep(data) {
        const instances = data[File.Instances];
        const rootInfo = instances[instances.length - 1];
        if (typeof rootInfo !== 'number') {
          return false;
        } else {
          return rootInfo < 0;
        }
      }
      function getDependUuidList(json) {
        const sharedUuids = json[File.SharedUuids];
        return json[File.DependUuidIndices].map(index => sharedUuids[index]);
      }
      function parseUuidDependencies(serialized) {
        {
          return getDependUuidList(serialized);
        }
      }
      legacyCC.deserialize = deserialize;

      const dependMap = new WeakMap();
      const nativeDependMap = new WeakSet();
      const onLoadedInvokedMap = new WeakSet();

      function deserializeAsset(json, options) {
        let classFinder;
        {
          classFinder = MissingScript.safeFindClass;
        }
        const tdInfo = Details.pool.get();
        let asset;
        try {
          asset = deserialize(json, tdInfo, {
            classFinder,
            customEnv: options
          });
        } catch (e) {
          error(e);
          Details.pool.put(tdInfo);
          throw e;
        }
        asset._uuid = options.__uuid__ || '';
        const uuidList = tdInfo.uuidList;
        const objList = tdInfo.uuidObjList;
        const propList = tdInfo.uuidPropList;
        const typeList = tdInfo.uuidTypeList || [];
        const depends = [];
        for (let i = 0; i < uuidList.length; i++) {
          const dependUuid = uuidList[i];
          depends[i] = {
            uuid: decodeUuid(dependUuid),
            owner: objList[i],
            prop: propList[i],
            type: getClassById(typeList[i])
          };
        }
        dependMap.set(asset, depends);
        if (asset._native) {
          nativeDependMap.add(asset);
        }
        Details.pool.put(tdInfo);
        return asset;
      }

      class DependUtil {
        static get instance() {
          if (!this._instance) {
            this._instance = new DependUtil();
          }
          return this._instance;
        }
        constructor() {
          this._depends = new Cache();
        }
        init() {
          this._depends.clear();
        }
        getNativeDep(uuid) {
          const depend = this._depends.get(uuid);
          if (depend && depend.nativeDep) {
            return {
              ...depend.nativeDep
            };
          }
          return null;
        }
        getDeps(uuid) {
          if (this._depends.has(uuid)) {
            return this._depends.get(uuid).deps;
          }
          return [];
        }
        getDepsRecursively(uuid) {
          const exclude = Object.create(null);
          const depends = [];
          this._descend(uuid, exclude, depends);
          return depends;
        }
        remove(uuid) {
          this._depends.remove(uuid);
        }
        parse(uuid, json) {
          let out = null;
          if (Array.isArray(json) || json.__type__ || json instanceof CCON) {
            if (this._depends.has(uuid)) {
              return this._depends.get(uuid);
            }
            if (Array.isArray(json) && (!hasNativeDep(json))) {
              out = {
                deps: this._parseDepsFromJson(json)
              };
            } else {
              try {
                const asset = deserializeAsset(json, {
                  __uuid__: uuid
                });
                out = this._parseDepsFromAsset(asset);
                if (out.nativeDep) {
                  out.nativeDep.uuid = uuid;
                }
                parsed.add(`${uuid}@import`, asset);
              } catch (e) {
                files.remove(`${uuid}@import`);
                out = {
                  deps: []
                };
              }
            }
          } else {
            if (this._depends.has(uuid)) {
              out = this._depends.get(uuid);
              if (out.parsedFromExistAsset) {
                return out;
              }
            }
            out = this._parseDepsFromAsset(json);
          }
          this._depends.add(uuid, out);
          return out;
        }
        _parseDepsFromAsset(asset) {
          const out = {
            deps: [],
            parsedFromExistAsset: true
          };
          const deps = dependMap.get(asset);
          assertIsNonNullable(deps);
          for (let i = 0, l = deps.length; i < l; i++) {
            out.deps.push(deps[i].uuid);
          }
          if (nativeDependMap.has(asset)) {
            out.nativeDep = asset._nativeDep;
          }
          return out;
        }
        _parseDepsFromJson(json) {
          const depends = parseUuidDependencies(json);
          depends.forEach((uuid, index) => depends[index] = decodeUuid(uuid));
          return depends;
        }
        _descend(uuid, exclude, depends) {
          const deps = this.getDeps(uuid);
          for (let i = 0; i < deps.length; i++) {
            const depend = deps[i];
            if (!exclude[depend]) {
              exclude[depend] = true;
              depends.push(depend);
              this._descend(depend, exclude, depends);
            }
          }
        }
      }
      DependUtil._instance = void 0;
      var dependUtil = DependUtil.instance;

      const textureBaseProto$1 = jsb.TextureBase.prototype;
      textureBaseProto$1._serialize = function (ctxForExporting) {
        return '';
      };
      textureBaseProto$1._deserialize = function (serializedData, handle) {
        const data = serializedData;
        const fields = data.split(',');
        fields.unshift('');
        if (fields.length >= 5) {
          this.setFilters(parseInt(fields[1]), parseInt(fields[2]));
          this.setWrapMode(parseInt(fields[3]), parseInt(fields[4]));
        }
        if (fields.length >= 7) {
          this.setMipFilter(parseInt(fields[5]));
          this.setAnisotropy(parseInt(fields[6]));
        }
      };
      textureBaseProto$1._getGFXDevice = function () {
        return deviceManager.gfxDevice;
      };
      textureBaseProto$1._getGFXFormat = function () {
        return this._getGFXPixelFormat(this.format);
      };
      textureBaseProto$1._setGFXFormat = function (format) {
        this.format = format === undefined ? PixelFormat.RGBA8888 : format;
      };
      textureBaseProto$1._getGFXPixelFormat = function (format) {
        if (format === PixelFormat.RGBA_ETC1) {
          format = PixelFormat.RGB_ETC1;
        } else if (format === PixelFormat.RGB_A_PVRTC_4BPPV1) {
          format = PixelFormat.RGB_PVRTC_4BPPV1;
        } else if (format === PixelFormat.RGB_A_PVRTC_2BPPV1) {
          format = PixelFormat.RGB_PVRTC_2BPPV1;
        }
        return format;
      };
      textureBaseProto$1.createNode = null;
      const TextureBase = jsb.TextureBase;
      TextureBase.Filter = Filter;
      TextureBase.PixelFormat = PixelFormat;
      TextureBase.WrapMode = WrapMode;
      textureBaseProto$1._ctor = function () {
        jsb.Asset.prototype._ctor.apply(this, arguments);
        this._gfxSampler = null;
        this._samplerInfo = null;
        this._textureHash = 0;
        this._registerGFXSamplerUpdatedListener();
      };
      const oldGetGFXSampler = textureBaseProto$1.getGFXSampler;
      textureBaseProto$1.getGFXSampler = function () {
        if (!this._gfxSampler) {
          this._gfxSampler = oldGetGFXSampler.call(this);
        }
        return this._gfxSampler;
      };
      const oldGetHash = textureBaseProto$1.getHash;
      textureBaseProto$1.getHash = function () {
        if (this._textureHash === 0) {
          this._textureHash = oldGetHash.call(this);
        }
        return this._textureHash;
      };
      const oldGetSamplerInfo = textureBaseProto$1.getSamplerInfo;
      textureBaseProto$1.getSamplerInfo = function () {
        if (!this._samplerInfo) {
          this._samplerInfo = oldGetSamplerInfo.call(this);
        }
        return this._samplerInfo;
      };
      const oldDestroy = textureBaseProto$1.destroy;
      textureBaseProto$1.destroy = function () {
        var _cclegacy$director$ro;
        if ((_cclegacy$director$ro = legacyCC.director.root) !== null && _cclegacy$director$ro !== void 0 && _cclegacy$director$ro.batcher2D) {
          legacyCC.director.root.batcher2D._releaseDescriptorSetCache(this.getGFXTexture(), this.getGFXSampler());
        }
        return oldDestroy.call(this);
      };
      textureBaseProto$1._onGFXSamplerUpdated = function (gfxSampler, samplerInfo) {
        this._gfxSampler = gfxSampler;
        this._samplerInfo = samplerInfo;
      };
      legacyCC.TextureBase = jsb.TextureBase;
      patch_cc_TextureBase({
        TextureBase,
        Filter,
        WrapMode,
        PixelFormat
      });

      const SimpleTexture = jsb.SimpleTexture;
      const jsbWindow = jsb.window;
      SimpleTexture.Filter = Filter;
      SimpleTexture.PixelFormat = PixelFormat;
      SimpleTexture.WrapMode = WrapMode;
      const simpleTextureProto = jsb.SimpleTexture.prototype;
      const oldUpdateDataFunc = simpleTextureProto.uploadData;
      simpleTextureProto.uploadData = function (source, level = 0, arrayIndex = 0) {
        let data;
        if (source instanceof jsbWindow.HTMLCanvasElement) {
          data = source.data;
        } else if (source instanceof jsbWindow.HTMLImageElement) {
          data = source._data;
        } else if (ArrayBuffer.isView(source)) {
          data = source.buffer;
        }
        oldUpdateDataFunc.call(this, data, level, arrayIndex);
      };
      simpleTextureProto._ctor = function () {
        jsb.TextureBase.prototype._ctor.apply(this, arguments);
        this._gfxTexture = null;
        this._registerListeners();
      };
      const oldGetGFXTexture = simpleTextureProto.getGFXTexture;
      simpleTextureProto.getGFXTexture = function () {
        if (!this._gfxTexture) {
          this._gfxTexture = oldGetGFXTexture.call(this);
        }
        return this._gfxTexture;
      };
      simpleTextureProto._onGFXTextureUpdated = function (gfxTexture) {
        this._gfxTexture = gfxTexture;
      };
      simpleTextureProto._onAfterAssignImage = function (image) {
        if (macro.CLEANUP_IMAGE_CACHE) {
          const deps = dependUtil.getDeps(this._uuid);
          const index = deps.indexOf(image._uuid);
          if (index !== -1) {
            fastRemoveAt$2(deps, index);
            image.decRef();
          }
        }
      };
      patch_cc_SimpleTexture({
        SimpleTexture
      });
      legacyCC.SimpleTexture = jsb.SimpleTexture;

      const texture2DProto = jsb.Texture2D.prototype;
      texture2DProto.createNode = null;
      const Texture2D$1 = exports('Texture2D', jsb.Texture2D);
      Texture2D$1.Filter = Filter;
      Texture2D$1.PixelFormat = PixelFormat;
      Texture2D$1.WrapMode = WrapMode;
      texture2DProto._ctor = function () {
        SimpleTexture.prototype._ctor.apply(this, arguments);
        this._mipmaps = [];
      };
      texture2DProto._serialize = function (ctxForExporting) {
        return null;
      };
      texture2DProto._deserialize = function (serializedData, handle) {
        const data = serializedData;
        TextureBase.prototype._deserialize.call(this, data.base, undefined);
        this._mipmaps = new Array(data.mipmaps.length);
        for (let i = 0; i < data.mipmaps.length; ++i) {
          this._mipmaps[i] = new ImageAsset$1();
          if (!data.mipmaps[i]) {
            continue;
          }
          const mipmapUUID = data.mipmaps[i];
          handle.result.push(this._mipmaps, `${i}`, mipmapUUID, getClassId(ImageAsset$1));
        }
      };
      const oldOnLoaded$2 = texture2DProto.onLoaded;
      texture2DProto.onLoaded = function () {
        this.syncMipmapsForJS(this._mipmaps);
        oldOnLoaded$2.call(this);
      };
      Object.defineProperty(texture2DProto, 'image', {
        configurable: true,
        enumerable: true,
        get() {
          return this._mipmaps.length === 0 ? null : this._mipmaps[0];
        },
        set(value) {
          this.mipmaps = value ? [value] : [];
        }
      });
      Object.defineProperty(texture2DProto, 'mipmaps', {
        configurable: true,
        enumerable: true,
        get() {
          return this._mipmaps;
        },
        set(arr) {
          for (let i = 0, len = arr.length; i < len; ++i) {
            arr[i]._syncDataToNative();
          }
          this._mipmaps = arr;
          this.setMipmaps(arr);
        }
      });
      legacyCC.Texture2D = jsb.Texture2D;
      patch_cc_Texture2D({
        Texture2D: Texture2D$1,
        ImageAsset: ImageAsset$1
      });

      const space$1 = 2;
      class Atlas {
        constructor(width, height) {
          this._texture = void 0;
          this._width = void 0;
          this._height = void 0;
          this._x = void 0;
          this._y = void 0;
          this._nexty = void 0;
          this._innerTextureInfos = {};
          this._innerSpriteFrames = void 0;
          this._count = void 0;
          const texture = new DynamicAtlasTexture();
          texture.initWithSize(width, height);
          this._texture = texture;
          this._width = width;
          this._height = height;
          this._x = space$1;
          this._y = space$1;
          this._nexty = space$1;
          this._innerTextureInfos = {};
          this._innerSpriteFrames = [];
          this._count = 0;
        }
        insertSpriteFrame(spriteFrame) {
          const rect = spriteFrame.rect;
          const texture = spriteFrame.texture;
          const info = this._innerTextureInfos[texture.getId()];
          let sx = rect.x;
          let sy = rect.y;
          if (info) {
            sx += info.x;
            sy += info.y;
          } else {
            const width = texture.width;
            const height = texture.height;
            if (this._x + width + space$1 > this._width) {
              this._x = space$1;
              this._y = this._nexty;
            }
            if (this._y + height + space$1 > this._nexty) {
              this._nexty = this._y + height + space$1;
            }
            if (this._nexty > this._height) {
              return null;
            }
            if (legacyCC.internal.dynamicAtlasManager.textureBleeding) {
              if (width <= 8 || height <= 8) {
                this._texture.drawTextureAt(texture.image, this._x - 1, this._y - 1);
                this._texture.drawTextureAt(texture.image, this._x - 1, this._y + 1);
                this._texture.drawTextureAt(texture.image, this._x + 1, this._y - 1);
                this._texture.drawTextureAt(texture.image, this._x + 1, this._y + 1);
              }
              this._texture.drawTextureAt(texture.image, this._x - 1, this._y);
              this._texture.drawTextureAt(texture.image, this._x + 1, this._y);
              this._texture.drawTextureAt(texture.image, this._x, this._y - 1);
              this._texture.drawTextureAt(texture.image, this._x, this._y + 1);
            }
            this._texture.drawTextureAt(texture.image, this._x, this._y);
            this._innerTextureInfos[texture.getId()] = {
              x: this._x,
              y: this._y,
              texture
            };
            this._count++;
            sx += this._x;
            sy += this._y;
            this._x += width + space$1;
          }
          const frame = {
            x: sx,
            y: sy,
            texture: this._texture
          };
          this._innerSpriteFrames.push(spriteFrame);
          return frame;
        }
        deleteInnerTexture(texture) {
          if (texture && this._innerTextureInfos[texture.getId()]) {
            delete this._innerTextureInfos[texture.getId()];
            this._count--;
          }
        }
        isEmpty() {
          return this._count <= 0;
        }
        reset() {
          this._x = space$1;
          this._y = space$1;
          this._nexty = space$1;
          const frames = this._innerSpriteFrames;
          for (let i = 0, l = frames.length; i < l; i++) {
            const frame = frames[i];
            if (!frame.isValid) {
              continue;
            }
            frame._resetDynamicAtlasFrame();
          }
          this._innerSpriteFrames.length = 0;
          this._innerTextureInfos = {};
        }
        destroy() {
          this.reset();
          this._texture.destroy();
        }
      }
      class DynamicAtlasTexture extends Texture2D$1 {
        initWithSize(width, height, format = PixelFormat.RGBA8888) {
          this.reset({
            width,
            height,
            format
          });
        }
        drawTextureAt(image, x, y) {
          const gfxTexture = this.getGFXTexture();
          if (!image || !gfxTexture) {
            return;
          }
          const gfxDevice = this._getGFXDevice();
          if (!gfxDevice) {
            console.warn('Unable to get device');
            return;
          }
          const region = new BufferTextureCopy();
          region.texOffset.x = x;
          region.texOffset.y = y;
          region.texExtent.width = image.width;
          region.texExtent.height = image.height;
          gfxDevice.copyTexImagesToTexture([image.data], gfxTexture, [region]);
        }
      }

      const SceneAsset = exports('SceneAsset', jsb.SceneAsset);
      legacyCC.SceneAsset = SceneAsset;
      const sceneAssetProto = SceneAsset.prototype;
      Object.defineProperty(sceneAssetProto, 'scene', {
        enumerable: true,
        configurable: true,
        get() {
          if (!this._scene) {
            this._scene = this.getScene();
          }
          return this._scene;
        },
        set(v) {
          this._scene = v;
          this.setScene(v);
        }
      });
      sceneAssetProto._ctor = function () {
        jsb.Asset.prototype._ctor.apply(this, arguments);
        this._scene = null;
      };
      patch_cc_SceneAsset({
        SceneAsset
      });

      deprecateModuleExportedName({
        SystemEventType: {
          newName: 'Input.EventType',
          since: '3.3.0',
          removed: false
        }
      });

      deprecateModuleExportedName({
        SystemEvent: {
          newName: 'Input',
          since: '3.4.0',
          removed: false
        },
        systemEvent: {
          newName: 'input',
          since: '3.4.0',
          removed: false
        }
      });

      class Event {
        constructor(type, bubbles) {
          this.type = void 0;
          this.bubbles = void 0;
          this.target = null;
          this.currentTarget = null;
          this.eventPhase = 0;
          this.propagationStopped = false;
          this.propagationImmediateStopped = false;
          this.type = type;
          this.bubbles = !!bubbles;
        }
        unuse() {
          this.type = Event.NO_TYPE;
          this.target = null;
          this.currentTarget = null;
          this.eventPhase = Event.NONE;
          this.propagationStopped = false;
          this.propagationImmediateStopped = false;
        }
        reuse(type, bubbles) {
          this.type = type;
          this.bubbles = bubbles || false;
        }
        isStopped() {
          return this.propagationStopped || this.propagationImmediateStopped;
        }
        getCurrentTarget() {
          return this.currentTarget;
        }
        getType() {
          return this.type;
        }
      } exports('Event', Event);
      Event.NO_TYPE = 'no_type';
      Event.TOUCH = 'touch';
      Event.MOUSE = 'mouse';
      Event.KEYBOARD = 'keyboard';
      Event.ACCELERATION = 'acceleration';
      Event.NONE = 0;
      Event.CAPTURING_PHASE = 1;
      Event.AT_TARGET = 2;
      Event.BUBBLING_PHASE = 3;
      legacyCC.Event = Event;

      let SystemEventType; exports('SystemEventType', SystemEventType);
      (function (SystemEventType) {
        SystemEventType["TOUCH_START"] = "touch-start";
        SystemEventType["TOUCH_MOVE"] = "touch-move";
        SystemEventType["TOUCH_END"] = "touch-end";
        SystemEventType["TOUCH_CANCEL"] = "touch-cancel";
        SystemEventType["MOUSE_DOWN"] = "mouse-down";
        SystemEventType["MOUSE_MOVE"] = "mouse-move";
        SystemEventType["MOUSE_UP"] = "mouse-up";
        SystemEventType["MOUSE_WHEEL"] = "mouse-wheel";
        SystemEventType["MOUSE_ENTER"] = "mouse-enter";
        SystemEventType["MOUSE_LEAVE"] = "mouse-leave";
        SystemEventType["KEY_DOWN"] = "keydown";
        SystemEventType["KEY_UP"] = "keyup";
        SystemEventType["DEVICEMOTION"] = "devicemotion";
        SystemEventType["TRANSFORM_CHANGED"] = "transform-changed";
        SystemEventType["SCENE_CHANGED_FOR_PERSISTS"] = "scene-changed-for-persists";
        SystemEventType["SIZE_CHANGED"] = "size-changed";
        SystemEventType["ANCHOR_CHANGED"] = "anchor-changed";
        SystemEventType["COLOR_CHANGED"] = "color-changed";
        SystemEventType["CHILD_ADDED"] = "child-added";
        SystemEventType["CHILD_REMOVED"] = "child-removed";
        SystemEventType["PARENT_CHANGED"] = "parent-changed";
        SystemEventType["NODE_DESTROYED"] = "node-destroyed";
        SystemEventType["LAYER_CHANGED"] = "layer-changed";
        SystemEventType["SIBLING_ORDER_CHANGED"] = "sibling-order-changed";
      })(SystemEventType || (exports('SystemEventType', SystemEventType = {})));
      let InputEventType;
      (function (InputEventType) {
        InputEventType["TOUCH_START"] = "touch-start";
        InputEventType["TOUCH_MOVE"] = "touch-move";
        InputEventType["TOUCH_END"] = "touch-end";
        InputEventType["TOUCH_CANCEL"] = "touch-cancel";
        InputEventType["MOUSE_DOWN"] = "mouse-down";
        InputEventType["MOUSE_MOVE"] = "mouse-move";
        InputEventType["MOUSE_UP"] = "mouse-up";
        InputEventType["MOUSE_WHEEL"] = "mouse-wheel";
        InputEventType["KEY_DOWN"] = "keydown";
        InputEventType["KEY_PRESSING"] = "key-pressing";
        InputEventType["KEY_UP"] = "keyup";
        InputEventType["DEVICEMOTION"] = "devicemotion";
        InputEventType["GAMEPAD_INPUT"] = "gamepad-input";
        InputEventType["GAMEPAD_CHANGE"] = "gamepad-change";
        InputEventType["HANDLE_INPUT"] = "handle-input";
        InputEventType["HANDLE_POSE_INPUT"] = "handle-pose-input";
        InputEventType["HMD_POSE_INPUT"] = "hmd-pose-input";
        InputEventType["HANDHELD_POSE_INPUT"] = "handheld-pose-input";
      })(InputEventType || (InputEventType = {}));
      legacyCC.SystemEventType = SystemEventType;

      class EventAcceleration extends Event {
        constructor(acc, bubbles) {
          super(SystemEventType.DEVICEMOTION, bubbles);
          this.acc = void 0;
          this.acc = acc;
        }
      } exports('EventAcceleration', EventAcceleration);
      Event.EventAcceleration = EventAcceleration;

      class EventKeyboard extends Event {
        get isPressed() {
          return this._isPressed;
        }
        constructor(keyCode, eventType, bubbles) {
          if (typeof eventType === 'boolean') {
            const isPressed = eventType;
            eventType = isPressed ? SystemEventType.KEY_DOWN : SystemEventType.KEY_UP;
          }
          super(eventType, bubbles);
          this.windowId = void 0;
          this.keyCode = void 0;
          this.rawEvent = void 0;
          this._isPressed = void 0;
          this._isPressed = eventType !== SystemEventType.KEY_UP;
          if (typeof keyCode === 'number') {
            this.keyCode = keyCode;
          } else {
            this.keyCode = keyCode.keyCode;
            this.rawEvent = keyCode;
          }
          this.windowId = 0;
        }
      } exports('EventKeyboard', EventKeyboard);
      Event.EventKeyboard = EventKeyboard;

      class EventMouse extends Event {
        get eventType() {
          return this._eventType;
        }
        constructor(eventType, bubbles, prevLoc, windowId) {
          super(eventType, bubbles);
          this.movementX = 0;
          this.movementY = 0;
          this.windowId = 0;
          this.preventSwallow = false;
          this._eventType = void 0;
          this._button = EventMouse.BUTTON_MISSING;
          this._x = 0;
          this._y = 0;
          this._prevX = 0;
          this._prevY = 0;
          this._scrollX = 0;
          this._scrollY = 0;
          this._eventType = eventType;
          if (prevLoc) {
            this._prevX = prevLoc.x;
            this._prevY = prevLoc.y;
          }
          this.windowId = windowId !== null && windowId !== void 0 ? windowId : this.windowId;
        }
        setScrollData(scrollX, scrollY) {
          this._scrollX = scrollX;
          this._scrollY = scrollY;
        }
        getScrollX() {
          return this._scrollX;
        }
        getScrollY() {
          return this._scrollY;
        }
        setLocation(x, y) {
          this._x = x;
          this._y = y;
        }
        getLocation(out) {
          if (!out) {
            out = new Vec2();
          }
          Vec2.set(out, this._x, this._y);
          return out;
        }
        getLocationInView(out) {
          if (!out) {
            out = new Vec2();
          }
          Vec2.set(out, this._x, legacyCC.view._designResolutionSize.height - this._y);
          return out;
        }
        getUILocation(out) {
          if (!out) {
            out = new Vec2();
          }
          Vec2.set(out, this._x, this._y);
          legacyCC.view._convertToUISpace(out);
          return out;
        }
        getPreviousLocation(out) {
          if (!out) {
            out = new Vec2();
          }
          Vec2.set(out, this._prevX, this._prevY);
          return out;
        }
        getUIPreviousLocation(out) {
          if (!out) {
            out = new Vec2();
          }
          Vec2.set(out, this._prevX, this._prevY);
          legacyCC.view._convertToUISpace(out);
          return out;
        }
        getDelta(out) {
          if (!out) {
            out = new Vec2();
          }
          Vec2.set(out, this._x - this._prevX, this._y - this._prevY);
          return out;
        }
        getDeltaX() {
          return this._x - this._prevX;
        }
        getDeltaY() {
          return this._y - this._prevY;
        }
        getUIDelta(out) {
          if (!out) {
            out = new Vec2();
          }
          Vec2.set(out, (this._x - this._prevX) / legacyCC.view.getScaleX(), (this._y - this._prevY) / legacyCC.view.getScaleY());
          return out;
        }
        getUIDeltaX() {
          return (this._x - this._prevX) / legacyCC.view.getScaleX();
        }
        getUIDeltaY() {
          return (this._y - this._prevY) / legacyCC.view.getScaleY();
        }
        setButton(button) {
          this._button = button;
        }
        getButton() {
          return this._button;
        }
        getLocationX() {
          return this._x;
        }
        getLocationY() {
          return this._y;
        }
        getUILocationX() {
          const viewport = legacyCC.view.getViewportRect();
          return (this._x - viewport.x) / legacyCC.view.getScaleX();
        }
        getUILocationY() {
          const viewport = legacyCC.view.getViewportRect();
          return (this._y - viewport.y) / legacyCC.view.getScaleY();
        }
      } exports('EventMouse', EventMouse);
      EventMouse.BUTTON_MISSING = -1;
      EventMouse.BUTTON_LEFT = 0;
      EventMouse.BUTTON_RIGHT = 2;
      EventMouse.BUTTON_MIDDLE = 1;
      EventMouse.BUTTON_4 = 3;
      EventMouse.BUTTON_5 = 4;
      EventMouse.BUTTON_6 = 5;
      EventMouse.BUTTON_7 = 6;
      EventMouse.BUTTON_8 = 7;
      Event.EventMouse = EventMouse;

      const _vec2$2 = new Vec2();
      class EventTouch extends Event {
        constructor(changedTouches, bubbles, eventType, touches = []) {
          super(eventType, bubbles);
          this.touch = null;
          this.simulate = false;
          this.windowId = 0;
          this.preventSwallow = false;
          this._eventCode = void 0;
          this._touches = void 0;
          this._allTouches = void 0;
          this._eventCode = eventType;
          this._touches = changedTouches || [];
          this._allTouches = touches;
        }
        getEventCode() {
          return this._eventCode;
        }
        getTouches() {
          return this._touches;
        }
        getAllTouches() {
          return this._allTouches;
        }
        setLocation(x, y) {
          if (this.touch) {
            this.touch.setTouchInfo(this.touch.getID(), x, y);
          }
        }
        getLocation(out) {
          return this.touch ? this.touch.getLocation(out) : new Vec2();
        }
        getUILocation(out) {
          return this.touch ? this.touch.getUILocation(out) : new Vec2();
        }
        getLocationInView(out) {
          return this.touch ? this.touch.getLocationInView(out) : new Vec2();
        }
        getPreviousLocation(out) {
          return this.touch ? this.touch.getPreviousLocation(out) : new Vec2();
        }
        getStartLocation(out) {
          return this.touch ? this.touch.getStartLocation(out) : new Vec2();
        }
        getUIStartLocation(out) {
          return this.touch ? this.touch.getUIStartLocation(out) : new Vec2();
        }
        getID() {
          return this.touch ? this.touch.getID() : null;
        }
        getDelta(out) {
          return this.touch ? this.touch.getDelta(out) : new Vec2();
        }
        getUIDelta(out) {
          return this.touch ? this.touch.getUIDelta(out) : new Vec2();
        }
        getDeltaX() {
          return this.touch ? this.touch.getDelta(_vec2$2).x : 0;
        }
        getDeltaY() {
          return this.touch ? this.touch.getDelta(_vec2$2).y : 0;
        }
        getLocationX() {
          return this.touch ? this.touch.getLocationX() : 0;
        }
        getLocationY() {
          return this.touch ? this.touch.getLocationY() : 0;
        }
      } exports('EventTouch', EventTouch);
      EventTouch.MAX_TOUCHES = 5;
      Event.EventTouch = EventTouch;

      class EventGamepad extends Event {
        constructor(type, gamepad) {
          super(type, false);
          this.gamepad = void 0;
          this.gamepad = gamepad;
        }
      } exports('EventGamepad', EventGamepad);

      class EventHandle extends Event {
        constructor(eventType, handleInputDevice) {
          super(eventType, false);
          this.handleInputDevice = void 0;
          this.handleInputDevice = handleInputDevice;
        }
      } exports('EventHandle', EventHandle);

      class EventHMD extends Event {
        constructor(eventType, hmdInputDevice) {
          super(eventType, false);
          this.hmdInputDevice = void 0;
          this.hmdInputDevice = hmdInputDevice;
        }
      } exports('EventHMD', EventHMD);

      class EventHandheld extends Event {
        constructor(eventType, handheldInputDevice) {
          super(eventType, false);
          this.handheldInputDevice = void 0;
          this.handheldInputDevice = handheldInputDevice;
        }
      } exports('EventHandheld', EventHandheld);

      class Acceleration {
        constructor(x = 0, y = 0, z = 0, timestamp = 0) {
          this.x = void 0;
          this.y = void 0;
          this.z = void 0;
          this.timestamp = void 0;
          this.x = x;
          this.y = y;
          this.z = z;
          this.timestamp = timestamp;
        }
      } exports('Acceleration', Acceleration);

      let KeyCode; exports('KeyCode', KeyCode);
      (function (KeyCode) {
        KeyCode[KeyCode["NONE"] = 0] = "NONE";
        KeyCode[KeyCode["MOBILE_BACK"] = 6] = "MOBILE_BACK";
        KeyCode[KeyCode["BACKSPACE"] = 8] = "BACKSPACE";
        KeyCode[KeyCode["TAB"] = 9] = "TAB";
        KeyCode[KeyCode["ENTER"] = 13] = "ENTER";
        KeyCode[KeyCode["SHIFT_LEFT"] = 16] = "SHIFT_LEFT";
        KeyCode[KeyCode["CTRL_LEFT"] = 17] = "CTRL_LEFT";
        KeyCode[KeyCode["ALT_LEFT"] = 18] = "ALT_LEFT";
        KeyCode[KeyCode["PAUSE"] = 19] = "PAUSE";
        KeyCode[KeyCode["CAPS_LOCK"] = 20] = "CAPS_LOCK";
        KeyCode[KeyCode["ESCAPE"] = 27] = "ESCAPE";
        KeyCode[KeyCode["SPACE"] = 32] = "SPACE";
        KeyCode[KeyCode["PAGE_UP"] = 33] = "PAGE_UP";
        KeyCode[KeyCode["PAGE_DOWN"] = 34] = "PAGE_DOWN";
        KeyCode[KeyCode["END"] = 35] = "END";
        KeyCode[KeyCode["HOME"] = 36] = "HOME";
        KeyCode[KeyCode["ARROW_LEFT"] = 37] = "ARROW_LEFT";
        KeyCode[KeyCode["ARROW_UP"] = 38] = "ARROW_UP";
        KeyCode[KeyCode["ARROW_RIGHT"] = 39] = "ARROW_RIGHT";
        KeyCode[KeyCode["ARROW_DOWN"] = 40] = "ARROW_DOWN";
        KeyCode[KeyCode["INSERT"] = 45] = "INSERT";
        KeyCode[KeyCode["DELETE"] = 46] = "DELETE";
        KeyCode[KeyCode["DIGIT_0"] = 48] = "DIGIT_0";
        KeyCode[KeyCode["DIGIT_1"] = 49] = "DIGIT_1";
        KeyCode[KeyCode["DIGIT_2"] = 50] = "DIGIT_2";
        KeyCode[KeyCode["DIGIT_3"] = 51] = "DIGIT_3";
        KeyCode[KeyCode["DIGIT_4"] = 52] = "DIGIT_4";
        KeyCode[KeyCode["DIGIT_5"] = 53] = "DIGIT_5";
        KeyCode[KeyCode["DIGIT_6"] = 54] = "DIGIT_6";
        KeyCode[KeyCode["DIGIT_7"] = 55] = "DIGIT_7";
        KeyCode[KeyCode["DIGIT_8"] = 56] = "DIGIT_8";
        KeyCode[KeyCode["DIGIT_9"] = 57] = "DIGIT_9";
        KeyCode[KeyCode["KEY_A"] = 65] = "KEY_A";
        KeyCode[KeyCode["KEY_B"] = 66] = "KEY_B";
        KeyCode[KeyCode["KEY_C"] = 67] = "KEY_C";
        KeyCode[KeyCode["KEY_D"] = 68] = "KEY_D";
        KeyCode[KeyCode["KEY_E"] = 69] = "KEY_E";
        KeyCode[KeyCode["KEY_F"] = 70] = "KEY_F";
        KeyCode[KeyCode["KEY_G"] = 71] = "KEY_G";
        KeyCode[KeyCode["KEY_H"] = 72] = "KEY_H";
        KeyCode[KeyCode["KEY_I"] = 73] = "KEY_I";
        KeyCode[KeyCode["KEY_J"] = 74] = "KEY_J";
        KeyCode[KeyCode["KEY_K"] = 75] = "KEY_K";
        KeyCode[KeyCode["KEY_L"] = 76] = "KEY_L";
        KeyCode[KeyCode["KEY_M"] = 77] = "KEY_M";
        KeyCode[KeyCode["KEY_N"] = 78] = "KEY_N";
        KeyCode[KeyCode["KEY_O"] = 79] = "KEY_O";
        KeyCode[KeyCode["KEY_P"] = 80] = "KEY_P";
        KeyCode[KeyCode["KEY_Q"] = 81] = "KEY_Q";
        KeyCode[KeyCode["KEY_R"] = 82] = "KEY_R";
        KeyCode[KeyCode["KEY_S"] = 83] = "KEY_S";
        KeyCode[KeyCode["KEY_T"] = 84] = "KEY_T";
        KeyCode[KeyCode["KEY_U"] = 85] = "KEY_U";
        KeyCode[KeyCode["KEY_V"] = 86] = "KEY_V";
        KeyCode[KeyCode["KEY_W"] = 87] = "KEY_W";
        KeyCode[KeyCode["KEY_X"] = 88] = "KEY_X";
        KeyCode[KeyCode["KEY_Y"] = 89] = "KEY_Y";
        KeyCode[KeyCode["KEY_Z"] = 90] = "KEY_Z";
        KeyCode[KeyCode["NUM_0"] = 96] = "NUM_0";
        KeyCode[KeyCode["NUM_1"] = 97] = "NUM_1";
        KeyCode[KeyCode["NUM_2"] = 98] = "NUM_2";
        KeyCode[KeyCode["NUM_3"] = 99] = "NUM_3";
        KeyCode[KeyCode["NUM_4"] = 100] = "NUM_4";
        KeyCode[KeyCode["NUM_5"] = 101] = "NUM_5";
        KeyCode[KeyCode["NUM_6"] = 102] = "NUM_6";
        KeyCode[KeyCode["NUM_7"] = 103] = "NUM_7";
        KeyCode[KeyCode["NUM_8"] = 104] = "NUM_8";
        KeyCode[KeyCode["NUM_9"] = 105] = "NUM_9";
        KeyCode[KeyCode["NUM_MULTIPLY"] = 106] = "NUM_MULTIPLY";
        KeyCode[KeyCode["NUM_PLUS"] = 107] = "NUM_PLUS";
        KeyCode[KeyCode["NUM_SUBTRACT"] = 109] = "NUM_SUBTRACT";
        KeyCode[KeyCode["NUM_DECIMAL"] = 110] = "NUM_DECIMAL";
        KeyCode[KeyCode["NUM_DIVIDE"] = 111] = "NUM_DIVIDE";
        KeyCode[KeyCode["F1"] = 112] = "F1";
        KeyCode[KeyCode["F2"] = 113] = "F2";
        KeyCode[KeyCode["F3"] = 114] = "F3";
        KeyCode[KeyCode["F4"] = 115] = "F4";
        KeyCode[KeyCode["F5"] = 116] = "F5";
        KeyCode[KeyCode["F6"] = 117] = "F6";
        KeyCode[KeyCode["F7"] = 118] = "F7";
        KeyCode[KeyCode["F8"] = 119] = "F8";
        KeyCode[KeyCode["F9"] = 120] = "F9";
        KeyCode[KeyCode["F10"] = 121] = "F10";
        KeyCode[KeyCode["F11"] = 122] = "F11";
        KeyCode[KeyCode["F12"] = 123] = "F12";
        KeyCode[KeyCode["NUM_LOCK"] = 144] = "NUM_LOCK";
        KeyCode[KeyCode["SCROLL_LOCK"] = 145] = "SCROLL_LOCK";
        KeyCode[KeyCode["SEMICOLON"] = 186] = "SEMICOLON";
        KeyCode[KeyCode["EQUAL"] = 187] = "EQUAL";
        KeyCode[KeyCode["COMMA"] = 188] = "COMMA";
        KeyCode[KeyCode["DASH"] = 189] = "DASH";
        KeyCode[KeyCode["PERIOD"] = 190] = "PERIOD";
        KeyCode[KeyCode["SLASH"] = 191] = "SLASH";
        KeyCode[KeyCode["BACK_QUOTE"] = 192] = "BACK_QUOTE";
        KeyCode[KeyCode["BRACKET_LEFT"] = 219] = "BRACKET_LEFT";
        KeyCode[KeyCode["BACKSLASH"] = 220] = "BACKSLASH";
        KeyCode[KeyCode["BRACKET_RIGHT"] = 221] = "BRACKET_RIGHT";
        KeyCode[KeyCode["QUOTE"] = 222] = "QUOTE";
        KeyCode[KeyCode["SHIFT_RIGHT"] = 2000] = "SHIFT_RIGHT";
        KeyCode[KeyCode["CTRL_RIGHT"] = 2001] = "CTRL_RIGHT";
        KeyCode[KeyCode["ALT_RIGHT"] = 2002] = "ALT_RIGHT";
        KeyCode[KeyCode["NUM_ENTER"] = 2003] = "NUM_ENTER";
      })(KeyCode || (exports('KeyCode', KeyCode = {})));

      const _vec2$1 = new Vec2();
      class Touch {
        get lastModified() {
          return this._lastModified;
        }
        constructor(x, y, id = 0) {
          this._point = new Vec2();
          this._prevPoint = new Vec2();
          this._lastModified = 0;
          this._id = 0;
          this._startPoint = new Vec2();
          this._startPointCaptured = false;
          this.setTouchInfo(id, x, y);
        }
        getLocation(out) {
          if (!out) {
            out = new Vec2();
          }
          out.set(this._point.x, this._point.y);
          return out;
        }
        getLocationX() {
          return this._point.x;
        }
        getLocationY() {
          return this._point.y;
        }
        getUILocation(out) {
          if (!out) {
            out = new Vec2();
          }
          out.set(this._point.x, this._point.y);
          legacyCC.view._convertToUISpace(out);
          return out;
        }
        getUILocationX() {
          const viewport = legacyCC.view.getViewportRect();
          return (this._point.x - viewport.x) / legacyCC.view.getScaleX();
        }
        getUILocationY() {
          const viewport = legacyCC.view.getViewportRect();
          return (this._point.y - viewport.y) / legacyCC.view.getScaleY();
        }
        getPreviousLocation(out) {
          if (!out) {
            out = new Vec2();
          }
          out.set(this._prevPoint.x, this._prevPoint.y);
          return out;
        }
        getUIPreviousLocation(out) {
          if (!out) {
            out = new Vec2();
          }
          out.set(this._prevPoint.x, this._prevPoint.y);
          legacyCC.view._convertToUISpace(out);
          return out;
        }
        getStartLocation(out) {
          if (!out) {
            out = new Vec2();
          }
          out.set(this._startPoint.x, this._startPoint.y);
          return out;
        }
        getUIStartLocation(out) {
          if (!out) {
            out = new Vec2();
          }
          out.set(this._startPoint.x, this._startPoint.y);
          legacyCC.view._convertToUISpace(out);
          return out;
        }
        getDelta(out) {
          if (!out) {
            out = new Vec2();
          }
          out.set(this._point);
          out.subtract(this._prevPoint);
          return out;
        }
        getUIDelta(out) {
          if (!out) {
            out = new Vec2();
          }
          _vec2$1.set(this._point);
          _vec2$1.subtract(this._prevPoint);
          out.set(legacyCC.view.getScaleX(), legacyCC.view.getScaleY());
          Vec2.divide(out, _vec2$1, out);
          return out;
        }
        getLocationInView(out) {
          if (!out) {
            out = new Vec2();
          }
          out.set(this._point.x, legacyCC.view._designResolutionSize.height - this._point.y);
          return out;
        }
        getPreviousLocationInView(out) {
          if (!out) {
            out = new Vec2();
          }
          out.set(this._prevPoint.x, legacyCC.view._designResolutionSize.height - this._prevPoint.y);
          return out;
        }
        getStartLocationInView(out) {
          if (!out) {
            out = new Vec2();
          }
          out.set(this._startPoint.x, legacyCC.view._designResolutionSize.height - this._startPoint.y);
          return out;
        }
        getID() {
          return this._id;
        }
        setTouchInfo(id = 0, x, y) {
          this._prevPoint = this._point;
          this._point = new Vec2(x || 0, y || 0);
          this._id = id;
          if (!this._startPointCaptured) {
            this._startPoint = new Vec2(this._point);
            this._startPointCaptured = true;
          }
        }
        setPoint(x, y) {
          if (typeof x === 'object') {
            this._point.x = x.x;
            this._point.y = x.y;
          } else {
            this._point.x = x || 0;
            this._point.y = y || 0;
          }
          this._lastModified = legacyCC.game.frameStartTime;
        }
        setPrevPoint(x, y) {
          if (typeof x === 'object') {
            this._prevPoint = new Vec2(x.x, x.y);
          } else {
            this._prevPoint = new Vec2(x || 0, y || 0);
          }
          this._lastModified = legacyCC.game.frameStartTime;
        }
      } exports('Touch', Touch);
      legacyCC.Touch = Touch;

      class AccelerometerInputSource {
        constructor() {
          this._intervalInSeconds = 0.2;
          this._intervalId = void 0;
          this._isEnabled = false;
          this._eventTarget = new EventTarget();
          this._didAccelerateFunc = void 0;
          this._didAccelerateFunc = this._didAccelerate.bind(this);
        }
        _didAccelerate() {
          const deviceMotionValue = jsb.device.getDeviceMotionValue();
          let x = deviceMotionValue[3] * 0.1;
          let y = deviceMotionValue[4] * 0.1;
          const z = deviceMotionValue[5] * 0.1;
          const orientation = screenAdapter.orientation;
          const tmpX = x;
          if (orientation === Orientation.LANDSCAPE_RIGHT) {
            x = -y;
            y = tmpX;
          } else if (orientation === Orientation.LANDSCAPE_LEFT) {
            x = y;
            y = -tmpX;
          } else if (orientation === Orientation.PORTRAIT_UPSIDE_DOWN) {
            x = -x;
            y = -y;
          }
          if (systemInfo.os === OS.ANDROID || systemInfo.os === OS.OHOS || systemInfo.os === OS.OPENHARMONY) {
            x = -x;
            y = -y;
          }
          const timestamp = performance.now();
          const acceleration = new Acceleration(x, y, z, timestamp);
          const eventAcceleration = new EventAcceleration(acceleration);
          this._eventTarget.emit(InputEventType.DEVICEMOTION, eventAcceleration);
        }
        start() {
          if (this._intervalId) {
            clearInterval(this._intervalId);
          }
          this._intervalId = setInterval(this._didAccelerateFunc, this._intervalInSeconds * 1000);
          jsb.device.setAccelerometerInterval(this._intervalInSeconds);
          jsb.device.setAccelerometerEnabled(true);
          this._isEnabled = true;
        }
        stop() {
          if (this._intervalId) {
            clearInterval(this._intervalId);
            this._intervalId = undefined;
          }
          jsb.device.setAccelerometerEnabled(false);
          this._isEnabled = false;
        }
        setInterval(intervalInMileseconds) {
          this._intervalInSeconds = intervalInMileseconds / 1000;
          jsb.device.setAccelerometerInterval(this._intervalInSeconds);
          if (this._isEnabled) {
            jsb.device.setAccelerometerEnabled(false);
            jsb.device.setAccelerometerEnabled(true);
          }
        }
        on(eventType, callback, target) {
          this._eventTarget.on(eventType, callback, target);
        }
      }

      class InputSource {}
      class InputSourceAxis1D extends InputSource {
        getValue() {
          throw new Error('Method not implemented.');
        }
      }
      class InputSourceAxis2D extends InputSource {
        getValue() {
          throw new Error('Method not implemented.');
        }
      }
      class InputSourceAxis3D extends InputSource {
        getValue() {
          throw new Error('Method not implemented.');
        }
      }
      class InputSourceQuat extends InputSource {
        getValue() {
          throw new Error('Method not implemented.');
        }
      }
      class CompositeInputSourceAxis1D extends InputSourceAxis1D {
        constructor(options) {
          super();
          this.positive = void 0;
          this.negative = void 0;
          this.positive = options.positive;
          this.negative = options.negative;
        }
        getValue() {
          const positiveValue = this.positive.getValue();
          const negativeValue = this.negative.getValue();
          if (Math.abs(positiveValue) > Math.abs(negativeValue)) {
            return positiveValue;
          }
          return -negativeValue;
        }
      }
      class CompositeInputSourceAxis2D extends InputSourceAxis2D {
        constructor(options) {
          super();
          this.up = void 0;
          this.down = void 0;
          this.left = void 0;
          this.right = void 0;
          this.xAxis = void 0;
          this.yAxis = void 0;
          this.up = options.up;
          this.down = options.down;
          this.left = options.left;
          this.right = options.right;
          this.xAxis = new CompositeInputSourceAxis1D({
            positive: this.right,
            negative: this.left
          });
          this.yAxis = new CompositeInputSourceAxis1D({
            positive: this.up,
            negative: this.down
          });
        }
        getValue() {
          return new Vec2(this.xAxis.getValue(), this.yAxis.getValue());
        }
      }
      class InputSourceButton extends InputSourceAxis1D {
        getValue() {
          return super.getValue();
        }
      }
      class InputSourceDpad extends CompositeInputSourceAxis2D {}
      class InputSourceStick extends CompositeInputSourceAxis2D {}
      class InputSourceOrientation extends InputSourceQuat {
        getValue() {
          return super.getValue();
        }
      }
      class InputSourcePosition extends InputSourceAxis3D {
        getValue() {
          return super.getValue();
        }
      }

      var Button$2;
      (function (Button) {
        Button[Button["BUTTON_SOUTH"] = 0] = "BUTTON_SOUTH";
        Button[Button["BUTTON_EAST"] = 1] = "BUTTON_EAST";
        Button[Button["BUTTON_WEST"] = 2] = "BUTTON_WEST";
        Button[Button["BUTTON_NORTH"] = 3] = "BUTTON_NORTH";
        Button[Button["NS_MINUS"] = 4] = "NS_MINUS";
        Button[Button["NS_PLUS"] = 5] = "NS_PLUS";
        Button[Button["BUTTON_L1"] = 6] = "BUTTON_L1";
        Button[Button["BUTTON_L2"] = 7] = "BUTTON_L2";
        Button[Button["BUTTON_L3"] = 8] = "BUTTON_L3";
        Button[Button["BUTTON_R1"] = 9] = "BUTTON_R1";
        Button[Button["BUTTON_R2"] = 10] = "BUTTON_R2";
        Button[Button["BUTTON_R3"] = 11] = "BUTTON_R3";
        Button[Button["DPAD_UP"] = 12] = "DPAD_UP";
        Button[Button["DPAD_DOWN"] = 13] = "DPAD_DOWN";
        Button[Button["DPAD_LEFT"] = 14] = "DPAD_LEFT";
        Button[Button["DPAD_RIGHT"] = 15] = "DPAD_RIGHT";
        Button[Button["LEFT_STICK_UP"] = 16] = "LEFT_STICK_UP";
        Button[Button["LEFT_STICK_DOWN"] = 17] = "LEFT_STICK_DOWN";
        Button[Button["LEFT_STICK_LEFT"] = 18] = "LEFT_STICK_LEFT";
        Button[Button["LEFT_STICK_RIGHT"] = 19] = "LEFT_STICK_RIGHT";
        Button[Button["RIGHT_STICK_UP"] = 20] = "RIGHT_STICK_UP";
        Button[Button["RIGHT_STICK_DOWN"] = 21] = "RIGHT_STICK_DOWN";
        Button[Button["RIGHT_STICK_LEFT"] = 22] = "RIGHT_STICK_LEFT";
        Button[Button["RIGHT_STICK_RIGHT"] = 23] = "RIGHT_STICK_RIGHT";
        Button[Button["ROKID_MENU"] = 24] = "ROKID_MENU";
        Button[Button["ROKID_START"] = 25] = "ROKID_START";
      })(Button$2 || (Button$2 = {}));
      const _nativeButtonMap$1 = {
        1: Button$2.BUTTON_EAST,
        2: Button$2.BUTTON_SOUTH,
        3: Button$2.BUTTON_NORTH,
        4: Button$2.BUTTON_WEST,
        5: Button$2.BUTTON_L1,
        6: Button$2.BUTTON_R1,
        7: Button$2.NS_MINUS,
        8: Button$2.NS_PLUS,
        9: Button$2.BUTTON_L3,
        10: Button$2.BUTTON_R3,
        11: Button$2.ROKID_MENU,
        12: Button$2.ROKID_START
      };
      class GamepadInputDevice {
        get buttonNorth() {
          return this._buttonNorth;
        }
        get buttonEast() {
          return this._buttonEast;
        }
        get buttonWest() {
          return this._buttonWest;
        }
        get buttonSouth() {
          return this._buttonSouth;
        }
        get buttonL1() {
          return this._buttonL1;
        }
        get buttonL2() {
          return this._buttonL2;
        }
        get buttonL3() {
          return this._buttonL3;
        }
        get buttonR1() {
          return this._buttonR1;
        }
        get buttonR2() {
          return this._buttonR2;
        }
        get buttonR3() {
          return this._buttonR3;
        }
        get buttonShare() {
          return this._buttonShare;
        }
        get buttonOptions() {
          return this._buttonOptions;
        }
        get dpad() {
          return this._dpad;
        }
        get leftStick() {
          return this._leftStick;
        }
        get rightStick() {
          return this._rightStick;
        }
        get buttonStart() {
          return this._buttonStart;
        }
        get gripLeft() {
          return this._gripLeft;
        }
        get gripRight() {
          return this._gripRight;
        }
        get handLeftPosition() {
          return this._handLeftPosition;
        }
        get handLeftOrientation() {
          return this._handLeftOrientation;
        }
        get handRightPosition() {
          return this._handRightPosition;
        }
        get handRightOrientation() {
          return this._handRightOrientation;
        }
        get aimLeftPosition() {
          return this._aimLeftPosition;
        }
        get aimLeftOrientation() {
          return this._aimLeftOrientation;
        }
        get aimRightPosition() {
          return this._aimRightPosition;
        }
        get aimRightOrientation() {
          return this._aimRightOrientation;
        }
        get deviceId() {
          return this._deviceId;
        }
        get connected() {
          return this._connected;
        }
        constructor(deviceId) {
          this._buttonNorth = void 0;
          this._buttonEast = void 0;
          this._buttonWest = void 0;
          this._buttonSouth = void 0;
          this._buttonL1 = void 0;
          this._buttonL2 = void 0;
          this._buttonL3 = void 0;
          this._buttonR1 = void 0;
          this._buttonR2 = void 0;
          this._buttonR3 = void 0;
          this._buttonShare = void 0;
          this._buttonOptions = void 0;
          this._dpad = void 0;
          this._leftStick = void 0;
          this._rightStick = void 0;
          this._buttonStart = void 0;
          this._gripLeft = void 0;
          this._gripRight = void 0;
          this._handLeftPosition = void 0;
          this._handLeftOrientation = void 0;
          this._handRightPosition = void 0;
          this._handRightOrientation = void 0;
          this._aimLeftPosition = void 0;
          this._aimLeftOrientation = void 0;
          this._aimRightPosition = void 0;
          this._aimRightOrientation = void 0;
          this._deviceId = -1;
          this._connected = false;
          this._nativeButtonState = {
            [Button$2.BUTTON_SOUTH]: 0,
            [Button$2.BUTTON_EAST]: 0,
            [Button$2.BUTTON_WEST]: 0,
            [Button$2.BUTTON_NORTH]: 0,
            [Button$2.NS_MINUS]: 0,
            [Button$2.NS_PLUS]: 0,
            [Button$2.BUTTON_L1]: 0,
            [Button$2.BUTTON_L2]: 0,
            [Button$2.BUTTON_L3]: 0,
            [Button$2.BUTTON_R1]: 0,
            [Button$2.BUTTON_R2]: 0,
            [Button$2.BUTTON_R3]: 0,
            [Button$2.DPAD_UP]: 0,
            [Button$2.DPAD_DOWN]: 0,
            [Button$2.DPAD_LEFT]: 0,
            [Button$2.DPAD_RIGHT]: 0,
            [Button$2.LEFT_STICK_UP]: 0,
            [Button$2.LEFT_STICK_DOWN]: 0,
            [Button$2.LEFT_STICK_LEFT]: 0,
            [Button$2.LEFT_STICK_RIGHT]: 0,
            [Button$2.RIGHT_STICK_UP]: 0,
            [Button$2.RIGHT_STICK_DOWN]: 0,
            [Button$2.RIGHT_STICK_LEFT]: 0,
            [Button$2.RIGHT_STICK_RIGHT]: 0,
            [Button$2.ROKID_MENU]: 0,
            [Button$2.ROKID_START]: 0
          };
          this._deviceId = deviceId;
          this._initInputSource();
        }
        static _init() {
          if (!systemInfo.hasFeature(Feature$1.EVENT_GAMEPAD)) {
            return;
          }
          GamepadInputDevice._registerEvent();
        }
        static _on(eventType, cb, target) {
          GamepadInputDevice._eventTarget.on(eventType, cb, target);
        }
        static _removeInputDevice(id) {
          const removeIndex = GamepadInputDevice.all.findIndex(device => device.deviceId === id);
          if (removeIndex === -1) {
            return;
          }
          fastRemoveAt$2(GamepadInputDevice.all, removeIndex);
        }
        static _getInputDevice(id) {
          return GamepadInputDevice.all.find(device => device.deviceId === id);
        }
        static _createInputDevice(id, connected) {
          const device = new GamepadInputDevice(id);
          device._connected = connected;
          GamepadInputDevice.all.push(device);
          return device;
        }
        static _getOrCreateInputDevice(id, connected) {
          let device = GamepadInputDevice._getInputDevice(id);
          if (!device) {
            device = GamepadInputDevice._createInputDevice(id, connected);
          }
          device._connected = connected;
          return device;
        }
        static _registerEvent() {
          jsb.onControllerInput = infoList => {
            for (let i = 0; i < infoList.length; ++i) {
              const info = infoList[i];
              const device = GamepadInputDevice._getOrCreateInputDevice(info.id, true);
              device._updateNativeButtonState(info);
              GamepadInputDevice._eventTarget.emit(InputEventType.GAMEPAD_INPUT, new EventGamepad(InputEventType.GAMEPAD_INPUT, device));
            }
          };
          jsb.onControllerChange = controllerIds => {
            for (let i = 0; i < controllerIds.length; ++i) {
              const id = controllerIds[i];
              let device = GamepadInputDevice._getInputDevice(id);
              if (!device) {
                device = GamepadInputDevice._createInputDevice(id, true);
                GamepadInputDevice._eventTarget.emit(InputEventType.GAMEPAD_CHANGE, new EventGamepad(InputEventType.GAMEPAD_CHANGE, device));
              }
            }
            const allDevices = GamepadInputDevice.all;
            for (let i = 0; i < allDevices.length; ++i) {
              const device = allDevices[i];
              if (!controllerIds.includes(device.deviceId)) {
                GamepadInputDevice._removeInputDevice(device.deviceId);
                device._connected = false;
                GamepadInputDevice._eventTarget.emit(InputEventType.GAMEPAD_CHANGE, new EventGamepad(InputEventType.GAMEPAD_CHANGE, device));
              }
            }
          };
        }
        _axisToButtons(axisValue) {
          const value = Math.abs(axisValue);
          if (axisValue > 0) {
            return {
              negative: 0,
              positive: value
            };
          } else if (axisValue < 0) {
            return {
              negative: value,
              positive: 0
            };
          } else {
            return {
              negative: 0,
              positive: 0
            };
          }
        }
        _updateNativeButtonState(info) {
          const {
            buttonInfoList,
            axisInfoList
          } = info;
          for (let i = 0; i < buttonInfoList.length; ++i) {
            const buttonInfo = buttonInfoList[i];
            const button = _nativeButtonMap$1[buttonInfo.code];
            this._nativeButtonState[button] = buttonInfo.isPressed ? 1 : 0;
          }
          for (let i = 0; i < axisInfoList.length; ++i) {
            const axisInfo = axisInfoList[i];
            const {
              code,
              value
            } = axisInfo;
            let negativeButton;
            let positiveButton;
            let axisValue;
            switch (code) {
              case 1:
                negativeButton = Button$2.DPAD_LEFT;
                positiveButton = Button$2.DPAD_RIGHT;
                axisValue = this._axisToButtons(value);
                break;
              case 2:
                negativeButton = Button$2.DPAD_DOWN;
                positiveButton = Button$2.DPAD_UP;
                axisValue = this._axisToButtons(value);
                break;
              case 3:
                negativeButton = Button$2.LEFT_STICK_LEFT;
                positiveButton = Button$2.LEFT_STICK_RIGHT;
                axisValue = this._axisToButtons(value);
                break;
              case 4:
                negativeButton = Button$2.LEFT_STICK_DOWN;
                positiveButton = Button$2.LEFT_STICK_UP;
                axisValue = this._axisToButtons(value);
                break;
              case 5:
                negativeButton = Button$2.RIGHT_STICK_LEFT;
                positiveButton = Button$2.RIGHT_STICK_RIGHT;
                axisValue = this._axisToButtons(value);
                break;
              case 6:
                negativeButton = Button$2.RIGHT_STICK_DOWN;
                positiveButton = Button$2.RIGHT_STICK_UP;
                axisValue = this._axisToButtons(value);
                break;
              default:
                if (code === 7) {
                  this._nativeButtonState[Button$2.BUTTON_L2] = value;
                } else if (code === 8) {
                  this._nativeButtonState[Button$2.BUTTON_R2] = value;
                }
                break;
            }
            if (negativeButton && positiveButton && axisValue) {
              this._nativeButtonState[negativeButton] = axisValue.negative;
              this._nativeButtonState[positiveButton] = axisValue.positive;
            }
          }
        }
        _initInputSource() {
          this._buttonNorth = new InputSourceButton();
          this._buttonNorth.getValue = () => this._nativeButtonState[Button$2.BUTTON_NORTH];
          this._buttonEast = new InputSourceButton();
          this._buttonEast.getValue = () => this._nativeButtonState[Button$2.BUTTON_EAST];
          this._buttonWest = new InputSourceButton();
          this._buttonWest.getValue = () => this._nativeButtonState[Button$2.BUTTON_WEST];
          this._buttonSouth = new InputSourceButton();
          this._buttonSouth.getValue = () => this._nativeButtonState[Button$2.BUTTON_SOUTH];
          this._buttonL1 = new InputSourceButton();
          this._buttonL1.getValue = () => this._nativeButtonState[Button$2.BUTTON_L1];
          this._buttonL2 = new InputSourceButton();
          this._buttonL2.getValue = () => this._nativeButtonState[Button$2.BUTTON_L2];
          this._buttonL3 = new InputSourceButton();
          this._buttonL3.getValue = () => this._nativeButtonState[Button$2.BUTTON_L3];
          this._buttonR1 = new InputSourceButton();
          this._buttonR1.getValue = () => this._nativeButtonState[Button$2.BUTTON_R1];
          this._buttonR2 = new InputSourceButton();
          this._buttonR2.getValue = () => this._nativeButtonState[Button$2.BUTTON_R2];
          this._buttonR3 = new InputSourceButton();
          this._buttonR3.getValue = () => this._nativeButtonState[Button$2.BUTTON_R3];
          this._buttonShare = new InputSourceButton();
          this._buttonShare.getValue = () => this._nativeButtonState[Button$2.NS_MINUS];
          this._buttonOptions = new InputSourceButton();
          this._buttonOptions.getValue = () => this._nativeButtonState[Button$2.NS_PLUS] || this._nativeButtonState[Button$2.ROKID_MENU];
          const dpadUp = new InputSourceButton();
          dpadUp.getValue = () => this._nativeButtonState[Button$2.DPAD_UP];
          const dpadDown = new InputSourceButton();
          dpadDown.getValue = () => this._nativeButtonState[Button$2.DPAD_DOWN];
          const dpadLeft = new InputSourceButton();
          dpadLeft.getValue = () => this._nativeButtonState[Button$2.DPAD_LEFT];
          const dpadRight = new InputSourceButton();
          dpadRight.getValue = () => this._nativeButtonState[Button$2.DPAD_RIGHT];
          this._dpad = new InputSourceDpad({
            up: dpadUp,
            down: dpadDown,
            left: dpadLeft,
            right: dpadRight
          });
          const leftStickUp = new InputSourceButton();
          leftStickUp.getValue = () => this._nativeButtonState[Button$2.LEFT_STICK_UP];
          const leftStickDown = new InputSourceButton();
          leftStickDown.getValue = () => this._nativeButtonState[Button$2.LEFT_STICK_DOWN];
          const leftStickLeft = new InputSourceButton();
          leftStickLeft.getValue = () => this._nativeButtonState[Button$2.LEFT_STICK_LEFT];
          const leftStickRight = new InputSourceButton();
          leftStickRight.getValue = () => this._nativeButtonState[Button$2.LEFT_STICK_RIGHT];
          this._leftStick = new InputSourceStick({
            up: leftStickUp,
            down: leftStickDown,
            left: leftStickLeft,
            right: leftStickRight
          });
          const rightStickUp = new InputSourceButton();
          rightStickUp.getValue = () => this._nativeButtonState[Button$2.RIGHT_STICK_UP];
          const rightStickDown = new InputSourceButton();
          rightStickDown.getValue = () => this._nativeButtonState[Button$2.RIGHT_STICK_DOWN];
          const rightStickLeft = new InputSourceButton();
          rightStickLeft.getValue = () => this._nativeButtonState[Button$2.RIGHT_STICK_LEFT];
          const rightStickRight = new InputSourceButton();
          rightStickRight.getValue = () => this._nativeButtonState[Button$2.RIGHT_STICK_RIGHT];
          this._rightStick = new InputSourceStick({
            up: rightStickUp,
            down: rightStickDown,
            left: rightStickLeft,
            right: rightStickRight
          });
          this._buttonStart = new InputSourceButton();
          this._buttonStart.getValue = () => this._nativeButtonState[Button$2.ROKID_START];
          this._gripLeft = new InputSourceButton();
          this._gripLeft.getValue = () => 0;
          this._gripRight = new InputSourceButton();
          this._gripRight.getValue = () => 0;
          this._handLeftPosition = new InputSourcePosition();
          this._handLeftPosition.getValue = () => Vec3.ZERO;
          this._handLeftOrientation = new InputSourceOrientation();
          this._handLeftOrientation.getValue = () => Quat.IDENTITY;
          this._handRightPosition = new InputSourcePosition();
          this._handRightPosition.getValue = () => Vec3.ZERO;
          this._handRightOrientation = new InputSourceOrientation();
          this._handRightOrientation.getValue = () => Quat.IDENTITY;
          this._aimLeftPosition = new InputSourcePosition();
          this._aimLeftPosition.getValue = () => Vec3.ZERO;
          this._aimLeftOrientation = new InputSourceOrientation();
          this._aimLeftOrientation.getValue = () => Quat.IDENTITY;
          this._aimRightPosition = new InputSourcePosition();
          this._aimRightPosition.getValue = () => Vec3.ZERO;
          this._aimRightOrientation = new InputSourceOrientation();
          this._aimRightOrientation.getValue = () => Quat.IDENTITY;
        }
      }
      GamepadInputDevice.all = [];
      GamepadInputDevice.xr = null;
      GamepadInputDevice._eventTarget = new EventTarget();

      var Button$1;
      (function (Button) {
        Button[Button["BUTTON_EAST"] = 0] = "BUTTON_EAST";
        Button[Button["BUTTON_SOUTH"] = 1] = "BUTTON_SOUTH";
        Button[Button["BUTTON_WEST"] = 2] = "BUTTON_WEST";
        Button[Button["BUTTON_NORTH"] = 3] = "BUTTON_NORTH";
        Button[Button["BUTTON_TRIGGER_LEFT"] = 4] = "BUTTON_TRIGGER_LEFT";
        Button[Button["BUTTON_TRIGGER_RIGHT"] = 5] = "BUTTON_TRIGGER_RIGHT";
        Button[Button["TRIGGER_LEFT"] = 6] = "TRIGGER_LEFT";
        Button[Button["TRIGGER_RIGHT"] = 7] = "TRIGGER_RIGHT";
        Button[Button["GRIP_LEFT"] = 8] = "GRIP_LEFT";
        Button[Button["GRIP_RIGHT"] = 9] = "GRIP_RIGHT";
        Button[Button["BUTTON_LEFT_STICK"] = 10] = "BUTTON_LEFT_STICK";
        Button[Button["LEFT_STICK_UP"] = 11] = "LEFT_STICK_UP";
        Button[Button["LEFT_STICK_DOWN"] = 12] = "LEFT_STICK_DOWN";
        Button[Button["LEFT_STICK_LEFT"] = 13] = "LEFT_STICK_LEFT";
        Button[Button["LEFT_STICK_RIGHT"] = 14] = "LEFT_STICK_RIGHT";
        Button[Button["BUTTON_RIGHT_STICK"] = 15] = "BUTTON_RIGHT_STICK";
        Button[Button["RIGHT_STICK_UP"] = 16] = "RIGHT_STICK_UP";
        Button[Button["RIGHT_STICK_DOWN"] = 17] = "RIGHT_STICK_DOWN";
        Button[Button["RIGHT_STICK_LEFT"] = 18] = "RIGHT_STICK_LEFT";
        Button[Button["RIGHT_STICK_RIGHT"] = 19] = "RIGHT_STICK_RIGHT";
        Button[Button["ROKID_MENU"] = 20] = "ROKID_MENU";
        Button[Button["ROKID_START"] = 21] = "ROKID_START";
      })(Button$1 || (Button$1 = {}));
      var Pose$2;
      (function (Pose) {
        Pose[Pose["HAND_LEFT"] = 0] = "HAND_LEFT";
        Pose[Pose["HAND_RIGHT"] = 1] = "HAND_RIGHT";
        Pose[Pose["AIM_LEFT"] = 2] = "AIM_LEFT";
        Pose[Pose["AIM_RIGHT"] = 3] = "AIM_RIGHT";
      })(Pose$2 || (Pose$2 = {}));
      const _nativeButtonMap = {
        1: Button$1.BUTTON_EAST,
        2: Button$1.BUTTON_SOUTH,
        3: Button$1.BUTTON_NORTH,
        4: Button$1.BUTTON_WEST,
        9: Button$1.BUTTON_LEFT_STICK,
        10: Button$1.BUTTON_RIGHT_STICK,
        11: Button$1.ROKID_MENU,
        12: Button$1.ROKID_START,
        13: Button$1.BUTTON_TRIGGER_LEFT,
        14: Button$1.BUTTON_TRIGGER_RIGHT
      };
      class HandleInputDevice {
        get buttonNorth() {
          return this._buttonNorth;
        }
        get buttonEast() {
          return this._buttonEast;
        }
        get buttonWest() {
          return this._buttonWest;
        }
        get buttonSouth() {
          return this._buttonSouth;
        }
        get buttonTriggerLeft() {
          return this._buttonTriggerLeft;
        }
        get buttonTriggerRight() {
          return this._buttonTriggerRight;
        }
        get triggerLeft() {
          return this._triggerLeft;
        }
        get triggerRight() {
          return this._triggerRight;
        }
        get gripLeft() {
          return this._gripLeft;
        }
        get gripRight() {
          return this._gripRight;
        }
        get leftStick() {
          return this._leftStick;
        }
        get rightStick() {
          return this._rightStick;
        }
        get buttonLeftStick() {
          return this._buttonLeftStick;
        }
        get buttonRightStick() {
          return this._buttonRightStick;
        }
        get buttonOptions() {
          return this._buttonOptions;
        }
        get buttonStart() {
          return this._buttonStart;
        }
        get handLeftPosition() {
          return this._handLeftPosition;
        }
        get handLeftOrientation() {
          return this._handLeftOrientation;
        }
        get handRightPosition() {
          return this._handRightPosition;
        }
        get handRightOrientation() {
          return this._handRightOrientation;
        }
        get aimLeftPosition() {
          return this._aimLeftPosition;
        }
        get aimLeftOrientation() {
          return this._aimLeftOrientation;
        }
        get aimRightPosition() {
          return this._aimRightPosition;
        }
        get aimRightOrientation() {
          return this._aimRightOrientation;
        }
        constructor() {
          this._eventTarget = new EventTarget();
          this._buttonNorth = void 0;
          this._buttonEast = void 0;
          this._buttonWest = void 0;
          this._buttonSouth = void 0;
          this._buttonTriggerLeft = void 0;
          this._buttonTriggerRight = void 0;
          this._triggerLeft = void 0;
          this._triggerRight = void 0;
          this._gripLeft = void 0;
          this._gripRight = void 0;
          this._leftStick = void 0;
          this._rightStick = void 0;
          this._buttonLeftStick = void 0;
          this._buttonRightStick = void 0;
          this._buttonOptions = void 0;
          this._buttonStart = void 0;
          this._handLeftPosition = void 0;
          this._handLeftOrientation = void 0;
          this._handRightPosition = void 0;
          this._handRightOrientation = void 0;
          this._aimLeftPosition = void 0;
          this._aimLeftOrientation = void 0;
          this._aimRightPosition = void 0;
          this._aimRightOrientation = void 0;
          this._nativeButtonState = {
            [Button$1.BUTTON_SOUTH]: 0,
            [Button$1.BUTTON_EAST]: 0,
            [Button$1.BUTTON_WEST]: 0,
            [Button$1.BUTTON_NORTH]: 0,
            [Button$1.BUTTON_TRIGGER_LEFT]: 0,
            [Button$1.BUTTON_TRIGGER_RIGHT]: 0,
            [Button$1.TRIGGER_LEFT]: 0,
            [Button$1.TRIGGER_RIGHT]: 0,
            [Button$1.GRIP_LEFT]: 0,
            [Button$1.GRIP_RIGHT]: 0,
            [Button$1.LEFT_STICK_UP]: 0,
            [Button$1.LEFT_STICK_DOWN]: 0,
            [Button$1.LEFT_STICK_LEFT]: 0,
            [Button$1.LEFT_STICK_RIGHT]: 0,
            [Button$1.RIGHT_STICK_UP]: 0,
            [Button$1.RIGHT_STICK_DOWN]: 0,
            [Button$1.RIGHT_STICK_LEFT]: 0,
            [Button$1.RIGHT_STICK_RIGHT]: 0,
            [Button$1.BUTTON_LEFT_STICK]: 0,
            [Button$1.BUTTON_RIGHT_STICK]: 0,
            [Button$1.ROKID_MENU]: 0,
            [Button$1.ROKID_START]: 0
          };
          this._nativePoseState = {
            [Pose$2.HAND_LEFT]: {
              position: Vec3.ZERO,
              orientation: Quat.IDENTITY
            },
            [Pose$2.HAND_RIGHT]: {
              position: Vec3.ZERO,
              orientation: Quat.IDENTITY
            },
            [Pose$2.AIM_LEFT]: {
              position: Vec3.ZERO,
              orientation: Quat.IDENTITY
            },
            [Pose$2.AIM_RIGHT]: {
              position: Vec3.ZERO,
              orientation: Quat.IDENTITY
            }
          };
          this._initInputSource();
          this._registerEvent();
        }
        _registerEvent() {
          jsb.onHandleInput = infoList => {
            for (let i = 0; i < infoList.length; ++i) {
              const info = infoList[i];
              this._updateNativeButtonState(info);
              this._eventTarget.emit(InputEventType.HANDLE_INPUT, new EventHandle(InputEventType.HANDLE_INPUT, this));
            }
          };
          jsb.onHandlePoseInput = infoList => {
            for (let i = 0; i < infoList.length; ++i) {
              const info = infoList[i];
              this._updateNativePoseState(info);
            }
            this._eventTarget.emit(InputEventType.HANDLE_POSE_INPUT, new EventHandle(InputEventType.HANDLE_POSE_INPUT, this));
          };
        }
        _on(eventType, callback, target) {
          this._eventTarget.on(eventType, callback, target);
        }
        _axisToButtons(axisValue) {
          const value = Math.abs(axisValue);
          if (axisValue > 0) {
            return {
              negative: 0,
              positive: value
            };
          } else if (axisValue < 0) {
            return {
              negative: value,
              positive: 0
            };
          } else {
            return {
              negative: 0,
              positive: 0
            };
          }
        }
        _updateNativeButtonState(info) {
          const {
            buttonInfoList,
            axisInfoList
          } = info;
          for (let i = 0; i < buttonInfoList.length; ++i) {
            const buttonInfo = buttonInfoList[i];
            const button = _nativeButtonMap[buttonInfo.code];
            this._nativeButtonState[button] = buttonInfo.isPressed ? 1 : 0;
          }
          for (let i = 0; i < axisInfoList.length; ++i) {
            const axisInfo = axisInfoList[i];
            const {
              code,
              value
            } = axisInfo;
            let negativeButton;
            let positiveButton;
            let axisValue;
            switch (code) {
              case 3:
                negativeButton = Button$1.LEFT_STICK_LEFT;
                positiveButton = Button$1.LEFT_STICK_RIGHT;
                axisValue = this._axisToButtons(value);
                break;
              case 4:
                negativeButton = Button$1.LEFT_STICK_DOWN;
                positiveButton = Button$1.LEFT_STICK_UP;
                axisValue = this._axisToButtons(value);
                break;
              case 5:
                negativeButton = Button$1.RIGHT_STICK_LEFT;
                positiveButton = Button$1.RIGHT_STICK_RIGHT;
                axisValue = this._axisToButtons(value);
                break;
              case 6:
                negativeButton = Button$1.RIGHT_STICK_DOWN;
                positiveButton = Button$1.RIGHT_STICK_UP;
                axisValue = this._axisToButtons(value);
                break;
              default:
                if (code === 7) {
                  this._nativeButtonState[Button$1.TRIGGER_LEFT] = value;
                } else if (code === 8) {
                  this._nativeButtonState[Button$1.TRIGGER_RIGHT] = value;
                } else if (code === 9) {
                  this._nativeButtonState[Button$1.GRIP_LEFT] = value;
                } else if (code === 10) {
                  this._nativeButtonState[Button$1.GRIP_RIGHT] = value;
                }
                break;
            }
            if (negativeButton && positiveButton && axisValue) {
              this._nativeButtonState[negativeButton] = axisValue.negative;
              this._nativeButtonState[positiveButton] = axisValue.positive;
            }
          }
        }
        _updateNativePoseState(info) {
          switch (info.code) {
            case 1:
              this._nativePoseState[Pose$2.HAND_LEFT] = {
                position: new Vec3(info.x, info.y, info.z),
                orientation: new Quat(info.quaternionX, info.quaternionY, info.quaternionZ, info.quaternionW)
              };
              break;
            case 2:
              this._nativePoseState[Pose$2.AIM_LEFT] = {
                position: new Vec3(info.x, info.y, info.z),
                orientation: new Quat(info.quaternionX, info.quaternionY, info.quaternionZ, info.quaternionW)
              };
              break;
            case 4:
              this._nativePoseState[Pose$2.HAND_RIGHT] = {
                position: new Vec3(info.x, info.y, info.z),
                orientation: new Quat(info.quaternionX, info.quaternionY, info.quaternionZ, info.quaternionW)
              };
              break;
            case 5:
              this._nativePoseState[Pose$2.AIM_RIGHT] = {
                position: new Vec3(info.x, info.y, info.z),
                orientation: new Quat(info.quaternionX, info.quaternionY, info.quaternionZ, info.quaternionW)
              };
              break;
          }
        }
        _initInputSource() {
          this._buttonNorth = new InputSourceButton();
          this._buttonNorth.getValue = () => this._nativeButtonState[Button$1.BUTTON_NORTH];
          this._buttonEast = new InputSourceButton();
          this._buttonEast.getValue = () => this._nativeButtonState[Button$1.BUTTON_EAST];
          this._buttonWest = new InputSourceButton();
          this._buttonWest.getValue = () => this._nativeButtonState[Button$1.BUTTON_WEST];
          this._buttonSouth = new InputSourceButton();
          this._buttonSouth.getValue = () => this._nativeButtonState[Button$1.BUTTON_SOUTH];
          this._buttonTriggerLeft = new InputSourceButton();
          this._buttonTriggerLeft.getValue = () => this._nativeButtonState[Button$1.BUTTON_TRIGGER_LEFT];
          this._buttonTriggerRight = new InputSourceButton();
          this._buttonTriggerRight.getValue = () => this._nativeButtonState[Button$1.BUTTON_TRIGGER_RIGHT];
          this._triggerLeft = new InputSourceButton();
          this._triggerLeft.getValue = () => this._nativeButtonState[Button$1.TRIGGER_LEFT];
          this._triggerRight = new InputSourceButton();
          this._triggerRight.getValue = () => this._nativeButtonState[Button$1.TRIGGER_RIGHT];
          this._gripLeft = new InputSourceButton();
          this._gripLeft.getValue = () => this._nativeButtonState[Button$1.GRIP_LEFT];
          this._gripRight = new InputSourceButton();
          this._gripRight.getValue = () => this._nativeButtonState[Button$1.GRIP_RIGHT];
          this._buttonLeftStick = new InputSourceButton();
          this._buttonLeftStick.getValue = () => this._nativeButtonState[Button$1.BUTTON_LEFT_STICK];
          const leftStickUp = new InputSourceButton();
          leftStickUp.getValue = () => this._nativeButtonState[Button$1.LEFT_STICK_UP];
          const leftStickDown = new InputSourceButton();
          leftStickDown.getValue = () => this._nativeButtonState[Button$1.LEFT_STICK_DOWN];
          const leftStickLeft = new InputSourceButton();
          leftStickLeft.getValue = () => this._nativeButtonState[Button$1.LEFT_STICK_LEFT];
          const leftStickRight = new InputSourceButton();
          leftStickRight.getValue = () => this._nativeButtonState[Button$1.LEFT_STICK_RIGHT];
          this._leftStick = new InputSourceStick({
            up: leftStickUp,
            down: leftStickDown,
            left: leftStickLeft,
            right: leftStickRight
          });
          this._buttonRightStick = new InputSourceButton();
          this._buttonRightStick.getValue = () => this._nativeButtonState[Button$1.BUTTON_RIGHT_STICK];
          const rightStickUp = new InputSourceButton();
          rightStickUp.getValue = () => this._nativeButtonState[Button$1.RIGHT_STICK_UP];
          const rightStickDown = new InputSourceButton();
          rightStickDown.getValue = () => this._nativeButtonState[Button$1.RIGHT_STICK_DOWN];
          const rightStickLeft = new InputSourceButton();
          rightStickLeft.getValue = () => this._nativeButtonState[Button$1.RIGHT_STICK_LEFT];
          const rightStickRight = new InputSourceButton();
          rightStickRight.getValue = () => this._nativeButtonState[Button$1.RIGHT_STICK_RIGHT];
          this._rightStick = new InputSourceStick({
            up: rightStickUp,
            down: rightStickDown,
            left: rightStickLeft,
            right: rightStickRight
          });
          this._buttonOptions = new InputSourceButton();
          this._buttonOptions.getValue = () => this._nativeButtonState[Button$1.ROKID_MENU];
          this._buttonStart = new InputSourceButton();
          this._buttonStart.getValue = () => this._nativeButtonState[Button$1.ROKID_START];
          this._handLeftPosition = new InputSourcePosition();
          this._handLeftPosition.getValue = () => this._nativePoseState[Pose$2.HAND_LEFT].position;
          this._handLeftOrientation = new InputSourceOrientation();
          this._handLeftOrientation.getValue = () => this._nativePoseState[Pose$2.HAND_LEFT].orientation;
          this._handRightPosition = new InputSourcePosition();
          this._handRightPosition.getValue = () => this._nativePoseState[Pose$2.HAND_RIGHT].position;
          this._handRightOrientation = new InputSourceOrientation();
          this._handRightOrientation.getValue = () => this._nativePoseState[Pose$2.HAND_RIGHT].orientation;
          this._aimLeftPosition = new InputSourcePosition();
          this._aimLeftPosition.getValue = () => this._nativePoseState[Pose$2.AIM_LEFT].position;
          this._aimLeftOrientation = new InputSourceOrientation();
          this._aimLeftOrientation.getValue = () => this._nativePoseState[Pose$2.AIM_LEFT].orientation;
          this._aimRightPosition = new InputSourcePosition();
          this._aimRightPosition.getValue = () => this._nativePoseState[Pose$2.AIM_RIGHT].position;
          this._aimRightOrientation = new InputSourceOrientation();
          this._aimRightOrientation.getValue = () => this._nativePoseState[Pose$2.AIM_RIGHT].orientation;
        }
      }

      var Pose$1;
      (function (Pose) {
        Pose[Pose["VIEW_LEFT"] = 0] = "VIEW_LEFT";
        Pose[Pose["VIEW_RIGHT"] = 1] = "VIEW_RIGHT";
        Pose[Pose["HEAD_MIDDLE"] = 2] = "HEAD_MIDDLE";
      })(Pose$1 || (Pose$1 = {}));
      class HMDInputDevice {
        get viewLeftPosition() {
          return this._viewLeftPosition;
        }
        get viewLeftOrientation() {
          return this._viewLeftOrientation;
        }
        get viewRightPosition() {
          return this._viewRightPosition;
        }
        get viewRightOrientation() {
          return this._viewRightOrientation;
        }
        get headMiddlePosition() {
          return this._headMiddlePosition;
        }
        get headMiddleOrientation() {
          return this._headMiddleOrientation;
        }
        constructor() {
          this._eventTarget = new EventTarget();
          this._viewLeftPosition = void 0;
          this._viewLeftOrientation = void 0;
          this._viewRightPosition = void 0;
          this._viewRightOrientation = void 0;
          this._headMiddlePosition = void 0;
          this._headMiddleOrientation = void 0;
          this._nativePoseState = {
            [Pose$1.VIEW_LEFT]: {
              position: Vec3.ZERO,
              orientation: Quat.IDENTITY
            },
            [Pose$1.VIEW_RIGHT]: {
              position: Vec3.ZERO,
              orientation: Quat.IDENTITY
            },
            [Pose$1.HEAD_MIDDLE]: {
              position: Vec3.ZERO,
              orientation: Quat.IDENTITY
            }
          };
          this._initInputSource();
          this._registerEvent();
        }
        _registerEvent() {
          jsb.onHMDPoseInput = infoList => {
            for (let i = 0; i < infoList.length; ++i) {
              const info = infoList[i];
              this._updateNativePoseState(info);
            }
            this._eventTarget.emit(InputEventType.HMD_POSE_INPUT, new EventHMD(InputEventType.HMD_POSE_INPUT, this));
          };
        }
        _on(eventType, callback, target) {
          this._eventTarget.on(eventType, callback, target);
        }
        _updateNativePoseState(info) {
          switch (info.code) {
            case 0:
              this._nativePoseState[Pose$1.VIEW_LEFT] = {
                position: new Vec3(info.x, info.y, info.z),
                orientation: new Quat(info.quaternionX, info.quaternionY, info.quaternionZ, info.quaternionW)
              };
              break;
            case 3:
              this._nativePoseState[Pose$1.VIEW_RIGHT] = {
                position: new Vec3(info.x, info.y, info.z),
                orientation: new Quat(info.quaternionX, info.quaternionY, info.quaternionZ, info.quaternionW)
              };
              break;
            case 6:
              this._nativePoseState[Pose$1.HEAD_MIDDLE] = {
                position: new Vec3(info.x, info.y, info.z),
                orientation: new Quat(info.quaternionX, info.quaternionY, info.quaternionZ, info.quaternionW)
              };
              break;
          }
        }
        _initInputSource() {
          this._viewLeftPosition = new InputSourcePosition();
          this._viewLeftPosition.getValue = () => this._nativePoseState[Pose$1.VIEW_LEFT].position;
          this._viewLeftOrientation = new InputSourceOrientation();
          this._viewLeftOrientation.getValue = () => this._nativePoseState[Pose$1.VIEW_LEFT].orientation;
          this._viewRightPosition = new InputSourcePosition();
          this._viewRightPosition.getValue = () => this._nativePoseState[Pose$1.VIEW_RIGHT].position;
          this._viewRightOrientation = new InputSourceOrientation();
          this._viewRightOrientation.getValue = () => this._nativePoseState[Pose$1.VIEW_RIGHT].orientation;
          this._headMiddlePosition = new InputSourcePosition();
          this._headMiddlePosition.getValue = () => this._nativePoseState[Pose$1.HEAD_MIDDLE].position;
          this._headMiddleOrientation = new InputSourceOrientation();
          this._headMiddleOrientation.getValue = () => this._nativePoseState[Pose$1.HEAD_MIDDLE].orientation;
        }
      }

      var Pose;
      (function (Pose) {
        Pose[Pose["AR_MOBILE"] = 0] = "AR_MOBILE";
      })(Pose || (Pose = {}));
      class HandheldInputDevice {
        get handheldPosition() {
          return this._handheldPosition;
        }
        get handheldOrientation() {
          return this._handheldOrientation;
        }
        constructor() {
          this._eventTarget = new EventTarget();
          this._handheldPosition = void 0;
          this._handheldOrientation = void 0;
          this._nativePoseState = {
            [Pose.AR_MOBILE]: {
              position: Vec3.ZERO,
              orientation: Quat.IDENTITY
            }
          };
          this._initInputSource();
          this._registerEvent();
        }
        _registerEvent() {
          jsb.onHandheldPoseInput = infoList => {
            for (let i = 0; i < infoList.length; ++i) {
              const info = infoList[i];
              this._updateNativePoseState(info);
            }
            this._eventTarget.emit(InputEventType.HANDHELD_POSE_INPUT, new EventHandheld(InputEventType.HANDHELD_POSE_INPUT, this));
          };
        }
        _on(eventType, callback, target) {
          this._eventTarget.on(eventType, callback, target);
        }
        _updateNativePoseState(info) {
          switch (info.code) {
            case 7:
              this._nativePoseState[Pose.AR_MOBILE] = {
                position: new Vec3(info.x, info.y, info.z),
                orientation: new Quat(info.quaternionX, info.quaternionY, info.quaternionZ, info.quaternionW)
              };
              break;
          }
        }
        _initInputSource() {
          this._handheldPosition = new InputSourcePosition();
          this._handheldPosition.getValue = () => this._nativePoseState[Pose.AR_MOBILE].position;
          this._handheldOrientation = new InputSourceOrientation();
          this._handheldOrientation.getValue = () => this._nativePoseState[Pose.AR_MOBILE].orientation;
        }
      }

      const code2KeyCode = {
        Backspace: KeyCode.BACKSPACE,
        Tab: KeyCode.TAB,
        Enter: KeyCode.ENTER,
        ShiftLeft: KeyCode.SHIFT_LEFT,
        ControlLeft: KeyCode.CTRL_LEFT,
        AltLeft: KeyCode.ALT_LEFT,
        ShiftRight: KeyCode.SHIFT_RIGHT,
        ControlRight: KeyCode.CTRL_RIGHT,
        AltRight: KeyCode.ALT_RIGHT,
        Pause: KeyCode.PAUSE,
        CapsLock: KeyCode.CAPS_LOCK,
        Escape: KeyCode.ESCAPE,
        Space: KeyCode.SPACE,
        PageUp: KeyCode.PAGE_UP,
        PageDown: KeyCode.PAGE_DOWN,
        End: KeyCode.END,
        Home: KeyCode.HOME,
        ArrowLeft: KeyCode.ARROW_LEFT,
        ArrowUp: KeyCode.ARROW_UP,
        ArrowRight: KeyCode.ARROW_RIGHT,
        ArrowDown: KeyCode.ARROW_DOWN,
        Insert: KeyCode.INSERT,
        Delete: KeyCode.DELETE,
        Digit0: KeyCode.DIGIT_0,
        Digit1: KeyCode.DIGIT_1,
        Digit2: KeyCode.DIGIT_2,
        Digit3: KeyCode.DIGIT_3,
        Digit4: KeyCode.DIGIT_4,
        Digit5: KeyCode.DIGIT_5,
        Digit6: KeyCode.DIGIT_6,
        Digit7: KeyCode.DIGIT_7,
        Digit8: KeyCode.DIGIT_8,
        Digit9: KeyCode.DIGIT_9,
        KeyA: KeyCode.KEY_A,
        KeyB: KeyCode.KEY_B,
        KeyC: KeyCode.KEY_C,
        KeyD: KeyCode.KEY_D,
        KeyE: KeyCode.KEY_E,
        KeyF: KeyCode.KEY_F,
        KeyG: KeyCode.KEY_G,
        KeyH: KeyCode.KEY_H,
        KeyI: KeyCode.KEY_I,
        KeyJ: KeyCode.KEY_J,
        KeyK: KeyCode.KEY_K,
        KeyL: KeyCode.KEY_L,
        KeyM: KeyCode.KEY_M,
        KeyN: KeyCode.KEY_N,
        KeyO: KeyCode.KEY_O,
        KeyP: KeyCode.KEY_P,
        KeyQ: KeyCode.KEY_Q,
        KeyR: KeyCode.KEY_R,
        KeyS: KeyCode.KEY_S,
        KeyT: KeyCode.KEY_T,
        KeyU: KeyCode.KEY_U,
        KeyV: KeyCode.KEY_V,
        KeyW: KeyCode.KEY_W,
        KeyX: KeyCode.KEY_X,
        KeyY: KeyCode.KEY_Y,
        KeyZ: KeyCode.KEY_Z,
        Numpad0: KeyCode.NUM_0,
        Numpad1: KeyCode.NUM_1,
        Numpad2: KeyCode.NUM_2,
        Numpad3: KeyCode.NUM_3,
        Numpad4: KeyCode.NUM_4,
        Numpad5: KeyCode.NUM_5,
        Numpad6: KeyCode.NUM_6,
        Numpad7: KeyCode.NUM_7,
        Numpad8: KeyCode.NUM_8,
        Numpad9: KeyCode.NUM_9,
        NumpadMultiply: KeyCode.NUM_MULTIPLY,
        NumpadAdd: KeyCode.NUM_PLUS,
        NumpadSubtract: KeyCode.NUM_SUBTRACT,
        NumpadDecimal: KeyCode.NUM_DECIMAL,
        NumpadDivide: KeyCode.NUM_DIVIDE,
        NumpadEnter: KeyCode.NUM_ENTER,
        F1: KeyCode.F1,
        F2: KeyCode.F2,
        F3: KeyCode.F3,
        F4: KeyCode.F4,
        F5: KeyCode.F5,
        F6: KeyCode.F6,
        F7: KeyCode.F7,
        F8: KeyCode.F8,
        F9: KeyCode.F9,
        F10: KeyCode.F10,
        F11: KeyCode.F11,
        F12: KeyCode.F12,
        NumLock: KeyCode.NUM_LOCK,
        ScrollLock: KeyCode.SCROLL_LOCK,
        Semicolon: KeyCode.SEMICOLON,
        Equal: KeyCode.EQUAL,
        Comma: KeyCode.COMMA,
        Minus: KeyCode.DASH,
        Period: KeyCode.PERIOD,
        Slash: KeyCode.SLASH,
        Backquote: KeyCode.BACK_QUOTE,
        BracketLeft: KeyCode.BRACKET_LEFT,
        Backslash: KeyCode.BACKSLASH,
        BracketRight: KeyCode.BRACKET_RIGHT,
        Quote: KeyCode.QUOTE
      };

      const nativeKeyCode2KeyCode = {
        12: KeyCode.NUM_LOCK,
        10048: KeyCode.NUM_0,
        10049: KeyCode.NUM_1,
        10050: KeyCode.NUM_2,
        10051: KeyCode.NUM_3,
        10052: KeyCode.NUM_4,
        10053: KeyCode.NUM_5,
        10054: KeyCode.NUM_6,
        10055: KeyCode.NUM_7,
        10056: KeyCode.NUM_8,
        10057: KeyCode.NUM_9,
        20013: KeyCode.NUM_ENTER,
        20016: KeyCode.SHIFT_RIGHT,
        20017: KeyCode.CTRL_RIGHT,
        20018: KeyCode.ALT_RIGHT
      };
      function getKeyCode(event) {
        if (event.code) {
          if (event.code in code2KeyCode) {
            return code2KeyCode[event.code];
          } else {
            console.error(`Can not find keyCode for code: ${event.code}`);
          }
        }
        return nativeKeyCode2KeyCode[event.keyCode] || event.keyCode;
      }
      class KeyboardInputSource {
        constructor() {
          this._eventTarget = new EventTarget();
          this._keyStateMap = {};
          this._handleKeyboardDown = void 0;
          this._handleKeyboardUp = void 0;
          this._handleKeyboardDown = event => {
            const keyCode = getKeyCode(event);
            if (!this._keyStateMap[keyCode]) {
              const eventKeyDown = this._getInputEvent(event, InputEventType.KEY_DOWN);
              this._eventTarget.emit(InputEventType.KEY_DOWN, eventKeyDown);
            } else {
              const eventKeyPressing = this._getInputEvent(event, InputEventType.KEY_PRESSING);
              this._eventTarget.emit(InputEventType.KEY_PRESSING, eventKeyPressing);
            }
            this._keyStateMap[keyCode] = true;
          };
          this._handleKeyboardUp = event => {
            const keyCode = getKeyCode(event);
            const eventKeyUp = this._getInputEvent(event, InputEventType.KEY_UP);
            this._keyStateMap[keyCode] = false;
            this._eventTarget.emit(InputEventType.KEY_UP, eventKeyUp);
          };
          this._registerEvent();
        }
        dispatchKeyboardDownEvent(nativeKeyboardEvent) {
          this._handleKeyboardDown(nativeKeyboardEvent);
        }
        dispatchKeyboardUpEvent(nativeKeyboardEvent) {
          this._handleKeyboardUp(nativeKeyboardEvent);
        }
        _registerEvent() {
          jsb.onKeyDown = this._handleKeyboardDown;
          jsb.onKeyUp = this._handleKeyboardUp;
        }
        _getInputEvent(event, eventType) {
          const keyCode = getKeyCode(event);
          const eventKeyboard = new EventKeyboard(keyCode, eventType);
          eventKeyboard.windowId = event.windowId;
          return eventKeyboard;
        }
        on(eventType, callback, target) {
          this._eventTarget.on(eventType, callback, target);
        }
      }

      class MouseInputSource {
        constructor() {
          this._eventTarget = new EventTarget();
          this._preMousePos = new Vec2();
          this._isPressed = false;
          this._windowManager = void 0;
          this._pointLocked = false;
          this._handleMouseDown = void 0;
          this._handleMouseMove = void 0;
          this._handleMouseUp = void 0;
          this._boundedHandleMouseWheel = void 0;
          this._handleMouseDown = this._createCallback(InputEventType.MOUSE_DOWN);
          this._handleMouseMove = this._createCallback(InputEventType.MOUSE_MOVE);
          this._handleMouseUp = this._createCallback(InputEventType.MOUSE_UP);
          this._boundedHandleMouseWheel = this._handleMouseWheel.bind(this);
          this._registerEvent();
          this._windowManager = jsb.ISystemWindowManager.getInstance();
        }
        dispatchMouseDownEvent(nativeMouseEvent) {
          this._handleMouseDown(nativeMouseEvent);
        }
        dispatchMouseMoveEvent(nativeMouseEvent) {
          this._handleMouseMove(nativeMouseEvent);
        }
        dispatchMouseUpEvent(nativeMouseEvent) {
          this._handleMouseUp(nativeMouseEvent);
        }
        dispatchScrollEvent(nativeMouseEvent) {
          this._boundedHandleMouseWheel(nativeMouseEvent);
        }
        _getLocation(event) {
          const window = this._windowManager.getWindow(event.windowId);
          const windowSize = window.getViewSize();
          const dpr = screenAdapter.devicePixelRatio;
          const x = event.x * dpr;
          const y = windowSize.height - event.y * dpr;
          return new Vec2(x, y);
        }
        _registerEvent() {
          jsb.onMouseDown = this._handleMouseDown;
          jsb.onMouseMove = this._handleMouseMove;
          jsb.onMouseUp = this._handleMouseUp;
          jsb.onMouseWheel = this._boundedHandleMouseWheel;
          jsb.onPointerlockChange = value => {
            this._pointLocked = value;
          };
        }
        _createCallback(eventType) {
          return mouseEvent => {
            const location = this._getLocation(mouseEvent);
            let button = mouseEvent.button;
            switch (eventType) {
              case InputEventType.MOUSE_DOWN:
                this._isPressed = true;
                break;
              case InputEventType.MOUSE_UP:
                this._isPressed = false;
                break;
              case InputEventType.MOUSE_MOVE:
                if (!this._isPressed) {
                  button = EventMouse.BUTTON_MISSING;
                }
                break;
            }
            const eventMouse = new EventMouse(eventType, false, this._preMousePos, mouseEvent.windowId);
            eventMouse.setLocation(location.x, location.y);
            eventMouse.setButton(button);
            const dpr = screenAdapter.devicePixelRatio;
            eventMouse.movementX = typeof mouseEvent.xDelta === 'undefined' ? 0 : mouseEvent.xDelta * dpr;
            eventMouse.movementY = typeof mouseEvent.yDelta === 'undefined' ? 0 : mouseEvent.yDelta * dpr;
            this._preMousePos.set(location.x, location.y);
            this._eventTarget.emit(eventType, eventMouse);
          };
        }
        _handleMouseWheel(mouseEvent) {
          const eventType = InputEventType.MOUSE_WHEEL;
          const location = this._getLocation(mouseEvent);
          const button = mouseEvent.button;
          const eventMouse = new EventMouse(eventType, false, this._preMousePos, mouseEvent.windowId);
          eventMouse.setLocation(location.x, location.y);
          eventMouse.setButton(button);
          eventMouse.movementX = location.x - this._preMousePos.x;
          eventMouse.movementY = this._preMousePos.y - location.y;
          const matchStandardFactor = 120;
          eventMouse.setScrollData(mouseEvent.wheelDeltaX * matchStandardFactor, mouseEvent.wheelDeltaY * matchStandardFactor);
          this._preMousePos.set(location.x, location.y);
          this._eventTarget.emit(eventType, eventMouse);
        }
        on(eventType, callback, target) {
          this._eventTarget.on(eventType, callback, target);
        }
      }

      const tempVec2 = new Vec2();
      class TouchManager {
        constructor() {
          this._touchMap = void 0;
          this._maxTouches = 8;
          this._touchMap = new Map();
        }
        _cloneTouch(touch) {
          const touchID = touch.getID();
          touch.getStartLocation(tempVec2);
          const clonedTouch = new Touch(tempVec2.x, tempVec2.y, touchID);
          touch.getLocation(tempVec2);
          clonedTouch.setPoint(tempVec2.x, tempVec2.y);
          touch.getPreviousLocation(tempVec2);
          clonedTouch.setPrevPoint(tempVec2);
          return clonedTouch;
        }
        _createTouch(touchID, x, y) {
          if (this._touchMap.has(touchID)) {
            console.log('Cannot create the same touch object.');
            return undefined;
          }
          const checkResult = this._checkTouchMapSizeMoreThanMax(touchID);
          if (checkResult) {
            console.log('The touches is more than MAX_TOUCHES.');
            return undefined;
          }
          const touch = new Touch(x, y, touchID);
          this._touchMap.set(touchID, touch);
          this._updateTouch(touch, x, y);
          return this._cloneTouch(touch);
        }
        releaseTouch(touchID) {
          if (!this._touchMap.has(touchID)) {
            return;
          }
          this._touchMap.delete(touchID);
        }
        getTouch(touchID, x, y) {
          let touch = this._touchMap.get(touchID);
          if (!touch) {
            touch = this._createTouch(touchID, x, y);
          } else {
            this._updateTouch(touch, x, y);
          }
          return touch ? this._cloneTouch(touch) : undefined;
        }
        getAllTouches() {
          const touches = [];
          this._touchMap.forEach(touch => {
            if (touch) {
              const clonedTouch = this._cloneTouch(touch);
              touches.push(clonedTouch);
            }
          });
          return touches;
        }
        _updateTouch(touch, x, y) {
          touch.getLocation(tempVec2);
          touch.setPrevPoint(tempVec2);
          touch.setPoint(x, y);
        }
        _checkTouchMapSizeMoreThanMax(touchID) {
          if (this._touchMap.has(touchID)) {
            return false;
          }
          const maxSize = macro.ENABLE_MULTI_TOUCH ? this._maxTouches : 1;
          if (this._touchMap.size < maxSize) {
            return false;
          }
          const now = performance.now();
          this._touchMap.forEach(touch => {
            if (now - touch.lastModified > macro.TOUCH_TIMEOUT) {
              console.log(`The touches is more than MAX_TOUCHES, release touch id ${touch.getID()}.`);
              this.releaseTouch(touch.getID());
            }
          });
          return maxSize >= this._touchMap.size;
        }
      }
      const touchManager = new TouchManager();

      class TouchInputSource {
        constructor() {
          this._eventTarget = new EventTarget();
          this._windowManager = void 0;
          this._registerEvent();
          this._windowManager = jsb.ISystemWindowManager.getInstance();
        }
        _registerEvent() {
          jsb.onTouchStart = this._createCallback(InputEventType.TOUCH_START);
          jsb.onTouchMove = this._createCallback(InputEventType.TOUCH_MOVE);
          jsb.onTouchEnd = this._createCallback(InputEventType.TOUCH_END);
          jsb.onTouchCancel = this._createCallback(InputEventType.TOUCH_CANCEL);
        }
        _createCallback(eventType) {
          return (changedTouches, windowId) => {
            const handleTouches = [];
            const length = changedTouches.length;
            const windowSize = this._windowManager.getWindow(windowId).getViewSize();
            for (let i = 0; i < length; ++i) {
              const changedTouch = changedTouches[i];
              const touchID = changedTouch.identifier;
              if (touchID === null) {
                continue;
              }
              const location = this._getLocation(changedTouch, windowSize);
              const touch = touchManager.getTouch(touchID, location.x, location.y);
              if (!touch) {
                continue;
              }
              if (eventType === InputEventType.TOUCH_END || eventType === InputEventType.TOUCH_CANCEL) {
                touchManager.releaseTouch(touchID);
              }
              handleTouches.push(touch);
            }
            if (handleTouches.length > 0) {
              const eventTouch = new EventTouch(handleTouches, false, eventType, macro.ENABLE_MULTI_TOUCH ? touchManager.getAllTouches() : handleTouches);
              eventTouch.windowId = windowId;
              this._eventTarget.emit(eventType, eventTouch);
            }
          };
        }
        _getLocation(touch, windowSize) {
          const dpr = screenAdapter.devicePixelRatio;
          const x = touch.clientX * dpr;
          const y = windowSize.height - touch.clientY * dpr;
          return new Vec2(x, y);
        }
        on(eventType, callback, target) {
          this._eventTarget.on(eventType, callback, target);
        }
      }

      let EventDispatcherPriority;
      (function (EventDispatcherPriority) {
        EventDispatcherPriority[EventDispatcherPriority["GLOBAL"] = 0] = "GLOBAL";
        EventDispatcherPriority[EventDispatcherPriority["UI"] = 1] = "UI";
      })(EventDispatcherPriority || (EventDispatcherPriority = {}));
      class InputEventDispatcher {
        constructor(inputEventTarget) {
          this.priority = EventDispatcherPriority.GLOBAL;
          this._inputEventTarget = void 0;
          this._inputEventTarget = inputEventTarget;
        }
        dispatchEvent(event) {
          this._inputEventTarget.emit(event.type, event);
          return true;
        }
      }
      const pointerEventTypeMap = {
        [InputEventType.MOUSE_DOWN]: InputEventType.TOUCH_START,
        [InputEventType.MOUSE_MOVE]: InputEventType.TOUCH_MOVE,
        [InputEventType.MOUSE_UP]: InputEventType.TOUCH_END
      };
      class Input {
        constructor() {
          this._dispatchImmediately = !NATIVE;
          this._eventTarget = new EventTarget();
          this._touchInput = new TouchInputSource();
          this._mouseInput = new MouseInputSource();
          this._keyboardInput = new KeyboardInputSource();
          this._accelerometerInput = new AccelerometerInputSource();
          this._handleInput = new HandleInputDevice();
          this._hmdInput = new HMDInputDevice();
          this._handheldInput = new HandheldInputDevice();
          this._eventTouchList = [];
          this._eventMouseList = [];
          this._eventKeyboardList = [];
          this._eventAccelerationList = [];
          this._eventGamepadList = [];
          this._eventHandleList = [];
          this._eventHMDList = [];
          this._eventHandheldList = [];
          this._needSimulateTouchMoveEvent = false;
          this._inputEventDispatcher = void 0;
          this._eventDispatcherList = [];
          this._registerEvent();
          this._inputEventDispatcher = new InputEventDispatcher(this._eventTarget);
          this._registerEventDispatcher(this._inputEventDispatcher);
          GamepadInputDevice._init();
        }
        _dispatchMouseDownEvent(nativeMouseEvent) {
          var _this$_mouseInput$dis, _this$_mouseInput;
          (_this$_mouseInput$dis = (_this$_mouseInput = this._mouseInput).dispatchMouseDownEvent) === null || _this$_mouseInput$dis === void 0 ? void 0 : _this$_mouseInput$dis.call(_this$_mouseInput, nativeMouseEvent);
        }
        _dispatchMouseMoveEvent(nativeMouseEvent) {
          var _this$_mouseInput$dis2, _this$_mouseInput2;
          (_this$_mouseInput$dis2 = (_this$_mouseInput2 = this._mouseInput).dispatchMouseMoveEvent) === null || _this$_mouseInput$dis2 === void 0 ? void 0 : _this$_mouseInput$dis2.call(_this$_mouseInput2, nativeMouseEvent);
        }
        _dispatchMouseUpEvent(nativeMouseEvent) {
          var _this$_mouseInput$dis3, _this$_mouseInput3;
          (_this$_mouseInput$dis3 = (_this$_mouseInput3 = this._mouseInput).dispatchMouseUpEvent) === null || _this$_mouseInput$dis3 === void 0 ? void 0 : _this$_mouseInput$dis3.call(_this$_mouseInput3, nativeMouseEvent);
        }
        _dispatchMouseScrollEvent(nativeMouseEvent) {
          var _this$_mouseInput$dis4, _this$_mouseInput4;
          (_this$_mouseInput$dis4 = (_this$_mouseInput4 = this._mouseInput).dispatchScrollEvent) === null || _this$_mouseInput$dis4 === void 0 ? void 0 : _this$_mouseInput$dis4.call(_this$_mouseInput4, nativeMouseEvent);
        }
        _dispatchKeyboardDownEvent(nativeKeyboardEvent) {
          var _this$_keyboardInput$, _this$_keyboardInput;
          (_this$_keyboardInput$ = (_this$_keyboardInput = this._keyboardInput).dispatchKeyboardDownEvent) === null || _this$_keyboardInput$ === void 0 ? void 0 : _this$_keyboardInput$.call(_this$_keyboardInput, nativeKeyboardEvent);
        }
        _dispatchKeyboardUpEvent(nativeKeyboardEvent) {
          var _this$_keyboardInput$2, _this$_keyboardInput2;
          (_this$_keyboardInput$2 = (_this$_keyboardInput2 = this._keyboardInput).dispatchKeyboardUpEvent) === null || _this$_keyboardInput$2 === void 0 ? void 0 : _this$_keyboardInput$2.call(_this$_keyboardInput2, nativeKeyboardEvent);
        }
        on(eventType, callback, target) {
          this._eventTarget.on(eventType, callback, target);
          return callback;
        }
        once(eventType, callback, target) {
          this._eventTarget.once(eventType, callback, target);
          return callback;
        }
        off(eventType, callback, target) {
          this._eventTarget.off(eventType, callback, target);
        }
        setAccelerometerEnabled(isEnable) {
          if (isEnable) {
            this._accelerometerInput.start();
          } else {
            this._accelerometerInput.stop();
          }
        }
        setAccelerometerInterval(intervalInMileSeconds) {
          this._accelerometerInput.setInterval(intervalInMileSeconds);
        }
        _simulateEventTouch(eventMouse) {
          const eventType = pointerEventTypeMap[eventMouse.type];
          const touchID = 0;
          const touch = touchManager.getTouch(touchID, eventMouse.getLocationX(), eventMouse.getLocationY());
          if (!touch) {
            return;
          }
          const changedTouches = [touch];
          const eventTouch = new EventTouch(changedTouches, false, eventType, eventType === InputEventType.TOUCH_END ? [] : changedTouches);
          eventTouch.windowId = eventMouse.windowId;
          if (eventType === InputEventType.TOUCH_END) {
            touchManager.releaseTouch(touchID);
          }
          this._dispatchOrPushEventTouch(eventTouch, this._eventTouchList);
        }
        _registerEventDispatcher(eventDispatcher) {
          this._eventDispatcherList.push(eventDispatcher);
          this._eventDispatcherList.sort((a, b) => b.priority - a.priority);
        }
        _emitEvent(event) {
          const length = this._eventDispatcherList.length;
          for (let i = 0; i < length; ++i) {
            const dispatcher = this._eventDispatcherList[i];
            try {
              if (!dispatcher.dispatchEvent(event)) {
                break;
              }
            } catch (e) {
              console.error(`Error occurs in an event listener: ${event.type}`);
              console.error(e);
            }
          }
        }
        _registerEvent() {
          if (sys.hasFeature(sys.Feature.INPUT_TOUCH)) {
            const eventTouchList = this._eventTouchList;
            this._touchInput.on(InputEventType.TOUCH_START, event => {
              this._dispatchOrPushEventTouch(event, eventTouchList);
            });
            this._touchInput.on(InputEventType.TOUCH_MOVE, event => {
              this._dispatchOrPushEventTouch(event, eventTouchList);
            });
            this._touchInput.on(InputEventType.TOUCH_END, event => {
              this._dispatchOrPushEventTouch(event, eventTouchList);
            });
            this._touchInput.on(InputEventType.TOUCH_CANCEL, event => {
              this._dispatchOrPushEventTouch(event, eventTouchList);
            });
          }
          if (sys.hasFeature(sys.Feature.EVENT_MOUSE)) {
            const eventMouseList = this._eventMouseList;
            this._mouseInput.on(InputEventType.MOUSE_DOWN, event => {
              this._needSimulateTouchMoveEvent = true;
              this._simulateEventTouch(event);
              this._dispatchOrPushEvent(event, eventMouseList);
            });
            this._mouseInput.on(InputEventType.MOUSE_MOVE, event => {
              if (this._needSimulateTouchMoveEvent) {
                this._simulateEventTouch(event);
              }
              this._dispatchOrPushEvent(event, eventMouseList);
            });
            this._mouseInput.on(InputEventType.MOUSE_UP, event => {
              this._needSimulateTouchMoveEvent = false;
              this._simulateEventTouch(event);
              this._dispatchOrPushEvent(event, eventMouseList);
            });
            this._mouseInput.on(InputEventType.MOUSE_WHEEL, event => {
              this._dispatchOrPushEvent(event, eventMouseList);
            });
          }
          if (sys.hasFeature(sys.Feature.EVENT_KEYBOARD)) {
            const eventKeyboardList = this._eventKeyboardList;
            this._keyboardInput.on(InputEventType.KEY_DOWN, event => {
              this._dispatchOrPushEvent(event, eventKeyboardList);
            });
            this._keyboardInput.on(InputEventType.KEY_PRESSING, event => {
              this._dispatchOrPushEvent(event, eventKeyboardList);
            });
            this._keyboardInput.on(InputEventType.KEY_UP, event => {
              this._dispatchOrPushEvent(event, eventKeyboardList);
            });
          }
          if (sys.hasFeature(sys.Feature.EVENT_ACCELEROMETER)) {
            const eventAccelerationList = this._eventAccelerationList;
            this._accelerometerInput.on(InputEventType.DEVICEMOTION, event => {
              this._dispatchOrPushEvent(event, eventAccelerationList);
            });
          }
          if (sys.hasFeature(sys.Feature.EVENT_GAMEPAD)) {
            const eventGamepadList = this._eventGamepadList;
            GamepadInputDevice._on(InputEventType.GAMEPAD_CHANGE, event => {
              this._dispatchOrPushEvent(event, eventGamepadList);
            });
            GamepadInputDevice._on(InputEventType.GAMEPAD_INPUT, event => {
              this._dispatchOrPushEvent(event, eventGamepadList);
            });
            GamepadInputDevice._on(InputEventType.HANDLE_POSE_INPUT, event => {
              this._dispatchOrPushEvent(event, eventGamepadList);
            });
          }
          if (sys.hasFeature(sys.Feature.EVENT_HANDLE)) {
            const eventHandleList = this._eventHandleList;
            this._handleInput._on(InputEventType.HANDLE_INPUT, event => {
              this._dispatchOrPushEvent(event, eventHandleList);
            });
            this._handleInput._on(InputEventType.HANDLE_POSE_INPUT, event => {
              this._dispatchOrPushEvent(event, eventHandleList);
            });
          }
          if (sys.hasFeature(sys.Feature.EVENT_HMD)) {
            const eventHMDList = this._eventHMDList;
            this._hmdInput._on(InputEventType.HMD_POSE_INPUT, event => {
              this._dispatchOrPushEvent(event, eventHMDList);
            });
          }
          if (sys.hasFeature(sys.Feature.EVENT_HANDHELD)) {
            const eventHandheldList = this._eventHandheldList;
            this._handheldInput._on(InputEventType.HANDHELD_POSE_INPUT, event => {
              this._dispatchOrPushEvent(event, eventHandheldList);
            });
          }
        }
        _clearEvents() {
          this._eventMouseList.length = 0;
          this._eventTouchList.length = 0;
          this._eventKeyboardList.length = 0;
          this._eventAccelerationList.length = 0;
          this._eventGamepadList.length = 0;
          this._eventHandleList.length = 0;
          this._eventHMDList.length = 0;
        }
        _dispatchOrPushEvent(event, eventList) {
          if (this._dispatchImmediately) {
            this._emitEvent(event);
          } else {
            eventList.push(event);
          }
        }
        _dispatchOrPushEventTouch(eventTouch, touchEventList) {
          if (this._dispatchImmediately) {
            const touches = eventTouch.getTouches();
            const touchesLength = touches.length;
            for (let i = 0; i < touchesLength; ++i) {
              eventTouch.touch = touches[i];
              eventTouch.propagationStopped = eventTouch.propagationImmediateStopped = false;
              this._emitEvent(eventTouch);
            }
          } else {
            touchEventList.push(eventTouch);
          }
        }
        _frameDispatchEvents() {
          const eventHMDList = this._eventHMDList;
          for (let i = 0, length = eventHMDList.length; i < length; ++i) {
            const eventHMD = eventHMDList[i];
            this._emitEvent(eventHMD);
          }
          const eventHandheldList = this._eventHandheldList;
          for (let i = 0, length = eventHandheldList.length; i < length; ++i) {
            const eventHandheld = eventHandheldList[i];
            this._emitEvent(eventHandheld);
          }
          const eventMouseList = this._eventMouseList;
          for (let i = 0, length = eventMouseList.length; i < length; ++i) {
            const eventMouse = eventMouseList[i];
            this._emitEvent(eventMouse);
          }
          const eventTouchList = this._eventTouchList;
          for (let i = 0, length = eventTouchList.length; i < length; ++i) {
            const eventTouch = eventTouchList[i];
            const touches = eventTouch.getTouches();
            const touchesLength = touches.length;
            for (let j = 0; j < touchesLength; ++j) {
              eventTouch.touch = touches[j];
              eventTouch.propagationStopped = eventTouch.propagationImmediateStopped = false;
              this._emitEvent(eventTouch);
            }
          }
          const eventKeyboardList = this._eventKeyboardList;
          for (let i = 0, length = eventKeyboardList.length; i < length; ++i) {
            const eventKeyboard = eventKeyboardList[i];
            this._emitEvent(eventKeyboard);
          }
          const eventAccelerationList = this._eventAccelerationList;
          for (let i = 0, length = eventAccelerationList.length; i < length; ++i) {
            const eventAcceleration = eventAccelerationList[i];
            this._emitEvent(eventAcceleration);
          }
          const eventGamepadList = this._eventGamepadList;
          for (let i = 0, length = eventGamepadList.length; i < length; ++i) {
            const eventGamepad = eventGamepadList[i];
            this._emitEvent(eventGamepad);
          }
          const eventHandleList = this._eventHandleList;
          for (let i = 0, length = eventHandleList.length; i < length; ++i) {
            const eventHandle = eventHandleList[i];
            this._emitEvent(eventHandle);
          }
          this._clearEvents();
        }
      } exports('Input', Input);
      Input.EventType = InputEventType;
      const input = exports('input', new Input());

      class SystemEvent extends EventTarget {
        constructor() {
          super();
          input.on(InputEventType.MOUSE_DOWN, e => {
            this.emit(SystemEventType.MOUSE_DOWN, e);
          });
          input.on(InputEventType.MOUSE_MOVE, e => {
            this.emit(SystemEventType.MOUSE_MOVE, e);
          });
          input.on(InputEventType.MOUSE_UP, e => {
            this.emit(SystemEventType.MOUSE_UP, e);
          });
          input.on(InputEventType.MOUSE_WHEEL, e => {
            this.emit(SystemEventType.MOUSE_WHEEL, e);
          });
          input.on(InputEventType.TOUCH_START, e => {
            this.emit(SystemEventType.TOUCH_START, e.touch, e);
          });
          input.on(InputEventType.TOUCH_MOVE, e => {
            this.emit(SystemEventType.TOUCH_MOVE, e.touch, e);
          });
          input.on(InputEventType.TOUCH_END, e => {
            this.emit(SystemEventType.TOUCH_END, e.touch, e);
          });
          input.on(InputEventType.TOUCH_CANCEL, e => {
            this.emit(SystemEventType.TOUCH_CANCEL, e.touch, e);
          });
          input.on(InputEventType.KEY_DOWN, e => {
            this.emit(SystemEventType.KEY_DOWN, e);
          });
          input.on(InputEventType.KEY_PRESSING, e => {
            this.emit(SystemEventType.KEY_DOWN, e);
          });
          input.on(InputEventType.KEY_UP, e => {
            this.emit(SystemEventType.KEY_UP, e);
          });
          input.on(InputEventType.DEVICEMOTION, e => {
            this.emit(SystemEventType.DEVICEMOTION, e);
          });
        }
        setAccelerometerEnabled(isEnabled) {
          input.setAccelerometerEnabled(isEnabled);
        }
        setAccelerometerInterval(interval) {
          input.setAccelerometerInterval(interval);
        }
        on(type, callback, target, once) {
          super.on(type, callback, target, once);
          return callback;
        }
        off(type, callback, target) {
          super.off(type, callback, target);
        }
      } exports('SystemEvent', SystemEvent);
      SystemEvent.EventType = SystemEventType;
      legacyCC.SystemEvent = SystemEvent;
      const systemEvent = exports('systemEvent', new SystemEvent());
      legacyCC.systemEvent = systemEvent;

      replaceProperty(SystemEventType, 'Node.EventType', [{
        name: 'POSITION_PART',
        newName: 'TRANSFORM_CHANGED'
      }, {
        name: 'ROTATION_PART',
        newName: 'TRANSFORM_CHANGED'
      }, {
        name: 'SCALE_PART',
        newName: 'TRANSFORM_CHANGED'
      }]);
      replaceProperty(Event, 'Event', [{
        name: 'ACCELERATION',
        newName: 'DEVICEMOTION',
        target: SystemEvent.EventType,
        targetName: 'SystemEvent.EventType'
      }]);
      markAsWarning(Event, 'Event', [{
        name: 'TOUCH',
        suggest: 'please use SystemEvent.EventType.TOUCH_START, SystemEvent.EventType.TOUCH_MOVE, SystemEvent.EventType.TOUCH_END and SystemEvent.EventType.TOUCH_CANCEL instead'
      }, {
        name: 'MOUSE',
        suggest: 'please use SystemEvent.EventType.MOUSE_DOWN, SystemEvent.EventType.MOUSE_MOVE, SystemEvent.EventType.MOUSE_UP, SystemEvent.EventType.MOUSE_WHEEL, Node.EventType.MOUSE_ENTER and Node.EventType.MOUSE_LEAVE instead'
      }, {
        name: 'KEYBOARD',
        suggest: 'please use SystemEvent.EventType.KEY_DOWN and SystemEvent.EventType.KEY_UP instead'
      }]);
      replaceProperty(EventMouse, 'EventMouse', ['DOWN', 'UP', 'MOVE'].map(item => ({
        name: item,
        newName: `MOUSE_${item}`,
        target: SystemEvent.EventType,
        targetName: 'SystemEvent.EventType'
      })));
      replaceProperty(EventMouse, 'EventMouse', [{
        name: 'SCROLL',
        newName: 'MOUSE_WHEEL',
        target: SystemEvent.EventType,
        targetName: 'SystemEvent.EventType'
      }]);
      markAsWarning(EventMouse.prototype, 'EventMouse.prototype', [{
        name: 'eventType',
        suggest: 'please use EventMouse.prototype.type instead'
      }]);
      replaceProperty(EventTouch, 'EventTouch', [{
        name: 'BEGAN',
        newName: 'TOUCH_START',
        target: SystemEvent.EventType,
        targetName: 'SystemEvent.EventType'
      }]);
      replaceProperty(EventTouch, 'EventTouch', [{
        name: 'MOVED',
        newName: 'TOUCH_MOVE',
        target: SystemEvent.EventType,
        targetName: 'SystemEvent.EventType'
      }]);
      replaceProperty(EventTouch, 'EventTouch', [{
        name: 'ENDED',
        newName: 'TOUCH_END',
        target: SystemEvent.EventType,
        targetName: 'SystemEvent.EventType'
      }]);
      replaceProperty(EventTouch, 'EventTouch', [{
        name: 'CANCELLED',
        newName: 'TOUCH_CANCEL',
        target: SystemEvent.EventType,
        targetName: 'SystemEvent.EventType'
      }]);
      markAsWarning(EventTouch.prototype, 'EventTouch.prototype', [{
        name: 'getEventCode',
        suggest: 'please use EventTouch.prototype.type instead'
      }]);
      replaceProperty(EventTouch.prototype, 'EventTouch.prototype', [{
        name: 'getUILocationInView',
        newName: 'getLocationInView',
        target: EventTouch,
        targetName: 'EventTouch'
      }]);
      markAsWarning(macro.KEY, 'macro.KEY', ['back', 'menu', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '*', '+', '-', '/', ';', '=', ',', '.', '[', ']', 'dpadLeft', 'dpadRight', 'dpadUp', 'dpadDown', 'dpadCenter'].map(item => ({
        name: item
      })));
      markAsWarning(macro.KEY, 'macro.KEY', [{
        name: 'shift',
        suggest: 'please use KeyCode.SHIFT_LEFT instead'
      }]);
      markAsWarning(macro.KEY, 'macro.KEY', [{
        name: 'ctrl',
        suggest: 'please use KeyCode.CTRL_LEFT instead'
      }]);
      markAsWarning(macro.KEY, 'macro.KEY', [{
        name: 'alt',
        suggest: 'please use KeyCode.ALT_LEFT instead'
      }]);
      markAsWarning(macro, 'macro', [{
        name: 'KEY',
        suggest: 'please use KeyCode instead'
      }]);

      const layerList = {
        NONE: 0,
        IGNORE_RAYCAST: 1 << 20,
        GIZMOS: 1 << 21,
        EDITOR: 1 << 22,
        UI_3D: 1 << 23,
        SCENE_GIZMO: 1 << 24,
        UI_2D: 1 << 25,
        PROFILER: 1 << 28,
        DEFAULT: 1 << 30,
        ALL: 0xffffffff
      };
      class Layers {
        static init() {
          const userLayers = settings.querySettings(Settings.Category.ENGINE, 'customLayers');
          if (!userLayers) return;
          for (let i = 0; i < userLayers.length; i++) {
            const layer = userLayers[i];
            Layers.addLayer(layer.name, layer.bit);
          }
        }
        static makeMaskInclude(includes) {
          let mask = 0;
          for (const inc of includes) {
            mask |= inc;
          }
          return mask;
        }
        static makeMaskExclude(excludes) {
          return ~Layers.makeMaskInclude(excludes);
        }
        static addLayer(name, bitNum) {
          if (bitNum === undefined) {
            console.warn('bitNum can\'t be undefined');
            return;
          }
          if (bitNum > 19 || bitNum < 0) {
            console.warn('maximum layers reached.');
            return;
          }
          const val = 1 << bitNum;
          assertIsTrue(!Layers.Enum[name], getError(2104, name));
          Layers.Enum[name] = val;
          value(Layers.Enum, String(val), name);
          Layers.BitMask[name] = val;
          value(Layers.BitMask, String(val), name);
          BitMask.update(Layers.BitMask);
          Enum.update(Layers.Enum);
        }
        static deleteLayer(bitNum) {
          if (bitNum > 19 || bitNum < 0) {
            console.warn('do not change buildin layers.');
            return;
          }
          const val = 1 << bitNum;
          delete Layers.Enum[Layers.Enum[val]];
          delete Layers.Enum[val];
          delete Layers.BitMask[Layers.BitMask[val]];
          delete Layers.BitMask[val];
          BitMask.update(Layers.BitMask);
          Enum.update(Layers.Enum);
        }
        static nameToLayer(name) {
          if (name === undefined) {
            console.warn('name can\'t be undefined');
            return -1;
          }
          return log2(Layers.Enum[name]);
        }
        static layerToName(bitNum) {
          if (bitNum > 31 || bitNum < 0) {
            console.warn('Unable to access unknown layer.');
            return '';
          }
          return Layers.Enum[1 << bitNum];
        }
      } exports('Layers', Layers);
      Layers.Enum = Enum(layerList);
      Layers.BitMask = BitMask({
        ...layerList
      });
      legacyCC.Layers = Layers;

      var _class$T, _class2$M, _class3$s, _class4$3, _class5$2, _class6, _class7$1, _class8$1, _class10$1, _class11$1, _class12, _class13$1, _class14$1, _class15;
      const PIPELINE_FLOW_MAIN = 'MainFlow';
      const PIPELINE_FLOW_FORWARD = 'ForwardFlow';
      const PIPELINE_FLOW_SHADOW = 'ShadowFlow';
      const PIPELINE_FLOW_SMAA = 'SMAAFlow';
      const PIPELINE_FLOW_TONEMAP = 'ToneMapFlow';
      let RenderPassStage;
      (function (RenderPassStage) {
        RenderPassStage[RenderPassStage["DEFAULT"] = 100] = "DEFAULT";
        RenderPassStage[RenderPassStage["UI"] = 200] = "UI";
      })(RenderPassStage || (RenderPassStage = {}));
      legacyCC.RenderPassStage = RenderPassStage;
      let RenderPriority;
      (function (RenderPriority) {
        RenderPriority[RenderPriority["MIN"] = 0] = "MIN";
        RenderPriority[RenderPriority["MAX"] = 255] = "MAX";
        RenderPriority[RenderPriority["DEFAULT"] = 128] = "DEFAULT";
      })(RenderPriority || (RenderPriority = {}));
      const globalDescriptorSetLayout = {
        bindings: [],
        layouts: {}
      };
      const localDescriptorSetLayout = {
        bindings: [],
        layouts: {}
      };
      let PipelineGlobalBindings;
      (function (PipelineGlobalBindings) {
        PipelineGlobalBindings[PipelineGlobalBindings["UBO_GLOBAL"] = 0] = "UBO_GLOBAL";
        PipelineGlobalBindings[PipelineGlobalBindings["UBO_CAMERA"] = 1] = "UBO_CAMERA";
        PipelineGlobalBindings[PipelineGlobalBindings["UBO_SHADOW"] = 2] = "UBO_SHADOW";
        PipelineGlobalBindings[PipelineGlobalBindings["UBO_CSM"] = 3] = "UBO_CSM";
        PipelineGlobalBindings[PipelineGlobalBindings["SAMPLER_SHADOWMAP"] = 4] = "SAMPLER_SHADOWMAP";
        PipelineGlobalBindings[PipelineGlobalBindings["SAMPLER_ENVIRONMENT"] = 5] = "SAMPLER_ENVIRONMENT";
        PipelineGlobalBindings[PipelineGlobalBindings["SAMPLER_SPOT_SHADOW_MAP"] = 6] = "SAMPLER_SPOT_SHADOW_MAP";
        PipelineGlobalBindings[PipelineGlobalBindings["SAMPLER_DIFFUSEMAP"] = 7] = "SAMPLER_DIFFUSEMAP";
        PipelineGlobalBindings[PipelineGlobalBindings["COUNT"] = 8] = "COUNT";
      })(PipelineGlobalBindings || (PipelineGlobalBindings = {}));
      const GLOBAL_UBO_COUNT = PipelineGlobalBindings.SAMPLER_SHADOWMAP;
      const GLOBAL_SAMPLER_COUNT = PipelineGlobalBindings.COUNT - GLOBAL_UBO_COUNT;
      let ModelLocalBindings;
      (function (ModelLocalBindings) {
        ModelLocalBindings[ModelLocalBindings["UBO_LOCAL"] = 0] = "UBO_LOCAL";
        ModelLocalBindings[ModelLocalBindings["UBO_FORWARD_LIGHTS"] = 1] = "UBO_FORWARD_LIGHTS";
        ModelLocalBindings[ModelLocalBindings["UBO_SKINNING_ANIMATION"] = 2] = "UBO_SKINNING_ANIMATION";
        ModelLocalBindings[ModelLocalBindings["UBO_SKINNING_TEXTURE"] = 3] = "UBO_SKINNING_TEXTURE";
        ModelLocalBindings[ModelLocalBindings["UBO_MORPH"] = 4] = "UBO_MORPH";
        ModelLocalBindings[ModelLocalBindings["UBO_UI_LOCAL"] = 5] = "UBO_UI_LOCAL";
        ModelLocalBindings[ModelLocalBindings["UBO_SH"] = 6] = "UBO_SH";
        ModelLocalBindings[ModelLocalBindings["SAMPLER_JOINTS"] = 7] = "SAMPLER_JOINTS";
        ModelLocalBindings[ModelLocalBindings["SAMPLER_MORPH_POSITION"] = 8] = "SAMPLER_MORPH_POSITION";
        ModelLocalBindings[ModelLocalBindings["SAMPLER_MORPH_NORMAL"] = 9] = "SAMPLER_MORPH_NORMAL";
        ModelLocalBindings[ModelLocalBindings["SAMPLER_MORPH_TANGENT"] = 10] = "SAMPLER_MORPH_TANGENT";
        ModelLocalBindings[ModelLocalBindings["SAMPLER_LIGHTMAP"] = 11] = "SAMPLER_LIGHTMAP";
        ModelLocalBindings[ModelLocalBindings["SAMPLER_SPRITE"] = 12] = "SAMPLER_SPRITE";
        ModelLocalBindings[ModelLocalBindings["SAMPLER_REFLECTION"] = 13] = "SAMPLER_REFLECTION";
        ModelLocalBindings[ModelLocalBindings["STORAGE_REFLECTION"] = 14] = "STORAGE_REFLECTION";
        ModelLocalBindings[ModelLocalBindings["SAMPLER_REFLECTION_PROBE_CUBE"] = 15] = "SAMPLER_REFLECTION_PROBE_CUBE";
        ModelLocalBindings[ModelLocalBindings["SAMPLER_REFLECTION_PROBE_PLANAR"] = 16] = "SAMPLER_REFLECTION_PROBE_PLANAR";
        ModelLocalBindings[ModelLocalBindings["SAMPLER_REFLECTION_PROBE_DATA_MAP"] = 17] = "SAMPLER_REFLECTION_PROBE_DATA_MAP";
        ModelLocalBindings[ModelLocalBindings["SAMPLER_REFLECTION_PROBE_BLEND_CUBE"] = 18] = "SAMPLER_REFLECTION_PROBE_BLEND_CUBE";
        ModelLocalBindings[ModelLocalBindings["COUNT"] = 19] = "COUNT";
      })(ModelLocalBindings || (ModelLocalBindings = {}));
      const LOCAL_UBO_COUNT = ModelLocalBindings.SAMPLER_JOINTS;
      const LOCAL_SAMPLER_COUNT = ModelLocalBindings.STORAGE_REFLECTION - LOCAL_UBO_COUNT;
      const LOCAL_STORAGE_IMAGE_COUNT = ModelLocalBindings.COUNT - LOCAL_UBO_COUNT - LOCAL_SAMPLER_COUNT;
      let SetIndex;
      (function (SetIndex) {
        SetIndex[SetIndex["GLOBAL"] = 0] = "GLOBAL";
        SetIndex[SetIndex["MATERIAL"] = 1] = "MATERIAL";
        SetIndex[SetIndex["LOCAL"] = 2] = "LOCAL";
        SetIndex[SetIndex["COUNT"] = 3] = "COUNT";
      })(SetIndex || (SetIndex = {}));
      const bindingMappingInfo = new BindingMappingInfo([GLOBAL_UBO_COUNT, 0, LOCAL_UBO_COUNT, 0], [GLOBAL_SAMPLER_COUNT, 0, LOCAL_SAMPLER_COUNT, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, LOCAL_STORAGE_IMAGE_COUNT, 0], [0, 0, 0, 0], [0, 2, 1, 3]);
      class UBOGlobal {}
      _class$T = UBOGlobal;
      UBOGlobal.TIME_OFFSET = 0;
      UBOGlobal.SCREEN_SIZE_OFFSET = _class$T.TIME_OFFSET + 4;
      UBOGlobal.NATIVE_SIZE_OFFSET = _class$T.SCREEN_SIZE_OFFSET + 4;
      UBOGlobal.PROBE_INFO_OFFSET = _class$T.NATIVE_SIZE_OFFSET + 4;
      UBOGlobal.DEBUG_VIEW_MODE_OFFSET = _class$T.PROBE_INFO_OFFSET + 4;
      UBOGlobal.COUNT = _class$T.DEBUG_VIEW_MODE_OFFSET + 4;
      UBOGlobal.SIZE = _class$T.COUNT * 4;
      UBOGlobal.NAME = 'CCGlobal';
      UBOGlobal.BINDING = PipelineGlobalBindings.UBO_GLOBAL;
      UBOGlobal.DESCRIPTOR = new DescriptorSetLayoutBinding(_class$T.BINDING, DescriptorType.UNIFORM_BUFFER, 1, ShaderStageFlagBit.ALL);
      UBOGlobal.LAYOUT = new UniformBlock(SetIndex.GLOBAL, _class$T.BINDING, _class$T.NAME, [new Uniform('cc_time', Type$1.FLOAT4, 1), new Uniform('cc_screenSize', Type$1.FLOAT4, 1), new Uniform('cc_nativeSize', Type$1.FLOAT4, 1), new Uniform('cc_probeInfo', Type$1.FLOAT4, 1), new Uniform('cc_debug_view_mode', Type$1.FLOAT4, 1)], 1);
      globalDescriptorSetLayout.layouts[UBOGlobal.NAME] = UBOGlobal.LAYOUT;
      globalDescriptorSetLayout.bindings[UBOGlobal.BINDING] = UBOGlobal.DESCRIPTOR;
      class UBOCamera {}
      _class2$M = UBOCamera;
      UBOCamera.MAT_VIEW_OFFSET = 0;
      UBOCamera.MAT_VIEW_INV_OFFSET = _class2$M.MAT_VIEW_OFFSET + 16;
      UBOCamera.MAT_PROJ_OFFSET = _class2$M.MAT_VIEW_INV_OFFSET + 16;
      UBOCamera.MAT_PROJ_INV_OFFSET = _class2$M.MAT_PROJ_OFFSET + 16;
      UBOCamera.MAT_VIEW_PROJ_OFFSET = _class2$M.MAT_PROJ_INV_OFFSET + 16;
      UBOCamera.MAT_VIEW_PROJ_INV_OFFSET = _class2$M.MAT_VIEW_PROJ_OFFSET + 16;
      UBOCamera.CAMERA_POS_OFFSET = _class2$M.MAT_VIEW_PROJ_INV_OFFSET + 16;
      UBOCamera.SURFACE_TRANSFORM_OFFSET = _class2$M.CAMERA_POS_OFFSET + 4;
      UBOCamera.SCREEN_SCALE_OFFSET = _class2$M.SURFACE_TRANSFORM_OFFSET + 4;
      UBOCamera.EXPOSURE_OFFSET = _class2$M.SCREEN_SCALE_OFFSET + 4;
      UBOCamera.MAIN_LIT_DIR_OFFSET = _class2$M.EXPOSURE_OFFSET + 4;
      UBOCamera.MAIN_LIT_COLOR_OFFSET = _class2$M.MAIN_LIT_DIR_OFFSET + 4;
      UBOCamera.AMBIENT_SKY_OFFSET = _class2$M.MAIN_LIT_COLOR_OFFSET + 4;
      UBOCamera.AMBIENT_GROUND_OFFSET = _class2$M.AMBIENT_SKY_OFFSET + 4;
      UBOCamera.GLOBAL_FOG_COLOR_OFFSET = _class2$M.AMBIENT_GROUND_OFFSET + 4;
      UBOCamera.GLOBAL_FOG_BASE_OFFSET = _class2$M.GLOBAL_FOG_COLOR_OFFSET + 4;
      UBOCamera.GLOBAL_FOG_ADD_OFFSET = _class2$M.GLOBAL_FOG_BASE_OFFSET + 4;
      UBOCamera.NEAR_FAR_OFFSET = _class2$M.GLOBAL_FOG_ADD_OFFSET + 4;
      UBOCamera.VIEW_PORT_OFFSET = _class2$M.NEAR_FAR_OFFSET + 4;
      UBOCamera.COUNT = _class2$M.VIEW_PORT_OFFSET + 4;
      UBOCamera.SIZE = _class2$M.COUNT * 4;
      UBOCamera.NAME = 'CCCamera';
      UBOCamera.BINDING = PipelineGlobalBindings.UBO_CAMERA;
      UBOCamera.DESCRIPTOR = new DescriptorSetLayoutBinding(_class2$M.BINDING, DescriptorType.UNIFORM_BUFFER, 1, ShaderStageFlagBit.ALL);
      UBOCamera.LAYOUT = new UniformBlock(SetIndex.GLOBAL, _class2$M.BINDING, _class2$M.NAME, [new Uniform('cc_matView', Type$1.MAT4, 1), new Uniform('cc_matViewInv', Type$1.MAT4, 1), new Uniform('cc_matProj', Type$1.MAT4, 1), new Uniform('cc_matProjInv', Type$1.MAT4, 1), new Uniform('cc_matViewProj', Type$1.MAT4, 1), new Uniform('cc_matViewProjInv', Type$1.MAT4, 1), new Uniform('cc_cameraPos', Type$1.FLOAT4, 1), new Uniform('cc_surfaceTransform', Type$1.FLOAT4, 1), new Uniform('cc_screenScale', Type$1.FLOAT4, 1), new Uniform('cc_exposure', Type$1.FLOAT4, 1), new Uniform('cc_mainLitDir', Type$1.FLOAT4, 1), new Uniform('cc_mainLitColor', Type$1.FLOAT4, 1), new Uniform('cc_ambientSky', Type$1.FLOAT4, 1), new Uniform('cc_ambientGround', Type$1.FLOAT4, 1), new Uniform('cc_fogColor', Type$1.FLOAT4, 1), new Uniform('cc_fogBase', Type$1.FLOAT4, 1), new Uniform('cc_fogAdd', Type$1.FLOAT4, 1), new Uniform('cc_nearFar', Type$1.FLOAT4, 1), new Uniform('cc_viewPort', Type$1.FLOAT4, 1)], 1);
      globalDescriptorSetLayout.layouts[UBOCamera.NAME] = UBOCamera.LAYOUT;
      globalDescriptorSetLayout.bindings[UBOCamera.BINDING] = UBOCamera.DESCRIPTOR;
      class UBOShadow {}
      _class3$s = UBOShadow;
      UBOShadow.MAT_LIGHT_VIEW_OFFSET = 0;
      UBOShadow.MAT_LIGHT_VIEW_PROJ_OFFSET = _class3$s.MAT_LIGHT_VIEW_OFFSET + 16;
      UBOShadow.SHADOW_INV_PROJ_DEPTH_INFO_OFFSET = _class3$s.MAT_LIGHT_VIEW_PROJ_OFFSET + 16;
      UBOShadow.SHADOW_PROJ_DEPTH_INFO_OFFSET = _class3$s.SHADOW_INV_PROJ_DEPTH_INFO_OFFSET + 4;
      UBOShadow.SHADOW_PROJ_INFO_OFFSET = _class3$s.SHADOW_PROJ_DEPTH_INFO_OFFSET + 4;
      UBOShadow.SHADOW_NEAR_FAR_LINEAR_SATURATION_INFO_OFFSET = _class3$s.SHADOW_PROJ_INFO_OFFSET + 4;
      UBOShadow.SHADOW_WIDTH_HEIGHT_PCF_BIAS_INFO_OFFSET = _class3$s.SHADOW_NEAR_FAR_LINEAR_SATURATION_INFO_OFFSET + 4;
      UBOShadow.SHADOW_LIGHT_PACKING_NBIAS_NULL_INFO_OFFSET = _class3$s.SHADOW_WIDTH_HEIGHT_PCF_BIAS_INFO_OFFSET + 4;
      UBOShadow.SHADOW_COLOR_OFFSET = _class3$s.SHADOW_LIGHT_PACKING_NBIAS_NULL_INFO_OFFSET + 4;
      UBOShadow.PLANAR_NORMAL_DISTANCE_INFO_OFFSET = _class3$s.SHADOW_COLOR_OFFSET + 4;
      UBOShadow.COUNT = _class3$s.PLANAR_NORMAL_DISTANCE_INFO_OFFSET + 4;
      UBOShadow.SIZE = _class3$s.COUNT * 4;
      UBOShadow.NAME = 'CCShadow';
      UBOShadow.BINDING = PipelineGlobalBindings.UBO_SHADOW;
      UBOShadow.DESCRIPTOR = new DescriptorSetLayoutBinding(_class3$s.BINDING, DescriptorType.UNIFORM_BUFFER, 1, ShaderStageFlagBit.ALL);
      UBOShadow.LAYOUT = new UniformBlock(SetIndex.GLOBAL, _class3$s.BINDING, _class3$s.NAME, [new Uniform('cc_matLightView', Type$1.MAT4, 1), new Uniform('cc_matLightViewProj', Type$1.MAT4, 1), new Uniform('cc_shadowInvProjDepthInfo', Type$1.FLOAT4, 1), new Uniform('cc_shadowProjDepthInfo', Type$1.FLOAT4, 1), new Uniform('cc_shadowProjInfo', Type$1.FLOAT4, 1), new Uniform('cc_shadowNFLSInfo', Type$1.FLOAT4, 1), new Uniform('cc_shadowWHPBInfo', Type$1.FLOAT4, 1), new Uniform('cc_shadowLPNNInfo', Type$1.FLOAT4, 1), new Uniform('cc_shadowColor', Type$1.FLOAT4, 1), new Uniform('cc_planarNDInfo', Type$1.FLOAT4, 1)], 1);
      globalDescriptorSetLayout.layouts[UBOShadow.NAME] = UBOShadow.LAYOUT;
      globalDescriptorSetLayout.bindings[UBOShadow.BINDING] = UBOShadow.DESCRIPTOR;
      class UBOCSM {}
      _class4$3 = UBOCSM;
      UBOCSM.CSM_LEVEL_COUNT = 4;
      UBOCSM.CSM_VIEW_DIR_0_OFFSET = 0;
      UBOCSM.CSM_VIEW_DIR_1_OFFSET = _class4$3.CSM_VIEW_DIR_0_OFFSET + 4 * _class4$3.CSM_LEVEL_COUNT;
      UBOCSM.CSM_VIEW_DIR_2_OFFSET = _class4$3.CSM_VIEW_DIR_1_OFFSET + 4 * _class4$3.CSM_LEVEL_COUNT;
      UBOCSM.CSM_ATLAS_OFFSET = _class4$3.CSM_VIEW_DIR_2_OFFSET + 4 * _class4$3.CSM_LEVEL_COUNT;
      UBOCSM.MAT_CSM_VIEW_PROJ_OFFSET = _class4$3.CSM_ATLAS_OFFSET + 4 * _class4$3.CSM_LEVEL_COUNT;
      UBOCSM.CSM_PROJ_DEPTH_INFO_OFFSET = _class4$3.MAT_CSM_VIEW_PROJ_OFFSET + 16 * _class4$3.CSM_LEVEL_COUNT;
      UBOCSM.CSM_PROJ_INFO_OFFSET = _class4$3.CSM_PROJ_DEPTH_INFO_OFFSET + 4 * _class4$3.CSM_LEVEL_COUNT;
      UBOCSM.CSM_SPLITS_INFO_OFFSET = _class4$3.CSM_PROJ_INFO_OFFSET + 4 * _class4$3.CSM_LEVEL_COUNT;
      UBOCSM.COUNT = _class4$3.CSM_SPLITS_INFO_OFFSET + 4;
      UBOCSM.SIZE = _class4$3.COUNT * 4;
      UBOCSM.NAME = 'CCCSM';
      UBOCSM.BINDING = PipelineGlobalBindings.UBO_CSM;
      UBOCSM.DESCRIPTOR = new DescriptorSetLayoutBinding(_class4$3.BINDING, DescriptorType.UNIFORM_BUFFER, 1, ShaderStageFlagBit.FRAGMENT);
      UBOCSM.LAYOUT = new UniformBlock(SetIndex.GLOBAL, _class4$3.BINDING, _class4$3.NAME, [new Uniform('cc_csmViewDir0', Type$1.FLOAT4, _class4$3.CSM_LEVEL_COUNT), new Uniform('cc_csmViewDir1', Type$1.FLOAT4, _class4$3.CSM_LEVEL_COUNT), new Uniform('cc_csmViewDir2', Type$1.FLOAT4, _class4$3.CSM_LEVEL_COUNT), new Uniform('cc_csmAtlas', Type$1.FLOAT4, _class4$3.CSM_LEVEL_COUNT), new Uniform('cc_matCSMViewProj', Type$1.MAT4, _class4$3.CSM_LEVEL_COUNT), new Uniform('cc_csmProjDepthInfo', Type$1.FLOAT4, _class4$3.CSM_LEVEL_COUNT), new Uniform('cc_csmProjInfo', Type$1.FLOAT4, _class4$3.CSM_LEVEL_COUNT), new Uniform('cc_csmSplitsInfo', Type$1.FLOAT4, 1)], 1);
      globalDescriptorSetLayout.layouts[UBOCSM.NAME] = UBOCSM.LAYOUT;
      globalDescriptorSetLayout.bindings[UBOCSM.BINDING] = UBOCSM.DESCRIPTOR;
      const UNIFORM_SHADOWMAP_NAME = 'cc_shadowMap';
      const UNIFORM_SHADOWMAP_BINDING = PipelineGlobalBindings.SAMPLER_SHADOWMAP;
      const UNIFORM_SHADOWMAP_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_SHADOWMAP_BINDING, DescriptorType.SAMPLER_TEXTURE, 1, ShaderStageFlagBit.FRAGMENT);
      const UNIFORM_SHADOWMAP_LAYOUT = new UniformSamplerTexture(SetIndex.GLOBAL, UNIFORM_SHADOWMAP_BINDING, UNIFORM_SHADOWMAP_NAME, Type$1.SAMPLER2D, 1);
      globalDescriptorSetLayout.layouts[UNIFORM_SHADOWMAP_NAME] = UNIFORM_SHADOWMAP_LAYOUT;
      globalDescriptorSetLayout.bindings[UNIFORM_SHADOWMAP_BINDING] = UNIFORM_SHADOWMAP_DESCRIPTOR;
      const UNIFORM_ENVIRONMENT_NAME = 'cc_environment';
      const UNIFORM_ENVIRONMENT_BINDING = PipelineGlobalBindings.SAMPLER_ENVIRONMENT;
      const UNIFORM_ENVIRONMENT_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_ENVIRONMENT_BINDING, DescriptorType.SAMPLER_TEXTURE, 1, ShaderStageFlagBit.FRAGMENT);
      const UNIFORM_ENVIRONMENT_LAYOUT = new UniformSamplerTexture(SetIndex.GLOBAL, UNIFORM_ENVIRONMENT_BINDING, UNIFORM_ENVIRONMENT_NAME, Type$1.SAMPLER_CUBE, 1);
      globalDescriptorSetLayout.layouts[UNIFORM_ENVIRONMENT_NAME] = UNIFORM_ENVIRONMENT_LAYOUT;
      globalDescriptorSetLayout.bindings[UNIFORM_ENVIRONMENT_BINDING] = UNIFORM_ENVIRONMENT_DESCRIPTOR;
      const UNIFORM_DIFFUSEMAP_NAME = 'cc_diffuseMap';
      const UNIFORM_DIFFUSEMAP_BINDING = PipelineGlobalBindings.SAMPLER_DIFFUSEMAP;
      const UNIFORM_DIFFUSEMAP_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_DIFFUSEMAP_BINDING, DescriptorType.SAMPLER_TEXTURE, 1, ShaderStageFlagBit.FRAGMENT);
      const UNIFORM_DIFFUSEMAP_LAYOUT = new UniformSamplerTexture(SetIndex.GLOBAL, UNIFORM_DIFFUSEMAP_BINDING, UNIFORM_DIFFUSEMAP_NAME, Type$1.SAMPLER_CUBE, 1);
      globalDescriptorSetLayout.layouts[UNIFORM_DIFFUSEMAP_NAME] = UNIFORM_DIFFUSEMAP_LAYOUT;
      globalDescriptorSetLayout.bindings[UNIFORM_DIFFUSEMAP_BINDING] = UNIFORM_DIFFUSEMAP_DESCRIPTOR;
      const UNIFORM_SPOT_SHADOW_MAP_TEXTURE_NAME = 'cc_spotShadowMap';
      const UNIFORM_SPOT_SHADOW_MAP_TEXTURE_BINDING = PipelineGlobalBindings.SAMPLER_SPOT_SHADOW_MAP;
      const UNIFORM_SPOT_SHADOW_MAP_TEXTURE_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_SPOT_SHADOW_MAP_TEXTURE_BINDING, DescriptorType.SAMPLER_TEXTURE, 1, ShaderStageFlagBit.FRAGMENT);
      const UNIFORM_SPOT_SHADOW_MAP_TEXTURE_LAYOUT = new UniformSamplerTexture(SetIndex.GLOBAL, UNIFORM_SPOT_SHADOW_MAP_TEXTURE_BINDING, UNIFORM_SPOT_SHADOW_MAP_TEXTURE_NAME, Type$1.SAMPLER2D, 1);
      globalDescriptorSetLayout.layouts[UNIFORM_SPOT_SHADOW_MAP_TEXTURE_NAME] = UNIFORM_SPOT_SHADOW_MAP_TEXTURE_LAYOUT;
      globalDescriptorSetLayout.bindings[UNIFORM_SPOT_SHADOW_MAP_TEXTURE_BINDING] = UNIFORM_SPOT_SHADOW_MAP_TEXTURE_DESCRIPTOR;
      class UBOLocal {}
      _class5$2 = UBOLocal;
      UBOLocal.MAT_WORLD_OFFSET = 0;
      UBOLocal.MAT_WORLD_IT_OFFSET = _class5$2.MAT_WORLD_OFFSET + 16;
      UBOLocal.LIGHTINGMAP_UVPARAM = _class5$2.MAT_WORLD_IT_OFFSET + 16;
      UBOLocal.LOCAL_SHADOW_BIAS = _class5$2.LIGHTINGMAP_UVPARAM + 4;
      UBOLocal.REFLECTION_PROBE_DATA1 = _class5$2.LOCAL_SHADOW_BIAS + 4;
      UBOLocal.REFLECTION_PROBE_DATA2 = _class5$2.REFLECTION_PROBE_DATA1 + 4;
      UBOLocal.REFLECTION_PROBE_BLEND_DATA1 = _class5$2.REFLECTION_PROBE_DATA2 + 4;
      UBOLocal.REFLECTION_PROBE_BLEND_DATA2 = _class5$2.REFLECTION_PROBE_BLEND_DATA1 + 4;
      UBOLocal.COUNT = _class5$2.REFLECTION_PROBE_BLEND_DATA2 + 4;
      UBOLocal.SIZE = _class5$2.COUNT * 4;
      UBOLocal.NAME = 'CCLocal';
      UBOLocal.BINDING = ModelLocalBindings.UBO_LOCAL;
      UBOLocal.DESCRIPTOR = new DescriptorSetLayoutBinding(_class5$2.BINDING, DescriptorType.UNIFORM_BUFFER, 1, ShaderStageFlagBit.VERTEX | ShaderStageFlagBit.COMPUTE);
      UBOLocal.LAYOUT = new UniformBlock(SetIndex.LOCAL, _class5$2.BINDING, _class5$2.NAME, [new Uniform('cc_matWorld', Type$1.MAT4, 1), new Uniform('cc_matWorldIT', Type$1.MAT4, 1), new Uniform('cc_lightingMapUVParam', Type$1.FLOAT4, 1), new Uniform('cc_localShadowBias', Type$1.FLOAT4, 1), new Uniform('cc_reflectionProbeData1', Type$1.FLOAT4, 1), new Uniform('cc_reflectionProbeData2', Type$1.FLOAT4, 1), new Uniform('cc_reflectionProbeBlendData1', Type$1.FLOAT4, 1), new Uniform('cc_reflectionProbeBlendData2', Type$1.FLOAT4, 1)], 1);
      localDescriptorSetLayout.layouts[UBOLocal.NAME] = UBOLocal.LAYOUT;
      localDescriptorSetLayout.bindings[UBOLocal.BINDING] = UBOLocal.DESCRIPTOR;
      class UBOWorldBound {}
      _class6 = UBOWorldBound;
      UBOWorldBound.WORLD_BOUND_CENTER = 0;
      UBOWorldBound.WORLD_BOUND_HALF_EXTENTS = _class6.WORLD_BOUND_CENTER + 4;
      UBOWorldBound.COUNT = _class6.WORLD_BOUND_HALF_EXTENTS + 4;
      UBOWorldBound.SIZE = _class6.COUNT * 4;
      UBOWorldBound.NAME = 'CCWorldBound';
      UBOWorldBound.BINDING = ModelLocalBindings.UBO_LOCAL;
      UBOWorldBound.DESCRIPTOR = new DescriptorSetLayoutBinding(_class6.BINDING, DescriptorType.UNIFORM_BUFFER, 1, ShaderStageFlagBit.VERTEX | ShaderStageFlagBit.COMPUTE);
      UBOWorldBound.LAYOUT = new UniformBlock(SetIndex.LOCAL, _class6.BINDING, _class6.NAME, [new Uniform('cc_worldBoundCenter', Type$1.FLOAT4, 1), new Uniform('cc_worldBoundHalfExtents', Type$1.FLOAT4, 1)], 1);
      localDescriptorSetLayout.layouts[UBOWorldBound.NAME] = UBOWorldBound.LAYOUT;
      localDescriptorSetLayout.bindings[UBOWorldBound.BINDING] = UBOWorldBound.DESCRIPTOR;
      const INST_MAT_WORLD = 'a_matWorld0';
      const INST_SH = 'a_sh_linear_const_r';
      class UBOLocalBatched {}
      _class7$1 = UBOLocalBatched;
      UBOLocalBatched.BATCHING_COUNT = 10;
      UBOLocalBatched.MAT_WORLDS_OFFSET = 0;
      UBOLocalBatched.COUNT = 16 * _class7$1.BATCHING_COUNT;
      UBOLocalBatched.SIZE = _class7$1.COUNT * 4;
      UBOLocalBatched.NAME = 'CCLocalBatched';
      UBOLocalBatched.BINDING = ModelLocalBindings.UBO_LOCAL;
      UBOLocalBatched.DESCRIPTOR = new DescriptorSetLayoutBinding(_class7$1.BINDING, DescriptorType.UNIFORM_BUFFER, 1, ShaderStageFlagBit.VERTEX | ShaderStageFlagBit.COMPUTE);
      UBOLocalBatched.LAYOUT = new UniformBlock(SetIndex.LOCAL, _class7$1.BINDING, _class7$1.NAME, [new Uniform('cc_matWorlds', Type$1.MAT4, _class7$1.BATCHING_COUNT)], 1);
      localDescriptorSetLayout.layouts[UBOLocalBatched.NAME] = UBOLocalBatched.LAYOUT;
      localDescriptorSetLayout.bindings[UBOLocalBatched.BINDING] = UBOLocalBatched.DESCRIPTOR;
      class UBOForwardLight {}
      _class8$1 = UBOForwardLight;
      UBOForwardLight.LIGHTS_PER_PASS = 1;
      UBOForwardLight.LIGHT_POS_OFFSET = 0;
      UBOForwardLight.LIGHT_COLOR_OFFSET = _class8$1.LIGHT_POS_OFFSET + _class8$1.LIGHTS_PER_PASS * 4;
      UBOForwardLight.LIGHT_SIZE_RANGE_ANGLE_OFFSET = _class8$1.LIGHT_COLOR_OFFSET + _class8$1.LIGHTS_PER_PASS * 4;
      UBOForwardLight.LIGHT_DIR_OFFSET = _class8$1.LIGHT_SIZE_RANGE_ANGLE_OFFSET + _class8$1.LIGHTS_PER_PASS * 4;
      UBOForwardLight.LIGHT_BOUNDING_SIZE_VS_OFFSET = _class8$1.LIGHT_DIR_OFFSET + _class8$1.LIGHTS_PER_PASS * 4;
      UBOForwardLight.COUNT = _class8$1.LIGHT_BOUNDING_SIZE_VS_OFFSET + _class8$1.LIGHTS_PER_PASS * 4;
      UBOForwardLight.SIZE = _class8$1.COUNT * 4;
      UBOForwardLight.NAME = 'CCForwardLight';
      UBOForwardLight.BINDING = ModelLocalBindings.UBO_FORWARD_LIGHTS;
      UBOForwardLight.DESCRIPTOR = new DescriptorSetLayoutBinding(_class8$1.BINDING, DescriptorType.DYNAMIC_UNIFORM_BUFFER, 1, ShaderStageFlagBit.FRAGMENT);
      UBOForwardLight.LAYOUT = new UniformBlock(SetIndex.LOCAL, _class8$1.BINDING, _class8$1.NAME, [new Uniform('cc_lightPos', Type$1.FLOAT4, _class8$1.LIGHTS_PER_PASS), new Uniform('cc_lightColor', Type$1.FLOAT4, _class8$1.LIGHTS_PER_PASS), new Uniform('cc_lightSizeRangeAngle', Type$1.FLOAT4, _class8$1.LIGHTS_PER_PASS), new Uniform('cc_lightDir', Type$1.FLOAT4, _class8$1.LIGHTS_PER_PASS), new Uniform('cc_lightBoundingSizeVS', Type$1.FLOAT4, _class8$1.LIGHTS_PER_PASS)], 1);
      localDescriptorSetLayout.layouts[UBOForwardLight.NAME] = UBOForwardLight.LAYOUT;
      localDescriptorSetLayout.bindings[UBOForwardLight.BINDING] = UBOForwardLight.DESCRIPTOR;
      class UBODeferredLight {}
      UBODeferredLight.LIGHTS_PER_PASS = 10;
      const JOINT_UNIFORM_CAPACITY = 30;
      class UBOSkinningTexture {}
      _class10$1 = UBOSkinningTexture;
      UBOSkinningTexture.JOINTS_TEXTURE_INFO_OFFSET = 0;
      UBOSkinningTexture.COUNT = _class10$1.JOINTS_TEXTURE_INFO_OFFSET + 4;
      UBOSkinningTexture.SIZE = _class10$1.COUNT * 4;
      UBOSkinningTexture.NAME = 'CCSkinningTexture';
      UBOSkinningTexture.BINDING = ModelLocalBindings.UBO_SKINNING_TEXTURE;
      UBOSkinningTexture.DESCRIPTOR = new DescriptorSetLayoutBinding(_class10$1.BINDING, DescriptorType.UNIFORM_BUFFER, 1, ShaderStageFlagBit.VERTEX);
      UBOSkinningTexture.LAYOUT = new UniformBlock(SetIndex.LOCAL, _class10$1.BINDING, _class10$1.NAME, [new Uniform('cc_jointTextureInfo', Type$1.FLOAT4, 1)], 1);
      localDescriptorSetLayout.layouts[UBOSkinningTexture.NAME] = UBOSkinningTexture.LAYOUT;
      localDescriptorSetLayout.bindings[UBOSkinningTexture.BINDING] = UBOSkinningTexture.DESCRIPTOR;
      class UBOSkinningAnimation {}
      _class11$1 = UBOSkinningAnimation;
      UBOSkinningAnimation.JOINTS_ANIM_INFO_OFFSET = 0;
      UBOSkinningAnimation.COUNT = _class11$1.JOINTS_ANIM_INFO_OFFSET + 4;
      UBOSkinningAnimation.SIZE = _class11$1.COUNT * 4;
      UBOSkinningAnimation.NAME = 'CCSkinningAnimation';
      UBOSkinningAnimation.BINDING = ModelLocalBindings.UBO_SKINNING_ANIMATION;
      UBOSkinningAnimation.DESCRIPTOR = new DescriptorSetLayoutBinding(_class11$1.BINDING, DescriptorType.UNIFORM_BUFFER, 1, ShaderStageFlagBit.VERTEX);
      UBOSkinningAnimation.LAYOUT = new UniformBlock(SetIndex.LOCAL, _class11$1.BINDING, _class11$1.NAME, [new Uniform('cc_jointAnimInfo', Type$1.FLOAT4, 1)], 1);
      localDescriptorSetLayout.layouts[UBOSkinningAnimation.NAME] = UBOSkinningAnimation.LAYOUT;
      localDescriptorSetLayout.bindings[UBOSkinningAnimation.BINDING] = UBOSkinningAnimation.DESCRIPTOR;
      const INST_JOINT_ANIM_INFO = 'a_jointAnimInfo';
      class UBOSkinning {
        static get JOINT_UNIFORM_CAPACITY() {
          return UBOSkinning._jointUniformCapacity;
        }
        static get COUNT() {
          return UBOSkinning._count;
        }
        static get SIZE() {
          return UBOSkinning._size;
        }
        static initLayout(capacity) {
          UBOSkinning._jointUniformCapacity = capacity;
          UBOSkinning._count = capacity * 12;
          UBOSkinning._size = UBOSkinning._count * 4;
          UBOSkinning.LAYOUT.members[0].count = capacity * 3;
        }
      }
      _class12 = UBOSkinning;
      UBOSkinning._jointUniformCapacity = 0;
      UBOSkinning._count = 0;
      UBOSkinning._size = 0;
      UBOSkinning.NAME = 'CCSkinning';
      UBOSkinning.BINDING = ModelLocalBindings.UBO_SKINNING_TEXTURE;
      UBOSkinning.DESCRIPTOR = new DescriptorSetLayoutBinding(_class12.BINDING, DescriptorType.UNIFORM_BUFFER, 1, ShaderStageFlagBit.VERTEX);
      UBOSkinning.LAYOUT = new UniformBlock(SetIndex.LOCAL, _class12.BINDING, _class12.NAME, [new Uniform('cc_joints', Type$1.FLOAT4, 1)], 1);
      function localDescriptorSetLayout_ResizeMaxJoints(maxCount) {
        UBOSkinning.initLayout(maxCount);
        localDescriptorSetLayout.layouts[UBOSkinning.NAME] = UBOSkinning.LAYOUT;
        localDescriptorSetLayout.bindings[UBOSkinning.BINDING] = UBOSkinning.DESCRIPTOR;
      }
      class UBOMorph {}
      _class13$1 = UBOMorph;
      UBOMorph.MAX_MORPH_TARGET_COUNT = 60;
      UBOMorph.OFFSET_OF_WEIGHTS = 0;
      UBOMorph.OFFSET_OF_DISPLACEMENT_TEXTURE_WIDTH = 4 * _class13$1.MAX_MORPH_TARGET_COUNT;
      UBOMorph.OFFSET_OF_DISPLACEMENT_TEXTURE_HEIGHT = _class13$1.OFFSET_OF_DISPLACEMENT_TEXTURE_WIDTH + 4;
      UBOMorph.OFFSET_OF_VERTICES_COUNT = _class13$1.OFFSET_OF_DISPLACEMENT_TEXTURE_HEIGHT + 4;
      UBOMorph.COUNT_BASE_4_BYTES = 4 * Math.ceil(_class13$1.MAX_MORPH_TARGET_COUNT / 4) + 4;
      UBOMorph.SIZE = _class13$1.COUNT_BASE_4_BYTES * 4;
      UBOMorph.NAME = 'CCMorph';
      UBOMorph.BINDING = ModelLocalBindings.UBO_MORPH;
      UBOMorph.DESCRIPTOR = new DescriptorSetLayoutBinding(_class13$1.BINDING, DescriptorType.UNIFORM_BUFFER, 1, ShaderStageFlagBit.VERTEX);
      UBOMorph.LAYOUT = new UniformBlock(SetIndex.LOCAL, _class13$1.BINDING, _class13$1.NAME, [new Uniform('cc_displacementWeights', Type$1.FLOAT4, _class13$1.MAX_MORPH_TARGET_COUNT / 4), new Uniform('cc_displacementTextureInfo', Type$1.FLOAT4, 1)], 1);
      localDescriptorSetLayout.layouts[UBOMorph.NAME] = UBOMorph.LAYOUT;
      localDescriptorSetLayout.bindings[UBOMorph.BINDING] = UBOMorph.DESCRIPTOR;
      class UBOUILocal {}
      _class14$1 = UBOUILocal;
      UBOUILocal.NAME = 'CCUILocal';
      UBOUILocal.BINDING = ModelLocalBindings.UBO_UI_LOCAL;
      UBOUILocal.DESCRIPTOR = new DescriptorSetLayoutBinding(_class14$1.BINDING, DescriptorType.DYNAMIC_UNIFORM_BUFFER, 1, ShaderStageFlagBit.VERTEX);
      UBOUILocal.LAYOUT = new UniformBlock(SetIndex.LOCAL, _class14$1.BINDING, _class14$1.NAME, [new Uniform('cc_local_data', Type$1.FLOAT4, 1)], 1);
      localDescriptorSetLayout.layouts[UBOUILocal.NAME] = UBOUILocal.LAYOUT;
      localDescriptorSetLayout.bindings[UBOUILocal.BINDING] = UBOUILocal.DESCRIPTOR;
      class UBOSH {}
      _class15 = UBOSH;
      UBOSH.SH_LINEAR_CONST_R_OFFSET = 0;
      UBOSH.SH_LINEAR_CONST_G_OFFSET = _class15.SH_LINEAR_CONST_R_OFFSET + 4;
      UBOSH.SH_LINEAR_CONST_B_OFFSET = _class15.SH_LINEAR_CONST_G_OFFSET + 4;
      UBOSH.SH_QUADRATIC_R_OFFSET = _class15.SH_LINEAR_CONST_B_OFFSET + 4;
      UBOSH.SH_QUADRATIC_G_OFFSET = _class15.SH_QUADRATIC_R_OFFSET + 4;
      UBOSH.SH_QUADRATIC_B_OFFSET = _class15.SH_QUADRATIC_G_OFFSET + 4;
      UBOSH.SH_QUADRATIC_A_OFFSET = _class15.SH_QUADRATIC_B_OFFSET + 4;
      UBOSH.COUNT = _class15.SH_QUADRATIC_A_OFFSET + 4;
      UBOSH.SIZE = _class15.COUNT * 4;
      UBOSH.NAME = 'CCSH';
      UBOSH.BINDING = ModelLocalBindings.UBO_SH;
      UBOSH.DESCRIPTOR = new DescriptorSetLayoutBinding(_class15.BINDING, DescriptorType.UNIFORM_BUFFER, 1, ShaderStageFlagBit.FRAGMENT);
      UBOSH.LAYOUT = new UniformBlock(SetIndex.LOCAL, _class15.BINDING, _class15.NAME, [new Uniform('cc_sh_linear_const_r', Type$1.FLOAT4, 1), new Uniform('cc_sh_linear_const_g', Type$1.FLOAT4, 1), new Uniform('cc_sh_linear_const_b', Type$1.FLOAT4, 1), new Uniform('cc_sh_quadratic_r', Type$1.FLOAT4, 1), new Uniform('cc_sh_quadratic_g', Type$1.FLOAT4, 1), new Uniform('cc_sh_quadratic_b', Type$1.FLOAT4, 1), new Uniform('cc_sh_quadratic_a', Type$1.FLOAT4, 1)], 1);
      localDescriptorSetLayout.layouts[UBOSH.NAME] = UBOSH.LAYOUT;
      localDescriptorSetLayout.bindings[UBOSH.BINDING] = UBOSH.DESCRIPTOR;
      const UNIFORM_JOINT_TEXTURE_NAME = 'cc_jointTexture';
      const UNIFORM_JOINT_TEXTURE_BINDING = ModelLocalBindings.SAMPLER_JOINTS;
      const UNIFORM_JOINT_TEXTURE_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_JOINT_TEXTURE_BINDING, DescriptorType.SAMPLER_TEXTURE, 1, ShaderStageFlagBit.VERTEX);
      const UNIFORM_JOINT_TEXTURE_LAYOUT = new UniformSamplerTexture(SetIndex.LOCAL, UNIFORM_JOINT_TEXTURE_BINDING, UNIFORM_JOINT_TEXTURE_NAME, Type$1.SAMPLER2D, 1);
      localDescriptorSetLayout.layouts[UNIFORM_JOINT_TEXTURE_NAME] = UNIFORM_JOINT_TEXTURE_LAYOUT;
      localDescriptorSetLayout.bindings[UNIFORM_JOINT_TEXTURE_BINDING] = UNIFORM_JOINT_TEXTURE_DESCRIPTOR;
      const UNIFORM_REALTIME_JOINT_TEXTURE_NAME = 'cc_realtimeJoint';
      const UNIFORM_REALTIME_JOINT_TEXTURE_BINDING = ModelLocalBindings.SAMPLER_JOINTS;
      const UNIFORM_REALTIME_JOINT_TEXTURE_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_REALTIME_JOINT_TEXTURE_BINDING, DescriptorType.SAMPLER_TEXTURE, 1, ShaderStageFlagBit.VERTEX);
      const UNIFORM_REALTIME_JOINT_TEXTURE_LAYOUT = new UniformSamplerTexture(SetIndex.LOCAL, UNIFORM_REALTIME_JOINT_TEXTURE_BINDING, UNIFORM_REALTIME_JOINT_TEXTURE_NAME, Type$1.SAMPLER2D, 1);
      localDescriptorSetLayout.layouts[UNIFORM_REALTIME_JOINT_TEXTURE_NAME] = UNIFORM_REALTIME_JOINT_TEXTURE_LAYOUT;
      localDescriptorSetLayout.bindings[UNIFORM_REALTIME_JOINT_TEXTURE_BINDING] = UNIFORM_REALTIME_JOINT_TEXTURE_DESCRIPTOR;
      const UNIFORM_POSITION_MORPH_TEXTURE_NAME = 'cc_PositionDisplacements';
      const UNIFORM_POSITION_MORPH_TEXTURE_BINDING = ModelLocalBindings.SAMPLER_MORPH_POSITION;
      const UNIFORM_POSITION_MORPH_TEXTURE_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_POSITION_MORPH_TEXTURE_BINDING, DescriptorType.SAMPLER_TEXTURE, 1, ShaderStageFlagBit.VERTEX);
      const UNIFORM_POSITION_MORPH_TEXTURE_LAYOUT = new UniformSamplerTexture(SetIndex.LOCAL, UNIFORM_POSITION_MORPH_TEXTURE_BINDING, UNIFORM_POSITION_MORPH_TEXTURE_NAME, Type$1.SAMPLER2D, 1);
      localDescriptorSetLayout.layouts[UNIFORM_POSITION_MORPH_TEXTURE_NAME] = UNIFORM_POSITION_MORPH_TEXTURE_LAYOUT;
      localDescriptorSetLayout.bindings[UNIFORM_POSITION_MORPH_TEXTURE_BINDING] = UNIFORM_POSITION_MORPH_TEXTURE_DESCRIPTOR;
      const UNIFORM_NORMAL_MORPH_TEXTURE_NAME = 'cc_NormalDisplacements';
      const UNIFORM_NORMAL_MORPH_TEXTURE_BINDING = ModelLocalBindings.SAMPLER_MORPH_NORMAL;
      const UNIFORM_NORMAL_MORPH_TEXTURE_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_NORMAL_MORPH_TEXTURE_BINDING, DescriptorType.SAMPLER_TEXTURE, 1, ShaderStageFlagBit.VERTEX);
      const UNIFORM_NORMAL_MORPH_TEXTURE_LAYOUT = new UniformSamplerTexture(SetIndex.LOCAL, UNIFORM_NORMAL_MORPH_TEXTURE_BINDING, UNIFORM_NORMAL_MORPH_TEXTURE_NAME, Type$1.SAMPLER2D, 1);
      localDescriptorSetLayout.layouts[UNIFORM_NORMAL_MORPH_TEXTURE_NAME] = UNIFORM_NORMAL_MORPH_TEXTURE_LAYOUT;
      localDescriptorSetLayout.bindings[UNIFORM_NORMAL_MORPH_TEXTURE_BINDING] = UNIFORM_NORMAL_MORPH_TEXTURE_DESCRIPTOR;
      const UNIFORM_TANGENT_MORPH_TEXTURE_NAME = 'cc_TangentDisplacements';
      const UNIFORM_TANGENT_MORPH_TEXTURE_BINDING = ModelLocalBindings.SAMPLER_MORPH_TANGENT;
      const UNIFORM_TANGENT_MORPH_TEXTURE_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_TANGENT_MORPH_TEXTURE_BINDING, DescriptorType.SAMPLER_TEXTURE, 1, ShaderStageFlagBit.VERTEX);
      const UNIFORM_TANGENT_MORPH_TEXTURE_LAYOUT = new UniformSamplerTexture(SetIndex.LOCAL, UNIFORM_TANGENT_MORPH_TEXTURE_BINDING, UNIFORM_TANGENT_MORPH_TEXTURE_NAME, Type$1.SAMPLER2D, 1);
      localDescriptorSetLayout.layouts[UNIFORM_TANGENT_MORPH_TEXTURE_NAME] = UNIFORM_TANGENT_MORPH_TEXTURE_LAYOUT;
      localDescriptorSetLayout.bindings[UNIFORM_TANGENT_MORPH_TEXTURE_BINDING] = UNIFORM_TANGENT_MORPH_TEXTURE_DESCRIPTOR;
      const UNIFORM_LIGHTMAP_TEXTURE_NAME = 'cc_lightingMap';
      const UNIFORM_LIGHTMAP_TEXTURE_BINDING = ModelLocalBindings.SAMPLER_LIGHTMAP;
      const UNIFORM_LIGHTMAP_TEXTURE_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_LIGHTMAP_TEXTURE_BINDING, DescriptorType.SAMPLER_TEXTURE, 1, ShaderStageFlagBit.FRAGMENT);
      const UNIFORM_LIGHTMAP_TEXTURE_LAYOUT = new UniformSamplerTexture(SetIndex.LOCAL, UNIFORM_LIGHTMAP_TEXTURE_BINDING, UNIFORM_LIGHTMAP_TEXTURE_NAME, Type$1.SAMPLER2D, 1);
      localDescriptorSetLayout.layouts[UNIFORM_LIGHTMAP_TEXTURE_NAME] = UNIFORM_LIGHTMAP_TEXTURE_LAYOUT;
      localDescriptorSetLayout.bindings[UNIFORM_LIGHTMAP_TEXTURE_BINDING] = UNIFORM_LIGHTMAP_TEXTURE_DESCRIPTOR;
      const UNIFORM_SPRITE_TEXTURE_NAME = 'cc_spriteTexture';
      const UNIFORM_SPRITE_TEXTURE_BINDING = ModelLocalBindings.SAMPLER_SPRITE;
      const UNIFORM_SPRITE_TEXTURE_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_SPRITE_TEXTURE_BINDING, DescriptorType.SAMPLER_TEXTURE, 1, ShaderStageFlagBit.FRAGMENT);
      const UNIFORM_SPRITE_TEXTURE_LAYOUT = new UniformSamplerTexture(SetIndex.LOCAL, UNIFORM_SPRITE_TEXTURE_BINDING, UNIFORM_SPRITE_TEXTURE_NAME, Type$1.SAMPLER2D, 1);
      localDescriptorSetLayout.layouts[UNIFORM_SPRITE_TEXTURE_NAME] = UNIFORM_SPRITE_TEXTURE_LAYOUT;
      localDescriptorSetLayout.bindings[UNIFORM_SPRITE_TEXTURE_BINDING] = UNIFORM_SPRITE_TEXTURE_DESCRIPTOR;
      const UNIFORM_REFLECTION_TEXTURE_NAME = 'cc_reflectionTexture';
      const UNIFORM_REFLECTION_TEXTURE_BINDING = ModelLocalBindings.SAMPLER_REFLECTION;
      const UNIFORM_REFLECTION_TEXTURE_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_REFLECTION_TEXTURE_BINDING, DescriptorType.SAMPLER_TEXTURE, 1, ShaderStageFlagBit.FRAGMENT);
      const UNIFORM_REFLECTION_TEXTURE_LAYOUT = new UniformSamplerTexture(SetIndex.LOCAL, UNIFORM_REFLECTION_TEXTURE_BINDING, UNIFORM_REFLECTION_TEXTURE_NAME, Type$1.SAMPLER2D, 1);
      localDescriptorSetLayout.layouts[UNIFORM_REFLECTION_TEXTURE_NAME] = UNIFORM_REFLECTION_TEXTURE_LAYOUT;
      localDescriptorSetLayout.bindings[UNIFORM_REFLECTION_TEXTURE_BINDING] = UNIFORM_REFLECTION_TEXTURE_DESCRIPTOR;
      const UNIFORM_REFLECTION_STORAGE_NAME = 'cc_reflectionStorage';
      const UNIFORM_REFLECTION_STORAGE_BINDING = ModelLocalBindings.STORAGE_REFLECTION;
      const UNIFORM_REFLECTION_STORAGE_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_REFLECTION_STORAGE_BINDING, DescriptorType.STORAGE_IMAGE, 1, ShaderStageFlagBit.COMPUTE);
      const UNIFORM_REFLECTION_STORAGE_LAYOUT = new UniformStorageImage(SetIndex.LOCAL, UNIFORM_REFLECTION_STORAGE_BINDING, UNIFORM_REFLECTION_STORAGE_NAME, Type$1.IMAGE2D, 1);
      localDescriptorSetLayout.layouts[UNIFORM_REFLECTION_STORAGE_NAME] = UNIFORM_REFLECTION_STORAGE_LAYOUT;
      localDescriptorSetLayout.bindings[UNIFORM_REFLECTION_STORAGE_BINDING] = UNIFORM_REFLECTION_STORAGE_DESCRIPTOR;
      const UNIFORM_REFLECTION_PROBE_CUBEMAP_NAME = 'cc_reflectionProbeCubemap';
      const UNIFORM_REFLECTION_PROBE_CUBEMAP_BINDING = ModelLocalBindings.SAMPLER_REFLECTION_PROBE_CUBE;
      const UNIFORM_REFLECTION_PROBE_CUBEMAP_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_REFLECTION_PROBE_CUBEMAP_BINDING, DescriptorType.SAMPLER_TEXTURE, 1, ShaderStageFlagBit.FRAGMENT);
      const UNIFORM_REFLECTION_PROBE_CUBEMAP_LAYOUT = new UniformSamplerTexture(SetIndex.LOCAL, UNIFORM_REFLECTION_PROBE_CUBEMAP_BINDING, UNIFORM_REFLECTION_PROBE_CUBEMAP_NAME, Type$1.SAMPLER_CUBE, 1);
      localDescriptorSetLayout.layouts[UNIFORM_REFLECTION_PROBE_CUBEMAP_NAME] = UNIFORM_REFLECTION_PROBE_CUBEMAP_LAYOUT;
      localDescriptorSetLayout.bindings[UNIFORM_REFLECTION_PROBE_CUBEMAP_BINDING] = UNIFORM_REFLECTION_PROBE_CUBEMAP_DESCRIPTOR;
      const UNIFORM_REFLECTION_PROBE_TEXTURE_NAME = 'cc_reflectionProbePlanarMap';
      const UNIFORM_REFLECTION_PROBE_TEXTURE_BINDING = ModelLocalBindings.SAMPLER_REFLECTION_PROBE_PLANAR;
      const UNIFORM_REFLECTION_PROBE_TEXTURE_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_REFLECTION_PROBE_TEXTURE_BINDING, DescriptorType.SAMPLER_TEXTURE, 1, ShaderStageFlagBit.FRAGMENT);
      const UNIFORM_REFLECTION_PROBE_TEXTURE_LAYOUT = new UniformSamplerTexture(SetIndex.LOCAL, UNIFORM_REFLECTION_PROBE_TEXTURE_BINDING, UNIFORM_REFLECTION_PROBE_TEXTURE_NAME, Type$1.SAMPLER2D, 1);
      localDescriptorSetLayout.layouts[UNIFORM_REFLECTION_PROBE_TEXTURE_NAME] = UNIFORM_REFLECTION_PROBE_TEXTURE_LAYOUT;
      localDescriptorSetLayout.bindings[UNIFORM_REFLECTION_PROBE_TEXTURE_BINDING] = UNIFORM_REFLECTION_PROBE_TEXTURE_DESCRIPTOR;
      const UNIFORM_REFLECTION_PROBE_DATA_MAP_NAME = 'cc_reflectionProbeDataMap';
      const UNIFORM_REFLECTION_PROBE_DATA_MAP_BINDING = ModelLocalBindings.SAMPLER_REFLECTION_PROBE_DATA_MAP;
      const UNIFORM_REFLECTION_PROBE_DATA_MAP_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_REFLECTION_PROBE_DATA_MAP_BINDING, DescriptorType.SAMPLER_TEXTURE, 1, ShaderStageFlagBit.FRAGMENT);
      const UNIFORM_REFLECTION_PROBE_DATA_MAP_LAYOUT = new UniformSamplerTexture(SetIndex.LOCAL, UNIFORM_REFLECTION_PROBE_DATA_MAP_BINDING, UNIFORM_REFLECTION_PROBE_DATA_MAP_NAME, Type$1.SAMPLER2D, 1);
      localDescriptorSetLayout.layouts[UNIFORM_REFLECTION_PROBE_DATA_MAP_NAME] = UNIFORM_REFLECTION_PROBE_DATA_MAP_LAYOUT;
      localDescriptorSetLayout.bindings[UNIFORM_REFLECTION_PROBE_DATA_MAP_BINDING] = UNIFORM_REFLECTION_PROBE_DATA_MAP_DESCRIPTOR;
      const UNIFORM_REFLECTION_PROBE_BLEND_CUBEMAP_NAME = 'cc_reflectionProbeBlendCubemap';
      const UNIFORM_REFLECTION_PROBE_BLEND_CUBEMAP_BINDING = ModelLocalBindings.SAMPLER_REFLECTION_PROBE_BLEND_CUBE;
      const UNIFORM_REFLECTION_PROBE_BLEND_CUBEMAP_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_REFLECTION_PROBE_BLEND_CUBEMAP_BINDING, DescriptorType.SAMPLER_TEXTURE, 1, ShaderStageFlagBit.FRAGMENT);
      const UNIFORM_REFLECTION_PROBE_BLEND_CUBEMAP_LAYOUT = new UniformSamplerTexture(SetIndex.LOCAL, UNIFORM_REFLECTION_PROBE_BLEND_CUBEMAP_BINDING, UNIFORM_REFLECTION_PROBE_BLEND_CUBEMAP_NAME, Type$1.SAMPLER_CUBE, 1);
      localDescriptorSetLayout.layouts[UNIFORM_REFLECTION_PROBE_BLEND_CUBEMAP_NAME] = UNIFORM_REFLECTION_PROBE_BLEND_CUBEMAP_LAYOUT;
      localDescriptorSetLayout.bindings[UNIFORM_REFLECTION_PROBE_BLEND_CUBEMAP_BINDING] = UNIFORM_REFLECTION_PROBE_BLEND_CUBEMAP_DESCRIPTOR;
      const CAMERA_DEFAULT_MASK = Layers.makeMaskExclude([Layers.BitMask.UI_2D, Layers.BitMask.GIZMOS, Layers.BitMask.EDITOR, Layers.BitMask.SCENE_GIZMO, Layers.BitMask.PROFILER]);
      const CAMERA_EDITOR_MASK = Layers.makeMaskExclude([Layers.BitMask.UI_2D, Layers.BitMask.PROFILER]);
      const MODEL_ALWAYS_MASK = Layers.Enum.ALL;
      function supportsR16HalfFloatTexture(device) {
        return (device.getFormatFeatures(Format.R16F) & (FormatFeatureBit.RENDER_TARGET | FormatFeatureBit.SAMPLED_TEXTURE)) === (FormatFeatureBit.RENDER_TARGET | FormatFeatureBit.SAMPLED_TEXTURE);
      }
      function supportsR32FloatTexture(device) {
        return (device.getFormatFeatures(Format.R32F) & (FormatFeatureBit.RENDER_TARGET | FormatFeatureBit.SAMPLED_TEXTURE)) === (FormatFeatureBit.RENDER_TARGET | FormatFeatureBit.SAMPLED_TEXTURE) && !(device.gfxAPI === API.WEBGL);
      }
      function supportsRGBA16HalfFloatTexture(device) {
        return (device.getFormatFeatures(Format.RGBA16F) & (FormatFeatureBit.RENDER_TARGET | FormatFeatureBit.SAMPLED_TEXTURE)) === (FormatFeatureBit.RENDER_TARGET | FormatFeatureBit.SAMPLED_TEXTURE) && !(device.gfxAPI === API.WEBGL);
      }
      function supportsRGBA32FloatTexture(device) {
        return (device.getFormatFeatures(Format.RGBA32F) & (FormatFeatureBit.RENDER_TARGET | FormatFeatureBit.SAMPLED_TEXTURE)) === (FormatFeatureBit.RENDER_TARGET | FormatFeatureBit.SAMPLED_TEXTURE) && !(device.gfxAPI === API.WEBGL);
      }
      function isEnableEffect() {
        return !!(legacyCC.rendering && legacyCC.rendering.enableEffectImport);
      }

      var define = /*#__PURE__*/Object.freeze({
        __proto__: null,
        PIPELINE_FLOW_MAIN: PIPELINE_FLOW_MAIN,
        PIPELINE_FLOW_FORWARD: PIPELINE_FLOW_FORWARD,
        PIPELINE_FLOW_SHADOW: PIPELINE_FLOW_SHADOW,
        PIPELINE_FLOW_SMAA: PIPELINE_FLOW_SMAA,
        PIPELINE_FLOW_TONEMAP: PIPELINE_FLOW_TONEMAP,
        get RenderPassStage () { return RenderPassStage; },
        get RenderPriority () { return RenderPriority; },
        globalDescriptorSetLayout: globalDescriptorSetLayout,
        localDescriptorSetLayout: localDescriptorSetLayout,
        get PipelineGlobalBindings () { return PipelineGlobalBindings; },
        get ModelLocalBindings () { return ModelLocalBindings; },
        get SetIndex () { return SetIndex; },
        bindingMappingInfo: bindingMappingInfo,
        UBOGlobal: UBOGlobal,
        UBOCamera: UBOCamera,
        UBOShadow: UBOShadow,
        UBOCSM: UBOCSM,
        UNIFORM_SHADOWMAP_BINDING: UNIFORM_SHADOWMAP_BINDING,
        UNIFORM_ENVIRONMENT_BINDING: UNIFORM_ENVIRONMENT_BINDING,
        UNIFORM_DIFFUSEMAP_BINDING: UNIFORM_DIFFUSEMAP_BINDING,
        UNIFORM_SPOT_SHADOW_MAP_TEXTURE_BINDING: UNIFORM_SPOT_SHADOW_MAP_TEXTURE_BINDING,
        UBOLocal: UBOLocal,
        UBOWorldBound: UBOWorldBound,
        INST_MAT_WORLD: INST_MAT_WORLD,
        INST_SH: INST_SH,
        UBOLocalBatched: UBOLocalBatched,
        UBOForwardLight: UBOForwardLight,
        UBODeferredLight: UBODeferredLight,
        JOINT_UNIFORM_CAPACITY: JOINT_UNIFORM_CAPACITY,
        UBOSkinningTexture: UBOSkinningTexture,
        UBOSkinningAnimation: UBOSkinningAnimation,
        INST_JOINT_ANIM_INFO: INST_JOINT_ANIM_INFO,
        UBOSkinning: UBOSkinning,
        localDescriptorSetLayout_ResizeMaxJoints: localDescriptorSetLayout_ResizeMaxJoints,
        UBOMorph: UBOMorph,
        UBOUILocal: UBOUILocal,
        UBOSH: UBOSH,
        UNIFORM_JOINT_TEXTURE_BINDING: UNIFORM_JOINT_TEXTURE_BINDING,
        UNIFORM_REALTIME_JOINT_TEXTURE_BINDING: UNIFORM_REALTIME_JOINT_TEXTURE_BINDING,
        UNIFORM_POSITION_MORPH_TEXTURE_BINDING: UNIFORM_POSITION_MORPH_TEXTURE_BINDING,
        UNIFORM_NORMAL_MORPH_TEXTURE_BINDING: UNIFORM_NORMAL_MORPH_TEXTURE_BINDING,
        UNIFORM_TANGENT_MORPH_TEXTURE_BINDING: UNIFORM_TANGENT_MORPH_TEXTURE_BINDING,
        UNIFORM_LIGHTMAP_TEXTURE_BINDING: UNIFORM_LIGHTMAP_TEXTURE_BINDING,
        UNIFORM_SPRITE_TEXTURE_BINDING: UNIFORM_SPRITE_TEXTURE_BINDING,
        UNIFORM_REFLECTION_TEXTURE_BINDING: UNIFORM_REFLECTION_TEXTURE_BINDING,
        UNIFORM_REFLECTION_STORAGE_BINDING: UNIFORM_REFLECTION_STORAGE_BINDING,
        UNIFORM_REFLECTION_PROBE_CUBEMAP_BINDING: UNIFORM_REFLECTION_PROBE_CUBEMAP_BINDING,
        UNIFORM_REFLECTION_PROBE_TEXTURE_BINDING: UNIFORM_REFLECTION_PROBE_TEXTURE_BINDING,
        UNIFORM_REFLECTION_PROBE_DATA_MAP_BINDING: UNIFORM_REFLECTION_PROBE_DATA_MAP_BINDING,
        UNIFORM_REFLECTION_PROBE_BLEND_CUBEMAP_BINDING: UNIFORM_REFLECTION_PROBE_BLEND_CUBEMAP_BINDING,
        CAMERA_DEFAULT_MASK: CAMERA_DEFAULT_MASK,
        CAMERA_EDITOR_MASK: CAMERA_EDITOR_MASK,
        MODEL_ALWAYS_MASK: MODEL_ALWAYS_MASK,
        supportsR16HalfFloatTexture: supportsR16HalfFloatTexture,
        supportsR32FloatTexture: supportsR32FloatTexture,
        supportsRGBA16HalfFloatTexture: supportsRGBA16HalfFloatTexture,
        supportsRGBA32FloatTexture: supportsRGBA32FloatTexture,
        isEnableEffect: isEnableEffect
      });
      exports('pipeline', define);

      const renderTextureProto = jsb.RenderTexture.prototype;
      const textureBaseProto = jsb.TextureBase.prototype;
      renderTextureProto.createNode = null;
      const RenderTexture = exports('RenderTexture', jsb.RenderTexture);
      RenderTexture.Filter = Filter;
      RenderTexture.PixelFormat = PixelFormat;
      RenderTexture.WrapMode = WrapMode;
      renderTextureProto._serialize = function (ctxForExporting) {
        return {};
      };
      renderTextureProto._deserialize = function (serializedData, handle) {
        const data = serializedData;
        this._width = data.w;
        this._height = data.h;
        this._name = data.n;
        textureBaseProto._deserialize.call(this, data.base, handle);
      };
      const oldReadPixels = renderTextureProto.readPixels;
      renderTextureProto.readPixels = function readPixels(x, y, width, height, buffer) {
        x = x || 0;
        y = y || 0;
        width = width || this.width;
        height = height || this.height;
        let tmpBuffer = oldReadPixels.call(this, x, y, width, height);
        if (tmpBuffer.length == 0) {
          return null;
        }
        buffer = tmpBuffer;
        return buffer;
      };
      legacyCC.RenderTexture = jsb.RenderTexture;
      patch_cc_RenderTexture({
        RenderTexture
      });

      const getPhaseID = exports('getPhaseID', (() => {
        const phases = new Map();
        let phaseNum = 0;
        return phaseName => {
          if (typeof phaseName === 'number') {
            return phaseName;
          }
          if (!phases.has(phaseName)) {
            phases.set(phaseName, 1 << phaseNum);
            phaseNum++;
          }
          return phases.get(phaseName);
        };
      })());

      let PipelineEventType; exports('PipelineEventType', PipelineEventType);
      (function (PipelineEventType) {
        PipelineEventType["RENDER_FRAME_BEGIN"] = "render-frame-begin";
        PipelineEventType["RENDER_FRAME_END"] = "render-frame-end";
        PipelineEventType["RENDER_CAMERA_BEGIN"] = "render-camera-begin";
        PipelineEventType["RENDER_CAMERA_END"] = "render-camera-end";
        PipelineEventType["ATTACHMENT_SCALE_CAHNGED"] = "attachment-scale-changed";
      })(PipelineEventType || (exports('PipelineEventType', PipelineEventType = {})));

      var _dec$U, _dec2$F, _class$S, _initializer$I, _initializer2$y, _initializer3$s, _dec3$w, _dec4$l, _class3$r, _class4$2, _initializer4$o, _initializer5$j;
      const RenderPipeline = exports('RenderPipeline', nr.RenderPipeline);
      const RenderFlow = exports('RenderFlow', nr.RenderFlow);
      const RenderStage = exports('RenderStage', nr.RenderStage);
      const InstancedBuffer = exports('InstancedBuffer', nr.InstancedBuffer);
      const PipelineStateManager = exports('PipelineStateManager', nr.PipelineStateManager);
      const ForwardPipeline = exports('ForwardPipeline', nr.ForwardPipeline);
      const ForwardFlow = exports('ForwardFlow', nr.ForwardFlow);
      const ShadowFlow = exports('ShadowFlow', nr.ShadowFlow);
      const ForwardStage = exports('ForwardStage', nr.ForwardStage);
      const ShadowStage = exports('ShadowStage', nr.ShadowStage);
      const DeferredPipeline = exports('DeferredPipeline', nr.DeferredPipeline);
      const MainFlow = exports('MainFlow', nr.MainFlow);
      const LightingStage = exports('LightingStage', nr.LightingStage);
      const PostProcessStage = exports('PostProcessStage', nr.PostProcessStage);
      const GbufferStage = exports('GbufferStage', nr.GbufferStage);
      const BloomStage = exports('BloomStage', nr.BloomStage);
      const ReflectionProbeFlow = exports('ReflectionProbeFlow', nr.ReflectionProbeFlow);
      const ReflectionProbeStage = exports('ReflectionProbeStage', nr.ReflectionProbeStage);
      let getOrCreatePipelineState = nr.PipelineStateManager.getOrCreatePipelineState;
      nr.PipelineStateManager.getOrCreatePipelineState = function (device, pass, shader, renderPass, ia) {
        return getOrCreatePipelineState(pass, shader, renderPass, ia);
      };
      const forwardPipelineProto = ForwardPipeline.prototype;
      forwardPipelineProto._ctor = function () {
        this._tag = 0;
        this._flows = [];
      };
      forwardPipelineProto.init = function () {
        for (let i = 0; i < this._flows.length; i++) {
          this._flows[i].init(this);
        }
        const info = {
          tag: this._tag,
          flows: this._flows
        };
        this.initialize(info);
      };
      const oldForwardOnLoaded = forwardPipelineProto.onLoaded;
      forwardPipelineProto.onLoaded = function () {
        if (oldForwardOnLoaded) oldForwardOnLoaded.call(this);
        for (let i = 0; i < this._flows.length; i++) {
          this._flows[i].init(this);
        }
        const info = {
          tag: this._tag,
          flows: this._flows
        };
        this.initialize(info);
      };
      const forwardFlowProto = ForwardFlow.prototype;
      forwardFlowProto._ctor = function () {
        this._name = 0;
        this._priority = 0;
        this._tag = 0;
        this._stages = [];
      };
      forwardFlowProto.init = function (pipeline) {
        for (let i = 0; i < this._stages.length; i++) {
          this._stages[i].init(pipeline);
        }
        const info = {
          name: this._name,
          priority: this._priority,
          tag: this._tag,
          stages: this._stages
        };
        this.initialize(info);
      };
      const shadowFlowProto = ShadowFlow.prototype;
      shadowFlowProto._ctor = function () {
        this._name = 0;
        this._priority = 0;
        this._tag = 0;
        this._stages = [];
      };
      shadowFlowProto.init = function (pipeline) {
        for (let i = 0; i < this._stages.length; i++) {
          this._stages[i].init(pipeline);
        }
        const info = {
          name: this._name,
          priority: this._priority,
          tag: this._tag,
          stages: this._stages
        };
        this.initialize(info);
      };
      const reflectionProbeFlowProto = ReflectionProbeFlow.prototype;
      reflectionProbeFlowProto._ctor = function () {
        this._name = 0;
        this._priority = 0;
        this._tag = 0;
        this._stages = [];
      };
      reflectionProbeFlowProto.init = function (pipeline) {
        for (let i = 0; i < this._stages.length; i++) {
          this._stages[i].init(pipeline);
        }
        const info = {
          name: this._name,
          priority: this._priority,
          tag: this._tag,
          stages: this._stages
        };
        this.initialize(info);
      };
      const forwardStageProto = ForwardStage.prototype;
      forwardStageProto._ctor = function () {
        this._name = 0;
        this._priority = 0;
        this._tag = 0;
        this.renderQueues = [];
      };
      forwardStageProto.init = function (pipeline) {
        const queues = [];
        for (let i = 0; i < this.renderQueues.length; i++) {
          queues.push(this.renderQueues[i].init());
        }
        const info = {
          name: this._name,
          priority: this._priority,
          tag: this._tag,
          renderQueues: queues
        };
        this.initialize(info);
      };
      const shadowStageProto = ShadowStage.prototype;
      shadowStageProto._ctor = function () {
        this._name = 0;
        this._priority = 0;
        this._tag = 0;
      };
      const reflectionProbeStage = ReflectionProbeStage.prototype;
      reflectionProbeStage._ctor = function () {
        this._name = 0;
        this._priority = 0;
        this._tag = 0;
        this.renderQueues = [];
      };
      reflectionProbeStage.init = function (pipeline) {
        const queues = [];
        for (let i = 0; i < this.renderQueues.length; i++) {
          queues.push(this.renderQueues[i].init());
        }
        const info = {
          name: this._name,
          priority: this._priority,
          tag: this._tag,
          renderQueues: queues
        };
        this.initialize(info);
      };
      let RenderQueueSortMode; exports('RenderQueueSortMode', RenderQueueSortMode);
      (function (RenderQueueSortMode) {
        RenderQueueSortMode[RenderQueueSortMode["FRONT_TO_BACK"] = 0] = "FRONT_TO_BACK";
        RenderQueueSortMode[RenderQueueSortMode["BACK_TO_FRONT"] = 1] = "BACK_TO_FRONT";
      })(RenderQueueSortMode || (exports('RenderQueueSortMode', RenderQueueSortMode = {})));
      ccenum(RenderQueueSortMode);
      shadowStageProto.init = function (pipeline) {
        const info = {
          name: this._name,
          priority: this._priority,
          tag: this._tag,
          renderQueues: []
        };
        this.initialize(info);
      };
      let RenderQueueDesc = exports('RenderQueueDesc', (_dec$U = type$2(RenderQueueSortMode), _dec2$F = type$2([CCString]), (_class$S = class RenderQueueDesc {
        constructor() {
          this.isTransparent = _initializer$I && _initializer$I();
          this.sortMode = _initializer2$y && _initializer2$y();
          this.stages = _initializer3$s && _initializer3$s();
          this.stages = [];
        }
        init() {
          return new nr.RenderQueueDesc(this.isTransparent, this.sortMode, this.stages);
        }
      }, (_initializer$I = applyDecoratedInitializer(_class$S.prototype, "isTransparent", [serializable$3], function () {
        return false;
      }), _initializer2$y = applyDecoratedInitializer(_class$S.prototype, "sortMode", [_dec$U], function () {
        return RenderQueueSortMode.FRONT_TO_BACK;
      }), _initializer3$s = applyDecoratedInitializer(_class$S.prototype, "stages", [_dec2$F], function () {
        return [];
      })), _class$S)));
      const deferredPipelineProto = DeferredPipeline.prototype;
      deferredPipelineProto._ctor = function () {
        this._tag = 0;
        this._flows = [];
        this.renderTextures = [];
        this.materials = [];
      };
      const oldDeferredOnLoaded = deferredPipelineProto.onLoaded;
      deferredPipelineProto.onLoaded = function () {
        if (oldDeferredOnLoaded) oldDeferredOnLoaded.call(this);
        for (let i = 0; i < this._flows.length; i++) {
          this._flows[i].init(this);
        }
        let info = {
          tag: this._tag,
          flows: this._flows
        };
        this.initialize(info);
      };
      const mainFlowProto = MainFlow.prototype;
      mainFlowProto._ctor = function () {
        this._name = 0;
        this._priority = 0;
        this._tag = 0;
        this._stages = [];
      };
      mainFlowProto.init = function (pipeline) {
        for (let i = 0; i < this._stages.length; i++) {
          this._stages[i].init(pipeline);
        }
        const info = {
          name: this._name,
          priority: this._priority,
          tag: this._tag,
          stages: this._stages
        };
        this.initialize(info);
      };
      const gbufferStageProto = GbufferStage.prototype;
      gbufferStageProto._ctor = function () {
        this._name = 0;
        this._priority = 0;
        this._tag = 0;
        this.renderQueues = [];
      };
      gbufferStageProto.init = function (pipeline) {
        const queues = [];
        for (let i = 0; i < this.renderQueues.length; i++) {
          queues.push(this.renderQueues[i].init());
        }
        const info = {
          name: this._name,
          priority: this._priority,
          tag: this._tag,
          renderQueues: queues
        };
        this.initialize(info);
      };
      const lightingStageProto = LightingStage.prototype;
      lightingStageProto._ctor = function () {
        this._name = 0;
        this._priority = 0;
        this._tag = 0;
        this.renderQueues = [];
        this._deferredMaterial = null;
      };
      lightingStageProto.init = function (pipeline) {
        const queues = [];
        for (let i = 0; i < this.renderQueues.length; i++) {
          queues.push(this.renderQueues[i].init());
        }
        pipeline.pipelineSceneData.deferredLightingMaterial = this._deferredMaterial;
        const info = {
          name: this._name,
          priority: this._priority,
          tag: this._tag,
          renderQueues: queues
        };
        this.initialize(info);
      };
      const bloomStageProto = BloomStage.prototype;
      bloomStageProto._ctor = function () {
        this._name = 0;
        this._priority = 0;
        this._tag = 0;
        this.renderQueues = [];
        this._bloomMaterial = null;
      };
      bloomStageProto.init = function (pipeline) {
        const queues = [];
        for (let i = 0; i < this.renderQueues.length; i++) {
          queues.push(this.renderQueues[i].init());
        }
        pipeline.pipelineSceneData.bloomMaterial = this._bloomMaterial;
        const info = {
          name: this._name,
          priority: this._priority,
          tag: this._tag,
          renderQueues: queues
        };
        this.initialize(info);
      };
      const postProcessStageProto = PostProcessStage.prototype;
      postProcessStageProto._ctor = function () {
        this._name = 0;
        this._priority = 0;
        this._tag = 0;
        this.renderQueues = [];
        this._postProcessMaterial = null;
      };
      postProcessStageProto.init = function (pipeline) {
        const queues = [];
        for (let i = 0; i < this.renderQueues.length; i++) {
          queues.push(this.renderQueues[i].init());
        }
        pipeline.pipelineSceneData.postProcessMaterial = this._postProcessMaterial;
        const info = {
          name: this._name,
          priority: this._priority,
          tag: this._tag,
          renderQueues: queues
        };
        this.initialize(info);
      };
      legacyCC.RenderFlow = RenderFlow;
      legacyCC.RenderStage = RenderStage;
      legacyCC.RenderPipeline = RenderPipeline;
      let RenderTextureConfig = (_dec3$w = ccclass$3('RenderTextureConfig'), _dec4$l = type$2(RenderTexture), _dec3$w(_class3$r = (_class4$2 = class RenderTextureConfig {
        constructor() {
          this.name = _initializer4$o && _initializer4$o();
          this.texture = _initializer5$j && _initializer5$j();
        }
      }, (_initializer4$o = applyDecoratedInitializer(_class4$2.prototype, "name", [serializable$3], function () {
        return '';
      }), _initializer5$j = applyDecoratedInitializer(_class4$2.prototype, "texture", [_dec4$l], function () {
        return null;
      })), _class4$2)) || _class3$r);
      function proxyArrayAttributeImpl(proto, attr) {
        const proxyTarget = `_${attr}_target`;
        let arrayProxy = (self, targetArrayAttr) => {
          return new Proxy(self[targetArrayAttr], {
            get(targetArray, prop, receiver) {
              return Reflect.get(targetArray, prop, receiver);
            },
            set(targetArray, prop, receiver) {
              const ret = Reflect.set(targetArray, prop, receiver);
              self[targetArrayAttr] = targetArray;
              return ret;
            }
          });
        };
        Object.defineProperty(proto, attr, {
          configurable: true,
          enumerable: true,
          get: function () {
            this[proxyTarget] || (this[proxyTarget] = []);
            return arrayProxy(this, proxyTarget);
          },
          set: function (v) {
            this[proxyTarget] = v;
          }
        });
      }
      let proxyArrayAttribute = proxyArrayAttributeImpl;
      {
        proxyArrayAttribute(RenderFlow.prototype, '_stages');
        proxyArrayAttribute(RenderPipeline.prototype, '_flows');
      }
      const Material$1 = jsb.Material;
      patch_RenderQueueDesc({
        RenderQueueDesc,
        RenderQueueSortMode,
        CCString
      });
      patch_RenderStage({
        RenderStage
      });
      patch_ReflectionProbeStage({
        ReflectionProbeStage
      });
      patch_GbufferStage({
        GbufferStage,
        RenderQueueDesc
      });
      patch_LightingStage({
        LightingStage,
        RenderQueueDesc,
        Material: Material$1
      });
      patch_BloomStage({
        BloomStage,
        Material: Material$1
      });
      patch_PostProcessStage({
        PostProcessStage,
        Material: Material$1,
        RenderQueueDesc
      });
      patch_ForwardStage({
        ForwardStage,
        RenderQueueDesc
      });
      patch_ShadowStage({
        ShadowStage
      });
      patch_RenderFlow({
        RenderFlow,
        RenderStage
      });
      patch_MainFlow({
        MainFlow
      });
      patch_ForwardFlow({
        ForwardFlow
      });
      patch_ShadowFlow({
        ShadowFlow
      });
      patch_ReflectionProbeFlow({
        ReflectionProbeFlow
      });
      patch_cc_RenderPipeline({
        RenderPipeline,
        RenderFlow
      });
      patch_ForwardPipeline({
        ForwardPipeline,
        RenderTextureConfig
      });
      patch_DeferredPipeline({
        DeferredPipeline,
        RenderTextureConfig
      });

      const Root = exports('Root', jsb.Root);
      var LightType$2;
      (function (LightType) {
        LightType[LightType["DIRECTIONAL"] = 0] = "DIRECTIONAL";
        LightType[LightType["SPHERE"] = 1] = "SPHERE";
        LightType[LightType["SPOT"] = 2] = "SPOT";
        LightType[LightType["POINT"] = 3] = "POINT";
        LightType[LightType["RANGED_DIRECTIONAL"] = 4] = "RANGED_DIRECTIONAL";
        LightType[LightType["UNKNOWN"] = 5] = "UNKNOWN";
      })(LightType$2 || (LightType$2 = {}));
      const rootProto = Root.prototype;
      rootProto._createBatcher2D = function () {
        if (!this._batcher && legacyCC.internal.Batcher2D) {
          this._batcher = new legacyCC.internal.Batcher2D(this);
          if (!this._batcher.initialize()) {
            this._batcher = null;
            this.destroy();
            return;
          }
          this._batcher._nativeObj = this.getBatcher2D();
        }
      };
      Object.defineProperty(rootProto, 'batcher2D', {
        configurable: true,
        enumerable: true,
        get() {
          return this._batcher;
        }
      });
      Object.defineProperty(rootProto, 'dataPoolManager', {
        configurable: true,
        enumerable: true,
        get() {
          return this._dataPoolMgr;
        }
      });
      Object.defineProperty(rootProto, 'pipelineEvent', {
        configurable: true,
        enumerable: true,
        get() {
          return this._pipelineEvent;
        }
      });
      class DummyPipelineEvent {
        on(type, callback, target, once) {}
        once(type, callback, target) {}
        off(type, callback, target) {}
        emit(type, arg0, arg1, arg2, arg3, arg4) {}
        targetOff(typeOrTarget) {}
        removeAll(typeOrTarget) {}
        hasEventListener(type, callback, target) {
          return false;
        }
      }
      rootProto._ctor = function (device) {
        this._device = device;
        this._dataPoolMgr = legacyCC.internal.DataPoolManager && new legacyCC.internal.DataPoolManager(device);
        this._modelPools = new Map();
        this._lightPools = new Map();
        this._batcher = null;
        this._pipelineEvent = new DummyPipelineEvent();
        this._registerListeners();
      };
      rootProto.initialize = function (info) {
        var _this$_dataPoolMgr;
        this._initialize(deviceManager.swapchain);
        const customJointTextureLayouts = settings.querySettings(Settings.Category.ANIMATION, 'customJointTextureLayouts') || [];
        (_this$_dataPoolMgr = this._dataPoolMgr) === null || _this$_dataPoolMgr === void 0 ? void 0 : _this$_dataPoolMgr.jointTexturePool.registerCustomTextureLayouts(customJointTextureLayouts);
      };
      rootProto.createModel = function (ModelCtor) {
        let p = this._modelPools.get(ModelCtor);
        if (!p) {
          this._modelPools.set(ModelCtor, new Pool(() => new ModelCtor(), 10, obj => obj.destroy()));
          p = this._modelPools.get(ModelCtor);
        }
        const model = p.alloc();
        model.initialize();
        return model;
      };
      rootProto.destroyModel = function (m) {
        const p = this._modelPools.get(m.constructor);
        if (p) {
          p.free(m);
          if (m.scene) {
            m.scene.removeModel(m);
          }
        } else {
          warnID(1300, m.constructor.name);
        }
        m.destroy();
      };
      rootProto.createLight = function (LightCtor) {
        let l = this._lightPools.get(LightCtor);
        if (!l) {
          this._lightPools.set(LightCtor, new Pool(() => new LightCtor(), 4, obj => obj.destroy()));
          l = this._lightPools.get(LightCtor);
        }
        const light = l.alloc();
        light.initialize();
        return light;
      };
      rootProto.destroyLight = function (l) {
        if (l.scene) {
          switch (l.type) {
            case LightType$2.DIRECTIONAL:
              l.scene.removeDirectionalLight(l);
              break;
            case LightType$2.SPHERE:
              l.scene.removeSphereLight(l);
              break;
            case LightType$2.SPOT:
              l.scene.removeSpotLight(l);
              break;
            case LightType$2.POINT:
              l.scene.removePointLight(l);
              break;
            case LightType$2.RANGED_DIRECTIONAL:
              l.scene.removeRangedDirLight(l);
              break;
          }
        }
        l.destroy();
      };
      rootProto.recycleLight = function (l) {
        const p = this._lightPools.get(l.constructor);
        if (p) {
          p.free(l);
          if (l.scene) {
            switch (l.type) {
              case LightType$2.DIRECTIONAL:
                l.scene.removeDirectionalLight(l);
                break;
              case LightType$2.SPHERE:
                l.scene.removeSphereLight(l);
                break;
              case LightType$2.SPOT:
                l.scene.removeSpotLight(l);
                break;
              case LightType$2.POINT:
                l.scene.removePointLight(l);
                break;
              case LightType$2.RANGED_DIRECTIONAL:
                l.scene.removeRangedDirLight(l);
                break;
            }
          }
        }
      };
      rootProto._onDirectorBeforeCommit = function () {
        legacyCC.director.emit(legacyCC.Director.EVENT_BEFORE_COMMIT);
      };
      rootProto._onDirectorBeforeRender = function () {
        legacyCC.director.emit(legacyCC.Director.EVENT_BEFORE_RENDER);
      };
      rootProto._onDirectorAfterRender = function () {
        legacyCC.director.emit(legacyCC.Director.EVENT_AFTER_RENDER);
      };
      rootProto._onDirectorPipelineChanged = function () {
        const scene = legacyCC.director.getScene();
        if (scene) {
          scene._activate();
        }
      };
      const oldOnGlobalPipelineStateChanged = rootProto.onGlobalPipelineStateChanged;
      rootProto.onGlobalPipelineStateChanged = function () {
        oldOnGlobalPipelineStateChanged.call(this);
        const builder = legacyCC.rendering.getCustomPipeline(macro.CUSTOM_PIPELINE_NAME);
        if (builder) {
          if (typeof builder.onGlobalPipelineStateChanged === 'function') {
            builder.onGlobalPipelineStateChanged();
          }
        }
      };
      const oldFrameMove = rootProto.frameMove;
      rootProto.frameMove = function (deltaTime) {
        oldFrameMove.call(this, deltaTime, legacyCC.director.getTotalFrames());
      };
      const oldSetPipeline = rootProto.setRenderPipeline;
      rootProto.setRenderPipeline = function (pipeline) {
        let ppl;
        if (macro.CUSTOM_PIPELINE_NAME !== '' && legacyCC.rendering && this.usesCustomPipeline) {
          legacyCC.rendering.createCustomPipeline();
          ppl = oldSetPipeline.call(this, null);
        } else {
          if (!pipeline) {
            pipeline = new ForwardPipeline();
            pipeline.init();
          }
          ppl = oldSetPipeline.call(this, pipeline);
        }
        this._createBatcher2D();
        return ppl;
      };
      rootProto.addBatch = function (batch) {
        console.error('The Draw Batch class is implemented differently in the native platform and does not support this interface.');
      };
      rootProto.removeBatch = function (batch) {
        console.error('The Draw Batch class is implemented differently in the native platform and does not support this interface.');
      };
      rootProto.removeBatches = function () {
        console.error('The Draw Batch class is implemented differently in the native platform and does not support this interface.');
      };

      let NodeEventType; exports('NodeEventType', NodeEventType);
      (function (NodeEventType) {
        NodeEventType["TOUCH_START"] = "touch-start";
        NodeEventType["TOUCH_MOVE"] = "touch-move";
        NodeEventType["TOUCH_END"] = "touch-end";
        NodeEventType["TOUCH_CANCEL"] = "touch-cancel";
        NodeEventType["MOUSE_DOWN"] = "mouse-down";
        NodeEventType["MOUSE_MOVE"] = "mouse-move";
        NodeEventType["MOUSE_UP"] = "mouse-up";
        NodeEventType["MOUSE_WHEEL"] = "mouse-wheel";
        NodeEventType["MOUSE_ENTER"] = "mouse-enter";
        NodeEventType["MOUSE_LEAVE"] = "mouse-leave";
        NodeEventType["KEY_DOWN"] = "keydown";
        NodeEventType["KEY_UP"] = "keyup";
        NodeEventType["DEVICEMOTION"] = "devicemotion";
        NodeEventType["TRANSFORM_CHANGED"] = "transform-changed";
        NodeEventType["MOBILITY_CHANGED"] = "mobility-changed";
        NodeEventType["SCENE_CHANGED_FOR_PERSISTS"] = "scene-changed-for-persists";
        NodeEventType["SIZE_CHANGED"] = "size-changed";
        NodeEventType["ANCHOR_CHANGED"] = "anchor-changed";
        NodeEventType["COLOR_CHANGED"] = "color-changed";
        NodeEventType["CHILD_ADDED"] = "child-added";
        NodeEventType["CHILD_REMOVED"] = "child-removed";
        NodeEventType["PARENT_CHANGED"] = "parent-changed";
        NodeEventType["NODE_DESTROYED"] = "node-destroyed";
        NodeEventType["LAYER_CHANGED"] = "layer-changed";
        NodeEventType["SIBLING_ORDER_CHANGED"] = "sibling-order-changed";
        NodeEventType["ACTIVE_IN_HIERARCHY_CHANGED"] = "active-in-hierarchy-changed";
        NodeEventType["COMPONENT_ADDED"] = "component-added";
        NodeEventType["COMPONENT_REMOVED"] = "component-removed";
        NodeEventType["LIGHT_PROBE_CHANGED"] = "light-probe-changed";
        NodeEventType["LIGHT_PROBE_BAKING_CHANGED"] = "light-probe-baking-changed";
      })(NodeEventType || (exports('NodeEventType', NodeEventType = {})));

      class NodeUIProperties {
        get uiTransformComp() {
          if (!this._uiTransformComp) {
            this._uiTransformComp = this._node.getComponent('cc.UITransform');
          }
          return this._uiTransformComp;
        }
        set uiTransformComp(value) {
          this._uiTransformComp = value;
        }
        get uiComp() {
          return this._uiComp;
        }
        set uiComp(comp) {
          if (this._uiComp && comp) {
            warnID(12002);
            return;
          }
          this._uiComp = comp;
        }
        setOpacity(v) {
          this._opacity = v;
        }
        get opacity() {
          return this._opacity;
        }
        get localOpacity() {
          return this._localOpacity;
        }
        set localOpacity(val) {
          this._localOpacity = val;
          this.colorDirty = true;
        }
        constructor(node) {
          this._uiComp = null;
          this._opacity = 1;
          this._localOpacity = 1;
          this.colorDirty = true;
          this._uiTransformComp = null;
          this._node = void 0;
          this._node = node;
        }
        applyOpacity(effectOpacity) {
          this._opacity = this._localOpacity * effectOpacity;
        }
        static markOpacityTree(node, isDirty = true) {}
      }

      let NodeSpace; exports('NodeSpace', NodeSpace);
      (function (NodeSpace) {
        NodeSpace[NodeSpace["LOCAL"] = 0] = "LOCAL";
        NodeSpace[NodeSpace["WORLD"] = 1] = "WORLD";
      })(NodeSpace || (exports('NodeSpace', NodeSpace = {})));
      let TransformBit; exports('TransformBit', TransformBit);
      (function (TransformBit) {
        TransformBit[TransformBit["NONE"] = 0] = "NONE";
        TransformBit[TransformBit["POSITION"] = 1] = "POSITION";
        TransformBit[TransformBit["ROTATION"] = 2] = "ROTATION";
        TransformBit[TransformBit["SCALE"] = 4] = "SCALE";
        TransformBit[TransformBit["RS"] = TransformBit.ROTATION | TransformBit.SCALE] = "RS";
        TransformBit[TransformBit["TRS"] = TransformBit.POSITION | TransformBit.ROTATION | TransformBit.SCALE] = "TRS";
        TransformBit[TransformBit["TRS_MASK"] = ~TransformBit.TRS] = "TRS_MASK";
      })(TransformBit || (exports('TransformBit', TransformBit = {})));
      legacyCC.internal.TransformBit = TransformBit;
      const MobilityMode = exports('MobilityMode', Enum({
        Static: 0,
        Stationary: 1,
        Movable: 2
      }));

      const _tempFloatArray = new Float32Array(jsb.createExternalArrayBuffer(20 * 4));
      const fillMat4WithTempFloatArray = function fillMat4WithTempFloatArray(out) {
        Mat4.set(out, _tempFloatArray[0], _tempFloatArray[1], _tempFloatArray[2], _tempFloatArray[3], _tempFloatArray[4], _tempFloatArray[5], _tempFloatArray[6], _tempFloatArray[7], _tempFloatArray[8], _tempFloatArray[9], _tempFloatArray[10], _tempFloatArray[11], _tempFloatArray[12], _tempFloatArray[13], _tempFloatArray[14], _tempFloatArray[15]);
      };

      CCObject.Flags.Destroying;
      !!legacyCC.GAME_VIEW;

      const reserveContentsForAllSyncablePrefabTag = Symbol('ReserveContentsForAllSyncablePrefab');
      const Node$1 = jsb.Node; exports({ Node: Node$1, BaseNode: Node$1 });
      legacyCC.Node = Node$1;
      const NodeCls = Node$1;
      NodeCls.reserveContentsForAllSyncablePrefabTag = reserveContentsForAllSyncablePrefabTag;
      NodeCls.EventType = NodeEventType;
      NodeCls.NodeSpace = NodeSpace;
      NodeCls.TransformDirtyBit = TransformBit;
      NodeCls.TransformBit = TransformBit;
      const TRANSFORMBIT_TRS = TransformBit.TRS;
      const nodeProto = jsb.Node.prototype;
      const TRANSFORM_ON = 1 << 0;
      const Destroying = CCObject.Flags.Destroying;
      Node$1._setTempFloatArray(_tempFloatArray.buffer);
      function getConstructor(typeOrClassName) {
        if (!typeOrClassName) {
          return null;
        }
        if (typeof typeOrClassName === 'string') {
          return getClassByName(typeOrClassName);
        }
        return typeOrClassName;
      }
      nodeProto.attr = function (attrs) {
        mixin(this, attrs);
      };
      nodeProto.getComponent = function (typeOrClassName) {
        const constructor = getConstructor(typeOrClassName);
        if (constructor) {
          return NodeCls._findComponent(this, constructor);
        }
        return null;
      };
      nodeProto.getComponents = function (typeOrClassName) {
        const constructor = getConstructor(typeOrClassName);
        const components = [];
        if (constructor) {
          NodeCls._findComponents(this, constructor, components);
        }
        return components;
      };
      nodeProto.getComponentInChildren = function (typeOrClassName) {
        const constructor = getConstructor(typeOrClassName);
        if (constructor) {
          return NodeCls._findChildComponent(this._children, constructor);
        }
        return null;
      };
      nodeProto.getComponentsInChildren = function (typeOrClassName) {
        const constructor = getConstructor(typeOrClassName);
        const components = [];
        if (constructor) {
          NodeCls._findComponents(this, constructor, components);
          NodeCls._findChildComponents(this.children, constructor, components);
        }
        return components;
      };
      nodeProto.addComponent = function (typeOrClassName) {
        let constructor;
        if (typeof typeOrClassName === 'string') {
          constructor = getClassByName(typeOrClassName);
          if (!constructor) {
            if (legacyCC._RF.peek()) {
              errorID(3808, typeOrClassName);
            }
            throw TypeError(getError(3807, typeOrClassName));
          }
        } else {
          if (!typeOrClassName) {
            throw TypeError(getError(3804));
          }
          constructor = typeOrClassName;
        }
        if (typeof constructor !== 'function') {
          throw TypeError(getError(3809));
        }
        if (!isChildClassOf(constructor, Component)) {
          throw TypeError(getError(3810));
        }
        const reqComps = constructor._requireComponent;
        if (reqComps) {
          const tryAdd = c => {
            if (!this.getComponent(c)) {
              this.addComponent(c);
            }
          };
          if (Array.isArray(reqComps)) {
            reqComps.forEach(c => tryAdd(c));
          } else {
            tryAdd(reqComps);
          }
        }
        const component = new constructor();
        component.node = this;
        this._components.push(component);
        this.emit(NodeEventType.COMPONENT_ADDED, component);
        if (this._activeInHierarchy) {
          legacyCC.director._nodeActivator.activateComp(component);
        }
        return component;
      };
      nodeProto.removeComponent = function (component) {
        if (!component) {
          errorID(3813);
          return;
        }
        let componentInstance = null;
        if (component instanceof Component) {
          componentInstance = component;
        } else {
          componentInstance = this.getComponent(component);
        }
        if (componentInstance) {
          componentInstance.destroy();
        }
      };
      const REGISTERED_EVENT_MASK_TRANSFORM_CHANGED = 1 << 0;
      const REGISTERED_EVENT_MASK_PARENT_CHANGED = 1 << 1;
      const REGISTERED_EVENT_MASK_MOBILITY_CHANGED = 1 << 2;
      const REGISTERED_EVENT_MASK_LAYER_CHANGED = 1 << 3;
      const REGISTERED_EVENT_MASK_SIBLING_ORDER_CHANGED = 1 << 4;
      const REGISTERED_EVENT_MASK_LIGHT_PROBE_BAKING_CHANGED = 1 << 5;
      nodeProto.on = function (type, callback, target, useCapture = false) {
        switch (type) {
          case NodeEventType.TRANSFORM_CHANGED:
            this._eventMask |= TRANSFORM_ON;
            if (!(this._registeredNodeEventTypeMask & REGISTERED_EVENT_MASK_TRANSFORM_CHANGED)) {
              this._registerOnTransformChanged();
              this._registeredNodeEventTypeMask |= REGISTERED_EVENT_MASK_TRANSFORM_CHANGED;
            }
            break;
          case NodeEventType.PARENT_CHANGED:
            if (!(this._registeredNodeEventTypeMask & REGISTERED_EVENT_MASK_PARENT_CHANGED)) {
              this._registerOnParentChanged();
              this._registeredNodeEventTypeMask |= REGISTERED_EVENT_MASK_PARENT_CHANGED;
            }
            break;
          case NodeEventType.MOBILITY_CHANGED:
            if (!(this._registeredNodeEventTypeMask & REGISTERED_EVENT_MASK_MOBILITY_CHANGED)) {
              this._registerOnMobilityChanged();
              this._registeredNodeEventTypeMask |= REGISTERED_EVENT_MASK_MOBILITY_CHANGED;
            }
            break;
          case NodeEventType.LAYER_CHANGED:
            if (!(this._registeredNodeEventTypeMask & REGISTERED_EVENT_MASK_LAYER_CHANGED)) {
              this._registerOnLayerChanged();
              this._registeredNodeEventTypeMask |= REGISTERED_EVENT_MASK_LAYER_CHANGED;
            }
            break;
          case NodeEventType.SIBLING_ORDER_CHANGED:
            if (!(this._registeredNodeEventTypeMask & REGISTERED_EVENT_MASK_SIBLING_ORDER_CHANGED)) {
              this._registerOnSiblingOrderChanged();
              this._registeredNodeEventTypeMask |= REGISTERED_EVENT_MASK_SIBLING_ORDER_CHANGED;
            }
            break;
          case NodeEventType.LIGHT_PROBE_BAKING_CHANGED:
            if (!(this._registeredNodeEventTypeMask & REGISTERED_EVENT_MASK_LIGHT_PROBE_BAKING_CHANGED)) {
              this._registerOnLightProbeBakingChanged();
              this._registeredNodeEventTypeMask |= REGISTERED_EVENT_MASK_LIGHT_PROBE_BAKING_CHANGED;
            }
            break;
        }
        this._eventProcessor.on(type, callback, target, useCapture);
      };
      nodeProto.off = function (type, callback, target, useCapture = false) {
        this._eventProcessor.off(type, callback, target, useCapture);
        const hasListeners = this._eventProcessor.hasEventListener(type);
        if (!hasListeners) {
          switch (type) {
            case NodeEventType.TRANSFORM_CHANGED:
              this._eventMask &= ~TRANSFORM_ON;
              break;
          }
        }
      };
      nodeProto.once = function (type, callback, target, useCapture) {
        this._eventProcessor.once(type, callback, target, useCapture);
      };
      nodeProto.emit = function (type, arg0, arg1, arg2, arg3, arg4) {
        this._eventProcessor.emit(type, arg0, arg1, arg2, arg3, arg4);
      };
      nodeProto.dispatchEvent = function (event) {
        this._eventProcessor.dispatchEvent(event);
      };
      nodeProto.hasEventListener = function (type, callback, target) {
        return this._eventProcessor.hasEventListener(type, callback, target);
      };
      nodeProto.targetOff = function (target) {
        this._eventProcessor.targetOff(target);
        if (this._eventMask & TRANSFORM_ON && !this._eventProcessor.hasEventListener(NodeEventType.TRANSFORM_CHANGED)) {
          this._eventMask &= ~TRANSFORM_ON;
        }
      };
      nodeProto.pauseSystemEvents = function pauseSystemEvents(recursive) {
        this._eventProcessor.setEnabled(false, recursive);
      };
      nodeProto.resumeSystemEvents = function resumeSystemEvents(recursive) {
        this._eventProcessor.setEnabled(true, recursive);
      };
      nodeProto.getWritableComponents = function () {
        return this._components;
      };
      nodeProto._setActiveInHierarchy = function (v) {
        return this._activeInHierarchy = v;
      };
      nodeProto._removeComponent = function (component) {
        if (!component) {
          errorID(3814);
          return;
        }
        if (!(this._objFlags & Destroying)) {
          const i = this._components.indexOf(component);
          if (i !== -1) {
            this._components.splice(i, 1);
            this.emit(NodeEventType.COMPONENT_REMOVED, component);
          } else if (component.node !== this) {
            errorID(3815);
          }
        }
      };
      nodeProto._registerIfAttached = undefined ;
      nodeProto._onTransformChanged = function (transformType) {
        this.emit(NodeEventType.TRANSFORM_CHANGED, transformType);
      };
      nodeProto._onParentChanged = function (oldParent) {
        this.emit(NodeEventType.PARENT_CHANGED, oldParent);
      };
      nodeProto._onReAttach = function () {
        this._eventProcessor.reattach();
      };
      nodeProto._onEditorAttached = function (attached) {
      };
      nodeProto._onRemovePersistRootNode = function () {
        legacyCC.game.removePersistRootNode(this);
      };
      nodeProto._onDestroyComponents = function () {
        this._eventProcessor.destroy();
        const comps = this._components;
        for (let i = 0; i < comps.length; ++i) {
          comps[i]._destroyImmediate();
        }
      };
      nodeProto._onMobilityChanged = function () {
        this.emit(NodeEventType.MOBILITY_CHANGED);
      };
      nodeProto._onLayerChanged = function (layer) {
        this.emit(NodeEventType.LAYER_CHANGED, layer);
      };
      nodeProto._onChildRemoved = function (child) {
        const removeAt = this._children.indexOf(child);
        if (removeAt < 0) {
          errorID(1633);
          return;
        }
        this._children.splice(removeAt, 1);
        this.emit(NodeEventType.CHILD_REMOVED, child);
      };
      nodeProto._onChildAdded = function (child) {
        this._children.push(child);
        this.emit(NodeEventType.CHILD_ADDED, child);
      };
      const oldPreDestroy = nodeProto._onPreDestroy;
      nodeProto._onPreDestroy = function _onPreDestroy() {
        const ret = oldPreDestroy.call(this);
        this.emit(NodeEventType.NODE_DESTROYED, this);
        this._eventProcessor.destroy();
        const children = this._children;
        for (let i = 0; i < children.length; ++i) {
          children[i]._destroyImmediate();
        }
        const comps = this._components;
        for (let i = 0; i < comps.length; ++i) {
          comps[i]._destroyImmediate();
        }
        return ret;
      };
      nodeProto.destroyAllChildren = function destroyAllChildren() {
        const children = this._children;
        for (let i = 0, len = children.length; i < len; ++i) {
          children[i].destroy();
        }
      };
      nodeProto._onSiblingOrderChanged = function () {
        this.emit(NodeEventType.SIBLING_ORDER_CHANGED);
      };
      nodeProto._onActivateNode = function (shouldActiveNow) {
        legacyCC.director._nodeActivator.activateNode(this, shouldActiveNow);
      };
      nodeProto._onPostActivated = function (active) {
        if (active) {
          this._eventProcessor.setEnabled(true);
          this.invalidateChildren(TransformBit.TRS);
          if (this._uiProps && this._uiProps.uiComp) {
            this._uiProps.uiComp.setNodeDirty();
            this._uiProps.uiComp.setTextureDirty();
            this._uiProps.uiComp.markForUpdateRenderData();
          }
        } else {
          this._eventProcessor.setEnabled(false);
        }
      };
      nodeProto._onLightProbeBakingChanged = function () {
        this.emit(NodeEventType.LIGHT_PROBE_BAKING_CHANGED);
      };
      NodeCls._findComponent = function (node, constructor) {
        const cls = constructor;
        const comps = node._components;
        if (cls._sealed) {
          for (let i = 0; i < comps.length; ++i) {
            const comp = comps[i];
            if (comp.constructor === constructor) {
              return comp;
            }
          }
        } else {
          for (let i = 0; i < comps.length; ++i) {
            const comp = comps[i];
            if (comp instanceof constructor) {
              return comp;
            }
          }
        }
        return null;
      };
      NodeCls._findComponents = function (node, constructor, components) {
        const cls = constructor;
        const comps = node._components;
        if (cls._sealed) {
          for (let i = 0; i < comps.length; ++i) {
            const comp = comps[i];
            if (comp.constructor === constructor) {
              components.push(comp);
            }
          }
        } else {
          for (let i = 0; i < comps.length; ++i) {
            const comp = comps[i];
            if (comp instanceof constructor) {
              components.push(comp);
            }
          }
        }
      };
      NodeCls._findChildComponent = function (children, constructor) {
        for (let i = 0; i < children.length; ++i) {
          const node = children[i];
          let comp = NodeCls._findComponent(node, constructor);
          if (comp) {
            return comp;
          }
          const childChildren = node.children;
          if (childChildren.length > 0) {
            comp = NodeCls._findChildComponent(childChildren, constructor);
            if (comp) {
              return comp;
            }
          }
        }
        return null;
      };
      NodeCls._findChildComponents = function (children, constructor, components) {
        for (let i = 0; i < children.length; ++i) {
          const node = children[i];
          NodeCls._findComponents(node, constructor, components);
          const childChildren = node.children;
          if (childChildren.length > 0) {
            NodeCls._findChildComponents(childChildren, constructor, components);
          }
        }
      };
      NodeCls.isNode = function (obj) {
        return obj instanceof jsb.Node && (obj.constructor === jsb.Node || !(obj instanceof legacyCC.Scene));
      };
      let _tempQuat = new Quat();
      nodeProto.setRTS = function setRTS(rot, pos, scale) {
        if (rot) {
          let val = _tempQuat;
          if (rot instanceof Quat) {
            val = rot;
          } else {
            Quat.fromEuler(val, rot.x, rot.y, rot.z);
          }
          _tempFloatArray[0] = 4;
          _tempFloatArray[1] = val.x;
          _tempFloatArray[2] = val.y;
          _tempFloatArray[3] = val.z;
          _tempFloatArray[4] = val.w;
          this._lrot.set(val.x, val.y, val.z, val.w);
        } else {
          _tempFloatArray[0] = 0;
        }
        if (pos) {
          _tempFloatArray[5] = 3;
          _tempFloatArray[6] = pos.x;
          _tempFloatArray[7] = pos.y;
          _tempFloatArray[8] = pos.z;
          this._lpos.set(pos.x, pos.y, pos.z);
        } else {
          _tempFloatArray[5] = 0;
        }
        if (scale) {
          _tempFloatArray[9] = 3;
          _tempFloatArray[10] = scale.x;
          _tempFloatArray[11] = scale.y;
          _tempFloatArray[12] = scale.z;
          this._lscale.set(scale.x, scale.y, scale.z);
        } else {
          _tempFloatArray[9] = 0;
        }
        this._setRTS();
      };
      nodeProto.getPosition = function getPosition(out) {
        if (out) {
          return Vec3.set(out, this._lpos.x, this._lpos.y, this._lpos.z);
        }
        return Vec3.copy(new Vec3(), this._lpos);
      };
      nodeProto.setPosition = function setPosition(val, y, z) {
        if (y === undefined && z === undefined) {
          _tempFloatArray[0] = 3;
          const pos = val;
          this._lpos.x = _tempFloatArray[1] = pos.x;
          this._lpos.y = _tempFloatArray[2] = pos.y;
          this._lpos.z = _tempFloatArray[3] = pos.z;
        } else if (z === undefined) {
          _tempFloatArray[0] = 2;
          this._lpos.x = _tempFloatArray[1] = val;
          this._lpos.y = _tempFloatArray[2] = y;
        } else {
          _tempFloatArray[0] = 3;
          this._lpos.x = _tempFloatArray[1] = val;
          this._lpos.y = _tempFloatArray[2] = y;
          this._lpos.z = _tempFloatArray[3] = z;
        }
        this._setPosition();
      };
      nodeProto.getRotation = function getRotation(out) {
        const lrot = this._lrot;
        if (out) {
          return Quat.set(out, lrot.x, lrot.y, lrot.z, lrot.w);
        }
        return Quat.copy(new Quat(), lrot);
      };
      nodeProto.setRotation = function setRotation(val, y, z, w) {
        if (y === undefined || z === undefined || w === undefined) {
          const rot = val;
          this._lrot.x = _tempFloatArray[0] = rot.x;
          this._lrot.y = _tempFloatArray[1] = rot.y;
          this._lrot.z = _tempFloatArray[2] = rot.z;
          this._lrot.w = _tempFloatArray[3] = rot.w;
        } else {
          this._lrot.x = _tempFloatArray[0] = val;
          this._lrot.y = _tempFloatArray[1] = y;
          this._lrot.z = _tempFloatArray[2] = z;
          this._lrot.w = _tempFloatArray[3] = w;
        }
        this._setRotation();
      };
      nodeProto.setRotationFromEuler = function setRotationFromEuler(val, y, zOpt) {
        const z = zOpt === undefined ? this._euler.z : zOpt;
        if (y === undefined) {
          const euler = val;
          this._euler.x = _tempFloatArray[0] = euler.x;
          this._euler.y = _tempFloatArray[1] = euler.y;
          this._euler.z = _tempFloatArray[2] = euler.z;
        } else {
          this._euler.x = _tempFloatArray[0] = val;
          this._euler.y = _tempFloatArray[1] = y;
          this._euler.z = _tempFloatArray[2] = z;
        }
        this._setRotationFromEuler();
      };
      nodeProto.getScale = function getScale(out) {
        if (out) {
          return Vec3.set(out, this._lscale.x, this._lscale.y, this._lscale.z);
        }
        return Vec3.copy(new Vec3(), this._lscale);
      };
      nodeProto.setScale = function setScale(val, y, z) {
        if (y === undefined && z === undefined) {
          _tempFloatArray[0] = 3;
          const scale = val;
          this._lscale.x = _tempFloatArray[1] = scale.x;
          this._lscale.y = _tempFloatArray[2] = scale.y;
          this._lscale.z = _tempFloatArray[3] = scale.z;
        } else if (z === undefined) {
          _tempFloatArray[0] = 2;
          this._lscale.x = _tempFloatArray[1] = val;
          this._lscale.y = _tempFloatArray[2] = y;
        } else {
          _tempFloatArray[0] = 3;
          this._lscale.x = _tempFloatArray[1] = val;
          this._lscale.y = _tempFloatArray[2] = y;
          this._lscale.z = _tempFloatArray[3] = z;
        }
        this._setScale();
      };
      nodeProto.getWorldPosition = function getWorldPosition(out) {
        this._getWorldPosition();
        out = out || new Vec3();
        return out.set(_tempFloatArray[0], _tempFloatArray[1], _tempFloatArray[2]);
      };
      nodeProto.getWorldRotation = function getWorldRotation(out) {
        this._getWorldRotation();
        out = out || new Quat();
        return out.set(_tempFloatArray[0], _tempFloatArray[1], _tempFloatArray[2], _tempFloatArray[3]);
      };
      nodeProto.getWorldScale = function getWorldScale(out) {
        this._getWorldScale();
        out = out || new Vec3();
        return out.set(_tempFloatArray[0], _tempFloatArray[1], _tempFloatArray[2]);
      };
      nodeProto.getWorldMatrix = function getWorldMatrix(out) {
        this._getWorldMatrix();
        out = out || new Mat4();
        fillMat4WithTempFloatArray(out);
        return out;
      };
      nodeProto.getEulerAngles = function getEulerAngles(out) {
        this._getEulerAngles();
        out = out || new Vec3();
        return out.set(_tempFloatArray[0], _tempFloatArray[1], _tempFloatArray[2]);
      };
      nodeProto.getForward = function getForward(out) {
        this._getForward();
        out = out || new Vec3();
        return out.set(_tempFloatArray[0], _tempFloatArray[1], _tempFloatArray[2]);
      };
      nodeProto.getUp = function getUp(out) {
        this._getUp();
        out = out || new Vec3();
        return out.set(_tempFloatArray[0], _tempFloatArray[1], _tempFloatArray[2]);
      };
      nodeProto.getRight = function getRight(out) {
        this._getRight();
        out = out || new Vec3();
        return out.set(_tempFloatArray[0], _tempFloatArray[1], _tempFloatArray[2]);
      };
      nodeProto.inverseTransformPoint = function inverseTransformPoint(out, p) {
        _tempFloatArray[0] = p.x;
        _tempFloatArray[1] = p.y;
        _tempFloatArray[2] = p.z;
        this._inverseTransformPoint();
        out.x = _tempFloatArray[0];
        out.y = _tempFloatArray[1];
        out.z = _tempFloatArray[2];
        return out;
      };
      nodeProto.getWorldRT = function getWorldRT(out) {
        out = out || new Mat4();
        this._getWorldRT();
        fillMat4WithTempFloatArray(out);
        return out;
      };
      nodeProto.getWorldRS = function getWorldRS(out) {
        out = out || new Mat4();
        this._getWorldRS();
        fillMat4WithTempFloatArray(out);
        return out;
      };
      nodeProto.isTransformDirty = function () {
        return this._transformFlags !== TransformBit.NONE;
      };
      Object.defineProperty(nodeProto, 'name', {
        configurable: true,
        enumerable: true,
        get() {
          return this._name;
        },
        set(v) {
          this._name = v;
        }
      });
      Object.defineProperty(nodeProto, 'position', {
        configurable: true,
        enumerable: true,
        get() {
          return this._lpos;
        },
        set(v) {
          this.setPosition(v);
        }
      });
      Object.defineProperty(nodeProto, 'rotation', {
        configurable: true,
        enumerable: true,
        get() {
          return this._lrot;
        },
        set(v) {
          this.setRotation(v);
        }
      });
      Object.defineProperty(nodeProto, 'scale', {
        configurable: true,
        enumerable: true,
        get() {
          return this._lscale;
        },
        set(v) {
          this.setScale(v);
        }
      });
      Object.defineProperty(nodeProto, 'worldPosition', {
        configurable: true,
        enumerable: true,
        get() {
          return this.getWorldPosition();
        },
        set(v) {
          this.setWorldPosition(v);
        }
      });
      Object.defineProperty(nodeProto, 'worldRotation', {
        configurable: true,
        enumerable: true,
        get() {
          return this.getWorldRotation();
        },
        set(v) {
          this.setWorldRotation(v);
        }
      });
      Object.defineProperty(nodeProto, 'worldScale', {
        configurable: true,
        enumerable: true,
        get() {
          return this.getWorldScale();
        },
        set(v) {
          this.setWorldScale(v);
        }
      });
      Object.defineProperty(nodeProto, '_pos', {
        configurable: true,
        enumerable: true,
        get() {
          return this.getWorldPosition();
        }
      });
      Object.defineProperty(nodeProto, '_rot', {
        configurable: true,
        enumerable: true,
        get() {
          return this.getWorldRotation();
        }
      });
      Object.defineProperty(nodeProto, '_scale', {
        configurable: true,
        enumerable: true,
        get() {
          return this.getWorldScale();
        }
      });
      Object.defineProperty(nodeProto, 'eulerAngles', {
        configurable: true,
        enumerable: true,
        get() {
          return this.getEulerAngles();
        },
        set(v) {
          this.setRotationFromEuler(v.x, v.y, v.z);
        }
      });
      Object.defineProperty(nodeProto, 'worldMatrix', {
        configurable: true,
        enumerable: true,
        get() {
          return this.getWorldMatrix();
        }
      });
      Object.defineProperty(nodeProto, '_mat', {
        configurable: true,
        enumerable: true,
        get() {
          return this.getWorldMatrix();
        }
      });
      Object.defineProperty(nodeProto, 'activeInHierarchy', {
        configurable: true,
        enumerable: true,
        get() {
          return this._sharedUint8Arr[0] != 0;
        },
        set(v) {
          this._sharedUint8Arr[0] = v ? 1 : 0;
        }
      });
      Object.defineProperty(nodeProto, '_activeInHierarchy', {
        configurable: true,
        enumerable: true,
        get() {
          return this._sharedUint8Arr[0] != 0;
        },
        set(v) {
          this._sharedUint8Arr[0] = v ? 1 : 0;
        }
      });
      Object.defineProperty(nodeProto, 'layer', {
        configurable: true,
        enumerable: true,
        get() {
          return this._sharedUint32Arr[1];
        },
        set(v) {
          this._sharedUint32Arr[1] = v;
          if (this._uiProps && this._uiProps.uiComp) {
            this._uiProps.uiComp.setNodeDirty();
            this._uiProps.uiComp.markForUpdateRenderData();
          }
          this.emit(NodeEventType.LAYER_CHANGED, v);
        }
      });
      Object.defineProperty(nodeProto, '_layer', {
        configurable: true,
        enumerable: true,
        get() {
          return this._sharedUint32Arr[1];
        },
        set(v) {
          this._sharedUint32Arr[1] = v;
        }
      });
      Object.defineProperty(nodeProto, '_eventMask', {
        configurable: true,
        enumerable: true,
        get() {
          return this._sharedUint32Arr[0];
        },
        set(v) {
          this._sharedUint32Arr[0] = v;
        }
      });
      Object.defineProperty(nodeProto, '_siblingIndex', {
        configurable: true,
        enumerable: true,
        get() {
          return this._sharedInt32Arr[0];
        },
        set(v) {
          this._sharedInt32Arr[0] = v;
        }
      });
      Object.defineProperty(nodeProto, 'prefab', {
        configurable: true,
        enumerable: true,
        get() {
          return this._prefab;
        }
      });
      Object.defineProperty(nodeProto, 'siblingIndex', {
        configurable: true,
        enumerable: true,
        get() {
          return this._sharedInt32Arr[0];
        },
        set(v) {
          this._sharedInt32Arr[0] = v;
        }
      });
      nodeProto.getSiblingIndex = function getSiblingIndex() {
        return this._sharedInt32Arr[0];
      };
      Object.defineProperty(nodeProto, '_transformFlags', {
        configurable: true,
        enumerable: true,
        get() {
          return this._sharedUint32Arr[2];
        },
        set(v) {
          this._sharedUint32Arr[2] = v;
        }
      });
      Object.defineProperty(nodeProto, '_active', {
        configurable: true,
        enumerable: true,
        get() {
          return this._sharedUint8Arr[1] != 0;
        },
        set(v) {
          this._sharedUint8Arr[1] = v ? 1 : 0;
        }
      });
      Object.defineProperty(nodeProto, 'active', {
        configurable: true,
        enumerable: true,
        get() {
          return this._sharedUint8Arr[1] != 0;
        },
        set(v) {
          this.setActive(!!v);
        }
      });
      Object.defineProperty(nodeProto, '_static', {
        configurable: true,
        enumerable: true,
        get() {
          return this._sharedUint8Arr[2] != 0;
        },
        set(v) {
          this._sharedUint8Arr[2] = v ? 1 : 0;
        }
      });
      Object.defineProperty(nodeProto, 'forward', {
        configurable: true,
        enumerable: true,
        get() {
          return this.getForward();
        },
        set(dir) {
          this.setForward(dir);
        }
      });
      Object.defineProperty(nodeProto, 'up', {
        configurable: true,
        enumerable: true,
        get() {
          return this.getUp();
        }
      });
      Object.defineProperty(nodeProto, 'right', {
        configurable: true,
        enumerable: true,
        get() {
          return this.getRight();
        }
      });
      Object.defineProperty(nodeProto, 'eventProcessor', {
        configurable: true,
        enumerable: true,
        get() {
          return this._eventProcessor;
        }
      });
      Object.defineProperty(nodeProto, 'components', {
        configurable: true,
        enumerable: true,
        get() {
          return this._components;
        }
      });
      Object.defineProperty(nodeProto, '_parent', {
        configurable: true,
        enumerable: true,
        get() {
          this._parentRef = this._parentInternal;
          return this._parentRef;
        },
        set(v) {
          this._parentRef = this._parentInternal = v;
        }
      });
      Object.defineProperty(nodeProto, 'parent', {
        configurable: true,
        enumerable: true,
        get() {
          this._parentRef = this.getParent();
          return this._parentRef;
        },
        set(v) {
          this._parentRef = v;
          this.setParent(v);
        }
      });
      Object.defineProperty(nodeProto, 'children', {
        configurable: true,
        enumerable: true,
        get() {
          return this._children;
        },
        set(v) {
          this._children = v;
        }
      });
      Object.defineProperty(nodeProto, 'scene', {
        configurable: true,
        enumerable: true,
        get() {
          return this._scene;
        }
      });
      nodeProto.rotate = function (rot, ns) {
        _tempFloatArray[1] = rot.x;
        _tempFloatArray[2] = rot.y;
        _tempFloatArray[3] = rot.z;
        _tempFloatArray[4] = rot.w;
        if (ns) {
          _tempFloatArray[5] = ns;
          _tempFloatArray[0] = 5;
        } else {
          _tempFloatArray[0] = 4;
        }
        this._rotateForJS();
        const lrot = this._lrot;
        lrot.x = _tempFloatArray[0];
        lrot.y = _tempFloatArray[1];
        lrot.z = _tempFloatArray[2];
        lrot.w = _tempFloatArray[3];
      };
      nodeProto.addChild = function (child) {
        child.setParent(this);
      };
      nodeProto.insertChild = function (child, siblingIndex) {
        child.parent = this;
        child.setSiblingIndex(siblingIndex);
      };
      nodeProto[serializeTag] = function (serializationOutput, context) {
        {
          serializationOutput.writeThis();
        }
        const isMountedChild = () => {
          var _this$editorExtrasTag;
          return !!((_this$editorExtrasTag = this[editorExtrasTag]) !== null && _this$editorExtrasTag !== void 0 && _this$editorExtrasTag.mountedRoot);
        };
        const isSyncPrefab = () => {
          var _this$_prefab, _this$_prefab$root, _this$_prefab$root$_p, _this$_prefab2;
          return ((_this$_prefab = this._prefab) === null || _this$_prefab === void 0 ? void 0 : (_this$_prefab$root = _this$_prefab.root) === null || _this$_prefab$root === void 0 ? void 0 : (_this$_prefab$root$_p = _this$_prefab$root._prefab) === null || _this$_prefab$root$_p === void 0 ? void 0 : _this$_prefab$root$_p.instance) && ((this === null || this === void 0 ? void 0 : (_this$_prefab2 = this._prefab) === null || _this$_prefab2 === void 0 ? void 0 : _this$_prefab2.instance) || !isMountedChild());
        };
        const canDiscardByPrefabRoot = () => !(context.customArguments[reserveContentsForAllSyncablePrefabTag] || !isSyncPrefab() || context.root === this);
        if (canDiscardByPrefabRoot()) {
          var _this$_prefab3;
          const isRoot = ((_this$_prefab3 = this._prefab) === null || _this$_prefab3 === void 0 ? void 0 : _this$_prefab3.root) === this;
          if (isRoot) {
            let isNestedPrefab = false;
            let parent = this.getParent();
            while (parent) {
              var _parent$_prefab;
              const nestedRoots = (_parent$_prefab = parent._prefab) === null || _parent$_prefab === void 0 ? void 0 : _parent$_prefab.nestedPrefabInstanceRoots;
              if (nestedRoots && nestedRoots.length > 0) {
                isNestedPrefab = !nestedRoots.some(root => root === this);
                break;
              }
              parent = parent.getParent();
            }
            if (!isNestedPrefab) {
              serializationOutput.writeProperty('_objFlags', this._objFlags);
              serializationOutput.writeProperty('_parent', this._parent);
              serializationOutput.writeProperty('_prefab', this._prefab);
              if (context.customArguments.keepNodeUuid) {
                serializationOutput.writeProperty('_id', this._id);
              }
            }
            serializationOutput.writeProperty(editorExtrasTag, this[editorExtrasTag]);
          }
        } else {
          serializationOutput.writeThis();
        }
      };
      nodeProto._onActiveNode = function (shouldActiveNow) {
        legacyCC.director._nodeActivator.activateNode(this, shouldActiveNow);
      };
      nodeProto._onBatchCreated = function (dontSyncChildPrefab) {
        this.hasChangedFlags = TRANSFORMBIT_TRS;
        this._transformFlags |= TRANSFORMBIT_TRS;
        const children = this._children;
        const len = children.length;
        let child;
        for (let i = 0; i < len; ++i) {
          child = children[i];
          child._siblingIndex = i;
          child._onBatchCreated(dontSyncChildPrefab);
        }
        syncNodeValues(this);
      };
      nodeProto._onSceneUpdated = function (scene) {
        this._scene = scene;
      };
      nodeProto._onLocalPositionUpdated = function (x, y, z) {
        const lpos = this._lpos;
        lpos.x = x;
        lpos.y = y;
        lpos.z = z;
      };
      nodeProto._onLocalRotationUpdated = function (x, y, z, w) {
        const lrot = this._lrot;
        lrot.x = x;
        lrot.y = y;
        lrot.z = z;
        lrot.w = w;
      };
      nodeProto._onLocalScaleUpdated = function (x, y, z) {
        const lscale = this._lscale;
        lscale.x = x;
        lscale.y = y;
        lscale.z = z;
      };
      nodeProto._onLocalPositionRotationScaleUpdated = function (px, py, pz, rx, ry, rz, rw, sx, sy, sz) {
        const lpos = this._lpos;
        lpos.x = px;
        lpos.y = py;
        lpos.z = pz;
        const lrot = this._lrot;
        lrot.x = rx;
        lrot.y = ry;
        lrot.z = rz;
        lrot.w = rw;
        const lscale = this._lscale;
        lscale.x = sx;
        lscale.y = sy;
        lscale.z = sz;
      };
      nodeProto._instantiate = function (cloned, isSyncedNode) {
        if (!cloned) {
          cloned = legacyCC.instantiate._clone(this, this);
        }
        cloned._prefab;
        cloned._parent = null;
        cloned._onBatchCreated(isSyncedNode);
        return cloned;
      };
      nodeProto._onSiblingIndexChanged = function (index) {
        const siblings = this._parent._children;
        index = index !== -1 ? index : siblings.length - 1;
        const oldIndex = siblings.indexOf(this);
        if (index !== oldIndex) {
          siblings.splice(oldIndex, 1);
          if (index < siblings.length) {
            siblings.splice(index, 0, this);
          } else {
            siblings.push(this);
          }
        }
      };
      nodeProto._ctor = function (name) {
        this.__nativeRefs = {};
        this._parentRef = null;
        this.__jsb_ref_id = undefined;
        this._iN$t = null;
        this.__editorExtras__ = {
          editorOnly: true
        };
        this._components = [];
        this._eventProcessor = new legacyCC.NodeEventProcessor(this);
        this._uiProps = new NodeUIProperties(this);
        const sharedArrayBuffer = this._initAndReturnSharedBuffer();
        this._sharedUint32Arr = new Uint32Array(sharedArrayBuffer, 0, 3);
        this._sharedInt32Arr = new Int32Array(sharedArrayBuffer, 12, 1);
        this._sharedUint8Arr = new Uint8Array(sharedArrayBuffer, 16, 3);
        this._sharedUint32Arr[1] = Layers.Enum.DEFAULT;
        this._scene = null;
        this._prefab = null;
        this._originalSceneId = '';
        this._children = [];
        this._lpos = new Vec3();
        this._lrot = new Quat();
        this._lscale = new Vec3(1, 1, 1);
        this._euler = new Vec3();
        this._registeredNodeEventTypeMask = 0;
      };
      patch_cc_Node({
        Node: Node$1,
        Vec3,
        Quat,
        MobilityMode,
        Layers
      });

      CCClass.Attr.setClassAttr(EventHandler, 'target', 'type', 'Object');
      CCClass.Attr.setClassAttr(EventHandler, 'target', 'ctor', Node$1);

      const _cachedArray = new Array(16);
      let _currentHovered = null;
      const pos = new Vec2();
      const _touchEvents = [NodeEventType.TOUCH_START, NodeEventType.TOUCH_MOVE, NodeEventType.TOUCH_END, NodeEventType.TOUCH_CANCEL];
      const _mouseEvents = [NodeEventType.MOUSE_DOWN, NodeEventType.MOUSE_ENTER, NodeEventType.MOUSE_MOVE, NodeEventType.MOUSE_LEAVE, NodeEventType.MOUSE_UP, NodeEventType.MOUSE_WHEEL];
      let DispatcherEventType;
      (function (DispatcherEventType) {
        DispatcherEventType[DispatcherEventType["ADD_POINTER_EVENT_PROCESSOR"] = 0] = "ADD_POINTER_EVENT_PROCESSOR";
        DispatcherEventType[DispatcherEventType["REMOVE_POINTER_EVENT_PROCESSOR"] = 1] = "REMOVE_POINTER_EVENT_PROCESSOR";
        DispatcherEventType[DispatcherEventType["MARK_LIST_DIRTY"] = 2] = "MARK_LIST_DIRTY";
      })(DispatcherEventType || (DispatcherEventType = {}));
      class NodeEventProcessor {
        get isEnabled() {
          return this._isEnabled;
        }
        get node() {
          return this._node;
        }
        constructor(node) {
          this.claimedTouchIdList = [];
          this.maskList = null;
          this.cachedCameraPriority = 0;
          this.previousMouseIn = false;
          this.bubblingTarget = null;
          this.capturingTarget = null;
          this.shouldHandleEventMouse = false;
          this.shouldHandleEventTouch = false;
          this._dispatchingTouch = null;
          this._isEnabled = false;
          this._node = void 0;
          this._node = node;
        }
        setEnabled(value, recursive = false) {
          if (this._isEnabled === value) {
            return;
          }
          this._isEnabled = value;
          const node = this.node;
          const children = node.children;
          if (value) {
            this._attachMask();
          }
          NodeEventProcessor.callbacksInvoker.emit(DispatcherEventType.MARK_LIST_DIRTY);
          if (recursive && children.length > 0) {
            for (let i = 0; i < children.length; ++i) {
              const child = children[i];
              child.eventProcessor.setEnabled(value, true);
            }
          }
          if (this._dispatchingTouch && !this._isEnabled) {
            const cancelEvent = new EventTouch([this._dispatchingTouch], true, InputEventType.TOUCH_CANCEL);
            cancelEvent.touch = this._dispatchingTouch;
            this.dispatchEvent(cancelEvent);
            this.claimedTouchIdList.length = 0;
            this._dispatchingTouch = null;
          }
        }
        reattach() {
          let currentMaskList;
          this.node.walk(node => {
            if (!currentMaskList) {
              currentMaskList = this._searchComponentsInParent(NodeEventProcessor._maskComp);
            }
            node.eventProcessor.maskList = currentMaskList;
          });
        }
        destroy() {
          if (_currentHovered === this._node) {
            _currentHovered = null;
          }
          if (this.capturingTarget) this.capturingTarget.clear();
          if (this.bubblingTarget) this.bubblingTarget.clear();
          NodeEventProcessor.callbacksInvoker.emit(DispatcherEventType.REMOVE_POINTER_EVENT_PROCESSOR, this);
          if (this._dispatchingTouch) {
            const cancelEvent = new EventTouch([this._dispatchingTouch], true, InputEventType.TOUCH_CANCEL);
            cancelEvent.touch = this._dispatchingTouch;
            this.dispatchEvent(cancelEvent);
            this._dispatchingTouch = null;
          }
        }
        on(type, callback, target, useCapture) {
          this._tryEmittingAddEvent(type);
          useCapture = !!useCapture;
          let invoker;
          if (useCapture) {
            var _this$capturingTarget;
            invoker = (_this$capturingTarget = this.capturingTarget) !== null && _this$capturingTarget !== void 0 ? _this$capturingTarget : this.capturingTarget = this._newCallbacksInvoker();
          } else {
            var _this$bubblingTarget;
            invoker = (_this$bubblingTarget = this.bubblingTarget) !== null && _this$bubblingTarget !== void 0 ? _this$bubblingTarget : this.bubblingTarget = this._newCallbacksInvoker();
          }
          invoker.on(type, callback, target);
          return callback;
        }
        once(type, callback, target, useCapture) {
          this._tryEmittingAddEvent(type);
          useCapture = !!useCapture;
          let invoker;
          if (useCapture) {
            var _this$capturingTarget2;
            invoker = (_this$capturingTarget2 = this.capturingTarget) !== null && _this$capturingTarget2 !== void 0 ? _this$capturingTarget2 : this.capturingTarget = this._newCallbacksInvoker();
          } else {
            var _this$bubblingTarget2;
            invoker = (_this$bubblingTarget2 = this.bubblingTarget) !== null && _this$bubblingTarget2 !== void 0 ? _this$bubblingTarget2 : this.bubblingTarget = this._newCallbacksInvoker();
          }
          invoker.on(type, callback, target, true);
          return callback;
        }
        off(type, callback, target, useCapture) {
          var _invoker;
          useCapture = !!useCapture;
          let invoker;
          if (useCapture) {
            invoker = this.capturingTarget;
          } else {
            invoker = this.bubblingTarget;
          }
          (_invoker = invoker) === null || _invoker === void 0 ? void 0 : _invoker.off(type, callback, target);
        }
        targetOff(target) {
          var _this$capturingTarget3, _this$bubblingTarget3;
          (_this$capturingTarget3 = this.capturingTarget) === null || _this$capturingTarget3 === void 0 ? void 0 : _this$capturingTarget3.removeAll(target);
          (_this$bubblingTarget3 = this.bubblingTarget) === null || _this$bubblingTarget3 === void 0 ? void 0 : _this$bubblingTarget3.removeAll(target);
          if (this.shouldHandleEventTouch && !this._hasTouchListeners()) {
            this.shouldHandleEventTouch = false;
          }
          if (this.shouldHandleEventMouse && !this._hasMouseListeners()) {
            this.shouldHandleEventMouse = false;
          }
          if (!this._hasPointerListeners()) {
            NodeEventProcessor.callbacksInvoker.emit(DispatcherEventType.REMOVE_POINTER_EVENT_PROCESSOR, this);
          }
        }
        emit(type, arg0, arg1, arg2, arg3, arg4) {
          var _this$bubblingTarget4;
          (_this$bubblingTarget4 = this.bubblingTarget) === null || _this$bubblingTarget4 === void 0 ? void 0 : _this$bubblingTarget4.emit(type, arg0, arg1, arg2, arg3, arg4);
        }
        dispatchEvent(event) {
          const owner = this.node;
          let target;
          let i = 0;
          event.target = owner;
          _cachedArray.length = 0;
          this.getCapturingTargets(event.type, _cachedArray);
          event.eventPhase = 1;
          for (i = _cachedArray.length - 1; i >= 0; --i) {
            target = _cachedArray[i];
            if (target.eventProcessor.capturingTarget) {
              event.currentTarget = target;
              target.eventProcessor.capturingTarget.emit(event.type, event, _cachedArray);
              if (event.propagationStopped) {
                _cachedArray.length = 0;
                return;
              }
            }
          }
          _cachedArray.length = 0;
          event.eventPhase = 2;
          event.currentTarget = owner;
          if (this.capturingTarget) {
            this.capturingTarget.emit(event.type, event);
          }
          if (!event.propagationImmediateStopped && this.bubblingTarget) {
            this.bubblingTarget.emit(event.type, event);
          }
          if (!event.propagationStopped && event.bubbles) {
            this.getBubblingTargets(event.type, _cachedArray);
            event.eventPhase = 3;
            for (i = 0; i < _cachedArray.length; ++i) {
              target = _cachedArray[i];
              if (target.eventProcessor.bubblingTarget) {
                event.currentTarget = target;
                target.eventProcessor.bubblingTarget.emit(event.type, event);
                if (event.propagationStopped) {
                  _cachedArray.length = 0;
                  return;
                }
              }
            }
          }
          _cachedArray.length = 0;
        }
        hasEventListener(type, callback, target) {
          let has = false;
          if (this.bubblingTarget) {
            has = this.bubblingTarget.hasEventListener(type, callback, target);
          }
          if (!has && this.capturingTarget) {
            has = this.capturingTarget.hasEventListener(type, callback, target);
          }
          return has;
        }
        getCapturingTargets(type, targets) {
          let parent = this._node.parent;
          while (parent) {
            var _parent$eventProcesso;
            if ((_parent$eventProcesso = parent.eventProcessor.capturingTarget) !== null && _parent$eventProcesso !== void 0 && _parent$eventProcesso.hasEventListener(type)) {
              targets.push(parent);
            }
            parent = parent.parent;
          }
        }
        getBubblingTargets(type, targets) {
          let parent = this._node.parent;
          while (parent) {
            var _parent$eventProcesso2;
            if ((_parent$eventProcesso2 = parent.eventProcessor.bubblingTarget) !== null && _parent$eventProcesso2 !== void 0 && _parent$eventProcesso2.hasEventListener(type)) {
              targets.push(parent);
            }
            parent = parent.parent;
          }
        }
        onUpdatingSiblingIndex() {
          NodeEventProcessor.callbacksInvoker.emit(DispatcherEventType.MARK_LIST_DIRTY);
        }
        _searchComponentsInParent(ctor) {
          const node = this.node;
          if (ctor) {
            let index = 0;
            let list = [];
            for (let curr = node; curr && Node$1.isNode(curr); curr = curr.parent, ++index) {
              const comp = curr.getComponent(ctor);
              if (comp) {
                const next = {
                  index,
                  comp
                };
                if (list) {
                  list.push(next);
                } else {
                  list = [next];
                }
              }
            }
            return list.length > 0 ? list : null;
          }
          return null;
        }
        _attachMask() {
          this.maskList = this._searchComponentsInParent(NodeEventProcessor._maskComp);
        }
        _isTouchEvent(type) {
          const index = _touchEvents.indexOf(type);
          return index !== -1;
        }
        _isMouseEvent(type) {
          const index = _mouseEvents.indexOf(type);
          return index !== -1;
        }
        _hasTouchListeners() {
          for (let i = 0; i < _touchEvents.length; ++i) {
            const eventType = _touchEvents[i];
            if (this.hasEventListener(eventType)) {
              return true;
            }
          }
          return false;
        }
        _hasMouseListeners() {
          for (let i = 0; i < _mouseEvents.length; ++i) {
            const eventType = _mouseEvents[i];
            if (this.hasEventListener(eventType)) {
              return true;
            }
          }
          return false;
        }
        _hasPointerListeners() {
          const has = this._hasTouchListeners();
          if (has) {
            return true;
          }
          return this._hasMouseListeners();
        }
        _tryEmittingAddEvent(typeToAdd) {
          const isTouchEvent = this._isTouchEvent(typeToAdd);
          const isMouseEvent = this._isMouseEvent(typeToAdd);
          if (isTouchEvent) {
            this.shouldHandleEventTouch = true;
          } else if (isMouseEvent) {
            this.shouldHandleEventMouse = true;
          }
          if ((isTouchEvent || isMouseEvent) && !this._hasPointerListeners()) {
            NodeEventProcessor.callbacksInvoker.emit(DispatcherEventType.ADD_POINTER_EVENT_PROCESSOR, this);
          }
        }
        _newCallbacksInvoker() {
          const callbacksInvoker = new CallbacksInvoker();
          callbacksInvoker._registerOffCallback(() => {
            if (this.shouldHandleEventTouch && !this._hasTouchListeners()) {
              this.shouldHandleEventTouch = false;
            }
            if (this.shouldHandleEventMouse && !this._hasMouseListeners()) {
              this.shouldHandleEventMouse = false;
            }
            if (!this._hasPointerListeners()) {
              NodeEventProcessor.callbacksInvoker.emit(DispatcherEventType.REMOVE_POINTER_EVENT_PROCESSOR, this);
            }
          });
          return callbacksInvoker;
        }
        _handleEventMouse(eventMouse) {
          switch (eventMouse.type) {
            case InputEventType.MOUSE_DOWN:
              return this._handleMouseDown(eventMouse);
            case InputEventType.MOUSE_MOVE:
              return this._handleMouseMove(eventMouse);
            case InputEventType.MOUSE_UP:
              return this._handleMouseUp(eventMouse);
            case InputEventType.MOUSE_WHEEL:
              return this._handleMouseWheel(eventMouse);
            default:
              return false;
          }
        }
        _handleMouseDown(event) {
          const node = this._node;
          if (!node || !node._uiProps.uiTransformComp) {
            return false;
          }
          event.getLocation(pos);
          if (node._uiProps.uiTransformComp.hitTest(pos, event.windowId)) {
            event.type = NodeEventType.MOUSE_DOWN;
            event.bubbles = true;
            node.dispatchEvent(event);
            event.propagationStopped = true;
            return true;
          }
          return false;
        }
        _handleMouseMove(event) {
          const node = this._node;
          if (!node || !node._uiProps.uiTransformComp) {
            return false;
          }
          event.getLocation(pos);
          const hit = node._uiProps.uiTransformComp.hitTest(pos, event.windowId);
          if (hit) {
            if (!this.previousMouseIn) {
              if (_currentHovered && _currentHovered !== node) {
                event.type = NodeEventType.MOUSE_LEAVE;
                _currentHovered.dispatchEvent(event);
                _currentHovered.eventProcessor.previousMouseIn = false;
              }
              _currentHovered = node;
              event.type = NodeEventType.MOUSE_ENTER;
              node.dispatchEvent(event);
              this.previousMouseIn = true;
            }
            event.type = NodeEventType.MOUSE_MOVE;
            event.bubbles = true;
            node.dispatchEvent(event);
            event.propagationStopped = true;
            return true;
          } else if (this.previousMouseIn) {
            event.type = NodeEventType.MOUSE_LEAVE;
            node.dispatchEvent(event);
            this.previousMouseIn = false;
            _currentHovered = null;
          }
          return false;
        }
        _handleMouseUp(event) {
          const node = this._node;
          if (!node || !node._uiProps.uiTransformComp) {
            return false;
          }
          event.getLocation(pos);
          if (node._uiProps.uiTransformComp.hitTest(pos, event.windowId)) {
            event.type = NodeEventType.MOUSE_UP;
            event.bubbles = true;
            node.dispatchEvent(event);
            event.propagationStopped = true;
            return true;
          }
          return false;
        }
        _handleMouseWheel(event) {
          const node = this._node;
          if (!node || !node._uiProps.uiTransformComp) {
            return false;
          }
          event.getLocation(pos);
          if (node._uiProps.uiTransformComp.hitTest(pos, event.windowId)) {
            event.type = NodeEventType.MOUSE_WHEEL;
            event.bubbles = true;
            node.dispatchEvent(event);
            event.propagationStopped = true;
            return true;
          }
          return false;
        }
        _handleEventTouch(eventTouch) {
          switch (eventTouch.type) {
            case InputEventType.TOUCH_START:
              return this._handleTouchStart(eventTouch);
            case InputEventType.TOUCH_MOVE:
              return this._handleTouchMove(eventTouch);
            case InputEventType.TOUCH_END:
              return this._handleTouchEnd(eventTouch);
            case InputEventType.TOUCH_CANCEL:
              return this._handleTouchCancel(eventTouch);
            default:
              return false;
          }
        }
        _handleTouchStart(event) {
          const node = this.node;
          if (!node || !node._uiProps.uiTransformComp) {
            return false;
          }
          event.getLocation(pos);
          if (node._uiProps.uiTransformComp.hitTest(pos, event.windowId)) {
            event.type = NodeEventType.TOUCH_START;
            event.bubbles = true;
            this._dispatchingTouch = event.touch;
            node.dispatchEvent(event);
            return true;
          }
          return false;
        }
        _handleTouchMove(event) {
          const node = this.node;
          if (!node || !node._uiProps.uiTransformComp) {
            return false;
          }
          event.type = NodeEventType.TOUCH_MOVE;
          event.bubbles = true;
          this._dispatchingTouch = event.touch;
          node.dispatchEvent(event);
          return true;
        }
        _handleTouchEnd(event) {
          const node = this.node;
          if (!node || !node._uiProps.uiTransformComp) {
            return;
          }
          event.getLocation(pos);
          if (node._uiProps.uiTransformComp.hitTest(pos, event.windowId)) {
            event.type = NodeEventType.TOUCH_END;
          } else {
            event.type = NodeEventType.TOUCH_CANCEL;
          }
          event.bubbles = true;
          node.dispatchEvent(event);
          this._dispatchingTouch = null;
        }
        _handleTouchCancel(event) {
          const node = this.node;
          if (!node || !node._uiProps.uiTransformComp) {
            return;
          }
          event.type = NodeEventType.TOUCH_CANCEL;
          event.bubbles = true;
          node.dispatchEvent(event);
        }
      }
      NodeEventProcessor._maskComp = null;
      NodeEventProcessor.callbacksInvoker = new CallbacksInvoker();
      legacyCC.NodeEventProcessor = NodeEventProcessor;

      const textureCubeProto = jsb.TextureCube.prototype;
      var FaceIndex;
      (function (FaceIndex) {
        FaceIndex[FaceIndex["right"] = 0] = "right";
        FaceIndex[FaceIndex["left"] = 1] = "left";
        FaceIndex[FaceIndex["top"] = 2] = "top";
        FaceIndex[FaceIndex["bottom"] = 3] = "bottom";
        FaceIndex[FaceIndex["front"] = 4] = "front";
        FaceIndex[FaceIndex["back"] = 5] = "back";
      })(FaceIndex || (FaceIndex = {}));
      var MipmapMode;
      (function (MipmapMode) {
        MipmapMode[MipmapMode["NONE"] = 0] = "NONE";
        MipmapMode[MipmapMode["AUTO"] = 1] = "AUTO";
        MipmapMode[MipmapMode["BAKED_CONVOLUTION_MAP"] = 2] = "BAKED_CONVOLUTION_MAP";
      })(MipmapMode || (MipmapMode = {}));
      textureCubeProto.createNode = null;
      const TextureCube = exports('TextureCube', jsb.TextureCube);
      TextureCube.Filter = Filter;
      TextureCube.PixelFormat = PixelFormat;
      TextureCube.WrapMode = WrapMode;
      textureCubeProto._ctor = function () {
        jsb.SimpleTexture.prototype._ctor.apply(this, arguments);
        this._mipmaps = null;
        this._mipmapAtlas = null;
      };
      Object.defineProperty(textureCubeProto, 'mipmaps', {
        get() {
          return this._mipmaps;
        },
        set(value) {
          this._mipmaps = value;
          this.setMipmaps(value);
        }
      });
      Object.defineProperty(textureCubeProto, 'image', {
        get() {
          return this._mipmaps.length === 0 ? null : this._mipmaps[0];
        },
        set(value) {
          this.mipmaps = value ? [value] : [];
        }
      });
      const oldOnLoaded$1 = textureCubeProto.onLoaded;
      textureCubeProto.onLoaded = function () {
        if (this._mipmapMode === MipmapMode.BAKED_CONVOLUTION_MAP) {
          this.setMipmapAtlasForJS(this._mipmapAtlas);
        } else {
          this.setMipmapsForJS(this._mipmaps);
        }
        oldOnLoaded$1.apply(this);
      };
      textureCubeProto._serialize = function (ctxForExporting) {
        return null;
      };
      textureCubeProto._deserialize = function (serializedData, handle) {
        const data = serializedData;
        jsb.TextureBase.prototype._deserialize.call(this, data.base, handle);
        this.isRGBE = data.rgbe;
        if (data.mipmapMode != undefined) {
          this._mipmapMode = data.mipmapMode;
        }
        if (this._mipmapMode === MipmapMode.BAKED_CONVOLUTION_MAP) {
          const mipmapAtlas = data.mipmapAtlas;
          const mipmapLayout = data.mipmapLayout;
          this._mipmapAtlas = {
            atlas: {},
            layout: mipmapLayout
          };
          this._mipmapAtlas.atlas = {
            front: new jsb.ImageAsset(),
            back: new jsb.ImageAsset(),
            left: new jsb.ImageAsset(),
            right: new jsb.ImageAsset(),
            top: new jsb.ImageAsset(),
            bottom: new jsb.ImageAsset()
          };
          if (mipmapAtlas) {
            const imageAssetClassId = getClassId(jsb.ImageAsset);
            handle.result.push(this._mipmapAtlas.atlas, `front`, mipmapAtlas.front, imageAssetClassId);
            handle.result.push(this._mipmapAtlas.atlas, `back`, mipmapAtlas.back, imageAssetClassId);
            handle.result.push(this._mipmapAtlas.atlas, `left`, mipmapAtlas.left, imageAssetClassId);
            handle.result.push(this._mipmapAtlas.atlas, `right`, mipmapAtlas.right, imageAssetClassId);
            handle.result.push(this._mipmapAtlas.atlas, `top`, mipmapAtlas.top, imageAssetClassId);
            handle.result.push(this._mipmapAtlas.atlas, `bottom`, mipmapAtlas.bottom, imageAssetClassId);
          }
        } else {
          this._mipmaps = new Array(data.mipmaps.length);
          for (let i = 0; i < data.mipmaps.length; ++i) {
            this._mipmaps[i] = {
              front: new jsb.ImageAsset(),
              back: new jsb.ImageAsset(),
              left: new jsb.ImageAsset(),
              right: new jsb.ImageAsset(),
              top: new jsb.ImageAsset(),
              bottom: new jsb.ImageAsset()
            };
            const mipmap = data.mipmaps[i];
            const imageAssetClassId = getClassId(jsb.ImageAsset);
            handle.result.push(this._mipmaps[i], `front`, mipmap.front, imageAssetClassId);
            handle.result.push(this._mipmaps[i], `back`, mipmap.back, imageAssetClassId);
            handle.result.push(this._mipmaps[i], `left`, mipmap.left, imageAssetClassId);
            handle.result.push(this._mipmaps[i], `right`, mipmap.right, imageAssetClassId);
            handle.result.push(this._mipmaps[i], `top`, mipmap.top, imageAssetClassId);
            handle.result.push(this._mipmaps[i], `bottom`, mipmap.bottom, imageAssetClassId);
          }
        }
      };
      legacyCC.TextureCube = jsb.TextureCube;
      patch_cc_TextureCube({
        TextureCube,
        MipmapMode
      });

      let ModelType;
      (function (ModelType) {
        ModelType[ModelType["DEFAULT"] = 0] = "DEFAULT";
        ModelType[ModelType["SKINNING"] = 1] = "SKINNING";
        ModelType[ModelType["BAKED_SKINNING"] = 2] = "BAKED_SKINNING";
        ModelType[ModelType["BATCH_2D"] = 3] = "BATCH_2D";
        ModelType[ModelType["PARTICLE_BATCH"] = 4] = "PARTICLE_BATCH";
        ModelType[ModelType["LINE"] = 5] = "LINE";
      })(ModelType || (ModelType = {}));
      const Model = jsb.Model;
      const modelProto = Model.prototype;
      modelProto._ctor = function () {
        this._device = deviceManager.gfxDevice;
      };
      const oldCreateBoundingShape = modelProto.createBoundingShape;
      modelProto.createBoundingShape = function (minPos, maxPos) {
        if (!minPos || !maxPos) {
          return;
        }
        oldCreateBoundingShape.call(this, minPos, maxPos);
      };

      const SubModel = jsb.SubModel;

      let CameraFOVAxis;
      (function (CameraFOVAxis) {
        CameraFOVAxis[CameraFOVAxis["VERTICAL"] = 0] = "VERTICAL";
        CameraFOVAxis[CameraFOVAxis["HORIZONTAL"] = 1] = "HORIZONTAL";
      })(CameraFOVAxis || (CameraFOVAxis = {}));
      let CameraProjection;
      (function (CameraProjection) {
        CameraProjection[CameraProjection["ORTHO"] = 0] = "ORTHO";
        CameraProjection[CameraProjection["PERSPECTIVE"] = 1] = "PERSPECTIVE";
      })(CameraProjection || (CameraProjection = {}));
      let CameraAperture;
      (function (CameraAperture) {
        CameraAperture[CameraAperture["F1_8"] = 0] = "F1_8";
        CameraAperture[CameraAperture["F2_0"] = 1] = "F2_0";
        CameraAperture[CameraAperture["F2_2"] = 2] = "F2_2";
        CameraAperture[CameraAperture["F2_5"] = 3] = "F2_5";
        CameraAperture[CameraAperture["F2_8"] = 4] = "F2_8";
        CameraAperture[CameraAperture["F3_2"] = 5] = "F3_2";
        CameraAperture[CameraAperture["F3_5"] = 6] = "F3_5";
        CameraAperture[CameraAperture["F4_0"] = 7] = "F4_0";
        CameraAperture[CameraAperture["F4_5"] = 8] = "F4_5";
        CameraAperture[CameraAperture["F5_0"] = 9] = "F5_0";
        CameraAperture[CameraAperture["F5_6"] = 10] = "F5_6";
        CameraAperture[CameraAperture["F6_3"] = 11] = "F6_3";
        CameraAperture[CameraAperture["F7_1"] = 12] = "F7_1";
        CameraAperture[CameraAperture["F8_0"] = 13] = "F8_0";
        CameraAperture[CameraAperture["F9_0"] = 14] = "F9_0";
        CameraAperture[CameraAperture["F10_0"] = 15] = "F10_0";
        CameraAperture[CameraAperture["F11_0"] = 16] = "F11_0";
        CameraAperture[CameraAperture["F13_0"] = 17] = "F13_0";
        CameraAperture[CameraAperture["F14_0"] = 18] = "F14_0";
        CameraAperture[CameraAperture["F16_0"] = 19] = "F16_0";
        CameraAperture[CameraAperture["F18_0"] = 20] = "F18_0";
        CameraAperture[CameraAperture["F20_0"] = 21] = "F20_0";
        CameraAperture[CameraAperture["F22_0"] = 22] = "F22_0";
      })(CameraAperture || (CameraAperture = {}));
      let CameraISO;
      (function (CameraISO) {
        CameraISO[CameraISO["ISO100"] = 0] = "ISO100";
        CameraISO[CameraISO["ISO200"] = 1] = "ISO200";
        CameraISO[CameraISO["ISO400"] = 2] = "ISO400";
        CameraISO[CameraISO["ISO800"] = 3] = "ISO800";
      })(CameraISO || (CameraISO = {}));
      let CameraShutter;
      (function (CameraShutter) {
        CameraShutter[CameraShutter["D1"] = 0] = "D1";
        CameraShutter[CameraShutter["D2"] = 1] = "D2";
        CameraShutter[CameraShutter["D4"] = 2] = "D4";
        CameraShutter[CameraShutter["D8"] = 3] = "D8";
        CameraShutter[CameraShutter["D15"] = 4] = "D15";
        CameraShutter[CameraShutter["D30"] = 5] = "D30";
        CameraShutter[CameraShutter["D60"] = 6] = "D60";
        CameraShutter[CameraShutter["D125"] = 7] = "D125";
        CameraShutter[CameraShutter["D250"] = 8] = "D250";
        CameraShutter[CameraShutter["D500"] = 9] = "D500";
        CameraShutter[CameraShutter["D1000"] = 10] = "D1000";
        CameraShutter[CameraShutter["D2000"] = 11] = "D2000";
        CameraShutter[CameraShutter["D4000"] = 12] = "D4000";
      })(CameraShutter || (CameraShutter = {}));
      let CameraType;
      (function (CameraType) {
        CameraType[CameraType["DEFAULT"] = -1] = "DEFAULT";
        CameraType[CameraType["LEFT_EYE"] = 0] = "LEFT_EYE";
        CameraType[CameraType["RIGHT_EYE"] = 1] = "RIGHT_EYE";
        CameraType[CameraType["MAIN"] = 2] = "MAIN";
      })(CameraType || (CameraType = {}));
      let TrackingType;
      (function (TrackingType) {
        TrackingType[TrackingType["NO_TRACKING"] = 0] = "NO_TRACKING";
        TrackingType[TrackingType["POSITION_AND_ROTATION"] = 1] = "POSITION_AND_ROTATION";
        TrackingType[TrackingType["POSITION"] = 2] = "POSITION";
        TrackingType[TrackingType["ROTATION"] = 3] = "ROTATION";
      })(TrackingType || (TrackingType = {}));
      let CameraUsage;
      (function (CameraUsage) {
        CameraUsage[CameraUsage["EDITOR"] = 0] = "EDITOR";
        CameraUsage[CameraUsage["GAME_VIEW"] = 1] = "GAME_VIEW";
        CameraUsage[CameraUsage["SCENE_VIEW"] = 2] = "SCENE_VIEW";
        CameraUsage[CameraUsage["PREVIEW"] = 3] = "PREVIEW";
        CameraUsage[CameraUsage["GAME"] = 100] = "GAME";
      })(CameraUsage || (CameraUsage = {}));
      const SKYBOX_FLAG = ClearFlagBit.STENCIL << 1;
      const Camera$1 = jsb.Camera;
      const cameraProto = jsb.Camera.prototype;
      Object.defineProperty(Camera$1, "standardExposureValue", {
        configurable: true,
        enumerable: true,
        get() {
          return Camera$1.getStandardExposureValue();
        }
      });
      Object.defineProperty(Camera$1, "standardLightMeterScale", {
        configurable: true,
        enumerable: true,
        get() {
          return Camera$1.getStandardLightMeterScale();
        }
      });
      Object.defineProperty(cameraProto, 'matView', {
        configurable: true,
        enumerable: true,
        get() {
          this.getMatView();
          fillMat4WithTempFloatArray(this._matView);
          return this._matView;
        }
      });
      Object.defineProperty(cameraProto, 'matProj', {
        configurable: true,
        enumerable: true,
        get() {
          this.getMatProj();
          fillMat4WithTempFloatArray(this._matProj);
          return this._matProj;
        }
      });
      Object.defineProperty(cameraProto, 'matProjInv', {
        configurable: true,
        enumerable: true,
        get() {
          this.getMatProjInv();
          fillMat4WithTempFloatArray(this._matProjInv);
          return this._matProjInv;
        }
      });
      Object.defineProperty(cameraProto, 'matViewProj', {
        configurable: true,
        enumerable: true,
        get() {
          this.getMatViewProj();
          fillMat4WithTempFloatArray(this._matViewProj);
          return this._matViewProj;
        }
      });
      Object.defineProperty(cameraProto, 'matViewProjInv', {
        configurable: true,
        enumerable: true,
        get() {
          this.getMatViewProjInv();
          fillMat4WithTempFloatArray(this._matViewProjInv);
          return this._matViewProjInv;
        }
      });
      const oldInitialize = cameraProto.initialize;
      cameraProto.initialize = function initialize() {
        oldInitialize.apply(this, arguments);
        this._matView = new Mat4();
        this._matProj = new Mat4();
        this._matProjInv = new Mat4();
        this._matViewProj = new Mat4();
        this._matViewProjInv = new Mat4();
      };
      const oldScreenPointToRay = cameraProto.screenPointToRay;
      const oldScreenToWorld = cameraProto.screenToWorld;
      const oldWorldToScreen = cameraProto.worldToScreen;
      const oldWorldMatrixToScreen = cameraProto.worldMatrixToScreen;
      cameraProto.screenPointToRay = function screenPointToRay(out, x, y) {
        _tempFloatArray[0] = x;
        _tempFloatArray[1] = y;
        oldScreenPointToRay.call(this);
        out.o.x = _tempFloatArray[0];
        out.o.y = _tempFloatArray[1];
        out.o.z = _tempFloatArray[2];
        out.d.x = _tempFloatArray[3];
        out.d.y = _tempFloatArray[4];
        out.d.z = _tempFloatArray[5];
        return out;
      };
      cameraProto.screenToWorld = function screenToWorld(out, screenPos) {
        _tempFloatArray[0] = screenPos.x;
        _tempFloatArray[1] = screenPos.y;
        _tempFloatArray[2] = screenPos.z;
        oldScreenToWorld.call(this);
        Vec3.set(out, _tempFloatArray[0], _tempFloatArray[1], _tempFloatArray[2]);
        return out;
      };
      cameraProto.worldToScreen = function worldToScreen(out, worldPos) {
        _tempFloatArray[0] = worldPos.x;
        _tempFloatArray[1] = worldPos.y;
        _tempFloatArray[2] = worldPos.z;
        oldWorldToScreen.call(this);
        Vec3.set(out, _tempFloatArray[0], _tempFloatArray[1], _tempFloatArray[2]);
        return out;
      };
      cameraProto.worldMatrixToScreen = function worldMatrixToScreen(out, worldMatrix, width, height) {
        _tempFloatArray[0] = worldMatrix.m00;
        _tempFloatArray[1] = worldMatrix.m01;
        _tempFloatArray[2] = worldMatrix.m02;
        _tempFloatArray[3] = worldMatrix.m03;
        _tempFloatArray[4] = worldMatrix.m04;
        _tempFloatArray[5] = worldMatrix.m05;
        _tempFloatArray[6] = worldMatrix.m06;
        _tempFloatArray[7] = worldMatrix.m07;
        _tempFloatArray[8] = worldMatrix.m08;
        _tempFloatArray[9] = worldMatrix.m09;
        _tempFloatArray[10] = worldMatrix.m10;
        _tempFloatArray[11] = worldMatrix.m11;
        _tempFloatArray[12] = worldMatrix.m12;
        _tempFloatArray[13] = worldMatrix.m13;
        _tempFloatArray[14] = worldMatrix.m14;
        _tempFloatArray[15] = worldMatrix.m15;
        _tempFloatArray[16] = width;
        _tempFloatArray[17] = height;
        oldWorldMatrixToScreen.call(this);
        fillMat4WithTempFloatArray(out);
        return out;
      };

      let ProbeClearFlag;
      (function (ProbeClearFlag) {
        ProbeClearFlag[ProbeClearFlag["SKYBOX"] = SKYBOX_FLAG | ClearFlagBit.DEPTH_STENCIL] = "SKYBOX";
        ProbeClearFlag[ProbeClearFlag["SOLID_COLOR"] = ClearFlagBit.ALL] = "SOLID_COLOR";
      })(ProbeClearFlag || (ProbeClearFlag = {}));
      let ProbeType;
      (function (ProbeType) {
        ProbeType[ProbeType["CUBE"] = 0] = "CUBE";
        ProbeType[ProbeType["PLANAR"] = 1] = "PLANAR";
      })(ProbeType || (ProbeType = {}));
      const ReflectionProbe = jsb.ReflectionProbe;
      const reflectionProbeProto = jsb.ReflectionProbe.prototype;
      reflectionProbeProto._ctor = function (id) {
        this._probeId = id;
      };

      const LODData = jsb.LODData;
      const LODGroup = jsb.LODGroup;
      const Ambient = jsb.Ambient;
      legacyCC.Ambient = Ambient;
      Ambient.SUN_ILLUM = 65000.0;
      Ambient.SKY_ILLUM = 20000.0;
      function ColorTemperatureToRGB(rgb, kelvin) {
        if (kelvin < 1000.0) {
          kelvin = 1000.0;
        } else if (kelvin > 15000.0) {
          kelvin = 15000.0;
        }
        const kSqr = kelvin * kelvin;
        const u = (0.860117757 + 1.54118254e-4 * kelvin + 1.28641212e-7 * kSqr) / (1.0 + 8.42420235e-4 * kelvin + 7.08145163e-7 * kSqr);
        const v = (0.317398726 + 4.22806245e-5 * kelvin + 4.20481691e-8 * kSqr) / (1.0 - 2.89741816e-5 * kelvin + 1.61456053e-7 * kSqr);
        const d = 2.0 * u - 8.0 * v + 4.0;
        const x = 3.0 * u / d;
        const y = 2.0 * v / d;
        const z = 1.0 - x - y;
        const X = 1.0 / y * x;
        const Z = 1.0 / y * z;
        rgb.x = 3.2404542 * X + -1.5371385 + -0.4985314 * Z;
        rgb.y = -0.9692660 * X + 1.8760108 + 0.0415560 * Z;
        rgb.z = 0.0556434 * X + -0.2040259 + 1.0572252 * Z;
      }
      let LightType$1;
      (function (LightType) {
        LightType[LightType["DIRECTIONAL"] = 0] = "DIRECTIONAL";
        LightType[LightType["SPHERE"] = 1] = "SPHERE";
        LightType[LightType["SPOT"] = 2] = "SPOT";
        LightType[LightType["POINT"] = 3] = "POINT";
        LightType[LightType["RANGED_DIRECTIONAL"] = 4] = "RANGED_DIRECTIONAL";
        LightType[LightType["UNKNOWN"] = 5] = "UNKNOWN";
      })(LightType$1 || (LightType$1 = {}));
      const nt2lm = size => 4 * Math.PI * Math.PI * size * size;
      const Light = jsb.Light;
      legacyCC.Light = jsb.Light;
      const DirectionalLight = jsb.DirectionalLight;
      legacyCC.DirectionalLight = jsb.DirectionalLight;
      const SpotLight = jsb.SpotLight;
      legacyCC.SpotLight = jsb.SpotLight;
      const SphereLight = jsb.SphereLight;
      legacyCC.SphereLight = jsb.SphereLight;
      const PointLight = jsb.PointLight;
      legacyCC.PointLight = jsb.PointLight;
      const RangedDirectionalLight = jsb.RangedDirectionalLight;
      legacyCC.RangedDirectionalLight = jsb.RangedDirectionalLight;
      const FogType$1 = Enum({
        LINEAR: 0,
        EXP: 1,
        EXP_SQUARED: 2,
        LAYERED: 3
      });
      const FOG_TYPE_NONE = FogType$1.LAYERED + 1;
      const FogInfo$1 = jsb.FogInfo;
      const Fog = jsb.Fog;
      legacyCC.Fog = Fog;
      const ShadowSize$1 = Enum({
        Low_256x256: 256,
        Medium_512x512: 512,
        High_1024x1024: 1024,
        Ultra_2048x2048: 2048
      });
      const ShadowType$2 = Enum({
        Planar: 0,
        ShadowMap: 1
      });
      const PCFType = Enum({
        HARD: 0,
        SOFT: 1,
        SOFT_2X: 2,
        SOFT_4X: 3
      });
      const CSMLevel$1 = Enum({
        LEVEL_1: 1,
        LEVEL_2: 2,
        LEVEL_3: 3,
        LEVEL_4: 4
      });
      const CSMOptimizationMode = Enum({
        NONE: 1,
        RemoveDuplicates: 2,
        DisableRotationFix: 3
      });
      const EnvironmentLightingType = Enum({
        HEMISPHERE_DIFFUSE: 0,
        AUTOGEN_HEMISPHERE_DIFFUSE_WITH_REFLECTION: 1,
        DIFFUSEMAP_WITH_REFLECTION: 2
      });
      const ToneMappingType = Enum({
        DEFAULT: 0,
        LINEAR: 1
      });
      const ShadowsInfo$1 = jsb.ShadowsInfo;
      const Shadows$1 = jsb.Shadows;
      legacyCC.Shadows = Shadows$1;
      Object.defineProperty(Shadows$1, "MAX_FAR", {
        configurable: true,
        enumerable: true,
        get() {
          return 2000.0;
        }
      });
      const COEFFICIENT_OF_EXPANSION = 2.0 * Math.sqrt(3.0);
      Object.defineProperty(Shadows$1, 'COEFFICIENT_OF_EXPANSION', {
        configurable: true,
        enumerable: true,
        get() {
          return COEFFICIENT_OF_EXPANSION;
        }
      });
      const Skybox = jsb.Skybox;
      legacyCC.Skybox = Skybox;
      const PostSettings = jsb.PostSettings;
      legacyCC.PostSettings = PostSettings;

      var index = /*#__PURE__*/Object.freeze({
        __proto__: null,
        get ModelType () { return ModelType; },
        Model: Model,
        SubModel: SubModel,
        get CameraFOVAxis () { return CameraFOVAxis; },
        get CameraProjection () { return CameraProjection; },
        get CameraAperture () { return CameraAperture; },
        get CameraISO () { return CameraISO; },
        get CameraShutter () { return CameraShutter; },
        get CameraType () { return CameraType; },
        get TrackingType () { return TrackingType; },
        get CameraUsage () { return CameraUsage; },
        SKYBOX_FLAG: SKYBOX_FLAG,
        Camera: Camera$1,
        get ProbeClearFlag () { return ProbeClearFlag; },
        get ProbeType () { return ProbeType; },
        ReflectionProbe: ReflectionProbe,
        LODData: LODData,
        LODGroup: LODGroup,
        Ambient: Ambient,
        ColorTemperatureToRGB: ColorTemperatureToRGB,
        get LightType () { return LightType$1; },
        nt2lm: nt2lm,
        Light: Light,
        DirectionalLight: DirectionalLight,
        SpotLight: SpotLight,
        SphereLight: SphereLight,
        PointLight: PointLight,
        RangedDirectionalLight: RangedDirectionalLight,
        FogType: FogType$1,
        FOG_TYPE_NONE: FOG_TYPE_NONE,
        FogInfo: FogInfo$1,
        Fog: Fog,
        ShadowSize: ShadowSize$1,
        ShadowType: ShadowType$2,
        PCFType: PCFType,
        CSMLevel: CSMLevel$1,
        CSMOptimizationMode: CSMOptimizationMode,
        EnvironmentLightingType: EnvironmentLightingType,
        ToneMappingType: ToneMappingType,
        ShadowsInfo: ShadowsInfo$1,
        Shadows: Shadows$1,
        Skybox: Skybox,
        PostSettings: PostSettings
      });

      const EffectAsset = exports('EffectAsset', jsb.EffectAsset);
      legacyCC.EffectAsset = EffectAsset;
      const effectAssetProto = EffectAsset.prototype;
      effectAssetProto._ctor = function () {
        jsb.Asset.prototype._ctor.apply(this, arguments);
        this.hideInEditor = false;
      };
      patch_cc_EffectAsset({
        EffectAsset
      });

      const matProto = jsb.Material.prototype;
      function wrapSetProperty(cb, target, name, val, passIdx) {
        if (passIdx != undefined) {
          cb.call(target, name, val, passIdx);
        } else {
          cb.call(target, name, val);
        }
      }
      var MathType;
      (function (MathType) {
        MathType[MathType["VEC2"] = 0] = "VEC2";
        MathType[MathType["VEC3"] = 1] = "VEC3";
        MathType[MathType["VEC4"] = 2] = "VEC4";
        MathType[MathType["QUATERNION"] = 3] = "QUATERNION";
        MathType[MathType["MAT3"] = 4] = "MAT3";
        MathType[MathType["MAT4"] = 5] = "MAT4";
        MathType[MathType["SIZE"] = 6] = "SIZE";
        MathType[MathType["RECT"] = 7] = "RECT";
        MathType[MathType["COLOR"] = 8] = "COLOR";
      })(MathType || (MathType = {}));
      matProto.setProperty = function (name, val, passIdx) {
        if (Array.isArray(val)) {
          const first = val[0];
          if (typeof first === 'number') {
            if (Number.isInteger(first)) {
              wrapSetProperty(this.setPropertyInt32Array, this, name, val, passIdx);
            } else {
              wrapSetProperty(this.setPropertyFloat32Array, this, name, val, passIdx);
            }
          } else if (first instanceof Vec2) {
            wrapSetProperty(this.setPropertyVec2Array, this, name, val, passIdx);
          } else if (first instanceof Vec3) {
            wrapSetProperty(this.setPropertyVec3Array, this, name, val, passIdx);
          } else if (first instanceof Vec4) {
            wrapSetProperty(this.setPropertyVec4Array, this, name, val, passIdx);
          } else if (first instanceof Color$1) {
            wrapSetProperty(this.setPropertyColorArray, this, name, val, passIdx);
          } else if (first instanceof Mat3) {
            wrapSetProperty(this.setPropertyMat3Array, this, name, val, passIdx);
          } else if (first instanceof Mat4) {
            wrapSetProperty(this.setPropertyMat4Array, this, name, val, passIdx);
          } else if (first instanceof Quat) {
            wrapSetProperty(this.setPropertyQuatArray, this, name, val, passIdx);
          } else if (first instanceof TextureBase) {
            wrapSetProperty(this.setPropertyTextureBaseArray, this, name, val, passIdx);
          } else if (first instanceof Texture) {
            wrapSetProperty(this.setPropertyGFXTextureArray, this, name, val, passIdx);
          } else {
            legacyCC.error(`Material.setProperty Unknown type: ${val}`);
          }
        } else if (typeof val === 'number') {
          if (Number.isInteger(val)) {
            wrapSetProperty(this.setPropertyInt32, this, name, val, passIdx);
          } else {
            wrapSetProperty(this.setPropertyFloat32, this, name, val, passIdx);
          }
        } else if (val instanceof Vec2) {
          wrapSetProperty(this.setPropertyVec2, this, name, val, passIdx);
        } else if (val instanceof Vec3) {
          wrapSetProperty(this.setPropertyVec3, this, name, val, passIdx);
        } else if (val instanceof Vec4) {
          wrapSetProperty(this.setPropertyVec4, this, name, val, passIdx);
        } else if (val instanceof Color$1) {
          wrapSetProperty(this.setPropertyColor, this, name, val, passIdx);
        } else if (val instanceof Mat3) {
          wrapSetProperty(this.setPropertyMat3, this, name, val, passIdx);
        } else if (val instanceof Mat4) {
          wrapSetProperty(this.setPropertyMat4, this, name, val, passIdx);
        } else if (val instanceof Quat) {
          wrapSetProperty(this.setPropertyQuat, this, name, val, passIdx);
        } else if (val instanceof TextureBase) {
          wrapSetProperty(this.setPropertyTextureBase, this, name, val, passIdx);
        } else if (val instanceof Texture) {
          wrapSetProperty(this.setPropertyGFXTexture, this, name, val, passIdx);
        } else if (val === null) {
          if (passIdx) {
            this.setPropertyNull(name, passIdx);
          } else {
            this.setPropertyNull(name);
          }
        } else {
          legacyCC.error(`Material.setProperty Unknown type: ${val}`);
        }
      };
      matProto.getProperty = function (name, passIdx) {
        let val;
        if (passIdx !== undefined) {
          val = this._getProperty(name, passIdx);
        } else {
          val = this._getProperty(name);
        }
        if (Array.isArray(val)) {
          const first = val[0];
          const arr = [];
          if (first instanceof jsb.Vec2 || first.type === MathType.VEC2) {
            for (let i = 0, len = val.length; i < len; ++i) {
              const e = val[i];
              arr.push(new Vec2(e.x, e.y));
            }
          } else if (first.type === MathType.VEC3) {
            for (let i = 0, len = val.length; i < len; ++i) {
              const e = val[i];
              arr.push(new Vec3(e.x, e.y, e.z));
            }
          } else if (first.type === MathType.VEC4) {
            for (let i = 0, len = val.length; i < len; ++i) {
              const e = val[i];
              arr.push(new Vec4(e.x, e.y, e.z, e.w));
            }
          } else if (first instanceof jsb.Color) {
            for (let i = 0, len = val.length; i < len; ++i) {
              const e = val[i];
              arr.push(new Color$1(e.r, e.g, e.b, e.a));
            }
          } else if (first.type === MathType.MAT3) {
            for (let i = 0, len = val.length; i < len; ++i) {
              const e = val[i];
              arr.push(new Mat3(e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8]));
            }
          } else if (first.type === MathType.MAT4) {
            for (let i = 0, len = val.length; i < len; ++i) {
              const e = val[i];
              arr.push(new Mat4(e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8], e[9], e[10], e[11], e[12], e[13], e[14], e[15]));
            }
          } else if (first.type === MathType.QUATERNION) {
            for (let i = 0, len = val.length; i < len; ++i) {
              const e = val[i];
              arr.push(new Quat(e.x, e.y, e.z, e.w));
            }
          }
          return arr || val;
        } else if (val === null || val === undefined) {
          return null;
        }
        let ret;
        const e = val;
        if (val instanceof jsb.Vec2 || val.type === MathType.VEC2) {
          ret = new Vec3(e.x, e.y);
        } else if (val.type === MathType.VEC3) {
          ret = new Vec3(e.x, e.y, e.z);
        } else if (val.type === MathType.VEC4) {
          ret = new Vec4(e.x, e.y, e.z, e.w);
        } else if (val instanceof jsb.Color) {
          ret = new Color$1(e.r, e.g, e.b, e.a);
        } else if (val.type === MathType.MAT3) {
          ret = new Mat3(e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8]);
        } else if (val.type === MathType.MAT4) {
          ret = new Mat4(e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8], e[9], e[10], e[11], e[12], e[13], e[14], e[15]);
        } else if (val.type === MathType.QUATERNION) {
          ret = new Quat(e.x, e.y, e.z, e.w);
        }
        return ret || val;
      };
      const Material = exports('Material', jsb.Material);
      legacyCC.Material = Material;
      const materialProto = Material.prototype;
      materialProto._ctor = function () {
        jsb.Asset.prototype._ctor.apply(this, arguments);
        this._props = [];
        this._passes = [];
        this._registerPassesUpdatedListener();
        this._isCtorCalled = true;
      };
      const oldOnLoaded = materialProto.onLoaded;
      materialProto.onLoaded = function () {
        this._propsInternal = this._props;
        oldOnLoaded.call(this);
      };
      materialProto._onPassesUpdated = function () {
        this._passes = this.getPasses();
      };
      Object.defineProperty(materialProto, 'passes', {
        enumerable: true,
        configurable: true,
        get() {
          if (!this._isCtorCalled) {
            this._ctor();
            this._passes = this.getPasses();
          }
          return this._passes;
        }
      });
      patch_cc_Material({
        Material,
        EffectAsset
      });

      const DEFAULT_WORLD_MIN_POS = exports('DEFAULT_WORLD_MIN_POS', new Vec3(-1024.0, -1024.0, -1024.0));
      const DEFAULT_WORLD_MAX_POS = exports('DEFAULT_WORLD_MAX_POS', new Vec3(1024.0, 1024.0, 1024.0));
      const DEFAULT_OCTREE_DEPTH = exports('DEFAULT_OCTREE_DEPTH', 8);
      const FogType = exports('FogType', Enum({
        LINEAR: 0,
        EXP: 1,
        EXP_SQUARED: 2,
        LAYERED: 3
      }));
      const ShadowSize = exports('ShadowSize', Enum({
        Low_256x256: 256,
        Medium_512x512: 512,
        High_1024x1024: 1024,
        Ultra_2048x2048: 2048
      }));
      const ShadowType$1 = exports('ShadowType', Enum({
        Planar: 0,
        ShadowMap: 1
      }));
      const AmbientInfo = exports('AmbientInfo', jsb.AmbientInfo);
      legacyCC.AmbientInfo = AmbientInfo;
      const SkyboxInfo = exports('SkyboxInfo', jsb.SkyboxInfo);
      legacyCC.SkyboxInfo = SkyboxInfo;
      const FogInfo = exports('FogInfo', jsb.FogInfo);
      legacyCC.FogInfo = FogInfo;
      FogInfo.FogType = FogType;
      const ShadowsInfo = exports('ShadowsInfo', jsb.ShadowsInfo);
      legacyCC.ShadowsInfo = ShadowsInfo;
      const OctreeInfo = exports('OctreeInfo', jsb.OctreeInfo);
      legacyCC.OctreeInfo = OctreeInfo;
      const LightProbeInfo = exports('LightProbeInfo', jsb.LightProbeInfo);
      const SceneGlobals = exports('SceneGlobals', jsb.SceneGlobals);
      legacyCC.SceneGlobals = SceneGlobals;
      const SkinInfo = exports('SkinInfo', jsb.SkinInfo);
      legacyCC.SkinInfo = SkinInfo;
      const PostSettingsInfo = exports('PostSettingsInfo', jsb.PostSettingsInfo);
      legacyCC.PostSettingsInfo = PostSettingsInfo;
      (function () {
        const sceneGlobalsProto = SceneGlobals.prototype;
        sceneGlobalsProto._ctor = function () {
          this._ambientRef = this.getAmbientInfo();
          this._shadowsRef = this.getShadowsInfo();
          this._skyboxRef = this.getSkyboxInfo();
          this._fogRef = this.getFogInfo();
          this._octreeRef = this.getOctreeInfo();
          this._lightProbeRef = this.getLightProbeInfo();
          this._skinRef = this.getSkinInfo();
          this._postSettingsRef = this.getPostSettingsInfo();
        };
        Object.defineProperty(sceneGlobalsProto, 'ambient', {
          enumerable: true,
          configurable: true,
          get() {
            return this._ambientRef;
          },
          set(v) {
            this._ambientRef = v;
            this.setAmbientInfo(v);
          }
        });
        Object.defineProperty(sceneGlobalsProto, 'shadows', {
          enumerable: true,
          configurable: true,
          get() {
            return this._shadowsRef;
          },
          set(v) {
            this._shadowsRef = v;
            this.setShadowsInfo(v);
          }
        });
        Object.defineProperty(sceneGlobalsProto, '_skybox', {
          enumerable: true,
          configurable: true,
          get() {
            return this._skyboxRef;
          },
          set(v) {
            this._skyboxRef = v;
            this.setSkyboxInfo(v);
          }
        });
        Object.defineProperty(sceneGlobalsProto, 'skybox', {
          enumerable: true,
          configurable: true,
          get() {
            return this._skyboxRef;
          },
          set(v) {
            this._skyboxRef = v;
            this.setSkyboxInfo(v);
          }
        });
        Object.defineProperty(sceneGlobalsProto, 'fog', {
          enumerable: true,
          configurable: true,
          get() {
            return this._fogRef;
          },
          set(v) {
            this._fogRef = v;
            this.setFogInfo(v);
          }
        });
        Object.defineProperty(sceneGlobalsProto, 'octree', {
          enumerable: true,
          configurable: true,
          get() {
            return this._octreeRef;
          },
          set(v) {
            this._octreeRef = v;
            this.setOctreeInfo(v);
          }
        });
        Object.defineProperty(sceneGlobalsProto, 'lightProbeInfo', {
          enumerable: true,
          configurable: true,
          get() {
            return this._lightProbeRef;
          },
          set(v) {
            this._lightProbeRef = v;
            this.setLightProbeInfo(v);
          }
        });
        Object.defineProperty(sceneGlobalsProto, 'skin', {
          enumerable: true,
          configurable: true,
          get() {
            return this._skinRef;
          },
          set(v) {
            this._skinRef = v;
            this.setSkinInfo(v);
          }
        });
        Object.defineProperty(sceneGlobalsProto, 'postSettings', {
          enumerable: true,
          configurable: true,
          get() {
            return this._postSettingsRef;
          },
          set(v) {
            this._postSettingsRef = v;
            this.setPostSettingsInfo(v);
          }
        });
      })();
      patch_cc_SceneGlobals({
        SceneGlobals,
        AmbientInfo,
        SkyboxInfo,
        FogInfo,
        ShadowsInfo,
        LightProbeInfo,
        OctreeInfo,
        SkinInfo,
        PostSettingsInfo
      });
      patch_cc_OctreeInfo({
        OctreeInfo,
        CCInteger,
        Vec3,
        DEFAULT_WORLD_MAX_POS,
        DEFAULT_WORLD_MIN_POS,
        DEFAULT_OCTREE_DEPTH
      });
      patch_cc_ShadowsInfo({
        ShadowsInfo,
        ShadowType: ShadowType$1,
        CCFloat,
        CCInteger,
        ShadowSize,
        Vec3,
        Color: Color$1,
        Vec2
      });
      patch_cc_FogInfo({
        FogInfo,
        FogType,
        CCFloat,
        Color: Color$1
      });
      patch_cc_SkyboxInfo({
        SkyboxInfo,
        EnvironmentLightingType,
        TextureCube,
        CCFloat,
        Material
      });
      patch_cc_AmbientInfo({
        AmbientInfo,
        Vec4,
        Ambient,
        CCFloat,
        legacyCC
      });
      patch_cc_LightProbeInfo({
        LightProbeInfo,
        CCFloat,
        CCInteger
      });
      patch_cc_SkinInfo({
        SkinInfo,
        CCFloat
      });
      patch_cc_PostSettingsInfo({
        PostSettingsInfo,
        ToneMappingType
      });

      var _dec$T, _class$R;
      replaceProperty(Node$1.prototype, 'Node', [{
        name: 'childrenCount',
        newName: 'children.length',
        customGetter() {
          return this.children.length;
        }
      }]);
      replaceProperty(Node$1.prototype, 'Node', [{
        name: 'width',
        targetName: 'node.getComponent(UITransform)',
        customGetter() {
          return this._uiProps.uiTransformComp.width;
        },
        customSetter(value) {
          this._uiProps.uiTransformComp.width = value;
        }
      }, {
        name: 'height',
        targetName: 'node.getComponent(UITransform)',
        customGetter() {
          return this._uiProps.uiTransformComp.height;
        },
        customSetter(value) {
          this._uiProps.uiTransformComp.height = value;
        }
      }, {
        name: 'anchorX',
        targetName: 'node.getComponent(UITransform)',
        customGetter() {
          return this._uiProps.uiTransformComp.anchorX;
        },
        customSetter(value) {
          this._uiProps.uiTransformComp.anchorX = value;
        }
      }, {
        name: 'anchorY',
        targetName: 'node.getComponent(UITransform)',
        customGetter() {
          return this._uiProps.uiTransformComp.anchorY;
        },
        customSetter(value) {
          this._uiProps.uiTransformComp.anchorY = value;
        }
      }, {
        name: 'getAnchorPoint',
        targetName: 'node.getComponent(UITransform)',
        customFunction(out) {
          if (!out) {
            out = new Vec2();
          }
          out.set(this._uiProps.uiTransformComp.anchorPoint);
          return out;
        }
      }, {
        name: 'setAnchorPoint',
        targetName: 'node.getComponent(UITransform)',
        customFunction(point, y) {
          this._uiProps.uiTransformComp.setAnchorPoint(point, y);
        }
      }, {
        name: 'getContentSize',
        targetName: 'node.getComponent(UITransform)',
        customFunction(out) {
          if (!out) {
            out = new Size$1();
          }
          out.set(this._uiProps.uiTransformComp.contentSize);
          return out;
        }
      }, {
        name: 'setContentSize',
        targetName: 'node.getComponent(UITransform)',
        customFunction(size, height) {
          if (typeof size === 'number') {
            this._uiProps.uiTransformComp.setContentSize(size, height);
          } else {
            this._uiProps.uiTransformComp.setContentSize(size);
          }
        }
      }]);
      removeProperty(SceneGlobals.prototype, 'SceneGlobals.prototype', [{
        name: 'aspect'
      }, {
        name: 'selfShadow'
      }, {
        name: 'linear'
      }, {
        name: 'packing'
      }, {
        name: 'autoAdapt'
      }, {
        name: 'fixedArea'
      }, {
        name: 'pcf'
      }, {
        name: 'bias'
      }, {
        name: 'normalBias'
      }, {
        name: 'near'
      }, {
        name: 'far'
      }, {
        name: 'shadowDistance'
      }, {
        name: 'invisibleOcclusionRange'
      }, {
        name: 'orthoSize'
      }, {
        name: 'saturation'
      }]);
      replaceProperty(SceneGlobals.prototype, 'SceneGlobals.prototype', [{
        name: 'distance',
        newName: 'planeHeight'
      }, {
        name: 'normal',
        newName: 'planeDirection'
      }, {
        name: 'size',
        newName: 'shadowMapSize'
      }]);
      removeProperty(Node$1.prototype, 'Node.prototype', [{
        name: 'addLayer'
      }, {
        name: 'removeLayer'
      }]);
      replaceProperty(NodeUIProperties.prototype, 'NodeUIProperties', [{
        name: 'opacityDirty',
        newName: 'colorDirty'
      }]);
      removeProperty(Layers, 'Layers', [{
        name: 'All'
      }, {
        name: 'RaycastMask'
      }, {
        name: 'check'
      }]);
      replaceProperty(Layers, 'Layers', [{
        name: 'Default',
        newName: 'DEFAULT',
        target: Layers.Enum,
        targetName: 'Layers.Enum'
      }, {
        name: 'Always',
        newName: 'ALWAYS',
        target: Layers.Enum,
        targetName: 'Layers.Enum'
      }, {
        name: 'IgnoreRaycast',
        newName: 'IGNORE_RAYCAST',
        target: Layers.Enum,
        targetName: 'Layers.Enum'
      }, {
        name: 'Gizmos',
        newName: 'GIZMOS',
        target: Layers.Enum,
        targetName: 'Layers.Enum'
      }, {
        name: 'Editor',
        newName: 'EDITOR',
        target: Layers.Enum,
        targetName: 'Layers.Enum'
      }, {
        name: 'UI',
        newName: 'UI_3D',
        target: Layers.Enum,
        targetName: 'Layers.Enum'
      }, {
        name: 'UI2D',
        newName: 'UI_2D',
        target: Layers.Enum,
        targetName: 'Layers.Enum'
      }, {
        name: 'SceneGizmo',
        newName: 'SCENE_GIZMO',
        target: Layers.Enum,
        targetName: 'Layers.Enum'
      }, {
        name: 'makeInclusiveMask',
        newName: 'makeMaskInclude',
        target: Layers,
        targetName: 'Layers'
      }, {
        name: 'makeExclusiveMask',
        newName: 'makeMaskExclude',
        target: Layers,
        targetName: 'Layers'
      }]);
      removeProperty(Layers.Enum, 'Layers.Enum', [{
        name: 'ALWAYS'
      }]);
      removeProperty(Layers.BitMask, 'Layers.BitMask', [{
        name: 'ALWAYS'
      }]);
      const HideInHierarchy = CCObject.Flags.HideInHierarchy;
      const DontSave = CCObject.Flags.DontSave;
      let PrivateNode = exports('PrivateNode', (_dec$T = ccclass$3('cc.PrivateNode'), _dec$T(_class$R = class PrivateNode extends Node$1 {
        constructor(name) {
          super(name);
          warnID(12003, this.name);
          this.hideFlags |= DontSave | HideInHierarchy;
        }
      }) || _class$R));
      replaceProperty(SystemEventType, 'SystemEventType', ['MOUSE_ENTER', 'MOUSE_LEAVE', 'TRANSFORM_CHANGED', 'SCENE_CHANGED_FOR_PERSISTS', 'SIZE_CHANGED', 'ANCHOR_CHANGED', 'COLOR_CHANGED', 'CHILD_ADDED', 'CHILD_REMOVED', 'PARENT_CHANGED', 'NODE_DESTROYED', 'LAYER_CHANGED', 'SIBLING_ORDER_CHANGED'].map(name => ({
        name,
        target: Node$1.EventType,
        targetName: 'Node.EventType'
      })));
      replaceProperty(Node$1.EventType, 'Node.EventType', [{
        name: 'DEVICEMOTION',
        target: SystemEvent.EventType,
        targetName: 'SystemEvent.EventType'
      }, {
        name: 'KEY_DOWN',
        target: SystemEvent.EventType,
        targetName: 'SystemEvent.EventType'
      }, {
        name: 'KEY_UP',
        target: SystemEvent.EventType,
        targetName: 'SystemEvent.EventType'
      }]);
      legacyCC.PrivateNode = PrivateNode;

      deprecateModuleExportedName({
        BaseNode: {
          newName: 'Node',
          since: '3.7.0',
          removed: false
        }
      });

      var _dec$S, _dec2$E, _class$Q, _class2$L, _initializer$H, _dec3$v, _dec4$k, _dec5$h, _dec6$b, _dec7$9, _dec8$6, _class4$1, _class5$1, _initializer2$x, _initializer3$r, _initializer4$n, _initializer5$i, _initializer6$e, _dec9$5, _class7, _class8, _initializer7$b, _dec10$3, _dec11$1, _dec12$1, _class10, _class11, _initializer8$b, _initializer9$b, _initializer10$b, _dec13$1, _dec14, _dec15, _class13, _class14, _initializer11$a, _initializer12$9, _dec16, _dec17, _dec18, _class16, _class17, _initializer13$8, _initializer14$7, _dec19, _dec20, _dec21, _dec22, _dec23, _dec24, _class19, _class20, _initializer15$5, _initializer16$5, _initializer17$4, _initializer18$3, _initializer19$2, _initializer20$2, _dec25, _dec26, _dec27, _dec28, _class22, _class23, _initializer21$2, _initializer22$2, _initializer23$1, _initializer24$1, _initializer25$1, _initializer26$1;
      let TargetInfo = (_dec$S = ccclass$3('cc.TargetInfo'), _dec2$E = type$2([CCString]), _dec$S(_class$Q = (_class2$L = class TargetInfo {
        constructor() {
          this.localID = _initializer$H && _initializer$H();
        }
      }, (_initializer$H = applyDecoratedInitializer(_class2$L.prototype, "localID", [serializable$3, _dec2$E], function () {
        return [];
      })), _class2$L)) || _class$Q);
      let TargetOverrideInfo = (_dec3$v = ccclass$3('cc.TargetOverrideInfo'), _dec4$k = type$2(CCObject), _dec5$h = type$2(TargetInfo), _dec6$b = type$2([CCString]), _dec7$9 = type$2(Node$1), _dec8$6 = type$2(TargetInfo), _dec3$v(_class4$1 = (_class5$1 = class TargetOverrideInfo {
        constructor() {
          this.source = _initializer2$x && _initializer2$x();
          this.sourceInfo = _initializer3$r && _initializer3$r();
          this.propertyPath = _initializer4$n && _initializer4$n();
          this.target = _initializer5$i && _initializer5$i();
          this.targetInfo = _initializer6$e && _initializer6$e();
        }
      }, (_initializer2$x = applyDecoratedInitializer(_class5$1.prototype, "source", [serializable$3, _dec4$k], function () {
        return null;
      }), _initializer3$r = applyDecoratedInitializer(_class5$1.prototype, "sourceInfo", [serializable$3, _dec5$h], function () {
        return null;
      }), _initializer4$n = applyDecoratedInitializer(_class5$1.prototype, "propertyPath", [serializable$3, _dec6$b], function () {
        return [];
      }), _initializer5$i = applyDecoratedInitializer(_class5$1.prototype, "target", [serializable$3, _dec7$9], function () {
        return null;
      }), _initializer6$e = applyDecoratedInitializer(_class5$1.prototype, "targetInfo", [serializable$3, _dec8$6], function () {
        return null;
      })), _class5$1)) || _class4$1);
      let CompPrefabInfo = (_dec9$5 = ccclass$3('cc.CompPrefabInfo'), _dec9$5(_class7 = (_class8 = class CompPrefabInfo {
        constructor() {
          this.fileId = _initializer7$b && _initializer7$b();
        }
      }, (_initializer7$b = applyDecoratedInitializer(_class8.prototype, "fileId", [serializable$3], function () {
        return '';
      })), _class8)) || _class7);
      let PropertyOverrideInfo = (_dec10$3 = ccclass$3('CCPropertyOverrideInfo'), _dec11$1 = type$2(TargetInfo), _dec12$1 = type$2([CCString]), _dec10$3(_class10 = (_class11 = class PropertyOverrideInfo {
        constructor() {
          this.targetInfo = _initializer8$b && _initializer8$b();
          this.propertyPath = _initializer9$b && _initializer9$b();
          this.value = _initializer10$b && _initializer10$b();
        }
        isTarget(localID, propPath) {
        }
      }, (_initializer8$b = applyDecoratedInitializer(_class11.prototype, "targetInfo", [serializable$3, _dec11$1], function () {
        return null;
      }), _initializer9$b = applyDecoratedInitializer(_class11.prototype, "propertyPath", [serializable$3, _dec12$1], function () {
        return [];
      }), _initializer10$b = applyDecoratedInitializer(_class11.prototype, "value", [serializable$3], null)), _class11)) || _class10);
      let MountedChildrenInfo = (_dec13$1 = ccclass$3('cc.MountedChildrenInfo'), _dec14 = type$2(TargetInfo), _dec15 = type$2([Node$1]), _dec13$1(_class13 = (_class14 = class MountedChildrenInfo {
        constructor() {
          this.targetInfo = _initializer11$a && _initializer11$a();
          this.nodes = _initializer12$9 && _initializer12$9();
        }
        isTarget(localID) {
        }
      }, (_initializer11$a = applyDecoratedInitializer(_class14.prototype, "targetInfo", [serializable$3, _dec14], function () {
        return null;
      }), _initializer12$9 = applyDecoratedInitializer(_class14.prototype, "nodes", [serializable$3, _dec15], function () {
        return [];
      })), _class14)) || _class13);
      let MountedComponentsInfo = (_dec16 = ccclass$3('cc.MountedComponentsInfo'), _dec17 = type$2(TargetInfo), _dec18 = type$2([Component]), _dec16(_class16 = (_class17 = class MountedComponentsInfo {
        constructor() {
          this.targetInfo = _initializer13$8 && _initializer13$8();
          this.components = _initializer14$7 && _initializer14$7();
        }
        isTarget(localID) {
        }
      }, (_initializer13$8 = applyDecoratedInitializer(_class17.prototype, "targetInfo", [serializable$3, _dec17], function () {
        return null;
      }), _initializer14$7 = applyDecoratedInitializer(_class17.prototype, "components", [serializable$3, _dec18], function () {
        return [];
      })), _class17)) || _class16);
      let PrefabInstance = (_dec19 = ccclass$3('cc.PrefabInstance'), _dec20 = type$2(Node$1), _dec21 = type$2([MountedChildrenInfo]), _dec22 = type$2([MountedComponentsInfo]), _dec23 = type$2([PropertyOverrideInfo]), _dec24 = type$2([TargetInfo]), _dec19(_class19 = (_class20 = class PrefabInstance {
        constructor() {
          this.fileId = _initializer15$5 && _initializer15$5();
          this.prefabRootNode = _initializer16$5 && _initializer16$5();
          this.mountedChildren = _initializer17$4 && _initializer17$4();
          this.mountedComponents = _initializer18$3 && _initializer18$3();
          this.propertyOverrides = _initializer19$2 && _initializer19$2();
          this.removedComponents = _initializer20$2 && _initializer20$2();
          this.targetMap = {};
          this.expanded = false;
        }
        findPropertyOverride(localID, propPath) {
        }
        removePropertyOverride(localID, propPath) {
        }
      }, (_initializer15$5 = applyDecoratedInitializer(_class20.prototype, "fileId", [serializable$3], function () {
        return '';
      }), _initializer16$5 = applyDecoratedInitializer(_class20.prototype, "prefabRootNode", [serializable$3, _dec20], null), _initializer17$4 = applyDecoratedInitializer(_class20.prototype, "mountedChildren", [serializable$3, _dec21], function () {
        return [];
      }), _initializer18$3 = applyDecoratedInitializer(_class20.prototype, "mountedComponents", [serializable$3, _dec22], function () {
        return [];
      }), _initializer19$2 = applyDecoratedInitializer(_class20.prototype, "propertyOverrides", [serializable$3, _dec23], function () {
        return [];
      }), _initializer20$2 = applyDecoratedInitializer(_class20.prototype, "removedComponents", [serializable$3, _dec24], function () {
        return [];
      })), _class20)) || _class19);
      let PrefabInfo = (_dec25 = ccclass$3('cc.PrefabInfo'), _dec26 = type$2(Node$1), _dec27 = type$2(PrefabInstance), _dec28 = type$2([TargetOverrideInfo]), _dec25(_class22 = (_class23 = class PrefabInfo {
        constructor() {
          this.root = _initializer21$2 && _initializer21$2();
          this.asset = _initializer22$2 && _initializer22$2();
          this.fileId = _initializer23$1 && _initializer23$1();
          this.instance = _initializer24$1 && _initializer24$1();
          this.targetOverrides = _initializer25$1 && _initializer25$1();
          this.nestedPrefabInstanceRoots = _initializer26$1 && _initializer26$1();
        }
      }, (_initializer21$2 = applyDecoratedInitializer(_class23.prototype, "root", [serializable$3, _dec26], null), _initializer22$2 = applyDecoratedInitializer(_class23.prototype, "asset", [serializable$3], null), _initializer23$1 = applyDecoratedInitializer(_class23.prototype, "fileId", [serializable$3], function () {
        return '';
      }), _initializer24$1 = applyDecoratedInitializer(_class23.prototype, "instance", [serializable$3, _dec27], null), _initializer25$1 = applyDecoratedInitializer(_class23.prototype, "targetOverrides", [serializable$3, _dec28], null), _initializer26$1 = applyDecoratedInitializer(_class23.prototype, "nestedPrefabInstanceRoots", [serializable$3], null)), _class23)) || _class22);
      legacyCC._PrefabInfo = PrefabInfo;

      function createNodeWithPrefab(node) {
        const prefabInfo = node === null || node === void 0 ? void 0 : node.prefab;
        if (!prefabInfo) {
          return;
        }
        const prefabInstance = prefabInfo.instance;
        if (!prefabInstance) {
          return;
        }
        if (!prefabInfo.asset) {
          {
            errorID(3701, node.name);
          }
          prefabInfo.instance = undefined;
          return;
        }
        const _objFlags = node._objFlags;
        const _parent = node.getParent();
        const _id = node.uuid;
        node[editorExtrasTag];
        legacyCC.game._isCloning = true;
        {
          prefabInfo.asset._doInstantiate(node);
        }
        legacyCC.game._isCloning = false;
        node._objFlags = _objFlags;
        node.modifyParent(_parent);
        node.id = _id;
        if (node.prefab) {
          node.prefab.instance = prefabInfo.instance;
        }
      }
      function generateTargetMap(node, targetMap, isRoot) {
        var _node$prefab;
        if (!targetMap) {
          return;
        }
        if (!node) {
          return;
        }
        let curTargetMap = targetMap;
        const prefabInstance = (_node$prefab = node.prefab) === null || _node$prefab === void 0 ? void 0 : _node$prefab.instance;
        if (!isRoot && prefabInstance) {
          targetMap[prefabInstance.fileId] = {};
          curTargetMap = targetMap[prefabInstance.fileId];
        }
        const prefabInfo = node.prefab;
        if (prefabInfo) {
          curTargetMap[prefabInfo.fileId] = node;
        }
        const components = node.components;
        for (let i = 0; i < components.length; i++) {
          const comp = components[i];
          if (comp.__prefab) {
            curTargetMap[comp.__prefab.fileId] = comp;
          }
        }
        for (let i = 0; i < node.children.length; i++) {
          const childNode = node.children[i];
          generateTargetMap(childNode, curTargetMap, false);
        }
      }
      function getTarget(localID, targetMap) {
        if (!localID) {
          return null;
        }
        let target = null;
        let targetIter = targetMap;
        for (let i = 0; i < localID.length; i++) {
          if (!targetIter) {
            return null;
          }
          targetIter = targetIter[localID[i]];
        }
        target = targetIter;
        return target;
      }
      function applyMountedChildren(node, mountedChildren, targetMap) {
        if (!mountedChildren) {
          return;
        }
        for (let i = 0; i < mountedChildren.length; i++) {
          const childInfo = mountedChildren[i];
          if (childInfo && childInfo.targetInfo) {
            const target = getTarget(childInfo.targetInfo.localID, targetMap);
            if (!target) {
              continue;
            }
            let curTargetMap = targetMap;
            const localID = childInfo.targetInfo.localID;
            if (localID.length > 0) {
              for (let i = 0; i < localID.length - 1; i++) {
                curTargetMap = curTargetMap[localID[i]];
              }
            }
            if (childInfo.nodes) {
              for (let i = 0; i < childInfo.nodes.length; i++) {
                const childNode = childInfo.nodes[i];
                if (!childNode || target.children.includes(childNode)) {
                  continue;
                }
                target.children.push(childNode);
                childNode.modifyParent(target);
                generateTargetMap(childNode, curTargetMap, false);
                childNode.siblingIndex = target.children.length - 1;
                expandPrefabInstanceNode(childNode, true);
              }
            }
          }
        }
      }
      function applyMountedComponents(node, mountedComponents, targetMap) {
        if (!mountedComponents) {
          return;
        }
        for (let i = 0; i < mountedComponents.length; i++) {
          const componentsInfo = mountedComponents[i];
          if (componentsInfo && componentsInfo.targetInfo) {
            const target = getTarget(componentsInfo.targetInfo.localID, targetMap);
            if (!target) {
              continue;
            }
            if (componentsInfo.components) {
              for (let i = 0; i < componentsInfo.components.length; i++) {
                const comp = componentsInfo.components[i];
                if (!comp) {
                  continue;
                }
                comp.node = target;
                target.getWritableComponents().push(comp);
              }
            }
          }
        }
      }
      function applyRemovedComponents(node, removedComponents, targetMap) {
        if (!removedComponents) {
          return;
        }
        for (let i = 0; i < removedComponents.length; i++) {
          const targetInfo = removedComponents[i];
          if (targetInfo) {
            const target = getTarget(targetInfo.localID, targetMap);
            if (!target || !target.node) {
              continue;
            }
            const index = target.node.components.indexOf(target);
            if (index >= 0) {
              target.node.getWritableComponents().splice(index, 1);
            }
          }
        }
      }
      function applyPropertyOverrides(node, propertyOverrides, targetMap) {
        if (propertyOverrides.length <= 0) {
          return;
        }
        let target = null;
        for (let i = 0; i < propertyOverrides.length; i++) {
          const propOverride = propertyOverrides[i];
          if (propOverride && propOverride.targetInfo) {
            const targetInfo = propOverride.targetInfo;
            target = getTarget(targetInfo.localID, targetMap);
            if (!target) {
              continue;
            }
            let targetPropOwner = target;
            const propertyPath = propOverride.propertyPath.slice();
            if (propertyPath.length > 0) {
              const targetPropName = propertyPath.pop();
              if (!targetPropName) {
                continue;
              }
              for (let i = 0; i < propertyPath.length; i++) {
                const propName = propertyPath[i];
                targetPropOwner = targetPropOwner[propName];
                if (!targetPropOwner) {
                  break;
                }
              }
              if (!targetPropOwner) {
                continue;
              }
              if (Array.isArray(targetPropOwner)) {
                if (targetPropName === 'length') {
                  targetPropOwner[targetPropName] = propOverride.value;
                } else {
                  const index = Number.parseInt(targetPropName);
                  if (Number.isInteger(index) && index < targetPropOwner.length) {
                    targetPropOwner[targetPropName] = propOverride.value;
                  }
                }
              } else if (targetPropOwner[targetPropName] instanceof ValueType) {
                targetPropOwner[targetPropName].set(propOverride.value);
              } else {
                targetPropOwner[targetPropName] = propOverride.value;
              }
            }
          }
        }
      }
      function applyTargetOverrides(node) {
        var _node$prefab2;
        const targetOverrides = (_node$prefab2 = node.prefab) === null || _node$prefab2 === void 0 ? void 0 : _node$prefab2.targetOverrides;
        if (targetOverrides) {
          for (let i = 0; i < targetOverrides.length; i++) {
            var _targetAsNode$prefab;
            const targetOverride = targetOverrides[i];
            let source = targetOverride.source;
            const sourceInfo = targetOverride.sourceInfo;
            if (sourceInfo) {
              var _src$prefab;
              const src = targetOverride.source;
              const sourceInstance = src === null || src === void 0 ? void 0 : (_src$prefab = src.prefab) === null || _src$prefab === void 0 ? void 0 : _src$prefab.instance;
              if (sourceInstance && sourceInstance.targetMap) {
                source = getTarget(sourceInfo.localID, sourceInstance.targetMap);
              }
            }
            if (!source) {
              continue;
            }
            let target = null;
            const targetInfo = targetOverride.targetInfo;
            if (!targetInfo) {
              continue;
            }
            const targetAsNode = targetOverride.target;
            const targetInstance = targetAsNode === null || targetAsNode === void 0 ? void 0 : (_targetAsNode$prefab = targetAsNode.prefab) === null || _targetAsNode$prefab === void 0 ? void 0 : _targetAsNode$prefab.instance;
            if (!targetInstance || !targetInstance.targetMap) {
              continue;
            }
            target = getTarget(targetInfo.localID, targetInstance.targetMap);
            if (!target) {
              continue;
            }
            const propertyPath = targetOverride.propertyPath.slice();
            let targetPropOwner = source;
            if (propertyPath.length > 0) {
              const targetPropName = propertyPath.pop();
              if (!targetPropName) {
                return;
              }
              for (let i = 0; i < propertyPath.length; i++) {
                const propName = propertyPath[i];
                targetPropOwner = targetPropOwner[propName];
                if (!targetPropOwner) {
                  break;
                }
              }
              if (!targetPropOwner) {
                continue;
              }
              targetPropOwner[targetPropName] = target;
            }
          }
        }
      }
      function expandPrefabInstanceNode(node, recursively = false) {
        var _node$prefab3;
        const prefabInstance = node === null || node === void 0 ? void 0 : (_node$prefab3 = node.prefab) === null || _node$prefab3 === void 0 ? void 0 : _node$prefab3.instance;
        if (prefabInstance && !prefabInstance.expanded) {
          createNodeWithPrefab(node);
          if (recursively) {
            if (node && node.children) {
              node.children.forEach(child => {
                expandPrefabInstanceNode(child, true);
              });
            }
          }
          const targetMap = {};
          prefabInstance.targetMap = targetMap;
          generateTargetMap(node, targetMap, true);
          applyMountedChildren(node, prefabInstance.mountedChildren, targetMap);
          applyRemovedComponents(node, prefabInstance.removedComponents, targetMap);
          applyMountedComponents(node, prefabInstance.mountedComponents, targetMap);
          applyPropertyOverrides(node, prefabInstance.propertyOverrides, targetMap);
          prefabInstance.expanded = true;
        } else if (recursively) {
          if (node && node.children) {
            node.children.forEach(child => {
              expandPrefabInstanceNode(child, true);
            });
          }
        }
      }
      function expandNestedPrefabInstanceNode(node) {
        const prefabInfo = node.prefab;
        if (prefabInfo && prefabInfo.nestedPrefabInstanceRoots) {
          prefabInfo.nestedPrefabInstanceRoots.forEach(instanceNode => {
            expandPrefabInstanceNode(instanceNode);
          });
        }
      }
      function applyNodeAndComponentId(prefabInstanceNode, rootId) {
        const {
          components,
          children
        } = prefabInstanceNode;
        for (let i = 0; i < components.length; i++) {
          var _comp$__prefab$fileId, _comp$__prefab;
          const comp = components[i];
          const fileID = (_comp$__prefab$fileId = (_comp$__prefab = comp.__prefab) === null || _comp$__prefab === void 0 ? void 0 : _comp$__prefab.fileId) !== null && _comp$__prefab$fileId !== void 0 ? _comp$__prefab$fileId : '';
          comp._id = `${rootId}${fileID}`;
        }
        for (let i = 0; i < children.length; i++) {
          const child = children[i];
          const prefabInfo = child.prefab;
          const fileId = prefabInfo !== null && prefabInfo !== void 0 && prefabInfo.instance ? prefabInfo.instance.fileId : prefabInfo === null || prefabInfo === void 0 ? void 0 : prefabInfo.fileId;
          if (!fileId) continue;
          child.id = `${rootId}${fileId}`;
          if (!(prefabInfo !== null && prefabInfo !== void 0 && prefabInfo.instance)) {
            applyNodeAndComponentId(child, rootId);
          }
        }
      }

      var utils = /*#__PURE__*/Object.freeze({
        __proto__: null,
        createNodeWithPrefab: createNodeWithPrefab,
        generateTargetMap: generateTargetMap,
        getTarget: getTarget,
        applyMountedChildren: applyMountedChildren,
        applyMountedComponents: applyMountedComponents,
        applyRemovedComponents: applyRemovedComponents,
        applyPropertyOverrides: applyPropertyOverrides,
        applyTargetOverrides: applyTargetOverrides,
        expandPrefabInstanceNode: expandPrefabInstanceNode,
        expandNestedPrefabInstanceNode: expandNestedPrefabInstanceNode,
        applyNodeAndComponentId: applyNodeAndComponentId,
        TargetInfo: TargetInfo,
        TargetOverrideInfo: TargetOverrideInfo,
        CompPrefabInfo: CompPrefabInfo,
        PropertyOverrideInfo: PropertyOverrideInfo,
        MountedChildrenInfo: MountedChildrenInfo,
        MountedComponentsInfo: MountedComponentsInfo,
        PrefabInstance: PrefabInstance,
        PrefabInfo: PrefabInfo
      });

      const Scene = exports('Scene', jsb.Scene);
      legacyCC.Scene = Scene;
      const sceneProto = Scene.prototype;
      Object.defineProperty(sceneProto, '_globals', {
        enumerable: true,
        configurable: true,
        get() {
          return this.getSceneGlobals();
        },
        set(v) {
          this._globalRef = v;
          this.setSceneGlobals(v);
        }
      });
      Object.defineProperty(sceneProto, 'globals', {
        enumerable: true,
        configurable: true,
        get() {
          return this.getSceneGlobals();
        }
      });
      Object.defineProperty(sceneProto, '_renderScene', {
        enumerable: true,
        configurable: true,
        get() {
          if (!this._renderSceneInternal) {
            this._renderSceneInternal = this.getRenderScene();
          }
          return this._renderSceneInternal;
        }
      });
      Object.defineProperty(sceneProto, 'renderScene', {
        enumerable: true,
        configurable: true,
        get() {
          if (!this._renderSceneInternal) {
            this._renderSceneInternal = this.getRenderScene();
          }
          return this._renderSceneInternal;
        }
      });
      sceneProto._ctor = function () {
        Node$1.prototype._ctor.apply(this, arguments);
        this._inited = false;
        this._renderSceneInternal = null;
        this._globalRef = null;
        this._prefabSyncedInLiveReload = false;
      };
      sceneProto._onBatchCreated = function (dontSyncChildPrefab) {
        if (this._parent) {
          this._siblingIndex = this._parent.children.indexOf(this);
        }
        const children = this._children;
        const len = children.length;
        let child;
        for (let i = 0; i < len; ++i) {
          child = children[i];
          child._siblingIndex = i;
          child._onBatchCreated(dontSyncChildPrefab);
        }
      };
      const oldLoad = sceneProto._load;
      sceneProto._load = function () {
        this._scene = this;
        if (!this._inited) {
          expandNestedPrefabInstanceNode(this);
          applyTargetOverrides(this);
          this._onBatchCreated(EDITOR );
          this._inited = true;
        }
        updateChildrenForDeserialize(this);
        oldLoad.call(this);
      };
      sceneProto._activate = function (active) {
        active = active !== false;
        legacyCC.director._nodeActivator.activateNode(this, active);
        {
          this._globals.activate(this);
          if (this._renderScene) {
            this._renderScene.activate();
          }
        }
      };
      sceneProto._instantiate = function () {};
      patch_cc_Scene({
        Scene,
        SceneGlobals
      });

      function find(path, referenceNode) {
        if (!referenceNode) {
          const scene = legacyCC.director.getScene();
          if (!scene) {
            return null;
          }
          referenceNode = scene;
        }
        return referenceNode.getChildByPath(path);
      }
      legacyCC.find = find;

      const fastRemoveAt = fastRemoveAt$2;
      const IsStartCalled = CCObject.Flags.IsStartCalled;
      const IsOnEnableCalled$1 = CCObject.Flags.IsOnEnableCalled;
      CCObject.Flags.IsEditorOnEnableCalled;
      function sortedIndex(array, comp) {
        const order = comp.constructor._executionOrder;
        const id = comp._id;
        let l = 0;
        for (let h = array.length - 1, m = h >>> 1; l <= h; m = l + h >>> 1) {
          const test = array[m];
          const testOrder = test.constructor._executionOrder;
          if (testOrder > order) {
            h = m - 1;
          } else if (testOrder < order) {
            l = m + 1;
          } else {
            const testId = test._id;
            if (testId > id) {
              h = m - 1;
            } else if (testId < id) {
              l = m + 1;
            } else {
              return m;
            }
          }
        }
        return ~l;
      }
      function stableRemoveInactive(iterator, flagToClear) {
        const array = iterator.array;
        let next = iterator.i + 1;
        while (next < array.length) {
          const comp = array[next];
          if (comp.node._activeInHierarchy) {
            ++next;
          } else {
            iterator.removeAt(next);
            if (flagToClear) {
              comp._objFlags &= ~flagToClear;
            }
          }
        }
      }
      class LifeCycleInvoker {
        get zero() {
          return this._zero;
        }
        get neg() {
          return this._neg;
        }
        get pos() {
          return this._pos;
        }
        constructor(invokeFunc) {
          this._zero = void 0;
          this._neg = void 0;
          this._pos = void 0;
          this._invoke = void 0;
          const Iterator = MutableForwardIterator;
          this._zero = new Iterator([]);
          this._neg = new Iterator([]);
          this._pos = new Iterator([]);
          this._invoke = invokeFunc;
        }
      }
      LifeCycleInvoker.stableRemoveInactive = stableRemoveInactive;
      function compareOrder(a, b) {
        return a.constructor._executionOrder - b.constructor._executionOrder;
      }
      class OneOffInvoker extends LifeCycleInvoker {
        add(comp) {
          const order = comp.constructor._executionOrder;
          (order === 0 ? this._zero : order < 0 ? this._neg : this._pos).array.push(comp);
        }
        remove(comp) {
          const order = comp.constructor._executionOrder;
          (order === 0 ? this._zero : order < 0 ? this._neg : this._pos).fastRemove(comp);
        }
        cancelInactive(flagToClear) {
          stableRemoveInactive(this._zero, flagToClear);
          stableRemoveInactive(this._neg, flagToClear);
          stableRemoveInactive(this._pos, flagToClear);
        }
        invoke() {
          const compsNeg = this._neg;
          if (compsNeg.array.length > 0) {
            compsNeg.array.sort(compareOrder);
            this._invoke(compsNeg);
            compsNeg.array.length = 0;
          }
          this._invoke(this._zero);
          this._zero.array.length = 0;
          const compsPos = this._pos;
          if (compsPos.array.length > 0) {
            compsPos.array.sort(compareOrder);
            this._invoke(compsPos);
            compsPos.array.length = 0;
          }
        }
      }
      class ReusableInvoker extends LifeCycleInvoker {
        add(comp) {
          const order = comp.constructor._executionOrder;
          if (order === 0) {
            this._zero.array.push(comp);
          } else {
            const array = order < 0 ? this._neg.array : this._pos.array;
            const i = sortedIndex(array, comp);
            if (i < 0) {
              array.splice(~i, 0, comp);
            }
          }
        }
        remove(comp) {
          const order = comp.constructor._executionOrder;
          if (order === 0) {
            this._zero.fastRemove(comp);
          } else {
            const iterator = order < 0 ? this._neg : this._pos;
            const i = sortedIndex(iterator.array, comp);
            if (i >= 0) {
              iterator.removeAt(i);
            }
          }
        }
        invoke(dt) {
          if (this._neg.array.length > 0) {
            this._invoke(this._neg, dt);
          }
          this._invoke(this._zero, dt);
          if (this._pos.array.length > 0) {
            this._invoke(this._pos, dt);
          }
        }
      }
      function createInvokeImplJit(code, useDt, ensureFlag) {
        const body = `${'var a=it.array;' + 'for(it.i=0;it.i<a.length;++it.i){' + 'var c=a[it.i];'}${code}}`;
        const fastPath = useDt ? Function('it', 'dt', body) : Function('it', body);
        const singleInvoke = Function('c', 'dt', code);
        return createInvokeImpl(singleInvoke, fastPath, ensureFlag);
      }
      function createInvokeImpl(singleInvoke, fastPath, ensureFlag) {
        return (iterator, dt) => {
          try {
            fastPath(iterator, dt);
          } catch (e) {
            legacyCC._throw(e);
            const array = iterator.array;
            if (ensureFlag) {
              array[iterator.i]._objFlags |= ensureFlag;
            }
            ++iterator.i;
            for (; iterator.i < array.length; ++iterator.i) {
              try {
                singleInvoke(array[iterator.i], dt);
              } catch (e) {
                legacyCC._throw(e);
                if (ensureFlag) {
                  array[iterator.i]._objFlags |= ensureFlag;
                }
              }
            }
          }
        };
      }
      const invokeStart = createInvokeImplJit(`c.start();c._objFlags|=${IsStartCalled}`, false, IsStartCalled) ;
      const invokeUpdate = createInvokeImplJit('c.update(dt)', true) ;
      const invokeLateUpdate = createInvokeImplJit('c.lateUpdate(dt)', true) ;
      const invokeOnEnable = iterator => {
        const compScheduler = legacyCC.director._compScheduler;
        const array = iterator.array;
        for (iterator.i = 0; iterator.i < array.length; ++iterator.i) {
          const comp = array[iterator.i];
          if (comp._enabled) {
            comp.onEnable();
            const deactivatedDuringOnEnable = !comp.node._activeInHierarchy;
            if (!deactivatedDuringOnEnable) {
              compScheduler._onEnabled(comp);
            }
          }
        }
      };
      class ComponentScheduler {
        constructor() {
          this.startInvoker = void 0;
          this.updateInvoker = void 0;
          this.lateUpdateInvoker = void 0;
          this._deferredComps = [];
          this._updating = void 0;
          this.unscheduleAll();
        }
        unscheduleAll() {
          this.startInvoker = new OneOffInvoker(invokeStart);
          this.updateInvoker = new ReusableInvoker(invokeUpdate);
          this.lateUpdateInvoker = new ReusableInvoker(invokeLateUpdate);
          this._updating = false;
        }
        _onEnabled(comp) {
          legacyCC.director.getScheduler().resumeTarget(comp);
          comp._objFlags |= IsOnEnableCalled$1;
          if (this._updating) {
            this._deferredComps.push(comp);
          } else {
            this._scheduleImmediate(comp);
          }
        }
        _onDisabled(comp) {
          legacyCC.director.getScheduler().pauseTarget(comp);
          comp._objFlags &= ~IsOnEnableCalled$1;
          const index = this._deferredComps.indexOf(comp);
          if (index >= 0) {
            fastRemoveAt(this._deferredComps, index);
            return;
          }
          if (comp.internalStart && !(comp._objFlags & IsStartCalled)) {
            this.startInvoker.remove(comp);
          }
          if (comp.internalUpdate) {
            this.updateInvoker.remove(comp);
          }
          if (comp.internalLateUpdate) {
            this.lateUpdateInvoker.remove(comp);
          }
        }
        enableComp(comp, invoker) {
          if (!(comp._objFlags & IsOnEnableCalled$1)) {
            if (comp.internalOnEnable) {
              if (invoker) {
                invoker.add(comp);
                return;
              } else {
                comp.internalOnEnable();
                const deactivatedDuringOnEnable = !comp.node.activeInHierarchy;
                if (deactivatedDuringOnEnable) {
                  return;
                }
              }
            }
            this._onEnabled(comp);
          }
        }
        disableComp(comp) {
          if (comp._objFlags & IsOnEnableCalled$1) {
            if (comp.internalOnDisable) {
              comp.internalOnDisable();
            }
            this._onDisabled(comp);
          }
        }
        startPhase() {
          this._updating = true;
          this.startInvoker.invoke();
          this._startForNewComps();
        }
        updatePhase(dt) {
          this.updateInvoker.invoke(dt);
        }
        lateUpdatePhase(dt) {
          this.lateUpdateInvoker.invoke(dt);
          this._updating = false;
          this._startForNewComps();
        }
        _startForNewComps() {
          if (this._deferredComps.length > 0) {
            this._deferredSchedule();
            this.startInvoker.invoke();
          }
        }
        _scheduleImmediate(comp) {
          if (typeof comp.internalStart === 'function' && !(comp._objFlags & IsStartCalled)) {
            this.startInvoker.add(comp);
          }
          if (typeof comp.internalUpdate === 'function') {
            this.updateInvoker.add(comp);
          }
          if (typeof comp.internalLateUpdate === 'function') {
            this.lateUpdateInvoker.add(comp);
          }
        }
        _deferredSchedule() {
          const comps = this._deferredComps;
          for (let i = 0, len = comps.length; i < len; i++) {
            this._scheduleImmediate(comps[i]);
          }
          comps.length = 0;
        }
      }

      const MAX_POOL_SIZE = 4;
      const IsPreloadStarted = CCObject.Flags.IsPreloadStarted;
      const IsOnLoadStarted = CCObject.Flags.IsOnLoadStarted;
      const IsOnLoadCalled = CCObject.Flags.IsOnLoadCalled;
      const IsOnEnableCalled = CCObject.Flags.IsOnEnableCalled;
      const Deactivating = CCObject.Flags.Deactivating;
      class UnsortedInvoker extends LifeCycleInvoker {
        add(comp) {
          this._zero.array.push(comp);
        }
        remove(comp) {
          this._zero.fastRemove(comp);
        }
        cancelInactive(flagToClear) {
          LifeCycleInvoker.stableRemoveInactive(this._zero, flagToClear);
        }
        invoke() {
          this._invoke(this._zero);
          this._zero.array.length = 0;
        }
      }
      const invokePreload = createInvokeImplJit('c.__preload();') ;
      const invokeOnLoad = createInvokeImplJit(`c.onLoad();c._objFlags|=${IsOnLoadCalled}`, false, IsOnLoadCalled) ;
      const activateTasksPool = new Pool$1(MAX_POOL_SIZE);
      activateTasksPool.get = function getActivateTask() {
        const task = this._get() || {
          preload: new UnsortedInvoker(invokePreload),
          onLoad: new OneOffInvoker(invokeOnLoad),
          onEnable: new OneOffInvoker(invokeOnEnable)
        };
        task.preload.zero.i = -1;
        let invoker = task.onLoad;
        invoker.zero.i = -1;
        invoker.neg.i = -1;
        invoker.pos.i = -1;
        invoker = task.onEnable;
        invoker.zero.i = -1;
        invoker.neg.i = -1;
        invoker.pos.i = -1;
        return task;
      };
      function _componentCorrupted(node, comp, index) {
        errorID(3817, node.name, index);
        console.log('Corrupted component value:', comp);
        if (comp) {
          node._removeComponent(comp);
        } else {
          removeAt(node.getWritableComponents(), index);
        }
      }
      class NodeActivator {
        constructor() {
          this._activatingStack = void 0;
          this.reset();
        }
        reset() {
          this._activatingStack = [];
        }
        activateNode(node, active) {
          if (active) {
            const task = activateTasksPool.get();
            if (task) {
              this._activatingStack.push(task);
              this._activateNodeRecursively(node, task.preload, task.onLoad, task.onEnable);
              task.preload.invoke();
              task.onLoad.invoke();
              task.onEnable.invoke();
              this._activatingStack.pop();
              activateTasksPool.put(task);
            }
          } else {
            this._deactivateNodeRecursively(node);
            const stack = this._activatingStack;
            for (const lastTask of stack) {
              lastTask.preload.cancelInactive(IsPreloadStarted);
              lastTask.onLoad.cancelInactive(IsOnLoadStarted);
              lastTask.onEnable.cancelInactive(IsOnEnableCalled);
            }
          }
          node.emit(NodeEventType.ACTIVE_IN_HIERARCHY_CHANGED, node);
        }
        activateComp(comp, preloadInvoker, onLoadInvoker, onEnableInvoker) {
          if (!isValid(comp, true)) {
            return;
          }
          if (!(comp._objFlags & IsPreloadStarted)) {
            comp._objFlags |= IsPreloadStarted;
            if (comp.internalPreload) {
              if (preloadInvoker) {
                preloadInvoker.add(comp);
              } else {
                comp.internalPreload();
              }
            }
          }
          if (!(comp._objFlags & IsOnLoadStarted)) {
            comp._objFlags |= IsOnLoadStarted;
            if (comp.internalOnLoad) {
              if (onLoadInvoker) {
                onLoadInvoker.add(comp);
              } else {
                comp.internalOnLoad();
                comp._objFlags |= IsOnLoadCalled;
              }
            } else {
              comp._objFlags |= IsOnLoadCalled;
            }
          }
          if (comp._enabled) {
            {
              assertIsTrue(comp.node, getError(3823, comp.uuid, comp.name));
            }
            const deactivatedOnLoading = !comp.node.activeInHierarchy;
            if (deactivatedOnLoading) {
              return;
            }
            legacyCC.director._compScheduler.enableComp(comp, onEnableInvoker);
          }
        }
        destroyComp(comp) {
          legacyCC.director._compScheduler.disableComp(comp);
          if (comp.internalOnDestroy && comp._objFlags & IsOnLoadCalled) {
            comp.internalOnDestroy();
          }
        }
        _activateNodeRecursively(node, preloadInvoker, onLoadInvoker, onEnableInvoker) {
          if (node._objFlags & Deactivating) {
            errorID(3816, node.name);
            return;
          }
          node._setActiveInHierarchy(true);
          let originCount = node.components.length;
          for (let i = 0; i < originCount; ++i) {
            const component = node.components[i];
            if (component instanceof legacyCC.Component) {
              this.activateComp(component, preloadInvoker, onLoadInvoker, onEnableInvoker);
            } else {
              _componentCorrupted(node, component, i);
              --i;
              --originCount;
            }
          }
          for (let i = 0, len = node.children.length; i < len; ++i) {
            const child = node.children[i];
            if (child.active) {
              this._activateNodeRecursively(child, preloadInvoker, onLoadInvoker, onEnableInvoker);
            }
          }
          node._onPostActivated(true);
        }
        _deactivateNodeRecursively(node) {
          node._objFlags |= Deactivating;
          node._setActiveInHierarchy(false);
          const originCount = node.components.length;
          for (let c = 0; c < originCount; ++c) {
            const component = node.components[c];
            if (component._enabled) {
              legacyCC.director._compScheduler.disableComp(component);
              if (node.activeInHierarchy) {
                node._objFlags &= ~Deactivating;
                return;
              }
            }
          }
          for (let i = 0, len = node.children.length; i < len; ++i) {
            const child = node.children[i];
            if (child.activeInHierarchy) {
              this._deactivateNodeRecursively(child);
              if (node.activeInHierarchy) {
                node._objFlags &= ~Deactivating;
                return;
              }
            }
          }
          node._onPostActivated(false);
          node._objFlags &= ~Deactivating;
        }
      } exports('NodeActivator', NodeActivator);

      const Destroyed$1 = CCObject.Flags.Destroyed;
      const PersistentMask$1 = CCObject.Flags.PersistentMask;
      const DEFAULT = `${CCClass.Attr.DELIMETER}default`;
      const IDENTIFIER_RE = CCClass.IDENTIFIER_RE;
      const VAR = 'var ';
      const LOCAL_OBJ = 'o';
      const LOCAL_TEMP_OBJ = 't';
      const LOCAL_ARRAY = 'a';
      const LINE_INDEX_OF_NEW_OBJ = 0;
      const DEFAULT_MODULE_CACHE = {
        'cc.ClickEvent': false,
        'cc.PrefabInfo': false
      };
      const escapeForJS = CCClass.escapeForJS;
      class Declaration {
        constructor(varName, expression) {
          this.varName = void 0;
          this.expression = void 0;
          this.varName = varName;
          this.expression = expression;
        }
        toString() {
          return `${VAR + this.varName}=${this.expression};`;
        }
      }
      function mergeDeclaration(statement, expression) {
        if (expression instanceof Declaration) {
          return new Declaration(expression.varName, statement + expression.expression);
        } else {
          return statement + expression;
        }
      }
      function writeAssignment(codeArray, statement, expression) {
        if (Array.isArray(expression)) {
          expression[0] = mergeDeclaration(statement, expression[0]);
          codeArray.push(expression);
        } else {
          codeArray.push(`${mergeDeclaration(statement, expression)};`);
        }
      }
      class Assignments {
        constructor(targetExpression) {
          this._exps = void 0;
          this._targetExp = void 0;
          this._exps = [];
          this._targetExp = targetExpression;
        }
        append(key, expression) {
          this._exps.push([key, expression]);
        }
        writeCode(codeArray) {
          let targetVar;
          if (this._exps.length > 1) {
            codeArray.push(`${LOCAL_TEMP_OBJ}=${this._targetExp};`);
            targetVar = LOCAL_TEMP_OBJ;
          } else if (this._exps.length === 1) {
            targetVar = this._targetExp;
          } else {
            return;
          }
          for (let i = 0; i < this._exps.length; i++) {
            const pair = this._exps[i];
            writeAssignment(codeArray, `${targetVar + getPropAccessor(pair[0])}=`, pair[1]);
          }
        }
      }
      Assignments.pool = void 0;
      Assignments.pool = new Pool$1(obj => {
        obj._exps.length = 0;
        obj._targetExp = null;
      }, 1);
      Assignments.pool.get = function (targetExpression) {
        const cache = this._get() || new Assignments();
        cache._targetExp = targetExpression;
        return cache;
      };
      function getPropAccessor(key) {
        return IDENTIFIER_RE.test(key) ? `.${key}` : `[${escapeForJS(key)}]`;
      }
      class Parser$1 {
        constructor(obj, parent) {
          this.parent = void 0;
          this.objsToClear_iN$t = void 0;
          this.codeArray = void 0;
          this.objs = void 0;
          this.funcs = void 0;
          this.funcModuleCache = void 0;
          this.globalVariables = void 0;
          this.globalVariableId = void 0;
          this.localVariableId = void 0;
          this.result = void 0;
          this.parent = parent;
          this.objsToClear_iN$t = [];
          this.codeArray = [];
          this.objs = [];
          this.funcs = [];
          this.funcModuleCache = createMap();
          mixin(this.funcModuleCache, DEFAULT_MODULE_CACHE);
          this.globalVariables = [];
          this.globalVariableId = 0;
          this.localVariableId = 0;
          this.codeArray.push(`${VAR + LOCAL_OBJ},${LOCAL_TEMP_OBJ};`, 'if(R){', `${LOCAL_OBJ}=R;`, '}else{', `${LOCAL_OBJ}=R=new ${this.getFuncModule(obj.constructor, true)}();`, '}');
          obj._iN$t = {
            globalVar: 'R'
          };
          this.objsToClear_iN$t.push(obj);
          this.enumerateObject(this.codeArray, obj);
          let globalVariablesDeclaration;
          if (this.globalVariables.length > 0) {
            globalVariablesDeclaration = `${VAR + this.globalVariables.join(',')};`;
          }
          const code = flattenCodeArray(['return (function(R){', globalVariablesDeclaration || [], this.codeArray, 'return o;', '})']);
          this.result = Function('O', 'F', code)(this.objs, this.funcs);
          for (let i = 0, len = this.objsToClear_iN$t.length; i < len; ++i) {
            this.objsToClear_iN$t[i]._iN$t = null;
          }
          this.objsToClear_iN$t.length = 0;
        }
        getFuncModule(func, usedInNew) {
          const clsName = getClassName(func);
          if (clsName) {
            const cache = this.funcModuleCache[clsName];
            if (cache) {
              return cache;
            } else if (cache === undefined) {
              let clsNameIsModule = clsName.indexOf('.') !== -1;
              if (clsNameIsModule) {
                try {
                  clsNameIsModule = func === Function(`return ${clsName}`)();
                  if (clsNameIsModule) {
                    this.funcModuleCache[clsName] = clsName;
                    return clsName;
                  }
                } catch (e) {}
              }
            }
          }
          let index = this.funcs.indexOf(func);
          if (index < 0) {
            index = this.funcs.length;
            this.funcs.push(func);
          }
          let res = `F[${index}]`;
          if (usedInNew) {
            res = `(${res})`;
          }
          this.funcModuleCache[clsName] = res;
          return res;
        }
        getObjRef(obj) {
          let index = this.objs.indexOf(obj);
          if (index < 0) {
            index = this.objs.length;
            this.objs.push(obj);
          }
          return `O[${index}]`;
        }
        setValueType(codeArray, defaultValue, srcValue, targetExpression) {
          const assignments = Assignments.pool.get(targetExpression);
          let fastDefinedProps = defaultValue.constructor.__props__;
          if (!fastDefinedProps) {
            fastDefinedProps = Object.keys(defaultValue);
          }
          for (let i = 0; i < fastDefinedProps.length; i++) {
            const propName = fastDefinedProps[i];
            const prop = srcValue[propName];
            if (defaultValue[propName] === prop) {
              continue;
            }
            const expression = this.enumerateField(srcValue, propName, prop);
            assignments.append(propName, expression);
          }
          assignments.writeCode(codeArray);
          Assignments.pool.put(assignments);
        }
        enumerateCCClass(codeArray, obj, klass) {
          const props = klass.__values__;
          const attrs = CCClass.Attr.getClassAttrs(klass);
          for (let p = 0; p < props.length; p++) {
            const key = props[p];
            const val = obj[key];
            let defaultValue = attrs[key + DEFAULT];
            if (equalsToDefault(defaultValue, val)) {
              continue;
            }
            if (typeof val === 'object' && val instanceof legacyCC.ValueType) {
              defaultValue = CCClass.getDefault(defaultValue);
              if (defaultValue && defaultValue.constructor === val.constructor) {
                const targetExpression = LOCAL_OBJ + getPropAccessor(key);
                this.setValueType(codeArray, defaultValue, val, targetExpression);
                continue;
              }
            }
            this.setObjProp(codeArray, obj, key, val);
          }
        }
        instantiateArray(value) {
          if (value.length === 0) {
            return '[]';
          }
          const arrayVar = LOCAL_ARRAY + ++this.localVariableId;
          const declaration = new Declaration(arrayVar, `new Array(${value.length})`);
          const codeArray = [declaration];
          value._iN$t = {
            globalVar: '',
            source: codeArray
          };
          this.objsToClear_iN$t.push(value);
          for (let i = 0; i < value.length; ++i) {
            const statement = `${arrayVar}[${i}]=`;
            const expression = this.enumerateField(value, i, value[i]);
            writeAssignment(codeArray, statement, expression);
          }
          return codeArray;
        }
        instantiateTypedArray(value) {
          const type = value.constructor.name;
          if (value.length === 0) {
            return `new ${type}`;
          }
          const arrayVar = LOCAL_ARRAY + ++this.localVariableId;
          const declaration = new Declaration(arrayVar, `new ${type}(${value.length})`);
          const codeArray = [declaration];
          value._iN$t = {
            globalVar: '',
            source: codeArray
          };
          this.objsToClear_iN$t.push(value);
          for (let i = 0; i < value.length; ++i) {
            if (value[i] !== 0) {
              const statement = `${arrayVar}[${i}]=`;
              writeAssignment(codeArray, statement, value[i]);
            }
          }
          return codeArray;
        }
        enumerateField(obj, key, value) {
          if (typeof value === 'object' && value) {
            const _iN$t = value._iN$t;
            if (_iN$t) {
              let globalVar = _iN$t.globalVar;
              if (!globalVar) {
                globalVar = _iN$t.globalVar = `v${++this.globalVariableId}`;
                this.globalVariables.push(globalVar);
                const line = _iN$t.source[LINE_INDEX_OF_NEW_OBJ];
                _iN$t.source[LINE_INDEX_OF_NEW_OBJ] = mergeDeclaration(`${globalVar}=`, line);
              }
              return globalVar;
            } else if (ArrayBuffer.isView(value)) {
              return this.instantiateTypedArray(value);
            } else if (Array.isArray(value)) {
              return this.instantiateArray(value);
            } else {
              return this.instantiateObj(value);
            }
          } else if (typeof value === 'function') {
            return this.getFuncModule(value);
          } else if (typeof value === 'string') {
            return escapeForJS(value);
          } else {
            if (key === '_objFlags' && isCCObject(obj)) {
              value &= PersistentMask$1;
            }
            return value;
          }
        }
        setObjProp(codeArray, obj, key, value) {
          const statement = `${LOCAL_OBJ + getPropAccessor(key)}=`;
          const expression = this.enumerateField(obj, key, value);
          writeAssignment(codeArray, statement, expression);
        }
        enumerateObject(codeArray, obj) {
          const klass = obj.constructor;
          if (isCCClassOrFastDefined(klass)) {
            this.enumerateCCClass(codeArray, obj, klass);
          } else {
            for (const key in obj) {
              if (!obj.hasOwnProperty(key) || key.charCodeAt(0) === 95 && key.charCodeAt(1) === 95 && key !== '__type__') {
                continue;
              }
              const value = obj[key];
              if (typeof value === 'object' && value && value === obj._iN$t) {
                continue;
              }
              this.setObjProp(codeArray, obj, key, value);
            }
          }
        }
        instantiateObj(obj) {
          if (obj instanceof legacyCC.ValueType) {
            return CCClass.getNewValueTypeCode(obj);
          }
          if (obj instanceof legacyCC.Asset) {
            return this.getObjRef(obj);
          }
          if (obj._objFlags & Destroyed$1) {
            return null;
          }
          let createCode;
          const ctor = obj.constructor;
          if (isCCClassOrFastDefined(ctor)) {
            if (this.parent) {
              if (this.parent instanceof legacyCC.Component) {
                if (obj instanceof legacyCC.Node || obj instanceof legacyCC.Component) {
                  return this.getObjRef(obj);
                }
              } else if (this.parent instanceof legacyCC.Node) {
                if (obj instanceof legacyCC.Node) {
                  if (!obj.isChildOf(this.parent)) {
                    return this.getObjRef(obj);
                  }
                } else if (obj instanceof legacyCC.Component) {
                  var _obj$node;
                  if (!((_obj$node = obj.node) !== null && _obj$node !== void 0 && _obj$node.isChildOf(this.parent))) {
                    return this.getObjRef(obj);
                  }
                }
              }
            }
            createCode = new Declaration(LOCAL_OBJ, `new ${this.getFuncModule(ctor, true)}()`);
          } else if (ctor === Object) {
            createCode = new Declaration(LOCAL_OBJ, '{}');
          } else if (!ctor) {
            createCode = new Declaration(LOCAL_OBJ, 'Object.create(null)');
          } else {
            return this.getObjRef(obj);
          }
          const codeArray = [createCode];
          obj._iN$t = {
            globalVar: '',
            source: codeArray
          };
          this.objsToClear_iN$t.push(obj);
          this.enumerateObject(codeArray, obj);
          return ['(function(){', codeArray, 'return o;})();'];
        }
      }
      function equalsToDefault(def, value) {
        if (typeof def === 'function') {
          try {
            def = def();
          } catch (e) {
            return false;
          }
        }
        if (def === value) {
          return true;
        }
        if (def && value && typeof def === 'object' && typeof value === 'object' && def.constructor === value.constructor) {
          if (def instanceof legacyCC.ValueType) {
            if (def.equals(value)) {
              return true;
            }
          } else if (Array.isArray(def)) {
            return def.length === 0 && value.length === 0;
          } else if (def.constructor === Object) {
            return isEmptyObject(def) && isEmptyObject(value);
          }
        }
        return false;
      }
      function compile(node) {
        const root = node instanceof legacyCC.Node && node;
        const parser = new Parser$1(node, root);
        return parser.result;
      }

      var _dec$R, _class$P, _class2$K, _initializer$G, _initializer2$w, _initializer3$q, _class3$q;
      const OptimizationPolicy = Enum({
        AUTO: 0,
        SINGLE_INSTANCE: 1,
        MULTI_INSTANCE: 2
      });
      let Prefab = exports('Prefab', (_dec$R = ccclass$3('cc.Prefab'), _dec$R(_class$P = (_class2$K = (_class3$q = class Prefab extends Asset {
        constructor() {
          super();
          this.data = _initializer$G && _initializer$G();
          this.optimizationPolicy = _initializer2$w && _initializer2$w();
          this.persistent = _initializer3$q && _initializer3$q();
          this._createFunction = void 0;
          this._instantiatedTimes = void 0;
          this._createFunction = null;
          this._instantiatedTimes = 0;
        }
        createNode(cb) {
          const node = legacyCC.instantiate(this);
          node.name = this.name;
          cb(null, node);
        }
        compileCreateFunction() {
          this._createFunction = compile(this.data);
        }
        _doInstantiate(rootToRedirect) {
          if (!this.data._prefab) {
            warnID(3700);
          }
          if (!this._createFunction) {
            this.compileCreateFunction();
          }
          return this._createFunction(rootToRedirect);
        }
        _instantiate() {
          let node;
          let useJit = false;
          {
            if (this.optimizationPolicy === OptimizationPolicy.SINGLE_INSTANCE) {
              useJit = false;
            } else if (this.optimizationPolicy === OptimizationPolicy.MULTI_INSTANCE) {
              useJit = true;
            } else {
              useJit = this._instantiatedTimes + 1 >= Prefab.OptimizationPolicyThreshold;
            }
          }
          if (useJit) {
            node = this._doInstantiate();
            this.data._instantiate(node);
          } else {
            node = this.data._instantiate();
          }
          ++this._instantiatedTimes;
          return node;
        }
        initDefault(uuid) {
          super.initDefault(uuid);
          this.data = new Node$1();
          this.data.name = '(Missing Node)';
          const prefabInfo = new legacyCC._PrefabInfo();
          prefabInfo.asset = this;
          prefabInfo.root = this.data;
          this.data._prefab = prefabInfo;
        }
        validate() {
          return !!this.data;
        }
        onLoaded() {
          const rootNode = this.data;
          expandNestedPrefabInstanceNode(rootNode);
          applyTargetOverrides(rootNode);
          {
            updateChildrenForDeserialize(rootNode);
          }
        }
      }, _class3$q.OptimizationPolicy = OptimizationPolicy, _class3$q.OptimizationPolicyThreshold = 3, _class3$q), (_initializer$G = applyDecoratedInitializer(_class2$K.prototype, "data", [serializable$3], function () {
        return null;
      }), _initializer2$w = applyDecoratedInitializer(_class2$K.prototype, "optimizationPolicy", [serializable$3], function () {
        return OptimizationPolicy.AUTO;
      }), _initializer3$q = applyDecoratedInitializer(_class2$K.prototype, "persistent", [serializable$3], function () {
        return false;
      })), _class2$K)) || _class$P));
      value(Prefab, '_utils', utils);
      legacyCC.Prefab = Prefab;
      {
        obsolete(legacyCC, 'cc._Prefab', 'Prefab');
      }

      class UIRendererManager {
        constructor() {
          this._allRenderers = [];
          this._dirtyRenderers = [];
          this._dirtyVersion = 0;
        }
        addRenderer(uiRenderer) {
          if (uiRenderer._internalId === -1) {
            uiRenderer._internalId = this._allRenderers.length;
            this._allRenderers.push(uiRenderer);
          }
        }
        removeRenderer(uiRenderer) {
          if (uiRenderer._internalId !== -1) {
            {
              assert(this._allRenderers[uiRenderer._internalId] === uiRenderer);
            }
            const id = uiRenderer._internalId;
            this._allRenderers[this._allRenderers.length - 1]._internalId = id;
            fastRemoveAt$2(this._allRenderers, id);
            uiRenderer._internalId = -1;
            if (uiRenderer._dirtyVersion === this._dirtyVersion) {
              fastRemove(this._dirtyRenderers, uiRenderer);
              uiRenderer._dirtyVersion = -1;
            }
          }
        }
        markDirtyRenderer(uiRenderer) {
          if (uiRenderer._dirtyVersion !== this._dirtyVersion && uiRenderer._internalId !== -1) {
            this._dirtyRenderers.push(uiRenderer);
            uiRenderer._dirtyVersion = this._dirtyVersion;
          }
        }
        updateAllDirtyRenderers() {
          const length = this._dirtyRenderers.length;
          const dirtyRenderers = this._dirtyRenderers;
          for (let i = 0; i < length; i++) {
            {
              assert(dirtyRenderers[i]._internalId !== -1);
            }
            dirtyRenderers[i].updateRenderer();
          }
          this._dirtyRenderers.length = 0;
          this._dirtyVersion++;
        }
      }
      const uiRendererManager = new UIRendererManager();

      const isMatchByWord = (path, test) => {
        if (path.length > test.length) {
          const nextAscii = path.charCodeAt(test.length);
          return nextAscii === 47;
        }
        return true;
      };
      const processOptions = options => {
        let uuids = options.uuids;
        const paths = options.paths;
        const types = options.types;
        const bundles = options.deps;
        const realEntries = options.paths = Object.create(null);
        if (options.debug === false) {
          for (let i = 0, l = uuids.length; i < l; i++) {
            uuids[i] = decodeUuid(uuids[i]);
          }
          for (const id in paths) {
            const entry = paths[id];
            const type = entry[1];
            entry[1] = types[type];
          }
        } else {
          const out = Object.create(null);
          for (let i = 0, l = uuids.length; i < l; i++) {
            const uuid = uuids[i];
            uuids[i] = out[uuid] = decodeUuid(uuid);
          }
          uuids = out;
        }
        for (const id in paths) {
          const entry = paths[id];
          realEntries[uuids[id]] = entry;
        }
        const scenes = options.scenes;
        for (const name in scenes) {
          const uuid = scenes[name];
          scenes[name] = uuids[uuid];
        }
        const packs = options.packs;
        for (const packId in packs) {
          const packedIds = packs[packId];
          for (let j = 0; j < packedIds.length; ++j) {
            packedIds[j] = uuids[packedIds[j]];
          }
        }
        const versions = options.versions;
        if (versions) {
          for (const folder in versions) {
            const entries = versions[folder];
            for (let i = 0; i < entries.length; i += 2) {
              const uuid = entries[i];
              entries[i] = uuids[uuid] || uuid;
            }
          }
        }
        const redirect = options.redirect;
        if (redirect) {
          for (let i = 0; i < redirect.length; i += 2) {
            redirect[i] = uuids[redirect[i]];
            redirect[i + 1] = bundles[redirect[i + 1]];
          }
        }
        const extensionMap = options.extensionMap;
        if (extensionMap) {
          for (const ext in options.extensionMap) {
            if (!Object.prototype.hasOwnProperty.call(options.extensionMap, ext)) {
              continue;
            }
            options.extensionMap[ext].forEach((uuid, index) => {
              options.extensionMap[ext][index] = uuids[uuid] || uuid;
            });
          }
        }
      };
      class Config {
        constructor() {
          this.name = '';
          this.base = '';
          this.importBase = '';
          this.nativeBase = '';
          this.deps = null;
          this.assetInfos = new Cache();
          this.scenes = new Cache();
          this.paths = new Cache();
        }
        init(options) {
          processOptions(options);
          this.importBase = options.importBase || '';
          this.nativeBase = options.nativeBase || '';
          this.base = options.base || '';
          this.name = options.name || '';
          this.deps = options.deps || [];
          this._initUuid(options.uuids);
          this._initPath(options.paths);
          this._initScene(options.scenes);
          this._initPackage(options.packs);
          this._initVersion(options.versions);
          this._initRedirect(options.redirect);
          for (const ext in options.extensionMap) {
            if (!Object.prototype.hasOwnProperty.call(options.extensionMap, ext)) {
              continue;
            }
            options.extensionMap[ext].forEach(uuid => {
              const assetInfo = this.assetInfos.get(uuid);
              if (assetInfo) {
                assetInfo.extension = ext;
              }
            });
          }
        }
        getInfoWithPath(path, type) {
          if (!path) {
            return null;
          }
          path = normalize(path);
          const items = this.paths.get(path);
          if (items) {
            if (type) {
              for (let i = 0, l = items.length; i < l; i++) {
                const assetInfo = items[i];
                if (isChildClassOf(assetInfo.ctor, type)) {
                  return assetInfo;
                }
              }
            } else {
              return items[0];
            }
          }
          return null;
        }
        getDirWithPath(path, type, out) {
          path = normalize(path);
          if (path[path.length - 1] === '/') {
            path = path.slice(0, -1);
          }
          const infos = out || [];
          this.paths.forEach((items, p) => {
            if (p.startsWith(path) && isMatchByWord(p, path) || !path) {
              for (let i = 0, l = items.length; i < l; i++) {
                const entry = items[i];
                if (!type || isChildClassOf(entry.ctor, type)) {
                  infos.push(entry);
                }
              }
            }
          });
          return infos;
        }
        getAssetInfo(uuid) {
          return this.assetInfos.get(uuid) || null;
        }
        getSceneInfo(name) {
          if (!name.endsWith('.scene')) {
            name += '.scene';
          }
          if (name[0] !== '/' && !name.startsWith('db://')) {
            name = `/${name}`;
          }
          const info = this.scenes.find((val, key) => key.endsWith(name));
          return info;
        }
        destroy() {
          this.paths.destroy();
          this.scenes.destroy();
          this.assetInfos.destroy();
        }
        _initUuid(uuidList) {
          if (!uuidList) {
            return;
          }
          this.assetInfos.clear();
          for (let i = 0, l = uuidList.length; i < l; i++) {
            const uuid = uuidList[i];
            this.assetInfos.add(uuid, {
              uuid
            });
          }
        }
        _initPath(pathList) {
          if (!pathList) {
            return;
          }
          const paths = this.paths;
          paths.clear();
          for (const uuid in pathList) {
            const info = pathList[uuid];
            const path = info[0];
            const type = info[1];
            const isSubAsset = info.length === 3;
            const assetInfo = this.assetInfos.get(uuid);
            assetInfo.path = path;
            assetInfo.ctor = getClassById(type);
            if (paths.has(path)) {
              if (isSubAsset) {
                paths.get(path).push(assetInfo);
              } else {
                paths.get(path).unshift(assetInfo);
              }
            } else {
              paths.add(path, [assetInfo]);
            }
          }
        }
        _initScene(sceneList) {
          if (!sceneList) {
            return;
          }
          const scenes = this.scenes;
          scenes.clear();
          const assetInfos = this.assetInfos;
          for (const sceneName in sceneList) {
            const uuid = sceneList[sceneName];
            const assetInfo = assetInfos.get(uuid);
            assetInfo.url = sceneName;
            scenes.add(sceneName, assetInfo);
          }
        }
        _initPackage(packageList) {
          if (!packageList) {
            return;
          }
          const assetInfos = this.assetInfos;
          for (const packUuid in packageList) {
            const uuids = packageList[packUuid];
            const pack = {
              uuid: packUuid,
              packedUuids: uuids,
              ext: '.json'
            };
            assetInfos.add(packUuid, pack);
            for (let i = 0, l = uuids.length; i < l; i++) {
              const uuid = uuids[i];
              const assetInfo = assetInfos.get(uuid);
              const assetPacks = assetInfo.packs;
              if (assetPacks) {
                if (l === 1) {
                  assetPacks.unshift(pack);
                } else {
                  assetPacks.push(pack);
                }
              } else {
                assetInfo.packs = [pack];
              }
            }
          }
        }
        _initVersion(versions) {
          if (!versions) {
            return;
          }
          const assetInfos = this.assetInfos;
          let entries = versions.import;
          if (entries) {
            for (let i = 0, l = entries.length; i < l; i += 2) {
              const uuid = entries[i];
              const assetInfo = assetInfos.get(uuid);
              assetInfo.ver = entries[i + 1];
            }
          }
          entries = versions.native;
          if (entries) {
            for (let i = 0, l = entries.length; i < l; i += 2) {
              const uuid = entries[i];
              const assetInfo = assetInfos.get(uuid);
              assetInfo.nativeVer = entries[i + 1];
            }
          }
        }
        _initRedirect(redirect) {
          if (!redirect) {
            return;
          }
          const assetInfos = this.assetInfos;
          for (let i = 0, l = redirect.length; i < l; i += 2) {
            const uuid = redirect[i];
            const assetInfo = assetInfos.get(uuid);
            assetInfo.redirect = redirect[i + 1];
          }
        }
      }

      function visitAsset(asset, deps) {
        if (!asset._uuid) {
          return;
        }
        deps.push(asset._uuid);
      }
      function visitComponent(comp, deps) {
        const props = Object.getOwnPropertyNames(comp);
        for (let i = 0; i < props.length; i++) {
          const propName = props[i];
          if (propName === 'node' || propName === '__eventTargets') {
            continue;
          }
          const value = comp[propName];
          if (typeof value === 'object' && value) {
            if (Array.isArray(value)) {
              for (let j = 0; j < value.length; j++) {
                const val = value[j];
                if (val instanceof Asset) {
                  visitAsset(val, deps);
                }
              }
            } else if (!value.constructor || value.constructor === Object) {
              const keys = Object.getOwnPropertyNames(value);
              for (let j = 0; j < keys.length; j++) {
                const val = value[keys[j]];
                if (val instanceof Asset) {
                  visitAsset(val, deps);
                }
              }
            } else if (value instanceof Asset) {
              visitAsset(value, deps);
            }
          }
        }
      }
      function visitNode$1(node, deps) {
        for (let i = 0; i < node._components.length; i++) {
          visitComponent(node._components[i], deps);
        }
        for (let i = 0; i < node._children.length; i++) {
          visitNode$1(node._children[i], deps);
        }
      }
      function descendOpRef(asset, refs, exclude, op) {
        exclude.push(asset._uuid);
        const depends = dependUtil.getDeps(asset._uuid);
        for (let i = 0, l = depends.length; i < l; i++) {
          const dependAsset = assets.get(depends[i]);
          if (!dependAsset) {
            continue;
          }
          const uuid = dependAsset._uuid;
          if (!(uuid in refs)) {
            refs[uuid] = dependAsset.refCount + op;
          } else {
            refs[uuid] += op;
          }
          if (exclude.includes(uuid)) {
            continue;
          }
          descendOpRef(dependAsset, refs, exclude, op);
        }
      }
      const _temp = [];
      function checkCircularReference(asset) {
        const refs = Object.create(null);
        refs[asset._uuid] = asset.refCount;
        descendOpRef(asset, refs, _temp, -1);
        _temp.length = 0;
        if (refs[asset._uuid] !== 0) {
          return refs[asset._uuid];
        }
        for (const uuid in refs) {
          if (refs[uuid] !== 0) {
            descendOpRef(assets.get(uuid), refs, _temp, 1);
          }
        }
        _temp.length = 0;
        return refs[asset._uuid];
      }
      class ReleaseManager {
        constructor() {
          this._persistNodeDeps = new Cache();
          this._toDelete = new Cache();
          this._eventListener = false;
          this._dontDestroyAssets = [];
        }
        addIgnoredAsset(asset) {
          this._dontDestroyAssets.push(asset._uuid);
        }
        init() {
          this._persistNodeDeps.clear();
          this._toDelete.clear();
        }
        _addPersistNodeRef(node) {
          const deps = [];
          visitNode$1(node, deps);
          for (let i = 0, l = deps.length; i < l; i++) {
            const dependAsset = assets.get(deps[i]);
            if (dependAsset) {
              dependAsset.addRef();
            }
          }
          this._persistNodeDeps.add(node.uuid, deps);
        }
        _removePersistNodeRef(node) {
          if (!this._persistNodeDeps.has(node.uuid)) {
            return;
          }
          const deps = this._persistNodeDeps.get(node.uuid);
          for (let i = 0, l = deps.length; i < l; i++) {
            const dependAsset = assets.get(deps[i]);
            if (dependAsset) {
              dependAsset.decRef();
            }
          }
          this._persistNodeDeps.remove(node.uuid);
        }
        _autoRelease(oldScene, newScene, persistNodes) {
          if (oldScene) {
            const childs = dependUtil.getDeps(oldScene.uuid);
            for (let i = 0, l = childs.length; i < l; i++) {
              const asset = assets.get(childs[i]);
              if (asset) {
                asset.decRef(oldScene.autoReleaseAssets);
              }
            }
            const dependencies = dependUtil._depends.get(oldScene.uuid);
            if (dependencies && dependencies.persistDeps) {
              const persistDeps = dependencies.persistDeps;
              for (let i = 0, l = persistDeps.length; i < l; i++) {
                const asset = assets.get(persistDeps[i]);
                if (asset) {
                  asset.decRef(oldScene.autoReleaseAssets);
                }
              }
            }
            if (oldScene.uuid !== newScene.uuid) {
              dependUtil.remove(oldScene.uuid);
            }
          }
          const sceneDeps = dependUtil._depends.get(newScene.uuid);
          if (sceneDeps) {
            sceneDeps.persistDeps = [];
          }
          for (const key in persistNodes) {
            const node = persistNodes[key];
            const deps = this._persistNodeDeps.get(node.uuid);
            for (const dep of deps) {
              const dependAsset = assets.get(dep);
              if (dependAsset) {
                dependAsset.addRef();
              }
            }
            if (!sceneDeps) {
              continue;
            }
            sceneDeps.persistDeps.push(...deps);
          }
        }
        tryRelease(asset, force = false) {
          if (!(asset instanceof Asset)) {
            return;
          }
          if (force) {
            this._free(asset, force);
            return;
          }
          this._toDelete.add(asset._uuid, asset);
          if (!this._eventListener) {
            this._eventListener = true;
            callInNextTick(this._freeAssets.bind(this));
          }
        }
        _freeAssets() {
          this._eventListener = false;
          this._toDelete.forEach(asset => {
            this._free(asset);
          });
          this._toDelete.clear();
        }
        _free(asset, force = false) {
          const uuid = asset._uuid;
          this._toDelete.remove(uuid);
          if (!isValid(asset, true) || this._dontDestroyAssets.indexOf(uuid) !== -1) {
            return;
          }
          if (!force) {
            if (asset.refCount > 0) {
              if (checkCircularReference(asset) > 0) {
                return;
              }
            }
          }
          assets.remove(uuid);
          const depends = dependUtil.getDeps(uuid);
          for (let i = 0, l = depends.length; i < l; i++) {
            const dependAsset = assets.get(depends[i]);
            if (dependAsset) {
              dependAsset.decRef(false);
              {
                this._free(dependAsset, false);
              }
            }
          }
          {
            asset.destroy();
          }
          dependUtil.remove(uuid);
        }
      }
      const releaseManager = new ReleaseManager();

      let defaultProgressCallback = null;
      function setDefaultProgressCallback(onProgress) {
        defaultProgressCallback = onProgress;
      }
      function clear(task, clearRef) {
        for (let i = 0, l = task.input.length; i < l; i++) {
          const item = task.input[i];
          if (clearRef) {
            if (!item.isNative && item.content instanceof Asset) {
              item.content.decRef(false);
            }
          }
          item.recycle();
        }
        task.input = null;
      }
      function urlAppendTimestamp(url, append) {
        if (append) {
          if (/\?/.test(url)) {
            return `${url}&_t=${Date.now()}`;
          }
          return `${url}?_t=${Date.now()}`;
        }
        return url;
      }
      function retry(process, times, wait, onComplete, index = 0) {
        process(index, (err, result) => {
          index++;
          if (!err || index > times) {
            if (onComplete) {
              onComplete(err, result);
            }
          } else {
            setTimeout(() => {
              retry(process, times, wait, onComplete, index);
            }, wait);
          }
        });
      }
      function getDepends(uuid, data, exclude, depends, config) {
        try {
          const info = dependUtil.parse(uuid, data);
          for (let i = 0, l = info.deps.length; i < l; i++) {
            const dep = info.deps[i];
            if (!(dep in exclude)) {
              exclude[dep] = true;
              depends.push({
                uuid: dep,
                bundle: config && config.name
              });
            }
          }
          if (info.nativeDep) {
            if (config) {
              info.nativeDep.bundle = config.name;
            }
            depends.push({
              ...info.nativeDep
            });
          }
        } catch (e) {
          error(e.message, e.stack);
        }
      }
      function cache(id, asset, cacheAsset) {
        if (!asset) {
          return;
        }
        cacheAsset = cacheAsset !== undefined ? cacheAsset : legacyCC.assetManager.cacheAsset;
        if (!isScene(asset) && cacheAsset && !asset.isDefault) {
          assets.add(id, asset);
        }
      }
      function setProperties(uuid, asset, assetsMap) {
        let missingAsset = false;
        const depends = dependMap.get(asset);
        if (depends) {
          for (let i = 0, l = depends.length; i < l; i++) {
            const depend = depends[i];
            const dependAsset = assetsMap[`${depend.uuid}@import`];
            if (!dependAsset) {
              {
                error(`The asset ${depend.uuid} is missing!`);
              }
              legacyCC.assetManager.dispatchAssetMissing(asset, depend.owner, depend.prop, depend.uuid);
              if (depend.type && depend.type !== Asset) {
                const placeHolder = new depend.type();
                placeHolder.initDefault(depend.uuid);
                depend.owner[depend.prop] = placeHolder;
              }
              missingAsset = true;
            } else {
              depend.owner[depend.prop] = dependAsset.addRef();
            }
          }
          dependMap.delete(asset);
        }
        if (nativeDependMap.has(asset)) {
          if (assetsMap[`${uuid}@native`]) {
            asset._nativeAsset = assetsMap[`${uuid}@native`];
          } else {
            missingAsset = true;
            console.error(`the native asset of ${uuid} is missing!`);
          }
          nativeDependMap.delete(asset);
        }
        return missingAsset;
      }
      function gatherAsset(task) {
        const source = task.source;
        if (!task.options.__outputAsArray__ && source.length === 1) {
          task.output = source[0].content;
        } else {
          const output = task.output = [];
          for (let i = 0, l = source.length; i < l; i++) {
            output.push(source[i].content);
          }
        }
      }
      function forEach(array, process, onComplete) {
        let count = 0;
        const errs = [];
        const length = array.length;
        if (length === 0 && onComplete) {
          onComplete(errs);
        }
        const cb = err => {
          if (err) {
            errs.push(err);
          }
          count++;
          if (count === length) {
            if (onComplete) {
              onComplete(errs);
            }
          }
        };
        for (let i = 0; i < length; i++) {
          process(array[i], cb);
        }
      }
      function parseParameters(options, onProgress, onComplete) {
        let optionsOut = options;
        let onProgressOut = onProgress;
        let onCompleteOut = onComplete;
        if (onComplete === undefined) {
          const isCallback = typeof options === 'function';
          if (onProgress) {
            onCompleteOut = onProgress;
            if (!isCallback) {
              onProgressOut = null;
            }
          } else if (onProgress === undefined && isCallback) {
            onCompleteOut = options;
            optionsOut = null;
            onProgressOut = null;
          }
          if (onProgress !== undefined && isCallback) {
            onProgressOut = options;
            optionsOut = null;
          }
        }
        return {
          options: optionsOut || Object.create(null),
          onProgress: onProgressOut,
          onComplete: onCompleteOut
        };
      }
      function parseLoadResArgs(type, onProgress, onComplete) {
        let typeOut = type;
        let onProgressOut = onProgress;
        let onCompleteOut = onComplete;
        if (onComplete === undefined) {
          const isValidType = isChildClassOf(type, Asset);
          if (onProgress) {
            onCompleteOut = onProgress;
            if (isValidType) {
              onProgressOut = null;
            }
          } else if (onProgress === undefined && !isValidType) {
            onCompleteOut = type;
            onProgressOut = null;
            typeOut = null;
          }
          if (onProgress !== undefined && !isValidType) {
            onProgressOut = type;
            typeOut = null;
          }
        }
        return {
          type: typeOut,
          onProgress: onProgressOut || defaultProgressCallback,
          onComplete: onCompleteOut
        };
      }
      function checkCircleReference(owner, uuid, map, checked = {}) {
        const item = map[uuid];
        if (!item || checked[uuid]) {
          return false;
        }
        checked[uuid] = true;
        let result = false;
        const deps = dependUtil.getDeps(uuid);
        if (deps) {
          for (let i = 0, l = deps.length; i < l; i++) {
            const dep = deps[i];
            if (dep === owner || checkCircleReference(owner, dep, map, checked)) {
              result = true;
              break;
            }
          }
        }
        return result;
      }
      function asyncify(cb) {
        return (p1, p2) => {
          if (!cb) {
            return;
          }
          const refs = [];
          if (Array.isArray(p2)) {
            p2.forEach(x => x instanceof Asset && refs.push(x.addRef()));
          } else if (p2 instanceof Asset) {
            refs.push(p2.addRef());
          }
          callInNextTick(() => {
            refs.forEach(x => x.decRef(false));
            cb(p1, p2);
          });
        };
      }

      class Bundle {
        constructor() {
          this._config = new Config();
        }
        get config() {
          return this._config;
        }
        get name() {
          return this._config.name;
        }
        get deps() {
          return this._config.deps;
        }
        get base() {
          return this._config.base;
        }
        getInfoWithPath(path, type) {
          return this._config.getInfoWithPath(path, type);
        }
        getDirWithPath(path, type, out) {
          return this._config.getDirWithPath(path, type, out);
        }
        getAssetInfo(uuid) {
          return this._config.getAssetInfo(uuid);
        }
        getSceneInfo(name) {
          return this._config.getSceneInfo(name);
        }
        init(options) {
          this._config.init(options);
          bundles.add(options.name, this);
        }
        load(paths, type, onProgress, onComplete) {
          const {
            type: _type,
            onProgress: onProg,
            onComplete: onComp
          } = parseLoadResArgs(type, onProgress, onComplete);
          const options = {
            __requestType__: RequestType.PATH,
            type: _type,
            bundle: this.name,
            __outputAsArray__: Array.isArray(paths)
          };
          legacyCC.assetManager.loadAny(paths, options, onProg, onComp);
        }
        preload(paths, type, onProgress, onComplete) {
          const {
            type: _type,
            onProgress: onProg,
            onComplete: onComp
          } = parseLoadResArgs(type, onProgress, onComplete);
          legacyCC.assetManager.preloadAny(paths, {
            __requestType__: RequestType.PATH,
            type: _type,
            bundle: this.name
          }, onProg, onComp);
        }
        loadDir(dir, type, onProgress, onComplete) {
          const {
            type: _type,
            onProgress: onProg,
            onComplete: onComp
          } = parseLoadResArgs(type, onProgress, onComplete);
          legacyCC.assetManager.loadAny(dir, {
            __requestType__: RequestType.DIR,
            type: _type,
            bundle: this.name,
            __outputAsArray__: true
          }, onProg, onComp);
        }
        preloadDir(dir, type, onProgress, onComplete) {
          const {
            type: _type,
            onProgress: onProg,
            onComplete: onComp
          } = parseLoadResArgs(type, onProgress, onComplete);
          legacyCC.assetManager.preloadAny(dir, {
            __requestType__: RequestType.DIR,
            type: _type,
            bundle: this.name
          }, onProg, onComp);
        }
        loadScene(sceneName, options, onProgress, onComplete) {
          const {
            options: opts,
            onProgress: onProg,
            onComplete: onComp
          } = parseParameters(options, onProgress, onComplete);
          opts.preset = opts.preset || 'scene';
          opts.bundle = this.name;
          legacyCC.assetManager.loadAny({
            scene: sceneName
          }, opts, onProg, (err, sceneAsset) => {
            if (err) {
              error(err.message, err.stack);
            } else if (sceneAsset.scene) {
              const scene = sceneAsset.scene;
              scene._id = sceneAsset._uuid;
              scene.name = sceneAsset.name;
            } else {
              err = new Error(`The asset ${sceneAsset._uuid} is not a scene`);
            }
            if (onComp) {
              onComp(err, sceneAsset);
            }
          });
        }
        preloadScene(sceneName, options, onProgress, onComplete) {
          const {
            options: opts,
            onProgress: onProg,
            onComplete: onComp
          } = parseParameters(options, onProgress, onComplete);
          opts.bundle = this.name;
          legacyCC.assetManager.preloadAny({
            scene: sceneName
          }, opts, onProg, err => {
            if (err) {
              errorID(1210, sceneName, err.message);
            }
            if (onComp) {
              onComp(err);
            }
          });
        }
        get(path, type) {
          const info = this.getInfoWithPath(path, type);
          if (info) {
            return assets.get(info.uuid) || null;
          }
          return null;
        }
        release(path, type) {
          const asset = this.get(path, type);
          if (asset) {
            releaseManager.tryRelease(asset, true);
          }
        }
        releaseUnusedAssets() {
          assets.forEach(asset => {
            const info = this.getAssetInfo(asset._uuid);
            if (info && !info.redirect) {
              releaseManager.tryRelease(asset);
            }
          });
        }
        releaseAll() {
          assets.forEach(asset => {
            const info = this.getAssetInfo(asset._uuid);
            if (info && !info.redirect) {
              releaseManager.tryRelease(asset, true);
            }
          });
        }
        _destroy() {
          this._config.destroy();
        }
      }
      const resources = exports('resources', new Bundle());
      legacyCC.resources = resources;

      class CacheManager {
        constructor() {
          this.cacheDir = void 0;
          this.cacheEnabled = void 0;
          this.autoClear = void 0;
          this.cacheInterval = void 0;
          this.deleteInterval = void 0;
          this.cachedFiles = void 0;
        }
      }

      function downloadDomImage(url, options, onComplete) {
        const img = new ccwindow$1.Image();
        if (ccwindow$1.location.protocol !== 'file:' || XIAOMI) {
          img.crossOrigin = 'anonymous';
        }
        function loadCallback() {
          img.removeEventListener('load', loadCallback);
          img.removeEventListener('error', errorCallback);
          if (onComplete) {
            onComplete(null, img);
          }
        }
        function errorCallback() {
          img.removeEventListener('load', loadCallback);
          img.removeEventListener('error', errorCallback);
          if (onComplete) {
            onComplete(new Error(getError(4930, url)));
          }
        }
        img.addEventListener('load', loadCallback);
        img.addEventListener('error', errorCallback);
        img.src = url;
        return img;
      }

      function downloadFile(url, options, onProgress, onComplete) {
        const xhr = new XMLHttpRequest();
        const errInfo = `download failed: ${url}, status: `;
        xhr.open('GET', url, true);
        if (options.xhrResponseType !== undefined) {
          xhr.responseType = options.xhrResponseType;
        }
        if (options.xhrWithCredentials !== undefined) {
          xhr.withCredentials = options.xhrWithCredentials;
        }
        if (options.xhrMimeType !== undefined && xhr.overrideMimeType) {
          xhr.overrideMimeType(options.xhrMimeType);
        }
        if (options.xhrTimeout !== undefined) {
          xhr.timeout = options.xhrTimeout;
        }
        if (options.xhrHeader) {
          for (const header in options.xhrHeader) {
            xhr.setRequestHeader(header, options.xhrHeader[header]);
          }
        }
        xhr.onload = () => {
          if (xhr.status === 200 || xhr.status === 0) {
            if (onComplete) {
              onComplete(null, xhr.response);
            }
          } else if (onComplete) {
            onComplete(new Error(`${errInfo}${xhr.status}(no response)`));
          }
        };
        if (onProgress) {
          xhr.onprogress = e => {
            if (e.lengthComputable) {
              onProgress(e.loaded, e.total);
            }
          };
        }
        xhr.onerror = () => {
          if (onComplete) {
            onComplete(new Error(`${errInfo}${xhr.status}(error)`));
          }
        };
        xhr.ontimeout = () => {
          if (onComplete) {
            onComplete(new Error(`${errInfo}${xhr.status}(time out)`));
          }
        };
        xhr.onabort = () => {
          if (onComplete) {
            onComplete(new Error(`${errInfo}${xhr.status}(abort)`));
          }
        };
        xhr.send(null);
        return xhr;
      }

      const ccdocument$3 = ccwindow$1.document;
      const downloaded = {};
      function downloadScript(url, options, onComplete) {
        if (downloaded[url]) {
          if (onComplete) {
            onComplete(null);
          }
          return null;
        }
        const script = ccdocument$3.createElement('script');
        if (ccwindow$1.location.protocol !== 'file:') {
          script.crossOrigin = 'anonymous';
        }
        script.async = options.scriptAsyncLoading || false;
        script.src = url;
        function loadHandler() {
          script.parentNode.removeChild(script);
          script.removeEventListener('load', loadHandler, false);
          script.removeEventListener('error', errorHandler, false);
          downloaded[url] = true;
          if (onComplete) {
            onComplete(null);
          }
        }
        function errorHandler() {
          script.parentNode.removeChild(script);
          script.removeEventListener('load', loadHandler, false);
          script.removeEventListener('error', errorHandler, false);
          if (onComplete) {
            onComplete(new Error(getError(4928, url)));
          }
        }
        script.addEventListener('load', loadHandler, false);
        script.addEventListener('error', errorHandler, false);
        ccdocument$3.body.appendChild(script);
        return script;
      }

      const REGEX = /^(?:\w+:\/\/|\.+\/).+/;
      const downloadImage = (url, options, onComplete) => {
        const func = sys.hasFeature(sys.Feature.IMAGE_BITMAP) && legacyCC.assetManager.allowImageBitmap ? downloadBlob : downloadDomImage;
        func(url, options, onComplete);
      };
      const downloadBlob = (url, options, onComplete) => {
        options.xhrResponseType = 'blob';
        downloadFile(url, options, options.onFileProgress, onComplete);
      };
      const downloadJson = (url, options, onComplete) => {
        options.xhrResponseType = 'json';
        downloadFile(url, options, options.onFileProgress, onComplete);
      };
      const downloadArrayBuffer = (url, options, onComplete) => {
        options.xhrResponseType = 'arraybuffer';
        downloadFile(url, options, options.onFileProgress, onComplete);
      };
      const downloadCCON = (url, options, onComplete) => {
        downloader._downloadJson(url, options, (err, json) => {
          if (err) {
            onComplete(err);
            return;
          }
          const cconPreface = parseCCONJson(json);
          const chunkPromises = Promise.all(cconPreface.chunks.map(chunk => new Promise((resolve, reject) => {
            downloader._downloadArrayBuffer(`${mainFileName(url)}${chunk}`, {}, (errChunk, chunkBuffer) => {
              if (err) {
                reject(err);
              } else {
                resolve(new Uint8Array(chunkBuffer));
              }
            });
          })));
          chunkPromises.then(chunks => {
            const ccon = new CCON(cconPreface.document, chunks);
            onComplete(null, ccon);
          }).catch(err => {
            onComplete(err);
          });
        });
      };
      const downloadCCONB = (url, options, onComplete) => {
        downloader._downloadArrayBuffer(url, options, (err, arrayBuffer) => {
          if (err) {
            onComplete(err);
            return;
          }
          try {
            const ccon = decodeCCONBinary(new Uint8Array(arrayBuffer));
            onComplete(null, ccon);
          } catch (err) {
            onComplete(err);
          }
        });
      };
      const downloadText = (url, options, onComplete) => {
        options.xhrResponseType = 'text';
        downloadFile(url, options, options.onFileProgress, onComplete);
      };
      const downloadBundle = (nameOrUrl, options, onComplete) => {
        const bundleName = basename(nameOrUrl);
        let url = nameOrUrl;
        if (!REGEX.test(url)) {
          if (downloader.remoteBundles.indexOf(bundleName) !== -1) {
            url = `${downloader.remoteServerAddress}remote/${bundleName}`;
          } else {
            url = `assets/${bundleName}`;
          }
        }
        const version = options.version || downloader.bundleVers[bundleName];
        let count = 0;
        const config = `${url}/config.${version ? `${version}.` : ''}json`;
        let out = null;
        let error = null;
        downloadJson(config, options, (err, response) => {
          error = err || error;
          out = response;
          if (out) {
            out.base = `${url}/`;
          }
          if (++count === 2) {
            onComplete(error, out);
          }
        });
        const jspath = `${url}/index.${version ? `${version}.` : ''}js`;
        downloadScript(jspath, options, err => {
          error = err || error;
          if (++count === 2) {
            onComplete(error, out);
          }
        });
      };
      class Downloader {
        static get instance() {
          if (!Downloader._instance) {
            Downloader._instance = new Downloader();
          }
          return Downloader._instance;
        }
        get remoteServerAddress() {
          return this._remoteServerAddress;
        }
        init(remoteServerAddress = '', bundleVers = {}, remoteBundles = []) {
          this._downloading.clear();
          this._queue.length = 0;
          this._remoteServerAddress = remoteServerAddress;
          this.bundleVers = bundleVers;
          this.remoteBundles = remoteBundles;
        }
        register(type, handler) {
          if (typeof type === 'object') {
            mixin(this._downloaders, type);
          } else {
            this._downloaders[type] = handler;
          }
        }
        download(id, url, type, options, onComplete) {
          const file = files.get(id);
          if (file) {
            onComplete(null, file);
            return;
          }
          const downloadCallbacks = this._downloading.get(id);
          if (downloadCallbacks) {
            downloadCallbacks.push(onComplete);
            const request = this._queue.find(x => x.id === id);
            if (!request) {
              return;
            }
            const priority = options.priority || 0;
            if (request.priority < priority) {
              request.priority = priority;
              this._queueDirty = true;
            }
            return;
          }
          const maxRetryCount = typeof options.maxRetryCount !== 'undefined' ? options.maxRetryCount : this.maxRetryCount;
          const maxConcurrency = typeof options.maxConcurrency !== 'undefined' ? options.maxConcurrency : this.maxConcurrency;
          const maxRequestsPerFrame = typeof options.maxRequestsPerFrame !== 'undefined' ? options.maxRequestsPerFrame : this.maxRequestsPerFrame;
          const handler = this._downloaders[type] || this._downloaders.default;
          const process = (index, callback) => {
            if (index === 0) {
              this._downloading.add(id, [onComplete]);
            }
            if (!this.limited) {
              handler(urlAppendTimestamp(url, this.appendTimeStamp), options, callback);
              return;
            }
            this._updateTime();
            const done = (err, data) => {
              this._totalNum--;
              this._handleQueueInNextFrame(maxConcurrency, maxRequestsPerFrame);
              callback(err, data);
            };
            if (this._totalNum < maxConcurrency && this._totalNumThisPeriod < maxRequestsPerFrame) {
              handler(urlAppendTimestamp(url, this.appendTimeStamp), options, done);
              this._totalNum++;
              this._totalNumThisPeriod++;
            } else {
              this._queue.push({
                id,
                priority: options.priority || 0,
                url,
                options,
                done,
                handler
              });
              this._queueDirty = true;
              if (this._totalNum < maxConcurrency) {
                this._handleQueueInNextFrame(maxConcurrency, maxRequestsPerFrame);
              }
            }
          };
          const finale = (err, result) => {
            if (!err) {
              files.add(id, result);
            }
            const callbacks = this._downloading.remove(id);
            for (let i = 0, l = callbacks.length; i < l; i++) {
              callbacks[i](err, result);
            }
          };
          retry(process, maxRetryCount, this.retryInterval, finale);
        }
        loadSubpackage(name, completeCallback) {
          legacyCC.assetManager.loadBundle(name, null, completeCallback);
        }
        constructor() {
          this.maxConcurrency = 15;
          this.maxRequestsPerFrame = 15;
          this.maxRetryCount = 3 ;
          this.appendTimeStamp = !!EDITOR_NOT_IN_PREVIEW;
          this.limited = !EDITOR;
          this.retryInterval = 2000;
          this.bundleVers = {};
          this.remoteBundles = [];
          this.downloadDomImage = downloadDomImage;
          this.downloadDomAudio = null;
          this.downloadFile = downloadFile;
          this.downloadScript = downloadScript;
          this._downloadArrayBuffer = downloadArrayBuffer;
          this._downloadJson = downloadJson;
          this._downloaders = {
            '.png': downloadImage,
            '.jpg': downloadImage,
            '.bmp': downloadImage,
            '.jpeg': downloadImage,
            '.gif': downloadImage,
            '.ico': downloadImage,
            '.tiff': downloadImage,
            '.webp': downloadImage,
            '.image': downloadImage,
            '.pvr': downloadArrayBuffer,
            '.pkm': downloadArrayBuffer,
            '.astc': downloadArrayBuffer,
            '.txt': downloadText,
            '.xml': downloadText,
            '.vsh': downloadText,
            '.fsh': downloadText,
            '.atlas': downloadText,
            '.tmx': downloadText,
            '.tsx': downloadText,
            '.json': downloadJson,
            '.ExportJson': downloadJson,
            '.plist': downloadText,
            '.ccon': downloadCCON,
            '.cconb': downloadCCONB,
            '.fnt': downloadText,
            '.binary': downloadArrayBuffer,
            '.bin': downloadArrayBuffer,
            '.dbbin': downloadArrayBuffer,
            '.skel': downloadArrayBuffer,
            '.js': downloadScript,
            bundle: downloadBundle,
            default: downloadText
          };
          this._downloading = new Cache();
          this._queue = [];
          this._queueDirty = false;
          this._totalNum = 0;
          this._totalNumThisPeriod = 0;
          this._lastDate = -1;
          this._checkNextPeriod = false;
          this._remoteServerAddress = '';
          this._maxInterval = 1 / 30;
        }
        _updateTime() {
          const now = performance.now();
          const deltaTime = legacyCC.game.deltaTime;
          const interval = deltaTime > this._maxInterval ? this._maxInterval : deltaTime;
          if (now - this._lastDate > interval * 1000) {
            this._totalNumThisPeriod = 0;
            this._lastDate = now;
          }
        }
        _handleQueue(maxConcurrency, maxRequestsPerFrame) {
          this._checkNextPeriod = false;
          this._updateTime();
          while (this._queue.length > 0 && this._totalNum < maxConcurrency && this._totalNumThisPeriod < maxRequestsPerFrame) {
            if (this._queueDirty) {
              this._queue.sort((a, b) => a.priority - b.priority);
              this._queueDirty = false;
            }
            const request = this._queue.pop();
            if (!request) {
              break;
            }
            this._totalNum++;
            this._totalNumThisPeriod++;
            request.handler(urlAppendTimestamp(request.url, this.appendTimeStamp), request.options, request.done);
          }
          this._handleQueueInNextFrame(maxConcurrency, maxRequestsPerFrame);
        }
        _handleQueueInNextFrame(maxConcurrency, maxRequestsPerFrame) {
          if (!this._checkNextPeriod && this._queue.length > 0) {
            callInNextTick(this._handleQueue.bind(this), maxConcurrency, maxRequestsPerFrame);
            this._checkNextPeriod = true;
          }
        }
      }
      Downloader._instance = void 0;
      const downloader = Downloader.instance;
      var downloader$1 = Downloader.instance;

      var _dec$Q, _class$O, _class2$J, _initializer$F;
      let JsonAsset = exports('JsonAsset', (_dec$Q = ccclass$3('cc.JsonAsset'), _dec$Q(_class$O = (_class2$J = class JsonAsset extends Asset {
        constructor(...args) {
          super(...args);
          this.json = _initializer$F && _initializer$F();
        }
      }, (_initializer$F = applyDecoratedInitializer(_class2$J.prototype, "json", [serializable$3], function () {
        return null;
      })), _class2$J)) || _class$O));
      legacyCC.JsonAsset = JsonAsset;

      var _dec$P, _class$N, _class2$I, _initializer$E;
      let TextAsset = exports('TextAsset', (_dec$P = ccclass$3('cc.TextAsset'), _dec$P(_class$N = (_class2$I = class TextAsset extends Asset {
        constructor(...args) {
          super(...args);
          this.text = _initializer$E && _initializer$E();
        }
        toString() {
          return this.text;
        }
      }, (_initializer$E = applyDecoratedInitializer(_class2$I.prototype, "text", [serializable$3], function () {
        return '';
      })), _class2$I)) || _class$N));
      legacyCC.TextAsset = TextAsset;

      const BufferAsset = exports('BufferAsset', jsb.BufferAsset);
      legacyCC.BufferAsset = jsb.BufferAsset;
      patch_cc_BufferAsset({
        BufferAsset
      });

      function createImageAsset(id, data, options, onComplete) {
        let out = null;
        let err = null;
        try {
          out = new ImageAsset$1();
          out._nativeUrl = id;
          out._nativeAsset = data;
        } catch (e) {
          err = e;
        }
        onComplete(err, out);
      }
      function createJsonAsset(id, data, options, onComplete) {
        const out = new JsonAsset();
        out.json = data;
        onComplete(null, out);
      }
      function createTextAsset(id, data, options, onComplete) {
        const out = new TextAsset();
        out.text = data;
        onComplete(null, out);
      }
      function createBufferAsset(id, data, options, onComplete) {
        const out = new BufferAsset();
        out._nativeUrl = id;
        out._nativeAsset = data;
        onComplete(null, out);
      }
      function createAsset(id, data, options, onComplete) {
        const out = new Asset();
        out._nativeUrl = id;
        out._nativeAsset = data;
        onComplete(null, out);
      }
      function createBundle(id, data, options, onComplete) {
        let bundle = bundles.get(data.name);
        if (!bundle) {
          bundle = data.name === BuiltinBundleName.RESOURCES ? resources : new Bundle();
          data.base = data.base || `${id}/`;
          bundle.init(data);
        }
        {
          module.import(`virtual:///prerequisite-imports/${bundle.name}`).then(() => {
            onComplete(null, bundle);
          }).catch(onComplete);
        }
      }
      class Factory {
        constructor() {
          this._creating = new Cache();
          this._producers = {
            '.png': createImageAsset,
            '.jpg': createImageAsset,
            '.bmp': createImageAsset,
            '.jpeg': createImageAsset,
            '.gif': createImageAsset,
            '.ico': createImageAsset,
            '.tiff': createImageAsset,
            '.webp': createImageAsset,
            '.image': createImageAsset,
            '.pvr': createImageAsset,
            '.pkm': createImageAsset,
            '.txt': createTextAsset,
            '.xml': createTextAsset,
            '.vsh': createTextAsset,
            '.fsh': createTextAsset,
            '.atlas': createTextAsset,
            '.tmx': createTextAsset,
            '.tsx': createTextAsset,
            '.fnt': createTextAsset,
            '.json': createJsonAsset,
            '.ExportJson': createJsonAsset,
            '.binary': createBufferAsset,
            '.bin': createBufferAsset,
            '.dbbin': createBufferAsset,
            '.skel': createBufferAsset,
            bundle: createBundle,
            default: createAsset
          };
        }
        register(type, handler) {
          if (typeof type === 'object') {
            mixin(this._producers, type);
          } else {
            this._producers[type] = handler;
          }
        }
        create(id, data, type, options, onComplete) {
          const handler = this._producers[type] || this._producers.default;
          const asset = assets.get(id);
          if (!options.reloadAsset && asset) {
            onComplete(null, asset);
            return;
          }
          const creating = this._creating.get(id);
          if (creating) {
            creating.push(onComplete);
            return;
          }
          this._creating.add(id, [onComplete]);
          handler(id, data, options, (err, result) => {
            if (!err && result instanceof Asset) {
              result._uuid = id;
              cache(id, result, options.cacheAsset);
            }
            const callbacks = this._creating.remove(id);
            for (let i = 0, l = callbacks.length; i < l; i++) {
              callbacks[i](err, result);
            }
          });
        }
      }
      var factory = new Factory();

      class PackManager {
        constructor() {
          this._loading = new Cache();
          this._unpackers = {
            '.json': this.unpackJson
          };
        }
        unpackJson(pack, json, options, onComplete) {
          const out = createMap(true);
          let err = null;
          if (Array.isArray(json)) {
            json = unpackJSONs(json);
            if (json.length !== pack.length) {
              errorID(4915);
            }
            for (let i = 0; i < pack.length; i++) {
              out[`${pack[i]}@import`] = json[i];
            }
          } else {
            const textureType = getClassId(Texture2D$1);
            const imageAssetType = getClassId(ImageAsset$1);
            if (json.type === textureType && json.data) {
              const datas = json.data;
              if (datas.length !== pack.length) {
                errorID(4915);
              }
              for (let i = 0; i < pack.length; i++) {
                out[`${pack[i]}@import`] = packCustomObjData(textureType, {
                  base: datas[i][0],
                  mipmaps: datas[i][1]
                });
              }
            } else if (json.type === imageAssetType && json.data) {
              const datas = json.data;
              if (datas.length !== pack.length) {
                errorID(4915);
              }
              for (let i = 0; i < pack.length; i++) {
                out[`${pack[i]}@import`] = datas[i];
              }
            } else {
              err = new Error('unmatched type pack!');
              onComplete(err, null);
              return;
            }
          }
          onComplete(err, out);
        }
        init() {
          this._loading.clear();
        }
        register(type, handler) {
          if (typeof type === 'object') {
            mixin(this._unpackers, type);
          } else {
            this._unpackers[type] = handler;
          }
        }
        unpack(pack, data, type, options, onComplete) {
          if (!data) {
            onComplete(new Error('package data is wrong!'));
            return;
          }
          const unpacker = this._unpackers[type];
          unpacker(pack, data, options, onComplete);
        }
        load(item, options, onComplete) {
          if (item.isNative || !item.info || !item.info.packs) {
            downloader$1.download(item.id, item.url, item.ext, item.options, onComplete);
            return;
          }
          if (files.has(item.id)) {
            onComplete(null, files.get(item.id));
            return;
          }
          const packs = item.info.packs;
          const loadingPack = packs.find(val => this._loading.has(val.uuid));
          if (loadingPack) {
            const req = this._loading.get(loadingPack.uuid);
            assertIsTrue(req);
            req.push({
              onComplete,
              id: item.id
            });
            return;
          }
          const pack = packs[0];
          this._loading.add(pack.uuid, [{
            onComplete,
            id: item.id
          }]);
          assertIsTrue(item.config);
          const url = transform(pack.uuid, {
            ext: pack.ext,
            bundle: item.config.name
          });
          downloader$1.download(pack.uuid, url, pack.ext, item.options, (err, data) => {
            files.remove(pack.uuid);
            if (err) {
              error(err.message, err.stack);
            }
            this.unpack(pack.packedUuids, data, pack.ext, item.options, (err2, result) => {
              if (!err2) {
                for (const id in result) {
                  files.add(id, result[id]);
                }
              }
              const callbacks = this._loading.remove(pack.uuid);
              assertIsTrue(callbacks);
              for (let i = 0, l = callbacks.length; i < l; i++) {
                const cb = callbacks[i];
                if (err || err2) {
                  cb.onComplete(err || err2);
                  continue;
                }
                const unpackedData = result[cb.id];
                if (!unpackedData) {
                  cb.onComplete(new Error('can not retrieve data from package'));
                } else {
                  cb.onComplete(null, unpackedData);
                }
              }
            });
          });
        }
      }
      var packManager = new PackManager();

      function fetch(task, done) {
        let firstTask = false;
        if (!task.progress) {
          task.progress = {
            finish: 0,
            total: task.input.length,
            canInvoke: true
          };
          firstTask = true;
        }
        const {
          options,
          progress
        } = task;
        const depends = [];
        const total = progress.total;
        const exclude = options.__exclude__ = options.__exclude__ || Object.create(null);
        task.output = [];
        forEach(task.input, (item, cb) => {
          if (!item.isNative && assets.has(item.uuid)) {
            const asset = assets.get(item.uuid);
            item.content = asset.addRef();
            task.output.push(item);
            if (progress.canInvoke) {
              task.dispatch('progress', ++progress.finish, progress.total, item);
            }
            cb();
            return;
          }
          packManager.load(item, task.options, (err, data) => {
            if (err) {
              if (!task.isFinished) {
                if (!legacyCC.assetManager.force || firstTask) {
                  error(err.message, err.stack);
                  progress.canInvoke = false;
                  done(err);
                } else {
                  task.output.push(item);
                  if (progress.canInvoke) {
                    task.dispatch('progress', ++progress.finish, progress.total, item);
                  }
                }
              }
            } else if (!task.isFinished) {
              item.file = data;
              task.output.push(item);
              if (!item.isNative) {
                exclude[item.uuid] = true;
                getDepends(item.uuid, data, exclude, depends, item.config);
                progress.total = total + depends.length;
              }
              if (progress.canInvoke) {
                task.dispatch('progress', ++progress.finish, progress.total, item);
              }
            }
            cb();
          });
        }, () => {
          if (task.isFinished) {
            clear(task, true);
            task.dispatch('error');
            return;
          }
          if (depends.length > 0) {
            const subTask = Task.create({
              input: depends,
              progress,
              options,
              onProgress: task.onProgress,
              onError: Task.prototype.recycle,
              onComplete: err => {
                if (!err) {
                  task.output.push(...subTask.output);
                  subTask.recycle();
                }
                if (firstTask) {
                  decreaseRef(task);
                }
                done(err);
              }
            });
            fetchPipeline.async(subTask);
            return;
          }
          if (firstTask) {
            decreaseRef(task);
          }
          done();
        });
      }
      function decreaseRef(task) {
        const output = task.output;
        for (let i = 0, l = output.length; i < l; i++) {
          if (output[i].content) {
            output[i].content.decRef(false);
          }
        }
      }

      class SAXParser {
        constructor() {
          this._parser = null;
          if (globalThis.DOMParser) {
            this._parser = new DOMParser();
          }
        }
        parse(xmlTxt) {
          return this._parseXML(xmlTxt);
        }
        _parseXML(textxml) {
          if (this._parser) {
            return this._parser.parseFromString(textxml, 'text/xml');
          }
          throw new Error('Dom parser is not supported in this platform!');
        }
      }
      class PlistParser extends SAXParser {
        parse(xmlTxt) {
          const xmlDoc = this._parseXML(xmlTxt);
          const plist = xmlDoc.documentElement;
          if (plist.tagName !== 'plist') {
            warnID(5100);
            return {};
          }
          let node = null;
          for (let i = 0, len = plist.childNodes.length; i < len; i++) {
            node = plist.childNodes[i];
            if (node.nodeType === 1) {
              break;
            }
          }
          return this._parseNode(node);
        }
        _parseNode(node) {
          let data = null;
          const tagName = node.tagName;
          if (tagName === 'dict') {
            data = this._parseDict(node);
          } else if (tagName === 'array') {
            data = this._parseArray(node);
          } else if (tagName === 'string') {
            if (node.childNodes.length === 1) {
              data = node.firstChild.nodeValue;
            } else {
              data = '';
              for (let i = 0; i < node.childNodes.length; i++) {
                data += node.childNodes[i].nodeValue;
              }
            }
          } else if (tagName === 'false') {
            data = false;
          } else if (tagName === 'true') {
            data = true;
          } else if (tagName === 'real') {
            data = parseFloat(node.firstChild.nodeValue);
          } else if (tagName === 'integer') {
            data = parseInt(node.firstChild.nodeValue, 10);
          }
          return data;
        }
        _parseArray(node) {
          const data = [];
          for (let i = 0, len = node.childNodes.length; i < len; i++) {
            const child = node.childNodes[i];
            if (child.nodeType !== 1) {
              continue;
            }
            data.push(this._parseNode(child));
          }
          return data;
        }
        _parseDict(node) {
          const data = {};
          let key = '';
          for (let i = 0, len = node.childNodes.length; i < len; i++) {
            const child = node.childNodes[i];
            if (child.nodeType !== 1) {
              continue;
            }
            if (child.tagName === 'key') {
              key = child.firstChild.nodeValue;
            } else {
              data[key] = this._parseNode(child);
            }
          }
          return data;
        }
      }
      const plistParser = new PlistParser();

      class Parser {
        static get instance() {
          if (!this._instance) {
            this._instance = new Parser();
          }
          return this._instance;
        }
        constructor() {
          this._parsing = new Cache();
          this._parsers = {
            '.png': this.parseImage,
            '.jpg': this.parseImage,
            '.bmp': this.parseImage,
            '.jpeg': this.parseImage,
            '.gif': this.parseImage,
            '.ico': this.parseImage,
            '.tiff': this.parseImage,
            '.webp': this.parseImage,
            '.image': this.parseImage,
            '.pvr': this.parsePVRTex,
            '.pkm': this.parsePKMTex,
            '.astc': this.parseASTCTex,
            '.plist': this.parsePlist,
            import: this.parseImport,
            '.ccon': this.parseImport,
            '.cconb': this.parseImport
          };
        }
        parseImage(file, options, onComplete) {
          if (file instanceof HTMLImageElement) {
            onComplete(null, file);
            return;
          }
          createImageBitmap(file, {
            premultiplyAlpha: 'none'
          }).then(result => {
            onComplete(null, result);
          }, err => {
            onComplete(err, null);
          });
        }
        parsePVRTex(file, options, onComplete) {
          let err = null;
          let out = null;
          try {
            out = ImageAsset$1.parseCompressedTextures(file, 0);
          } catch (e) {
            err = e;
            console.warn(err);
          }
          onComplete(err, out);
        }
        parsePKMTex(file, options, onComplete) {
          let err = null;
          let out = null;
          try {
            out = ImageAsset$1.parseCompressedTextures(file, 1);
          } catch (e) {
            err = e;
            console.warn(err);
          }
          onComplete(err, out);
        }
        parseASTCTex(file, options, onComplete) {
          let err = null;
          let out = null;
          try {
            out = ImageAsset$1.parseCompressedTextures(file, 2);
          } catch (e) {
            err = e;
            console.warn(err);
          }
          onComplete(err, out);
        }
        parsePlist(file, options, onComplete) {
          let err = null;
          const result = plistParser.parse(file);
          if (!result) {
            err = new Error('parse failed');
          }
          onComplete(err, result);
        }
        parseImport(file, options, onComplete) {
          if (!file) {
            onComplete(new Error(`The json file of asset ${options.__uuid__} is empty or missing`));
            return;
          }
          let result = null;
          let err = null;
          try {
            result = deserializeAsset(file, options);
          } catch (e) {
            err = e;
          }
          onComplete(err, result);
        }
        init() {
          this._parsing.clear();
        }
        register(type, handler) {
          if (typeof type === 'object') {
            mixin(this._parsers, type);
          } else {
            this._parsers[type] = handler;
          }
        }
        parse(id, file, type, options, onComplete) {
          const parsedAsset = parsed.get(id);
          if (parsedAsset) {
            onComplete(null, parsedAsset);
            return;
          }
          const parsing = this._parsing.get(id);
          if (parsing) {
            parsing.push(onComplete);
            return;
          }
          const parseHandler = this._parsers[type];
          if (!parseHandler) {
            onComplete(null, file);
            return;
          }
          this._parsing.add(id, [onComplete]);
          parseHandler(file, options, (err, data) => {
            if (err) {
              files.remove(id);
            } else if (!isScene(data)) {
              parsed.add(id, data);
            }
            const callbacks = this._parsing.remove(id);
            for (let i = 0, l = callbacks.length; i < l; i++) {
              callbacks[i](err, data);
            }
          });
        }
      }
      Parser._instance = void 0;
      var parser = Parser.instance;

      function load(task, done) {
        let firstTask = false;
        if (!task.progress) {
          task.progress = {
            finish: 0,
            total: task.input.length,
            canInvoke: true
          };
          firstTask = true;
        }
        const {
          options,
          progress
        } = task;
        options.__exclude__ = options.__exclude__ || Object.create(null);
        task.output = [];
        forEach(task.input, (item, cb) => {
          const subTask = Task.create({
            input: item,
            onProgress: task.onProgress,
            options,
            progress,
            onComplete: (err, result) => {
              if (err && !task.isFinished) {
                if (!legacyCC.assetManager.force || firstTask) {
                  {
                    error(err.message, err.stack);
                  }
                  progress.canInvoke = false;
                  done(err);
                } else if (progress.canInvoke) {
                  task.dispatch('progress', ++progress.finish, progress.total, item);
                }
              }
              task.output.push(result);
              subTask.recycle();
              cb(null);
            }
          });
          loadOneAssetPipeline.async(subTask);
        }, () => {
          options.__exclude__ = null;
          if (task.isFinished) {
            clear(task, true);
            task.dispatch('error');
            return;
          }
          gatherAsset(task);
          clear(task, true);
          done();
        });
      }
      const loadOneAssetPipeline = new Pipeline('loadOneAsset', [function fetch(task, done) {
        const item = task.output = task.input;
        const {
          options,
          isNative,
          uuid,
          file
        } = item;
        const {
          reloadAsset
        } = options;
        if (file || !reloadAsset && !isNative && assets.has(uuid)) {
          done();
          return;
        }
        packManager.load(item, task.options, (err, data) => {
          item.file = data;
          done(err);
        });
      }, function parse(task, done) {
        const item = task.output = task.input;
        const progress = task.progress;
        const exclude = task.options.__exclude__;
        const {
          id,
          file,
          options
        } = item;
        if (item.isNative) {
          parser.parse(id, file, item.ext, options, (err, asset) => {
            if (err) {
              done(err);
              return;
            }
            item.content = asset;
            if (progress.canInvoke) {
              task.dispatch('progress', ++progress.finish, progress.total, item);
            }
            files.remove(id);
            parsed.remove(id);
            done();
          });
        } else {
          const {
            uuid
          } = item;
          if (uuid in exclude) {
            const {
              finish,
              content,
              err,
              callbacks
            } = exclude[uuid];
            if (progress.canInvoke) {
              task.dispatch('progress', ++progress.finish, progress.total, item);
            }
            if (finish || checkCircleReference(uuid, uuid, exclude)) {
              if (content) {
                content.addRef();
              }
              item.content = content;
              done(err);
            } else {
              callbacks.push({
                done,
                item
              });
            }
          } else if (!options.reloadAsset && assets.has(uuid)) {
            const asset = assets.get(uuid);
            item.content = asset.addRef();
            if (progress.canInvoke) {
              task.dispatch('progress', ++progress.finish, progress.total, item);
            }
            done();
          } else {
            options.__uuid__ = uuid;
            parser.parse(id, file, 'import', options, (err, asset) => {
              if (err) {
                done(err);
                return;
              }
              loadDepends(task, asset, done);
            });
          }
        }
      }]);
      function loadDepends(task, asset, done) {
        const {
          input: item,
          progress
        } = task;
        const {
          uuid,
          id,
          options,
          config
        } = item;
        const {
          cacheAsset
        } = options;
        const depends = [];
        if (asset.addRef) {
          asset.addRef();
        }
        getDepends(uuid, asset, Object.create(null), depends, config);
        if (progress.canInvoke) {
          task.dispatch('progress', ++progress.finish, progress.total += depends.length, item);
        }
        const repeatItem = task.options.__exclude__[uuid] = {
          content: asset,
          finish: false,
          callbacks: [{
            done,
            item
          }]
        };
        const subTask = Task.create({
          input: depends,
          options: task.options,
          onProgress: task.onProgress,
          onError: Task.prototype.recycle,
          progress,
          onComplete: err => {
            if (asset.decRef) {
              asset.decRef(false);
            }
            repeatItem.finish = true;
            repeatItem.err = err;
            if (!err) {
              const output = Array.isArray(subTask.output) ? subTask.output : [subTask.output];
              const map = Object.create(null);
              for (const dependAsset of output) {
                if (!dependAsset) {
                  continue;
                }
                map[dependAsset instanceof Asset ? `${dependAsset._uuid}@import` : `${uuid}@native`] = dependAsset;
              }
              setProperties(uuid, asset, map);
              try {
                if (typeof asset.onLoaded === 'function' && !onLoadedInvokedMap.has(asset) && !nativeDependMap.has(asset)) {
                  asset.onLoaded();
                  onLoadedInvokedMap.add(asset);
                }
              } catch (e) {
                error(`The asset ${uuid} is invalid for some reason, detail message: ${e.message}, stack: ${e.stack}`);
              }
              files.remove(id);
              parsed.remove(id);
              cache(uuid, asset, cacheAsset);
              subTask.recycle();
            }
            const callbacks = repeatItem.callbacks;
            for (let i = 0, l = callbacks.length; i < l; i++) {
              const cb = callbacks[i];
              if (asset.addRef) {
                asset.addRef();
              }
              cb.item.content = asset;
              cb.done(err);
            }
            callbacks.length = 0;
          }
        });
        pipeline.async(subTask);
      }

      function preprocess(task, done) {
        const options = task.options;
        const subOptions = Object.create(null);
        const leftOptions = Object.create(null);
        for (const op in options) {
          switch (op) {
            case RequestType.PATH:
            case RequestType.UUID:
            case RequestType.DIR:
            case RequestType.SCENE:
            case RequestType.URL:
              break;
            case '__requestType__':
            case '__isNative__':
            case 'ext':
            case 'type':
            case '__nativeName__':
            case 'audioLoadMode':
            case 'bundle':
              subOptions[op] = options[op];
              break;
            case '__exclude__':
            case '__outputAsArray__':
              leftOptions[op] = options[op];
              break;
            default:
              subOptions[op] = options[op];
              leftOptions[op] = options[op];
              break;
          }
        }
        task.options = leftOptions;
        const subTask = Task.create({
          input: task.input,
          options: subOptions
        });
        let err = null;
        try {
          task.output = task.source = transformPipeline.sync(subTask);
        } catch (e) {
          err = e;
          for (let i = 0, l = subTask.output.length; i < l; i++) {
            subTask.output[i].recycle();
          }
        }
        subTask.recycle();
        done(err);
      }

      class RequestItem {
        constructor() {
          this.uuid = '';
          this.overrideUuid = '';
          this.url = '';
          this.ext = '.json';
          this.content = null;
          this.file = null;
          this.info = null;
          this.config = null;
          this.isNative = false;
          this.options = Object.create(null);
          this._id = '';
        }
        get id() {
          if (!this._id) {
            this._id = `${this.overrideUuid || this.uuid}@${this.isNative ? 'native' : 'import'}`;
          }
          return this._id;
        }
        static create() {
          let out;
          if (RequestItem._deadPool.length !== 0) {
            out = RequestItem._deadPool.pop();
          } else {
            out = new RequestItem();
          }
          return out;
        }
        recycle() {
          if (RequestItem._deadPool.length === RequestItem.MAX_DEAD_NUM) {
            return;
          }
          this._id = '';
          this.uuid = '';
          this.overrideUuid = '';
          this.url = '';
          this.ext = '.json';
          this.content = null;
          this.file = null;
          this.info = null;
          this.config = null;
          this.isNative = false;
          this.options = Object.create(null);
          RequestItem._deadPool.push(this);
        }
      }
      RequestItem.MAX_DEAD_NUM = 500;
      RequestItem._deadPool = [];

      const infos = [];
      function parse(task) {
        var _info2;
        const options = task.options;
        const input = Array.isArray(task.input) ? task.input : [task.input];
        task.output = [];
        for (let i = 0; i < input.length; i++) {
          let item = input[i];
          let out = RequestItem.create();
          let config = null;
          let info = null;
          if (typeof item === 'string') {
            item = Object.create(null);
            item[options.__requestType__ || RequestType.UUID] = input[i];
          }
          if (typeof item === 'object') {
            addon(item, options);
            if (item.preset) {
              addon(item, presets[item.preset]);
            }
            for (const key in item) {
              switch (key) {
                case RequestType.UUID:
                  {
                    var _info;
                    const uuid = out.uuid = decodeUuid(item.uuid);
                    if (!item.bundle) {
                      const bundle = bundles.find(bundle => !!bundle.getAssetInfo(uuid));
                      item.bundle = bundle && bundle.name;
                    }
                    if (bundles.has(item.bundle)) {
                      config = bundles.get(item.bundle).config;
                      info = config.getAssetInfo(uuid);
                      if (info && info.redirect) {
                        if (!bundles.has(info.redirect)) {
                          throw new Error(`Please load bundle ${info.redirect} first`);
                        }
                        config = bundles.get(info.redirect).config;
                        info = config.getAssetInfo(uuid);
                      }
                      out.config = config;
                      out.info = info;
                    }
                    out.ext = item.ext || ((_info = info) === null || _info === void 0 ? void 0 : _info.extension) || '.json';
                    break;
                  }
                case '__requestType__':
                case 'ext':
                case 'bundle':
                case 'preset':
                case 'type':
                  break;
                case RequestType.DIR:
                  if (bundles.has(item.bundle)) {
                    bundles.get(item.bundle).config.getDirWithPath(item.dir, item.type, infos);
                    for (const assetInfo of infos) {
                      input.push({
                        uuid: assetInfo.uuid,
                        __isNative__: false,
                        ext: assetInfo.extension || '.json',
                        bundle: item.bundle
                      });
                    }
                    infos.length = 0;
                  }
                  out.recycle();
                  out = null;
                  break;
                case RequestType.PATH:
                  if (bundles.has(item.bundle)) {
                    config = bundles.get(item.bundle).config;
                    info = config.getInfoWithPath(item.path, item.type);
                    if (info && info.redirect) {
                      if (!bundles.has(info.redirect)) {
                        throw new Error(`you need to load bundle ${info.redirect} first`);
                      }
                      config = bundles.get(info.redirect).config;
                      info = config.getAssetInfo(info.uuid);
                    }
                    if (!info) {
                      out.recycle();
                      throw new Error(`Bundle ${item.bundle} doesn't contain ${item.path}`);
                    }
                    out.config = config;
                    out.uuid = info.uuid;
                    out.info = info;
                  }
                  out.ext = item.ext || ((_info2 = info) === null || _info2 === void 0 ? void 0 : _info2.extension) || '.json';
                  break;
                case RequestType.SCENE:
                  if (!item.bundle) {
                    const bundle = bundles.find(bundle => !!bundle.getSceneInfo(item.scene));
                    item.bundle = bundle && bundle.name;
                  }
                  if (bundles.has(item.bundle)) {
                    config = bundles.get(item.bundle).config;
                    info = config.getSceneInfo(item.scene);
                    if (info && info.redirect) {
                      if (!bundles.has(info.redirect)) {
                        throw new Error(`you need to load bundle ${info.redirect} first`);
                      }
                      config = bundles.get(info.redirect).config;
                      info = config.getAssetInfo(info.uuid);
                    }
                    if (!info) {
                      out.recycle();
                      throw new Error(`Bundle ${config.name} doesn't contain scene ${item.scene}`);
                    }
                    out.config = config;
                    out.uuid = info.uuid;
                    out.info = info;
                  }
                  break;
                case '__isNative__':
                  out.isNative = item.__isNative__;
                  break;
                case RequestType.URL:
                  out.url = item.url;
                  out.uuid = item.uuid || item.url;
                  out.ext = item.ext || extname(item.url);
                  out.isNative = item.__isNative__ !== undefined ? item.__isNative__ : true;
                  break;
                default:
                  out.options[key] = item[key];
              }
              if (!out) {
                break;
              }
            }
          }
          if (!out) {
            continue;
          }
          task.output.push(out);
          if (!out.uuid && !out.url) {
            throw new Error(`Can not parse this input:${JSON.stringify(item)}`);
          }
        }
        return null;
      }
      function replaceOverrideAsset(task) {
        const input = task.output = task.input;
        for (let i = 0; i < input.length; i++) {
          const item = input[i];
          if (assetsOverrideMap.has(item.uuid)) {
            const uuid = assetsOverrideMap.get(item.uuid);
            const bundle = bundles.find(bundle => !!bundle.getAssetInfo(uuid));
            if (bundle) {
              var _info3;
              item.overrideUuid = uuid;
              let config = bundle.config;
              let info = config.getAssetInfo(uuid);
              if (info && info.redirect) {
                if (!bundles.has(info.redirect)) {
                  throw new Error(`Please load bundle ${info.redirect} first`);
                }
                config = bundles.get(info.redirect).config;
                info = config.getAssetInfo(uuid);
              }
              item.config = config;
              item.info = info;
              item.ext = item.isNative ? item.ext : ((_info3 = info) === null || _info3 === void 0 ? void 0 : _info3.extension) || '.json';
            } else {
              warnID(16201, uuid, item.uuid);
            }
          }
        }
      }
      function combine(task) {
        const input = task.output = task.input;
        for (let i = 0; i < input.length; i++) {
          const item = input[i];
          if (item.url) {
            continue;
          }
          let url = '';
          let base = '';
          const config = item.config;
          if (item.isNative) {
            base = config && config.nativeBase ? config.base + config.nativeBase : legacyCC.assetManager.generalNativeBase;
          } else {
            base = config && config.importBase ? config.base + config.importBase : legacyCC.assetManager.generalImportBase;
          }
          const uuid = item.overrideUuid || item.uuid;
          let ver = '';
          if (item.info) {
            if (item.isNative) {
              ver = item.info.nativeVer ? `.${item.info.nativeVer}` : '';
            } else {
              ver = item.info.ver ? `.${item.info.ver}` : '';
            }
          }
          if (item.ext === '.ttf') {
            url = `${base}/${uuid.slice(0, 2)}/${uuid}${ver}/${item.options.__nativeName__}`;
          } else {
            url = `${base}/${uuid.slice(0, 2)}/${uuid}${ver}${item.ext}`;
          }
          item.url = url;
        }
        return null;
      }

      const EVENT_ASSET_MISSING = 'asset-missing';
      class AssetManager {
        static get instance() {
          if (!this._instance) {
            this._instance = new AssetManager();
          }
          return this._instance;
        }
        constructor() {
          this.pipeline = pipeline.append(preprocess).append(load);
          this.fetchPipeline = fetchPipeline.append(preprocess).append(fetch);
          this.transformPipeline = transformPipeline.append(parse).append(replaceOverrideAsset).append(combine);
          this.bundles = bundles;
          this.assets = assets;
          this.assetsOverrideMap = assetsOverrideMap;
          this.generalImportBase = '';
          this.generalNativeBase = '';
          this.dependUtil = dependUtil;
          this.force = PREVIEW;
          this.allowImageBitmap = false;
          this.utils = helper;
          this.downloader = downloader$1;
          this.parser = parser;
          this.packManager = packManager;
          this.cacheAsset = true;
          this.cacheManager = null;
          this.presets = presets;
          this.factory = factory;
          this.preprocessPipe = preprocess;
          this.fetchPipe = fetch;
          this.loadPipe = load;
          this.references = references;
          this._releaseManager = releaseManager;
          this._files = files;
          this._parsed = parsed;
          this._parsePipeline = null ;
          this._projectBundles = [];
          this._eventTarget = new EventTarget();
        }
        get main() {
          return bundles.get(BuiltinBundleName.MAIN) || null;
        }
        get resources() {
          return bundles.get(BuiltinBundleName.RESOURCES) || null;
        }
        onAssetMissing(func, target) {
          this._eventTarget.on(EVENT_ASSET_MISSING, func, target);
        }
        offAssetMissing(func, target) {
          this._eventTarget.off(EVENT_ASSET_MISSING, func, target);
        }
        dispatchAssetMissing(parentAsset, owner, propName, uuid) {
          this._eventTarget.emit(EVENT_ASSET_MISSING, parentAsset, owner, propName, uuid);
        }
        init(options = {}) {
          const server = options.server || settings.querySettings(Settings.Category.ASSETS, 'server') || '';
          const bundleVers = options.bundleVers || settings.querySettings(Settings.Category.ASSETS, 'bundleVers') || {};
          const remoteBundles = options.remoteBundles || settings.querySettings(Settings.Category.ASSETS, 'remoteBundles') || [];
          this._files.clear();
          this._parsed.clear();
          this._releaseManager.init();
          this.assets.clear();
          this.bundles.clear();
          this.packManager.init();
          this.downloader.init(server, bundleVers, remoteBundles);
          this.parser.init();
          this.dependUtil.init();
          let importBase = options.importBase || settings.querySettings(Settings.Category.ASSETS, 'importBase') || '';
          if (importBase && importBase.endsWith('/')) {
            importBase = importBase.substr(0, importBase.length - 1);
          }
          let nativeBase = options.nativeBase || settings.querySettings(Settings.Category.ASSETS, 'nativeBase') || '';
          if (nativeBase && nativeBase.endsWith('/')) {
            nativeBase = nativeBase.substr(0, nativeBase.length - 1);
          }
          this.generalImportBase = importBase;
          this.generalNativeBase = nativeBase;
          this._projectBundles = settings.querySettings(Settings.Category.ASSETS, 'projectBundles') || [];
          const assetsOverride = settings.querySettings(Settings.Category.ASSETS, 'assetsOverrides') || {};
          for (const key in assetsOverride) {
            this.assetsOverrideMap.set(key, assetsOverride[key]);
          }
        }
        getBundle(name) {
          return bundles.get(name) || null;
        }
        removeBundle(bundle) {
          bundle._destroy();
          bundles.remove(bundle.name);
        }
        loadAny(requests, options, onProgress, onComplete) {
          const {
            options: opts,
            onProgress: onProg,
            onComplete: onComp
          } = parseParameters(options, onProgress, onComplete);
          opts.preset = opts.preset || 'default';
          requests = Array.isArray(requests) ? requests.slice() : requests;
          const task = Task.create({
            input: requests,
            onProgress: onProg,
            onComplete: asyncify(onComp),
            options: opts
          });
          pipeline.async(task);
        }
        preloadAny(requests, options, onProgress, onComplete) {
          const {
            options: opts,
            onProgress: onProg,
            onComplete: onComp
          } = parseParameters(options, onProgress, onComplete);
          opts.preset = opts.preset || 'preload';
          requests = Array.isArray(requests) ? requests.slice() : requests;
          const task = Task.create({
            input: requests,
            onProgress: onProg,
            onComplete: asyncify(onComp),
            options: opts
          });
          fetchPipeline.async(task);
        }
        loadRemote(url, options, onComplete) {
          const {
            options: opts,
            onComplete: onComp
          } = parseParameters(options, undefined, onComplete);
          if (!opts.reloadAsset && this.assets.has(url)) {
            asyncify(onComp)(null, this.assets.get(url));
            return;
          }
          opts.__isNative__ = true;
          opts.preset = opts.preset || 'remote';
          this.loadAny({
            url
          }, opts, null, (err, data) => {
            if (err) {
              error(err.message, err.stack);
              if (onComp) {
                onComp(err, data);
              }
            } else {
              factory.create(url, data, opts.ext || extname(url), opts, (p1, p2) => {
                if (onComp) {
                  onComp(p1, p2);
                }
              });
            }
          });
        }
        loadBundle(nameOrUrl, options, onComplete) {
          const {
            options: opts,
            onComplete: onComp
          } = parseParameters(options, undefined, onComplete);
          const bundleName = basename(nameOrUrl);
          if (this.bundles.has(bundleName)) {
            asyncify(onComp)(null, this.getBundle(bundleName));
            return;
          }
          opts.preset = opts.preset || 'bundle';
          opts.ext = 'bundle';
          opts.__isNative__ = true;
          this.loadAny({
            url: nameOrUrl
          }, opts, null, (err, data) => {
            if (err) {
              error(err.message, err.stack);
              if (onComp) {
                onComp(err, data);
              }
            } else {
              factory.create(nameOrUrl, data, 'bundle', opts, (p1, p2) => {
                if (onComp) {
                  onComp(p1, p2);
                }
              });
            }
          });
        }
        releaseAsset(asset) {
          releaseManager.tryRelease(asset, true);
        }
        releaseUnusedAssets() {
          assets.forEach(asset => {
            releaseManager.tryRelease(asset);
          });
        }
        releaseAll() {
          assets.forEach(asset => {
            releaseManager.tryRelease(asset, true);
          });
        }
        loadWithJson(json, options, onProgress, onComplete) {
          {
            throw new Error('Only valid in Editor');
          }
        }
      } exports('AssetManager', AssetManager);
      AssetManager._instance = void 0;
      AssetManager.Pipeline = Pipeline;
      AssetManager.Task = Task;
      AssetManager.Cache = Cache;
      AssetManager.RequestItem = RequestItem;
      AssetManager.Bundle = Bundle;
      AssetManager.BuiltinBundleName = BuiltinBundleName;
      AssetManager.CacheManager = CacheManager;
      AssetManager.Downloader = Downloader;
      AssetManager.Parser = Parser;
      AssetManager.DependUtil = DependUtil;
      const assetManager = exports('assetManager', legacyCC.assetManager = AssetManager.instance);
      legacyCC.AssetManager = AssetManager;

      const ImageFmts = ['.png', '.jpg', '.bmp', '.jpeg', '.gif', '.ico', '.tiff', '.webp', '.image', '.pvr', '.pkm', '.astc'];
      const AudioFmts = ['.mp3', '.ogg', '.wav', '.m4a'];
      function GetTrue() {
        return true;
      }
      const md5Pipe = {
        transformURL(url) {
          const uuid = getUuidFromURL(url);
          if (!uuid) {
            return url;
          }
          const bundle = bundles.find(b => !!b.getAssetInfo(uuid));
          if (!bundle) {
            return url;
          }
          let hashValue = '';
          const info = bundle.getAssetInfo(uuid);
          if (url.startsWith(bundle.base + bundle.config.nativeBase)) {
            hashValue = info.nativeVer || '';
          } else {
            hashValue = info.ver || '';
          }
          if (!hashValue || url.indexOf(hashValue) !== -1) {
            return url;
          }
          let hashPatchInFolder = false;
          if (extname(url) === '.ttf') {
            hashPatchInFolder = true;
          }
          if (hashPatchInFolder) {
            const dirname$1 = dirname(url);
            const basename$1 = basename(url);
            url = `${dirname$1}.${hashValue}/${basename$1}`;
          } else {
            url = url.replace(/.*[/\\][0-9a-fA-F]{2}[/\\]([0-9a-fA-F-@]{8,})/, (match, uuid) => `${match}.${hashValue}`);
          }
          return url;
        }
      };
      class CCLoader {
        constructor() {
          this._autoReleaseSetting = Object.create(null);
          this._parseLoadResArgs = parseLoadResArgs;
        }
        set onProgress(val) {
          setDefaultProgressCallback(val);
        }
        get _cache() {
          if (assets instanceof Cache) {
            return assets.map;
          } else {
            const map = {};
            assets.forEach((val, key) => {
              map[key] = val;
            });
            return map;
          }
        }
        load(res, progressCallback, completeCallback) {
          if (completeCallback === undefined) {
            if (progressCallback !== undefined) {
              completeCallback = progressCallback;
              progressCallback = null;
            }
          }
          const requests = Array.isArray(res) ? res : [res];
          for (let i = 0; i < requests.length; i++) {
            const item = requests[i];
            if (typeof item === 'string') {
              requests[i] = {
                url: item,
                __isNative__: true
              };
            } else {
              if (item.type) {
                item.ext = `.${item.type}`;
                item.type = undefined;
              }
              if (item.url) {
                item.__isNative__ = true;
              }
            }
          }
          const images = [];
          const audios = [];
          assetManager.loadAny(requests, null, (finish, total, item) => {
            if (item.content) {
              if (ImageFmts.includes(item.ext)) {
                images.push(item.content);
              } else if (AudioFmts.includes(item.ext)) {
                audios.push(item.content);
              }
            }
            if (progressCallback) {
              progressCallback(finish, total, item);
            }
          }, (err, native) => {
            let out = null;
            if (!err) {
              native = Array.isArray(native) ? native : [native];
              for (let i = 0; i < native.length; i++) {
                const item = native[i];
                if (!(item instanceof Asset)) {
                  let asset = item;
                  const url = requests[i].url;
                  if (images.includes(asset)) {
                    factory.create(url, item, '.png', {}, (err, image) => {
                      asset = native[i] = image;
                    });
                  } else if (audios.includes(asset)) {
                    factory.create(url, item, '.mp3', {}, (err, audio) => {
                      asset = native[i] = audio;
                    });
                  }
                  assets.add(url, asset);
                }
              }
              if (native.length > 1) {
                const map = Object.create(null);
                native.forEach(asset => {
                  map[asset._uuid] = asset;
                });
                out = {
                  isCompleted: GetTrue,
                  _map: map
                };
              } else {
                out = native[0];
              }
            }
            if (completeCallback) {
              completeCallback(err, out);
            }
          });
        }
        getXMLHttpRequest() {
          return new XMLHttpRequest();
        }
        getItem(id) {
          return assetManager.assets.has(id) ? {
            content: assetManager.assets.get(id)
          } : null;
        }
        loadRes(url, type, progressCallback, completeCallback) {
          const {
            type: _type,
            onProgress,
            onComplete
          } = this._parseLoadResArgs(type, progressCallback, completeCallback);
          const extname$1 = extname(url);
          if (extname$1 && !resources.getInfoWithPath(url, _type)) {
            url = url.slice(0, -extname$1.length);
          }
          resources.load(url, _type, onProgress, onComplete);
        }
        loadResArray(urls, type, progressCallback, completeCallback) {
          const {
            type: _type,
            onProgress,
            onComplete
          } = this._parseLoadResArgs(type, progressCallback, completeCallback);
          urls.forEach((url, i) => {
            const extname$1 = extname(url);
            if (extname$1 && !resources.getInfoWithPath(url, _type)) {
              urls[i] = url.slice(0, -extname$1.length);
            }
          });
          resources.load(urls, _type, onProgress, onComplete);
        }
        loadResDir(url, type, progressCallback, completeCallback) {
          const {
            type: _type,
            onProgress,
            onComplete
          } = this._parseLoadResArgs(type, progressCallback, completeCallback);
          resources.loadDir(url, _type, onProgress, (err, out) => {
            let urls = [];
            if (!err) {
              const infos = resources.getDirWithPath(url, _type);
              urls = infos.map(info => info.path);
            }
            if (onComplete) {
              onComplete(err, out, urls);
            }
          });
        }
        getRes(url, type) {
          return assets.has(url) ? assets.get(url) : resources.get(url, type);
        }
        getResCount() {
          return assets.count;
        }
        getDependsRecursively(owner) {
          if (!owner) {
            return [];
          }
          const uuid = typeof owner === 'string' ? owner : owner._uuid;
          return dependUtil.getDepsRecursively(uuid).concat([uuid]);
        }
        get md5Pipe() {
          return md5Pipe;
        }
        get downloader() {
          return downloader$1;
        }
        get loader() {
          return assetManager.parser;
        }
        addDownloadHandlers(extMap) {
          const handler = Object.create(null);
          for (const type in extMap) {
            const func = extMap[type];
            handler[`.${type}`] = (url, options, onComplete) => {
              func({
                url
              }, onComplete);
            };
          }
          downloader$1.register(handler);
        }
        addLoadHandlers(extMap) {
          const handler = Object.create(null);
          for (const type in extMap) {
            const func = extMap[type];
            handler[`.${type}`] = (file, options, onComplete) => {
              func({
                content: file
              }, onComplete);
            };
          }
          parser.register(handler);
        }
        release(asset) {
          if (Array.isArray(asset)) {
            for (let i = 0; i < asset.length; i++) {
              let key = asset[i];
              if (typeof key === 'string') {
                key = assets.get(key);
              }
              assetManager.releaseAsset(key);
            }
          } else if (asset) {
            if (typeof asset === 'string') {
              asset = assets.get(asset);
            }
            assetManager.releaseAsset(asset);
          }
        }
        releaseAsset(asset) {
          assetManager.releaseAsset(asset);
        }
        releaseRes(res, type) {
          resources.release(res, type);
        }
        releaseAll() {
          assetManager.releaseAll();
          assets.clear();
        }
        removeItem(id) {
          return !!assets.remove(id);
        }
        setAutoRelease(asset, autoRelease) {
          if (typeof asset === 'object') {
            asset = asset._uuid;
          }
          this._autoReleaseSetting[asset] = !!autoRelease;
        }
        setAutoReleaseRecursively(asset, autoRelease) {
          if (typeof asset === 'object') {
            asset = asset._uuid;
          }
          autoRelease = !!autoRelease;
          this._autoReleaseSetting[asset] = autoRelease;
          const depends = dependUtil.getDepsRecursively(asset);
          for (let i = 0; i < depends.length; i++) {
            this._autoReleaseSetting[depends[i]] = autoRelease;
          }
        }
        isAutoRelease(asset) {
          if (typeof asset === 'object') {
            asset = asset._uuid;
          }
          return !!this._autoReleaseSetting[asset];
        }
      } exports('CCLoader', CCLoader);
      const loader = exports('loader', new CCLoader());
      const AssetLibrary = exports('AssetLibrary', {
        init(options) {
          options.importBase = options.libraryPath;
          options.nativeBase = options.rawAssetsBase ;
          assetManager.init(options);
          if (options.rawAssets) {
            resources.init({
              base: '',
              deps: [],
              scenes: {},
              redirect: [],
              debug: true,
              packs: {},
              types: [],
              versions: {
                import: [],
                native: []
              },
              name: BuiltinBundleName.RESOURCES,
              importBase: options.importBase,
              nativeBase: options.nativeBase,
              paths: options.rawAssets.assets,
              uuids: Object.keys(options.rawAssets.assets),
              extensionMap: {}
            });
          }
        },
        loadAsset(uuid, callback, options) {
          assetManager.loadAny(uuid, callback);
        }
      });
      const url = exports('url', {});
      replaceProperty(url, 'url', [{
        name: 'normalize',
        target: assetManager.utils,
        targetName: 'assetManager.utils',
        newName: 'normalize'
      }, {
        name: 'raw',
        targetName: 'Asset.prototype',
        newName: 'nativeUrl',
        customFunction: url => {
          if (url.startsWith('resources/')) {
            return transform({
              path: changeExtname(url.substr(10)),
              bundle: BuiltinBundleName.RESOURCES,
              __isNative__: true,
              ext: extname(url)
            });
          }
          return '';
        }
      }]);
      removeProperty(AssetLibrary, 'AssetLibrary', [{
        name: 'getLibUrlNoExt',
        suggest: 'AssetLibrary.getLibUrlNoExt was removed, if you want to transform url, please use assetManager.utils.getUrlWithUuid instead'
      }, {
        name: 'queryAssetInfo',
        suggest: 'AssetLibrary.queryAssetInfo was removed'
      }]);
      removeProperty(loader, 'loader', [{
        name: 'releaseResDir',
        suggest: 'loader.releaseResDir was removed, please use assetManager.releaseAsset instead'
      }, {
        name: 'flowInDeps',
        suggest: 'loader.flowInDeps was removed'
      }, {
        name: 'assetLoader',
        suggest: 'loader.assetLoader was removed, assetLoader and md5Pipe were merged into assetManager.transformPipeline'
      }]);
      replaceProperty(legacyCC, 'cc', [{
        name: 'loader',
        newName: 'assetManager',
        logTimes: 1,
        customGetter: () => loader
      }, {
        name: 'AssetLibrary',
        newName: 'assetManager',
        logTimes: 1,
        customGetter: () => AssetLibrary
      }, {
        name: 'Pipeline',
        target: AssetManager,
        targetName: 'AssetManager',
        newName: 'Pipeline',
        logTimes: 1
      }, {
        name: 'url',
        targetName: 'assetManager',
        newName: 'utils',
        logTimes: 1,
        customGetter: () => url
      }]);
      removeProperty(legacyCC, 'cc', [{
        name: 'LoadingItems',
        suggest: getError(1400, 'LoadingItems', 'AssetManager.Task')
      }]);
      replaceProperty(macro, 'macro', [{
        name: 'DOWNLOAD_MAX_CONCURRENT',
        target: downloader$1,
        targetName: 'assetManager.downloader',
        newName: 'maxConcurrency'
      }]);
      const _autoRelease = releaseManager._autoRelease;
      releaseManager._autoRelease = function (oldScene, newScene, persistNodes) {
        _autoRelease.call(releaseManager, oldScene, newScene, persistNodes);
        const releaseSettings = loader._autoReleaseSetting;
        const keys = Object.keys(releaseSettings);
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          if (releaseSettings[key] === true) {
            const asset = assets.get(key);
            if (asset) {
              releaseManager.tryRelease(asset);
            }
          }
        }
      };

      const Texture2D = jsb.Texture2D;
      const ImageAsset = jsb.ImageAsset;
      const BuiltinResMgr = jsb.BuiltinResMgr;
      const builtinResMgrProto = BuiltinResMgr.prototype;
      builtinResMgrProto.init = function () {
        this._resources = {};
        this._materialsToBeCompiled = [];
        const resources = this._resources;
        const len = 2;
        const numChannels = 4;
        const blackValueView = new Uint8Array(len * len * numChannels);
        for (let i = 0; i < len * len; i++) {
          const offset = i * numChannels;
          blackValueView[offset] = 0;
          blackValueView[offset + 1] = 0;
          blackValueView[offset + 2] = 0;
          blackValueView[offset + 3] = 255;
        }
        const blackMemImageSource = {
          width: len,
          height: len,
          _data: blackValueView,
          _compressed: false,
          format: Texture2D.PixelFormat.RGBA8888
        };
        const imgAsset = new ImageAsset(blackMemImageSource);
        const blackTexture = new Texture2D();
        blackTexture._uuid = 'black-texture';
        blackTexture.image = imgAsset;
        resources[blackTexture._uuid] = blackTexture;
        if (legacyCC.SpriteFrame) {
          const spriteFrame = new legacyCC.SpriteFrame();
          const image = imgAsset;
          const texture = new Texture2D();
          texture.image = image;
          spriteFrame.texture = texture;
          spriteFrame._uuid = 'default-spriteframe';
          resources[spriteFrame._uuid] = spriteFrame;
        }
        this.initBuiltinRes();
      };
      builtinResMgrProto.get = function (uuid) {
        const res = this._resources[uuid];
        return res || this.getAsset(uuid);
      };
      builtinResMgrProto.compileBuiltinMaterial = function () {
        for (let i = 0; i < this._materialsToBeCompiled.length; ++i) {
          const mat = this._materialsToBeCompiled[i];
          for (let j = 0; j < mat.passes.length; ++j) {
            mat.passes[j].tryCompile();
          }
        }
        this._materialsToBeCompiled.length = 0;
      };
      builtinResMgrProto.loadBuiltinAssets = function () {
        const builtinAssets = settings.querySettings(Settings.Category.ENGINE, 'builtinAssets');
        if (!builtinAssets) return Promise.resolve();
        const resources = this._resources;
        return new Promise((resolve, reject) => {
          assetManager.loadBundle(BuiltinBundleName.INTERNAL, (err, bundle) => {
            if (err) {
              reject(err);
              return;
            }
            assetManager.loadAny(builtinAssets, (err, assets) => {
              if (err) {
                reject(err);
              } else {
                assets.forEach(asset => {
                  resources[asset.name] = asset;
                  asset.nativeUrl;
                  releaseManager.addIgnoredAsset(asset);
                  this.addAsset(asset.name, asset);
                  if (asset instanceof legacyCC.Material) {
                    this._materialsToBeCompiled.push(asset);
                  }
                });
                resolve();
              }
            });
          });
        });
      };
      const builtinResMgr = exports('builtinResMgr', legacyCC.builtinResMgr = BuiltinResMgr.getInstance());

      class Director extends EventTarget {
        constructor() {
          super();
          this._compScheduler = void 0;
          this._nodeActivator = void 0;
          this._invalid = void 0;
          this._paused = void 0;
          this._root = void 0;
          this._loadingScene = void 0;
          this._scene = void 0;
          this._totalFrames = void 0;
          this._scheduler = void 0;
          this._systems = void 0;
          this._persistRootNodes = {};
          this._invalid = false;
          this._paused = false;
          this._root = null;
          this._loadingScene = '';
          this._scene = null;
          this._totalFrames = 0;
          this._scheduler = new Scheduler();
          this._compScheduler = new ComponentScheduler();
          this._nodeActivator = new NodeActivator();
          this._systems = [];
        }
        calculateDeltaTime(now) {}
        end() {
          this.once(Director.EVENT_END_FRAME, () => {
            this.purgeDirector();
          });
        }
        pause() {
          if (this._paused) {
            return;
          }
          this._paused = true;
        }
        purgeDirector() {
          this._scheduler.unscheduleAll();
          this._compScheduler.unscheduleAll();
          this._nodeActivator.reset();
          {
            if (isValid(this._scene)) {
              this._scene.destroy();
            }
            this._scene = null;
          }
          this.stopAnimation();
          assetManager.releaseAll();
        }
        reset() {
          var _this$getScene;
          this.purgeDirector();
          for (const id in this._persistRootNodes) {
            this.removePersistRootNode(this._persistRootNodes[id]);
          }
          (_this$getScene = this.getScene()) === null || _this$getScene === void 0 ? void 0 : _this$getScene.destroy();
          this.emit(Director.EVENT_RESET);
          this.startAnimation();
        }
        runSceneImmediate(scene, onBeforeLoadScene, onLaunched) {
          if (scene instanceof SceneAsset) scene = scene.scene;
          assertID(scene instanceof Scene, 1216);
          {
            console.time('InitScene');
          }
          scene._load();
          {
            console.timeEnd('InitScene');
          }
          {
            console.time('AttachPersist');
          }
          const persistNodeList = Object.keys(this._persistRootNodes).map(x => this._persistRootNodes[x]);
          for (let i = 0; i < persistNodeList.length; i++) {
            const node = persistNodeList[i];
            node.emit(Node$1.EventType.SCENE_CHANGED_FOR_PERSISTS, scene.renderScene);
            const existNode = scene.uuid === node._originalSceneId && scene.getChildByUuid(node.uuid);
            if (existNode) {
              const index = existNode.getSiblingIndex();
              node.hideFlags &= ~CCObject.Flags.DontSave;
              node.hideFlags |= CCObject.Flags.DontSave & existNode.hideFlags;
              existNode._destroyImmediate();
              scene.insertChild(node, index);
            } else {
              node.hideFlags |= CCObject.Flags.DontSave;
              node.parent = scene;
            }
          }
          {
            console.timeEnd('AttachPersist');
          }
          const oldScene = this._scene;
          {
            console.time('Destroy');
          }
          if (isValid(oldScene)) {
            oldScene.destroy();
          }
          {
            {
              console.time('AutoRelease');
            }
            releaseManager._autoRelease(oldScene, scene, this._persistRootNodes);
            {
              console.timeEnd('AutoRelease');
            }
          }
          this._scene = null;
          CCObject._deferredDestroy();
          {
            console.timeEnd('Destroy');
          }
          if (onBeforeLoadScene) {
            onBeforeLoadScene();
          }
          this.emit(Director.EVENT_BEFORE_SCENE_LAUNCH, scene);
          this._scene = scene;
          {
            console.time('Activate');
          }
          scene._activate();
          {
            console.timeEnd('Activate');
          }
          if (this._root) {
            this._root.resetCumulativeTime();
          }
          this.startAnimation();
          if (onLaunched) {
            onLaunched(null, scene);
          }
          this.emit(Director.EVENT_AFTER_SCENE_LAUNCH, scene);
        }
        runScene(scene, onBeforeLoadScene, onLaunched) {
          if (scene instanceof SceneAsset) scene = scene.scene;
          assertID(Boolean(scene), 1205);
          assertID(scene instanceof Scene, 1216);
          this.once(Director.EVENT_END_FRAME, () => {
            this.runSceneImmediate(scene, onBeforeLoadScene, onLaunched);
          });
        }
        loadScene(sceneName, onLaunched, onUnloaded) {
          if (this._loadingScene) {
            warnID(1208, sceneName, this._loadingScene);
            return false;
          }
          const bundle = assetManager.bundles.find(bundle => !!bundle.getSceneInfo(sceneName));
          if (bundle) {
            this.emit(Director.EVENT_BEFORE_SCENE_LOADING, sceneName);
            this._loadingScene = sceneName;
            console.time(`LoadScene ${sceneName}`);
            bundle.loadScene(sceneName, (err, scene) => {
              console.timeEnd(`LoadScene ${sceneName}`);
              this._loadingScene = '';
              if (err) {
                error(err);
                if (onLaunched) {
                  onLaunched(err);
                }
              } else {
                this.runSceneImmediate(scene, onUnloaded, onLaunched);
              }
            });
            return true;
          } else {
            errorID(1209, sceneName);
            return false;
          }
        }
        preloadScene(sceneName, onProgress, onLoaded) {
          const bundle = assetManager.bundles.find(bundle => !!bundle.getSceneInfo(sceneName));
          if (bundle) {
            bundle.preloadScene(sceneName, null, onProgress, onLoaded);
          } else {
            const err = `Can not preload the scene "${sceneName}" because it is not in the build settings.`;
            if (onLoaded) {
              onLoaded(new Error(err));
            }
            error(`preloadScene: ${err}`);
          }
        }
        resume() {
          if (!this._paused) {
            return;
          }
          this._paused = false;
        }
        get root() {
          return this._root;
        }
        getScene() {
          return this._scene;
        }
        getDeltaTime() {
          return legacyCC.game.deltaTime;
        }
        getTotalTime() {
          return legacyCC.game.totalTime;
        }
        getCurrentTime() {
          return legacyCC.game.frameStartTime;
        }
        getTotalFrames() {
          return this._totalFrames;
        }
        isPaused() {
          return this._paused;
        }
        getScheduler() {
          return this._scheduler;
        }
        setScheduler(scheduler) {
          if (this._scheduler !== scheduler) {
            this.unregisterSystem(this._scheduler);
            this._scheduler = scheduler;
            this.registerSystem(Scheduler.ID, scheduler, 200);
          }
        }
        registerSystem(name, sys, priority) {
          sys.id = name;
          sys.priority = priority;
          this._systems.push(sys);
          this._systems.sort(System.sortByPriority);
        }
        unregisterSystem(sys) {
          fastRemove(this._systems, sys);
          this._systems.sort(System.sortByPriority);
        }
        getSystem(name) {
          return this._systems.find(sys => sys.id === name);
        }
        getAnimationManager() {
          return this.getSystem(legacyCC.AnimationManager.ID);
        }
        startAnimation() {
          this._invalid = false;
        }
        stopAnimation() {
          this._invalid = true;
        }
        mainLoop(now) {
          let dt;
          {
            dt = legacyCC.game._calculateDT(now);
          }
          this.tick(dt);
        }
        tick(dt) {
          if (!this._invalid) {
            this.emit(Director.EVENT_BEGIN_FRAME);
            {
              input._frameDispatchEvents();
            }
            if (!this._paused) {
              this.emit(Director.EVENT_BEFORE_UPDATE);
              this._compScheduler.startPhase();
              this._compScheduler.updatePhase(dt);
              for (let i = 0; i < this._systems.length; ++i) {
                this._systems[i].update(dt);
              }
              this._compScheduler.lateUpdatePhase(dt);
              this.emit(Director.EVENT_AFTER_UPDATE);
              CCObject._deferredDestroy();
              for (let i = 0; i < this._systems.length; ++i) {
                this._systems[i].postUpdate(dt);
              }
            }
            this.emit(Director.EVENT_BEFORE_DRAW);
            uiRendererManager.updateAllDirtyRenderers();
            this._root.frameMove(dt);
            this.emit(Director.EVENT_AFTER_DRAW);
            Node$1.resetHasChangedFlags();
            Node$1.clearNodeArray();
            scalableContainerManager.update(dt);
            this.emit(Director.EVENT_END_FRAME);
            this._totalFrames++;
          }
        }
        buildRenderPipeline() {
          if (this._root) {
            this._root.customPipeline.beginSetup();
            const builder = legacyCC.rendering.getCustomPipeline(macro.CUSTOM_PIPELINE_NAME);
            builder.setup(this._root.cameraList, this._root.customPipeline);
            this._root.customPipeline.endSetup();
          }
        }
        setupRenderPipelineBuilder() {
          if (macro.CUSTOM_PIPELINE_NAME !== '' && legacyCC.rendering && this._root && this._root.usesCustomPipeline) {
            this.on(Director.EVENT_BEFORE_RENDER, this.buildRenderPipeline, this);
          }
        }
        init() {
          this._totalFrames = 0;
          this._paused = false;
          this.registerSystem(Scheduler.ID, this._scheduler, 200);
          this._root = new Root(deviceManager.gfxDevice);
          const rootInfo = {};
          this._root.initialize(rootInfo);
          this.setupRenderPipelineBuilder();
          for (let i = 0; i < this._systems.length; i++) {
            this._systems[i].init();
          }
          this.emit(Director.EVENT_INIT);
        }
        addPersistRootNode(node) {
          if (!Node$1.isNode(node) || !node.uuid) {
            warnID(3800);
            return;
          }
          const id = node.uuid;
          if (!this._persistRootNodes[id]) {
            const scene = this._scene;
            if (isValid(scene)) {
              if (!node.parent) {
                node.parent = scene;
                node._originalSceneId = scene.uuid;
              } else if (!(node.parent instanceof Scene)) {
                warnID(3801);
                return;
              } else if (node.parent !== scene) {
                warnID(3802);
                return;
              } else {
                node._originalSceneId = scene.uuid;
              }
            }
            this._persistRootNodes[id] = node;
            node._persistNode = true;
            releaseManager._addPersistNodeRef(node);
          }
        }
        removePersistRootNode(node) {
          const id = node.uuid || '';
          if (node === this._persistRootNodes[id]) {
            delete this._persistRootNodes[id];
            node._persistNode = false;
            node._originalSceneId = '';
            releaseManager._removePersistNodeRef(node);
          }
        }
        isPersistRootNode(node) {
          return !!node._persistNode;
        }
      } exports('Director', Director);
      Director.EVENT_INIT = 'director_init';
      Director.EVENT_RESET = 'director_reset';
      Director.EVENT_BEFORE_SCENE_LOADING = 'director_before_scene_loading';
      Director.EVENT_BEFORE_SCENE_LAUNCH = 'director_before_scene_launch';
      Director.EVENT_AFTER_SCENE_LAUNCH = 'director_after_scene_launch';
      Director.EVENT_BEFORE_UPDATE = 'director_before_update';
      Director.EVENT_AFTER_UPDATE = 'director_after_update';
      Director.EVENT_BEFORE_DRAW = 'director_before_draw';
      Director.EVENT_AFTER_DRAW = 'director_after_draw';
      Director.EVENT_BEFORE_COMMIT = 'director_before_commit';
      Director.EVENT_BEFORE_RENDER = 'director_before_render';
      Director.EVENT_AFTER_RENDER = 'director_after_render';
      Director.EVENT_BEFORE_PHYSICS = 'director_before_physics';
      Director.EVENT_AFTER_PHYSICS = 'director_after_physics';
      Director.EVENT_BEGIN_FRAME = 'director_begin_frame';
      Director.EVENT_END_FRAME = 'director_end_frame';
      Director.instance = void 0;
      legacyCC.Director = Director;
      const director = exports('director', Director.instance = legacyCC.director = new Director());

      const ccwindow = typeof globalThis.jsb !== 'undefined' ? typeof jsb.window !== 'undefined' ? jsb.window : window : window;
      const ccdocument$2 = ccwindow.document;
      function findCanvas() {
        const container = ccdocument$2.createElement('div');
        const frame = ccdocument$2.documentElement;
        const canvas = ccwindow.__canvas;
        return {
          frame,
          canvas,
          container
        };
      }
      function loadJsFile(path) {
        if (window.oh) {
          window.oh.loadModule(path);
          return Promise.resolve();
        } else {
          return require(`${path}`);
        }
      }

      class Pacer {
        constructor() {
          this._rafHandle = 0;
          this._onTick = null;
          this._targetFrameRate = 60;
          this._isPlaying = false;
          this._updateCallback = void 0;
          this._updateCallback = () => {
            if (this._isPlaying) {
              this._rafHandle = requestAnimationFrame(this._updateCallback);
            }
            if (this._onTick) {
              this._onTick();
            }
          };
        }
        get targetFrameRate() {
          return this._targetFrameRate;
        }
        set targetFrameRate(val) {
          if (this._targetFrameRate !== val) {
            assertIsTrue(val > 0);
            this._targetFrameRate = val;
            jsb.setPreferredFramesPerSecond(this._targetFrameRate);
            if (this._isPlaying) {
              this.stop();
              this.start();
            }
          }
        }
        set onTick(val) {
          this._onTick = val;
        }
        get onTick() {
          return this._onTick;
        }
        start() {
          if (this._isPlaying) return;
          this._rafHandle = requestAnimationFrame(this._updateCallback);
          this._isPlaying = true;
        }
        stop() {
          if (!this._isPlaying) return;
          cancelAnimationFrame(this._rafHandle);
          this._rafHandle = 0;
          this._isPlaying = false;
        }
      }

      let XREye;
      (function (XREye) {
        XREye[XREye["NONE"] = -1] = "NONE";
        XREye[XREye["LEFT"] = 0] = "LEFT";
        XREye[XREye["RIGHT"] = 1] = "RIGHT";
      })(XREye || (XREye = {}));
      let XRConfigKey;
      (function (XRConfigKey) {
        XRConfigKey[XRConfigKey["SESSION_RUNNING"] = 2] = "SESSION_RUNNING";
        XRConfigKey[XRConfigKey["VIEW_COUNT"] = 6] = "VIEW_COUNT";
        XRConfigKey[XRConfigKey["SWAPCHAIN_WIDTH"] = 7] = "SWAPCHAIN_WIDTH";
        XRConfigKey[XRConfigKey["SWAPCHAIN_HEIGHT"] = 8] = "SWAPCHAIN_HEIGHT";
        XRConfigKey[XRConfigKey["DEVICE_IPD"] = 37] = "DEVICE_IPD";
        XRConfigKey[XRConfigKey["SPLIT_AR_GLASSES"] = 42] = "SPLIT_AR_GLASSES";
      })(XRConfigKey || (XRConfigKey = {}));
      let XRPoseType;
      (function (XRPoseType) {
        XRPoseType[XRPoseType["VIEW_LEFT"] = 0] = "VIEW_LEFT";
        XRPoseType[XRPoseType["HAND_LEFT"] = 1] = "HAND_LEFT";
        XRPoseType[XRPoseType["AIM_LEFT"] = 2] = "AIM_LEFT";
        XRPoseType[XRPoseType["VIEW_RIGHT"] = 3] = "VIEW_RIGHT";
        XRPoseType[XRPoseType["HAND_RIGHT"] = 4] = "HAND_RIGHT";
        XRPoseType[XRPoseType["AIM_RIGHT"] = 5] = "AIM_RIGHT";
        XRPoseType[XRPoseType["HEAD_MIDDLE"] = 6] = "HEAD_MIDDLE";
      })(XRPoseType || (XRPoseType = {}));

      const v2_0 = new Vec2();
      class SplashScreen {
        get isFinished() {
          return this._curTime >= this.settings.totalTime;
        }
        set curTime(val) {
          this._curTime = val;
        }
        get curTime() {
          return this._curTime;
        }
        init() {
          var _settings$querySettin, _settings$querySettin2, _settings$querySettin3, _settings$querySettin4, _settings$querySettin5, _settings$querySettin6;
          this.settings = {
            displayRatio: (_settings$querySettin = settings.querySettings(Settings.Category.SPLASH_SCREEN, 'displayRatio')) !== null && _settings$querySettin !== void 0 ? _settings$querySettin : 0.4,
            totalTime: (_settings$querySettin2 = settings.querySettings(Settings.Category.SPLASH_SCREEN, 'totalTime')) !== null && _settings$querySettin2 !== void 0 ? _settings$querySettin2 : 3000,
            watermarkLocation: (_settings$querySettin3 = settings.querySettings(Settings.Category.SPLASH_SCREEN, 'watermarkLocation')) !== null && _settings$querySettin3 !== void 0 ? _settings$querySettin3 : 'default',
            autoFit: (_settings$querySettin4 = settings.querySettings(Settings.Category.SPLASH_SCREEN, 'autoFit')) !== null && _settings$querySettin4 !== void 0 ? _settings$querySettin4 : true,
            logo: (_settings$querySettin5 = settings.querySettings(Settings.Category.SPLASH_SCREEN, 'logo')) !== null && _settings$querySettin5 !== void 0 ? _settings$querySettin5 : undefined,
            background: (_settings$querySettin6 = settings.querySettings(Settings.Category.SPLASH_SCREEN, 'background')) !== null && _settings$querySettin6 !== void 0 ? _settings$querySettin6 : undefined
          };
          this._curTime = 0;
          if (this.settings.totalTime <= 0 || this.settings.logo === undefined || this.settings.background === undefined) {
            this.settings.totalTime = 0;
          } else {
            this.device = legacyCC.director.root.device;
            this.swapchain = legacyCC.director.root.mainWindow.swapchain;
            this.preInit();
            this.initLayout();
            if (this.settings.logo.type === 'default') {
              this.initWaterMark();
            }
            let bgPromise = Promise.resolve();
            let logoPromise = Promise.resolve();
            if (this.settings.background.type === 'custom') {
              bgPromise = new Promise((resolve, reject) => {
                this.bgImage = new ccwindow$1.Image();
                this.bgImage.onload = () => {
                  this.initBG();
                  resolve();
                };
                this.bgImage.onerror = () => {
                  reject();
                };
                this.bgImage.src = this.settings.background.base64;
              });
            }
            if (this.settings.logo.type !== 'none') {
              logoPromise = new Promise((resolve, reject) => {
                this.logoImage = new ccwindow$1.Image();
                this.logoImage.onload = () => {
                  this.initLogo();
                  resolve();
                };
                this.logoImage.onerror = () => {
                  reject();
                };
                this.logoImage.src = this.settings.logo.base64;
              });
            }
            return Promise.all([bgPromise, logoPromise]);
          }
          return Promise.resolve([]);
        }
        preInit() {
          var _this$settings$backgr;
          const clearColor = (_this$settings$backgr = this.settings.background) === null || _this$settings$backgr === void 0 ? void 0 : _this$settings$backgr.color;
          this.clearColors = clearColor ? [new Color(clearColor.x, clearColor.y, clearColor.z, clearColor.w)] : [new Color(0, 0, 0, 1)];
          const {
            device,
            swapchain
          } = this;
          this.renderArea = new Rect(0, 0, swapchain.width, swapchain.height);
          this.cmdBuff = device.commandBuffer;
          const verts = new Float32Array([0.5, 0.5, 1, 0, -0.5, 0.5, 0, 0, 0.5, -0.5, 1, 1, -0.5, -0.5, 0, 1]);
          const vbStride = Float32Array.BYTES_PER_ELEMENT * 4;
          const vbSize = vbStride * 4;
          this.vertexBuffers = device.createBuffer(new BufferInfo(BufferUsageBit.VERTEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, vbSize, vbStride));
          this.vertexBuffers.update(verts);
          const indices = new Uint16Array([0, 1, 2, 1, 3, 2]);
          const ibStride = Uint16Array.BYTES_PER_ELEMENT;
          const ibSize = ibStride * 6;
          this.indicesBuffers = device.createBuffer(new BufferInfo(BufferUsageBit.INDEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, ibSize, ibStride));
          this.indicesBuffers.update(indices);
          const attributes = [new Attribute('a_position', Format.RG32F), new Attribute('a_texCoord', Format.RG32F)];
          const IAInfo = new InputAssemblerInfo(attributes, [this.vertexBuffers], this.indicesBuffers);
          this.quadAssmebler = device.createInputAssembler(IAInfo);
          this.projection = new Mat4();
          Mat4.ortho(this.projection, -1, 1, -1, 1, -1, 1, device.capabilities.clipSpaceMinZ, device.capabilities.clipSpaceSignY, swapchain.surfaceTransform);
          this.isMobile = sys.isMobile;
        }
        initLayout() {
          if (this.isMobile) {
            this.bgWidth = 812;
            this.bgHeight = 375;
            this.logoWidthTemp = 70;
            this.logoHeightTemp = 100;
            this.textSize = 12;
            this.textHeight = this.textSize + this.textExpandSize;
            this.textXTrans = 1 / 2;
            this.textYExtraTrans = 16;
          } else {
            this.bgWidth = 1920;
            this.bgHeight = 1080;
            this.logoWidthTemp = 140;
            this.logoHeightTemp = 200;
            this.textSize = 24;
            this.textHeight = this.textSize + this.textExpandSize;
            this.textXTrans = 1 / 2;
            this.textYExtraTrans = 32;
          }
          this.logoXTrans = 1 / 2;
          this.logoYTrans = 1 / 6 + 2.5 / 6;
          this.initScale();
        }
        initScale() {
          const dw = this.swapchain.width;
          const dh = this.swapchain.height;
          let desiredWidth = this.isMobile ? 375 : 1080;
          let desiredHeight = this.isMobile ? 812 : 1920;
          if (dw > dh) {
            const temp = desiredHeight;
            desiredHeight = desiredWidth;
            desiredWidth = temp;
          }
          if (dw / dh > 16 / 9) {
            this.scaleSize = dh / desiredHeight;
          } else {
            this.scaleSize = dw / desiredWidth;
          }
        }
        update(deltaTime) {
          const settings = this.settings;
          const {
            device,
            swapchain
          } = this;
          Mat4.ortho(this.projection, -1, 1, -1, 1, -1, 1, device.capabilities.clipSpaceMinZ, device.capabilities.clipSpaceSignY, swapchain.surfaceTransform);
          const dw = swapchain.width;
          const dh = swapchain.height;
          this.initScale();
          this._curTime += deltaTime * 1000;
          const percent = clamp01(this._curTime / settings.totalTime);
          const u_p = cubicOut(percent);
          let scaleX = 1;
          let scaleY = 1;
          if (this.settings.background.type === 'custom') {
            if (dw < dh) {
              scaleX = dh * this.bgRatio;
              scaleY = dh;
            } else {
              scaleX = dw;
              scaleY = dw * this.bgRatio;
            }
            this.bgMat.setProperty('resolution', v2_0.set(dw, dh), 0);
            this.bgMat.setProperty('scale', v2_0.set(scaleX, scaleY), 0);
            this.bgMat.setProperty('translate', v2_0.set(dw * 0.5, dh * 0.5), 0);
            this.bgMat.setProperty('percent', 1.0);
            this.bgMat.setProperty('u_projection', this.projection);
            this.bgMat.passes[0].update();
          }
          const logoYTrans = dh * this.logoYTrans;
          if (this.settings.logo.type !== 'none') {
            scaleX = this.logoWidth * this.scaleSize * settings.displayRatio;
            scaleY = this.logoHeight * this.scaleSize * settings.displayRatio;
            this.logoMat.setProperty('resolution', v2_0.set(dw, dh), 0);
            this.logoMat.setProperty('scale', v2_0.set(scaleX, scaleY), 0);
            this.logoMat.setProperty('translate', v2_0.set(dw * this.logoXTrans, logoYTrans), 0);
            this.logoMat.setProperty('percent', u_p);
            this.logoMat.setProperty('u_projection', this.projection);
            this.logoMat.passes[0].update();
          }
          if (this.settings.logo.type === 'default' && this.watermarkMat) {
            const watermarkTW = this.watermarkTexture.width;
            const watermarkTH = this.watermarkTexture.height;
            scaleX = watermarkTW;
            scaleY = watermarkTH;
            const textYTrans = logoYTrans - (this.logoHeight * 0.5 * settings.displayRatio + this.textYExtraTrans) * this.scaleSize - watermarkTH * 0.5;
            this.watermarkMat.setProperty('resolution', v2_0.set(dw, dh), 0);
            this.watermarkMat.setProperty('scale', v2_0.set(scaleX, scaleY), 0);
            this.watermarkMat.setProperty('translate', v2_0.set(dw * this.textXTrans, textYTrans), 0);
            this.watermarkMat.setProperty('percent', u_p);
            this.watermarkMat.setProperty('u_projection', this.projection);
            this.watermarkMat.passes[0].update();
          }
          this.frame();
        }
        initBG() {
          const device = this.device;
          this.bgMat = new Material();
          this.bgMat.initialize({
            effectName: 'util/splash-screen'
          });
          const samplerInfo = new SamplerInfo();
          samplerInfo.addressU = Address.CLAMP;
          samplerInfo.addressV = Address.CLAMP;
          samplerInfo.addressW = Address.CLAMP;
          this.sampler = device.getSampler(samplerInfo);
          this.bgTexture = device.createTexture(new TextureInfo(TextureType.TEX2D, TextureUsageBit.SAMPLED | TextureUsageBit.TRANSFER_DST, Format.RGBA8, this.bgImage.width, this.bgImage.height));
          const pass = this.bgMat.passes[0];
          const binding = pass.getBinding('mainTexture');
          pass.bindTexture(binding, this.bgTexture);
          this.shader = pass.getShaderVariant();
          const descriptorSet = pass.descriptorSet;
          descriptorSet.bindSampler(binding, this.sampler);
          descriptorSet.update();
          const region = new BufferTextureCopy();
          region.texExtent.width = this.bgImage.width;
          region.texExtent.height = this.bgImage.height;
          region.texExtent.depth = 1;
          device.copyTexImagesToTexture([this.bgImage], this.bgTexture, [region]);
        }
        initLogo() {
          const device = this.device;
          this.logoMat = new Material();
          this.logoMat.initialize({
            effectName: 'util/splash-screen'
          });
          const samplerInfo = new SamplerInfo();
          samplerInfo.addressU = Address.CLAMP;
          samplerInfo.addressV = Address.CLAMP;
          samplerInfo.addressW = Address.CLAMP;
          this.sampler = device.getSampler(samplerInfo);
          this.logoTexture = device.createTexture(new TextureInfo(TextureType.TEX2D, TextureUsageBit.SAMPLED | TextureUsageBit.TRANSFER_DST, Format.RGBA8, this.logoImage.width, this.logoImage.height));
          const pass = this.logoMat.passes[0];
          const binding = pass.getBinding('mainTexture');
          pass.bindTexture(binding, this.logoTexture);
          this.shader = pass.getShaderVariant();
          const descriptorSet = pass.descriptorSet;
          descriptorSet.bindSampler(binding, this.sampler);
          descriptorSet.update();
          const region = new BufferTextureCopy();
          region.texExtent.width = this.logoImage.width;
          region.texExtent.height = this.logoImage.height;
          region.texExtent.depth = 1;
          device.copyTexImagesToTexture([this.logoImage], this.logoTexture, [region]);
          const logoRatio = this.logoImage.width / this.logoImage.height;
          if (logoRatio < 1) {
            this.logoWidth = this.logoWidthTemp;
            this.logoHeight = this.logoWidthTemp / logoRatio;
          } else {
            this.logoWidth = this.logoHeightTemp * logoRatio;
            this.logoHeight = this.logoHeightTemp;
          }
        }
        initWaterMark() {
          const watermarkImg = ccwindow$1.document.createElement('canvas');
          watermarkImg.height = this.textHeight * this.scaleSize;
          watermarkImg.style.width = `${watermarkImg.width}`;
          watermarkImg.style.height = `${watermarkImg.height}`;
          const text = 'Created with Cocos';
          const ctx = watermarkImg.getContext('2d');
          ctx.font = `${this.textSize * this.scaleSize}px Arial`;
          ctx.textBaseline = 'top';
          ctx.textAlign = 'center';
          ctx.fillStyle = '#707070';
          const textLength = ctx.measureText(text).width + 10;
          watermarkImg.width = textLength;
          ctx.font = `${this.textSize * this.scaleSize}px Arial`;
          ctx.textBaseline = 'top';
          ctx.textAlign = 'center';
          ctx.fillStyle = '#707070';
          ctx.fillText(text, watermarkImg.width / 2, 0);
          const region = new BufferTextureCopy();
          region.texExtent.width = watermarkImg.width;
          region.texExtent.height = watermarkImg.height;
          region.texExtent.depth = 1;
          this.watermarkTexture = this.device.createTexture(new TextureInfo(TextureType.TEX2D, TextureUsageBit.SAMPLED | TextureUsageBit.TRANSFER_DST, Format.RGBA8, watermarkImg.width, watermarkImg.height));
          this.device.copyTexImagesToTexture([watermarkImg], this.watermarkTexture, [region]);
          this.watermarkMat = new Material();
          this.watermarkMat.initialize({
            effectName: 'util/splash-screen'
          });
          const pass = this.watermarkMat.passes[0];
          const binding = pass.getBinding('mainTexture');
          pass.bindTexture(binding, this.watermarkTexture);
          pass.descriptorSet.update();
        }
        frame() {
          const {
            device,
            swapchain
          } = this;
          if (!sys.isXR || xr.entry.isRenderAllowable()) {
            const renderSize = sys.isXR ? 2 : 1;
            for (let xrEye = 0; xrEye < renderSize; xrEye++) {
              if (sys.isXR) {
                xr.entry.renderLoopStart(xrEye);
                const xrFov = xr.entry.getEyeFov(xrEye);
                let radioLeft = 1.0;
                let radioRight = 1.0;
                if (xrEye === XREye.LEFT) {
                  radioLeft = Math.abs(Math.tan(xrFov[0])) / Math.abs(Math.tan(xrFov[1]));
                } else if (xrEye === XREye.RIGHT) {
                  radioRight = Math.abs(Math.tan(xrFov[1])) / Math.abs(Math.tan(xrFov[0]));
                }
                Mat4.ortho(this.projection, -radioLeft, radioRight, -1, 1, -1, 1, device.capabilities.clipSpaceMinZ, device.capabilities.clipSpaceSignY, swapchain.surfaceTransform);
                this.projection.m00 = preTransforms[swapchain.surfaceTransform][0];
                this.projection.m05 = preTransforms[swapchain.surfaceTransform][3] * device.capabilities.clipSpaceSignY;
                if (this.settings.background.type === 'custom') {
                  this.bgMat.setProperty('u_projection', this.projection);
                  this.bgMat.passes[0].update();
                }
                if (this.settings.logo.type !== 'none') {
                  this.logoMat.setProperty('u_projection', this.projection);
                  this.logoMat.passes[0].update();
                }
                if (this.settings.logo.type === 'default' && this.watermarkMat) {
                  this.watermarkMat.setProperty('u_projection', this.projection);
                  this.watermarkMat.passes[0].update();
                }
              }
              device.enableAutoBarrier(true);
              device.acquire([swapchain]);
              const cmdBuff = this.cmdBuff;
              const framebuffer = legacyCC.director.root.mainWindow.framebuffer;
              const renderArea = this.renderArea;
              renderArea.width = swapchain.width;
              renderArea.height = swapchain.height;
              cmdBuff.begin();
              cmdBuff.beginRenderPass(framebuffer.renderPass, framebuffer, renderArea, this.clearColors, 1.0, 0);
              if (this.settings.background.type === 'custom') {
                const bgPass = this.bgMat.passes[0];
                const bgPso = PipelineStateManager.getOrCreatePipelineState(device, bgPass, this.shader, framebuffer.renderPass, this.quadAssmebler);
                cmdBuff.bindPipelineState(bgPso);
                cmdBuff.bindDescriptorSet(SetIndex.MATERIAL, bgPass.descriptorSet);
                cmdBuff.bindInputAssembler(this.quadAssmebler);
                cmdBuff.draw(this.quadAssmebler);
              }
              if (this.settings.logo.type !== 'none') {
                const logoPass = this.logoMat.passes[0];
                const logoPso = PipelineStateManager.getOrCreatePipelineState(device, logoPass, this.shader, framebuffer.renderPass, this.quadAssmebler);
                cmdBuff.bindPipelineState(logoPso);
                cmdBuff.bindDescriptorSet(SetIndex.MATERIAL, logoPass.descriptorSet);
                cmdBuff.bindInputAssembler(this.quadAssmebler);
                cmdBuff.draw(this.quadAssmebler);
              }
              if (this.settings.logo.type === 'default' && this.watermarkMat) {
                const wartermarkPass = this.watermarkMat.passes[0];
                const watermarkPso = PipelineStateManager.getOrCreatePipelineState(device, wartermarkPass, this.shader, framebuffer.renderPass, this.quadAssmebler);
                cmdBuff.bindPipelineState(watermarkPso);
                cmdBuff.bindDescriptorSet(SetIndex.MATERIAL, wartermarkPass.descriptorSet);
                cmdBuff.bindInputAssembler(this.quadAssmebler);
                cmdBuff.draw(this.quadAssmebler);
              }
              cmdBuff.endRenderPass();
              cmdBuff.end();
              device.flushCommands([cmdBuff]);
              device.queue.submit([cmdBuff]);
              device.present();
              device.enableAutoBarrier(!legacyCC.rendering);
              if (sys.isXR) {
                xr.entry.renderLoopEnd(xrEye);
              }
            }
          }
        }
        destroy() {
          this.device = null;
          this.swapchain = null;
          this.clearColors = null;
          if (this.settings.background.type === 'custom') {
            if (this.bgImage.destroy) this.bgImage.destroy();
            this.bgImage = null;
            this.bgMat.destroy();
            this.bgMat = null;
            this.bgTexture.destroy();
            this.bgTexture = null;
          }
          if (this.settings.logo.type !== 'none') {
            if (this.logoImage.destroy) this.logoImage.destroy();
            this.logoImage = null;
            this.logoMat.destroy();
            this.logoMat = null;
            this.logoTexture.destroy();
            this.logoTexture = null;
          }
          this.renderArea = null;
          this.cmdBuff = null;
          this.shader = null;
          this.quadAssmebler.destroy();
          this.quadAssmebler = null;
          this.vertexBuffers.destroy();
          this.vertexBuffers = null;
          this.indicesBuffers.destroy();
          this.indicesBuffers = null;
          this.sampler = null;
          if (this.settings.logo.type === 'default' && this.watermarkTexture) {
            this.watermarkMat.destroy();
            this.watermarkMat = null;
            this.watermarkTexture.destroy();
            this.watermarkTexture = null;
          }
          this.settings = null;
        }
        static get instance() {
          if (!SplashScreen._ins) {
            SplashScreen._ins = new SplashScreen();
          }
          return SplashScreen._ins;
        }
        constructor() {
          this.settings = void 0;
          this._curTime = 0;
          this.device = void 0;
          this.swapchain = void 0;
          this.shader = void 0;
          this.sampler = void 0;
          this.cmdBuff = void 0;
          this.quadAssmebler = void 0;
          this.vertexBuffers = void 0;
          this.indicesBuffers = void 0;
          this.renderArea = void 0;
          this.clearColors = void 0;
          this.projection = void 0;
          this.isMobile = false;
          this.bgMat = void 0;
          this.bgImage = void 0;
          this.bgTexture = void 0;
          this.logoMat = void 0;
          this.logoImage = void 0;
          this.logoTexture = void 0;
          this.watermarkMat = void 0;
          this.watermarkTexture = void 0;
          this.bgWidth = 1920;
          this.bgHeight = 1080;
          this.bgRatio = 16 / 9;
          this.logoWidthTemp = 140;
          this.logoHeightTemp = 200;
          this.logoWidth = 0;
          this.logoHeight = 0;
          this.logoXTrans = 1 / 2;
          this.logoYTrans = 1 / 6 + 2.5 / 6;
          this.textSize = 24;
          this.textHeight = 24;
          this.textXTrans = 1 / 2;
          this.textYExtraTrans = 32;
          this.textExpandSize = 4;
          this.scaleSize = 1;
        }
      }
      SplashScreen._ins = void 0;
      legacyCC.internal.SplashScreen = SplashScreen;

      class EffectSettings {
        constructor() {
          this._data = null;
        }
        init(path = '') {
          if (!legacyCC.rendering || !legacyCC.rendering.enableEffectImport || !path) {
            return Promise.resolve();
          }
          return new Promise((resolve, reject) => {
            if (!path.startsWith('http')) {
              fsUtils.readArrayBuffer(path, (err, arrayBuffer) => {
                if (err) {
                  reject(err);
                  return;
                }
                this._data = arrayBuffer;
                resolve();
              });
            } else {
              const xhr = new XMLHttpRequest();
              xhr.open('GET', path);
              xhr.responseType = 'arraybuffer';
              xhr.onload = () => {
                this._data = xhr.response;
                resolve();
              };
              xhr.onerror = () => {
                reject(new Error('request effect settings failed!'));
              };
              xhr.send(null);
            }
          });
        }
        get data() {
          return this._data;
        }
      }
      const effectSettings = new EffectSettings();
      legacyCC.effectSettings = effectSettings;

      class Game extends EventTarget {
        constructor(...args) {
          super(...args);
          this.frame = null;
          this.container = null;
          this.canvas = null;
          this.renderType = -1;
          this.eventTargetOn = super.on;
          this.eventTargetOnce = super.once;
          this.config = {};
          this.onStart = null;
          this.frameTime = 1000 / 60;
          this._isCloning = false;
          this._inited = false;
          this._engineInited = false;
          this._rendererInitialized = false;
          this._paused = true;
          this._pausedByEngine = false;
          this._frameRate = 60;
          this._pacer = null;
          this._initTime = 0;
          this._startTime = 0;
          this._deltaTime = 0.0;
          this._useFixedDeltaTime = false;
          this._shouldLoadLaunchScene = true;
          this.onPreBaseInitDelegate = new AsyncDelegate();
          this.onPostBaseInitDelegate = new AsyncDelegate();
          this.onPreInfrastructureInitDelegate = new AsyncDelegate();
          this.onPostInfrastructureInitDelegate = new AsyncDelegate();
          this.onPreSubsystemInitDelegate = new AsyncDelegate();
          this.onPostSubsystemInitDelegate = new AsyncDelegate();
          this.onPreProjectInitDelegate = new AsyncDelegate();
          this.onPostProjectInitDelegate = new AsyncDelegate();
        }
        get inited() {
          return this._inited;
        }
        get frameRate() {
          return this._frameRate;
        }
        set frameRate(frameRate) {
          if (typeof frameRate !== 'number') {
            frameRate = parseInt(frameRate, 10);
            if (Number.isNaN(frameRate)) {
              frameRate = 60;
            }
          }
          this._frameRate = frameRate;
          this.frameTime = 1000 / frameRate;
          if (this._pacer) this._pacer.targetFrameRate = this._frameRate;
        }
        get deltaTime() {
          return this._useFixedDeltaTime ? this.frameTime / 1000 : this._deltaTime;
        }
        get totalTime() {
          return performance.now() - this._initTime;
        }
        get frameStartTime() {
          return this._startTime;
        }
        setFrameRate(frameRate) {
          this.frameRate = frameRate;
        }
        getFrameRate() {
          return this.frameRate;
        }
        step() {
          director.tick(this._calculateDT(true));
        }
        pauseByEngine() {
          if (this._paused) {
            return;
          }
          this._pausedByEngine = true;
          this.pause();
        }
        resumeByEngine() {
          if (this._pausedByEngine) {
            this.resume();
            this._pausedByEngine = false;
          }
        }
        pause() {
          var _this$_pacer;
          if (this._paused) {
            return;
          }
          this._paused = true;
          (_this$_pacer = this._pacer) === null || _this$_pacer === void 0 ? void 0 : _this$_pacer.stop();
          this.emit(Game.EVENT_PAUSE);
        }
        resume() {
          var _this$_pacer2;
          if (!this._paused) {
            return;
          }
          input._clearEvents();
          this._paused = false;
          (_this$_pacer2 = this._pacer) === null || _this$_pacer2 === void 0 ? void 0 : _this$_pacer2.start();
          this.emit(Game.EVENT_RESUME);
        }
        isPaused() {
          return this._paused;
        }
        restart() {
          const endFramePromise = new Promise(resolve => {
            director.once(Director.EVENT_END_FRAME, () => resolve());
          });
          return endFramePromise.then(() => {
            director.reset();
            legacyCC.Object._deferredDestroy();
            this.pause();
            this.resume();
            this._shouldLoadLaunchScene = true;
            SplashScreen.instance.curTime = 0;
            this._safeEmit(Game.EVENT_RESTART);
          });
        }
        end() {
          systemInfo.close();
        }
        on(type, callback, target, once) {
          if (this.canRegisterEvent(type)) {
            callback.call(target);
          }
          return this.eventTargetOn(type, callback, target, once);
        }
        once(type, callback, target) {
          if (this.canRegisterEvent(type)) {
            return callback.call(target);
          }
          return this.eventTargetOnce(type, callback, target);
        }
        canRegisterEvent(type) {
          return this._engineInited && type === Game.EVENT_ENGINE_INITED || this._inited && type === Game.EVENT_GAME_INITED || this._rendererInitialized && type === Game.EVENT_RENDERER_INITED;
        }
        init(config) {
          this._compatibleWithOldParams(config);
          return Promise.resolve().then(() => {
            this.emit(Game.EVENT_PRE_BASE_INIT);
            return this.onPreBaseInitDelegate.dispatch();
          }).then(() => {
            {
              console.time('Init Base');
            }
            const debugMode = config.debugMode || DebugMode.NONE;
            _resetDebugSetting(debugMode);
          }).then(() => sys.init()).then(() => {
            this._initEvents();
          }).then(() => settings.init(config.settingsPath, config.overrideSettings)).then(() => {
            {
              console.timeEnd('Init Base');
            }
            this.emit(Game.EVENT_POST_BASE_INIT);
            return this.onPostBaseInitDelegate.dispatch();
          }).then(() => {
            this.emit(Game.EVENT_PRE_INFRASTRUCTURE_INIT);
            return this.onPreInfrastructureInitDelegate.dispatch();
          }).then(() => {
            {
              console.time('Init Infrastructure');
            }
            macro.init();
            this._initXR();
            const adapter = findCanvas();
            if (adapter) {
              this.canvas = adapter.canvas;
              this.frame = adapter.frame;
              this.container = adapter.container;
            }
            screen.init();
            garbageCollectionManager.init();
            deviceManager.init(this.canvas, bindingMappingInfo);
            if (macro.CUSTOM_PIPELINE_NAME === '') {
              legacyCC.rendering = undefined;
            }
            assetManager.init();
            builtinResMgr.init();
            Layers.init();
            this.initPacer();
            {
              console.timeEnd('Init Infrastructure');
            }
          }).then(() => {
            this.emit(Game.EVENT_POST_INFRASTRUCTURE_INIT);
            return this.onPostInfrastructureInitDelegate.dispatch();
          }).then(() => {
            this.emit(Game.EVENT_PRE_SUBSYSTEM_INIT);
            return this.onPreSubsystemInitDelegate.dispatch();
          }).then(() => effectSettings.init(settings.querySettings(Settings.Category.RENDERING, 'effectSettingsPath'))).then(() => {
            if (!legacyCC.rendering || !legacyCC.rendering.enableEffectImport) {
              return;
            }
            const renderMode = settings.querySettings(Settings.Category.RENDERING, 'renderMode');
            if (renderMode === LegacyRenderMode.HEADLESS) {
              legacyCC.rendering.init(deviceManager.gfxDevice, null);
              return;
            }
            const data = effectSettings.data;
            if (data === null) {
              errorID(1102);
              return;
            }
            legacyCC.rendering.init(deviceManager.gfxDevice, data);
          }).then(() => {
            const scriptPackages = settings.querySettings(Settings.Category.SCRIPTING, 'scriptPackages');
            if (scriptPackages) {
              return Promise.all(scriptPackages.map(pack => module.import(pack)));
            }
            return Promise.resolve([]);
          }).then(() => {
            {
              console.time('Init SubSystem');
            }
            director.init();
            return builtinResMgr.loadBuiltinAssets();
          }).then(() => {
            {
              console.timeEnd('Init SubSystem');
            }
            this.emit(Game.EVENT_POST_SUBSYSTEM_INIT);
            return this.onPostSubsystemInitDelegate.dispatch();
          }).then(() => {
            log(`Cocos Creator v${engineVersion}`);
            this.emit(Game.EVENT_ENGINE_INITED);
            this._engineInited = true;
          }).then(() => {
            this.emit(Game.EVENT_PRE_PROJECT_INIT);
            return this.onPreProjectInitDelegate.dispatch();
          }).then(() => {
            {
              console.time('Init Project');
            }
            const jsList = settings.querySettings(Settings.Category.PLUGINS, 'jsList');
            let promise = Promise.resolve();
            if (jsList) {
              jsList.forEach(jsListFile => {
                promise = promise.then(() => loadJsFile(`${'src'}/${jsListFile}`));
              });
            }
            return promise;
          }).then(() => this._loadProjectBundles()).then(() => this._loadCCEScripts()).then(() => this._setupRenderPipeline()).then(() => this._loadPreloadAssets()).then(() => {
            builtinResMgr.compileBuiltinMaterial();
            return SplashScreen.instance.init();
          }).then(() => {
            {
              console.timeEnd('Init Project');
            }
            this.emit(Game.EVENT_POST_PROJECT_INIT);
            return this.onPostProjectInitDelegate.dispatch();
          }).then(() => {
            this._inited = true;
            this._safeEmit(Game.EVENT_GAME_INITED);
          });
        }
        _initXR() {
          var _settings$querySettin;
          if (typeof globalThis.__globalXR === 'undefined') {
            globalThis.__globalXR = {};
          }
          const globalXR = globalThis.__globalXR;
          globalXR.webxrCompatible = (_settings$querySettin = settings.querySettings(Settings.Category.XR, 'webxrCompatible')) !== null && _settings$querySettin !== void 0 ? _settings$querySettin : false;
          if (sys.isXR) {
            var _settings$querySettin2, _settings$querySettin3;
            xr.entry = xr.XrEntry.getInstance();
            const xrMSAA = (_settings$querySettin2 = settings.querySettings(Settings.Category.RENDERING, 'msaa')) !== null && _settings$querySettin2 !== void 0 ? _settings$querySettin2 : 1;
            const xrRenderingScale = (_settings$querySettin3 = settings.querySettings(Settings.Category.RENDERING, 'renderingScale')) !== null && _settings$querySettin3 !== void 0 ? _settings$querySettin3 : 1.0;
            xr.entry.setMultisamplesRTT(xrMSAA);
            xr.entry.setRenderingScale(xrRenderingScale);
          }
        }
        _compatibleWithOldParams(config) {
          const overrideSettings = config.overrideSettings = config.overrideSettings || {};
          if ('showFPS' in config) {
            overrideSettings.profiling = overrideSettings.profiling || {};
            overrideSettings.profiling.showFPS = config.showFPS;
          }
          if ('frameRate' in config) {
            overrideSettings.screen = overrideSettings.screen || {};
            overrideSettings.screen.frameRate = config.frameRate;
          }
          if ('renderMode' in config) {
            overrideSettings.rendering = overrideSettings.rendering || {};
            overrideSettings.rendering.renderMode = config.renderMode;
          }
          if ('renderPipeline' in config) {
            overrideSettings.rendering = overrideSettings.rendering || {};
            overrideSettings.rendering.renderPipeline = config.renderPipeline;
          }
          if ('assetOptions' in config) {
            overrideSettings.assets = overrideSettings.assets || {};
            Object.assign(overrideSettings.assets, config.assetOptions);
          }
          if ('customJointTextureLayouts' in config) {
            overrideSettings.animation = overrideSettings.animation || {};
            overrideSettings.animation.customJointTextureLayouts = config.customJointTextureLayouts;
          }
          if ('physics' in config) {
            overrideSettings.physics = overrideSettings.physics || {};
            Object.assign(overrideSettings.physics, config.physics);
          }
          if ('orientation' in config) {
            overrideSettings.screen = overrideSettings.screen || {};
            overrideSettings.screen.orientation = config.orientation;
          }
          if ('exactFitScreen' in config) {
            overrideSettings.screen = overrideSettings.screen || {};
            overrideSettings.screen.exactFitScreen = config.exactFitScreen;
          }
        }
        _loadPreloadAssets() {
          const preloadAssets = settings.querySettings(Settings.Category.ASSETS, 'preloadAssets');
          if (!preloadAssets) return Promise.resolve([]);
          return Promise.all(preloadAssets.map(uuid => new Promise((resolve, reject) => {
            assetManager.loadAny(uuid, err => {
              if (err) {
                reject(err);
                return;
              }
              resolve();
            });
          })));
        }
        _loadCCEScripts() {
          return new Promise((resolve, reject) => {
            {
              resolve();
            }
          });
        }
        _loadProjectBundles() {
          const preloadBundles = settings.querySettings(Settings.Category.ASSETS, 'preloadBundles');
          if (!preloadBundles) return Promise.resolve([]);
          return Promise.all(preloadBundles.map(({
            bundle,
            version
          }) => new Promise((resolve, reject) => {
            const opts = {};
            if (version) opts.version = version;
            assetManager.loadBundle(bundle, opts, err => {
              if (err) {
                reject(err);
                return;
              }
              resolve();
            });
          })));
        }
        run(onStart) {
          if (onStart) {
            this.onStart = onStart;
          }
          if (!this._inited || EDITOR_NOT_IN_PREVIEW) {
            return;
          }
          this.resume();
        }
        _calculateDT(useFixedDeltaTime) {
          this._useFixedDeltaTime = useFixedDeltaTime;
          if (useFixedDeltaTime) {
            this._startTime = performance.now();
            return this.frameTime / 1000;
          }
          const now = performance.now();
          this._deltaTime = now > this._startTime ? (now - this._startTime) / 1000 : 0;
          if (this._deltaTime > Game.DEBUG_DT_THRESHOLD) {
            this._deltaTime = this.frameTime / 1000;
          }
          this._startTime = now;
          return this._deltaTime;
        }
        _updateCallback() {
          if (!this._inited) return;
          if (!SplashScreen.instance.isFinished) {
            SplashScreen.instance.update(this._calculateDT(false));
          } else if (this._shouldLoadLaunchScene) {
            this._shouldLoadLaunchScene = false;
            const launchScene = settings.querySettings(Settings.Category.LAUNCH, 'launchScene');
            if (launchScene) {
              director.loadScene(launchScene, () => {
                var _this$onStart;
                logID(1103, launchScene);
                this._initTime = performance.now();
                director.startAnimation();
                (_this$onStart = this.onStart) === null || _this$onStart === void 0 ? void 0 : _this$onStart.call(this);
              });
            } else {
              var _this$onStart2;
              this._initTime = performance.now();
              director.startAnimation();
              (_this$onStart2 = this.onStart) === null || _this$onStart2 === void 0 ? void 0 : _this$onStart2.call(this);
            }
          } else {
            director.tick(this._calculateDT(false));
          }
        }
        initPacer() {
          var _settings$querySettin4;
          const frameRate = (_settings$querySettin4 = settings.querySettings(Settings.Category.SCREEN, 'frameRate')) !== null && _settings$querySettin4 !== void 0 ? _settings$querySettin4 : 60;
          assert(typeof frameRate === 'number');
          this._pacer = new Pacer();
          this._pacer.onTick = this._updateCallback.bind(this);
          this.frameRate = frameRate;
        }
        _initEvents() {
          systemInfo.on('show', this._onShow, this);
          systemInfo.on('hide', this._onHide, this);
          systemInfo.on('close', this._onClose, this);
        }
        _onHide() {
          this.emit(Game.EVENT_HIDE);
          this.pauseByEngine();
        }
        _onShow() {
          this.emit(Game.EVENT_SHOW);
          this.resumeByEngine();
        }
        _onClose() {
          this.emit(Game.EVENT_CLOSE);
          systemInfo.exit();
        }
        addPersistRootNode(node) {
          director.addPersistRootNode(node);
        }
        removePersistRootNode(node) {
          director.removePersistRootNode(node);
        }
        isPersistRootNode(node) {
          return director.isPersistRootNode(node);
        }
        _setupRenderPipeline() {
          const renderPipeline = settings.querySettings(Settings.Category.RENDERING, 'renderPipeline');
          if (!renderPipeline) {
            return this._setRenderPipeline();
          }
          return new Promise((resolve, reject) => {
            assetManager.loadAny(renderPipeline, (err, asset) => err || !(asset instanceof RenderPipeline) ? reject(err) : resolve(asset));
          }).then(asset => {
            this._setRenderPipeline(asset);
          }).catch(reason => {
            warn(reason);
            warn(`Failed load render pipeline: ${renderPipeline}, engine failed to initialize, will fallback to default pipeline`);
            this._setRenderPipeline();
          });
        }
        _setRenderPipeline(rppl) {
          if (!director.root.setRenderPipeline(rppl)) {
            this._setRenderPipeline();
          }
          this._rendererInitialized = true;
          this._safeEmit(Game.EVENT_RENDERER_INITED);
        }
        _safeEmit(event) {
          {
            this.emit(event);
          }
        }
      } exports('Game', Game);
      Game.EVENT_HIDE = 'game_on_hide';
      Game.EVENT_SHOW = 'game_on_show';
      Game.EVENT_LOW_MEMORY = 'game_on_low_memory';
      Game.EVENT_GAME_INITED = 'game_inited';
      Game.EVENT_ENGINE_INITED = 'engine_inited';
      Game.EVENT_RENDERER_INITED = 'renderer_inited';
      Game.EVENT_PRE_BASE_INIT = 'pre_base_init';
      Game.EVENT_POST_BASE_INIT = 'post_base_init';
      Game.EVENT_PRE_INFRASTRUCTURE_INIT = 'pre_infrastructure_init';
      Game.EVENT_POST_INFRASTRUCTURE_INIT = 'post_infrastructure_init';
      Game.EVENT_PRE_SUBSYSTEM_INIT = 'pre_subsystem_init';
      Game.EVENT_POST_SUBSYSTEM_INIT = 'post_subsystem_init';
      Game.EVENT_PRE_PROJECT_INIT = 'pre_project_init';
      Game.EVENT_POST_PROJECT_INIT = 'post_project_init';
      Game.EVENT_RESTART = 'game_on_restart';
      Game.EVENT_PAUSE = 'game_on_pause';
      Game.EVENT_RESUME = 'game_on_resume';
      Game.EVENT_CLOSE = 'game_on_close';
      Game.RENDER_TYPE_CANVAS = 0;
      Game.RENDER_TYPE_WEBGL = 1;
      Game.RENDER_TYPE_OPENGL = 2;
      Game.RENDER_TYPE_HEADLESS = 3;
      Game.DEBUG_DT_THRESHOLD = 1;
      legacyCC.Game = Game;
      const game = exports('game', legacyCC.game = new Game());

      markAsWarning(Director.prototype, 'director', [{
        name: 'calculateDeltaTime'
      }, {
        name: 'getDeltaTime',
        suggest: 'Use game.deltaTime instead'
      }, {
        name: 'getTotalTime',
        suggest: 'Use game.totalTime instead'
      }, {
        name: 'getCurrentTime',
        suggest: 'Use game.frameStartTime instead'
      }]);
      removeProperty(Director.prototype, 'director', [{
        name: 'setAnimationInterval',
        suggest: 'please use game.frameRate instead'
      }, {
        name: 'getAnimationInterval',
        suggest: 'please use game.frameRate instead'
      }, {
        name: 'getRunningScene',
        suggest: 'please use getScene instead'
      }, {
        name: 'setDepthTest',
        suggest: 'please use camera API instead'
      }, {
        name: 'setClearColor',
        suggest: 'please use camera API instead'
      }, {
        name: 'getWinSize',
        suggest: 'please use view.getVisibleSize instead'
      }, {
        name: 'getWinSizeInPixels'
      }, {
        name: 'purgeCachedData',
        suggest: 'please use assetManager.releaseAll instead'
      }, {
        name: 'convertToGL'
      }, {
        name: 'convertToUI'
      }]);
      replaceProperty(director, 'director', [{
        name: '_getSceneUuid',
        targetName: 'assetManager.main',
        newName: 'getSceneInfo',
        customFunction: sceneName => {
          if (assetManager.main) {
            var _assetManager$main$ge;
            return (_assetManager$main$ge = assetManager.main.getSceneInfo(sceneName)) === null || _assetManager$main$ge === void 0 ? void 0 : _assetManager$main$ge.uuid;
          }
          return '';
        }
      }]);
      markAsWarning(game, 'game', [{
        name: 'collisionMatrix'
      }, {
        name: 'groupList'
      }]);
      replaceProperty(game, 'game', [{
        name: '_sceneInfos',
        targetName: 'assetManager.main',
        newName: 'getSceneInfo',
        customGetter: () => {
          const scenes = [];
          if (assetManager.main) {
            assetManager.main.config.scenes.forEach(val => {
              scenes.push(val);
            });
          }
          return scenes;
        }
      }]);

      class DynamicAtlasManager extends System {
        constructor(...args) {
          super(...args);
          this._atlases = [];
          this._atlasIndex = -1;
          this._maxAtlasCount = 5;
          this._textureSize = 2048;
          this._maxFrameSize = 512;
          this._textureBleeding = true;
          this._enabled = false;
        }
        get enabled() {
          return this._enabled;
        }
        set enabled(value) {
          if (this._enabled === value) return;
          if (value) {
            this.reset();
            legacyCC.director.on(legacyCC.Director.EVENT_BEFORE_SCENE_LAUNCH, this.beforeSceneLoad, this);
          } else {
            this.reset();
            legacyCC.director.off(legacyCC.Director.EVENT_BEFORE_SCENE_LAUNCH, this.beforeSceneLoad, this);
          }
          this._enabled = value;
        }
        get maxAtlasCount() {
          return this._maxAtlasCount;
        }
        set maxAtlasCount(value) {
          this._maxAtlasCount = value;
        }
        get atlasCount() {
          return this._atlases.length;
        }
        get textureBleeding() {
          return this._textureBleeding;
        }
        set textureBleeding(enable) {
          this._textureBleeding = enable;
        }
        get textureSize() {
          return this._textureSize;
        }
        set textureSize(value) {
          this._textureSize = value;
        }
        get maxFrameSize() {
          return this._maxFrameSize;
        }
        set maxFrameSize(value) {
          this._maxFrameSize = value;
        }
        newAtlas() {
          let atlas = this._atlases[++this._atlasIndex];
          if (!atlas) {
            atlas = new Atlas(this._textureSize, this._textureSize);
            this._atlases.push(atlas);
          }
          return atlas;
        }
        beforeSceneLoad() {
          this.reset();
        }
        init() {
          this.enabled = !macro.CLEANUP_IMAGE_CACHE;
        }
        insertSpriteFrame(spriteFrame) {
          if (!this._enabled || this._atlasIndex === this._maxAtlasCount || !spriteFrame || spriteFrame._original) return null;
          if (!spriteFrame.packable) return null;
          const sampler = spriteFrame.texture.getSamplerInfo();
          if (sampler.minFilter !== Filter.LINEAR || sampler.magFilter !== Filter.LINEAR || sampler.mipFilter !== Filter.NONE) {
            return null;
          }
          let atlas = this._atlases[this._atlasIndex];
          if (!atlas) {
            atlas = this.newAtlas();
          }
          const frame = atlas.insertSpriteFrame(spriteFrame);
          if (!frame && this._atlasIndex !== this._maxAtlasCount) {
            atlas = this.newAtlas();
            return atlas.insertSpriteFrame(spriteFrame);
          }
          return frame;
        }
        reset() {
          for (let i = 0, l = this._atlases.length; i < l; i++) {
            this._atlases[i].destroy();
          }
          this._atlases.length = 0;
          this._atlasIndex = -1;
        }
        deleteAtlasSpriteFrame(spriteFrame) {
          if (!spriteFrame._original) return;
          let atlas;
          for (let i = this._atlases.length - 1; i >= 0; i--) {
            atlas = this._atlases[i];
            fastRemove(atlas._innerSpriteFrames, spriteFrame);
          }
          const texture = spriteFrame._original._texture;
          this.deleteAtlasTexture(texture);
        }
        deleteAtlasTexture(texture) {
          if (texture) {
            for (let i = this._atlases.length - 1; i >= 0; i--) {
              this._atlases[i].deleteInnerTexture(texture);
              if (this._atlases[i].isEmpty()) {
                this._atlases[i].destroy();
                this._atlases.splice(i, 1);
                this._atlasIndex--;
              }
            }
          }
        }
        packToDynamicAtlas(comp, frame) {
          if (!this._enabled) return;
          if (frame && !frame._original && frame.packable && frame.texture && frame.texture.width > 0 && frame.texture.height > 0) {
            const packedFrame = this.insertSpriteFrame(frame);
            if (packedFrame) {
              frame._setDynamicAtlasFrame(packedFrame);
            }
          }
        }
      } exports('DynamicAtlasManager', DynamicAtlasManager);
      DynamicAtlasManager.instance = void 0;
      const dynamicAtlasManager = exports('dynamicAtlasManager', DynamicAtlasManager.instance = new DynamicAtlasManager());
      director.registerSystem('dynamicAtlasManager', dynamicAtlasManager, 0);
      legacyCC.internal.dynamicAtlasManager = dynamicAtlasManager;

      ({
        [FormatType.UNORM]: 'Uint',
        [FormatType.SNORM]: 'Int',
        [FormatType.UINT]: 'Uint',
        [FormatType.INT]: 'Int',
        [FormatType.UFLOAT]: 'Float',
        [FormatType.FLOAT]: 'Float',
        default: 'Uint'
      });

      var _keyMap;
      (function (_keyMap) {
        _keyMap[_keyMap["positions"] = AttributeName.ATTR_POSITION] = "positions";
        _keyMap[_keyMap["normals"] = AttributeName.ATTR_NORMAL] = "normals";
        _keyMap[_keyMap["uvs"] = AttributeName.ATTR_TEX_COORD] = "uvs";
        _keyMap[_keyMap["colors"] = AttributeName.ATTR_COLOR] = "colors";
      })(_keyMap || (_keyMap = {}));

      const MeshUtils = jsb.MeshUtils;
      const createMesh = MeshUtils.createMesh;
      MeshUtils.createDynamicMesh;
      legacyCC.MeshUtils = jsb.MeshUtils;

      var _dec$O, _class$M, _class2$H;
      const INSET_LEFT = 0;
      const INSET_TOP = 1;
      const INSET_RIGHT = 2;
      const INSET_BOTTOM = 3;
      const temp_vec3 = new Vec3();
      const temp_matrix = new Mat4();
      var MeshType;
      (function (MeshType) {
        MeshType[MeshType["RECT"] = 0] = "RECT";
        MeshType[MeshType["POLYGON"] = 1] = "POLYGON";
      })(MeshType || (MeshType = {}));
      const temp_uvs = [{
        u: 0,
        v: 0
      }, {
        u: 0,
        v: 0
      }, {
        u: 0,
        v: 0
      }, {
        u: 0,
        v: 0
      }];
      let SpriteFrame = exports('SpriteFrame', (_dec$O = ccclass$3('cc.SpriteFrame'), _dec$O(_class$M = (_class2$H = class SpriteFrame extends Asset {
        static createWithImage(imageSourceOrImageAsset) {
          const img = imageSourceOrImageAsset instanceof ImageAsset$1 ? imageSourceOrImageAsset : new ImageAsset$1(imageSourceOrImageAsset);
          const tex = new Texture2D$1();
          tex.image = img;
          const spf = new SpriteFrame();
          spf.texture = tex;
          return spf;
        }
        get insetTop() {
          return this._capInsets[INSET_TOP];
        }
        set insetTop(value) {
          if (this._capInsets[INSET_TOP] === value) {
            return;
          }
          this._capInsets[INSET_TOP] = value;
          if (this._texture) {
            this._calculateSlicedUV();
          }
        }
        get insetBottom() {
          return this._capInsets[INSET_BOTTOM];
        }
        set insetBottom(value) {
          if (this._capInsets[INSET_BOTTOM] === value) {
            return;
          }
          this._capInsets[INSET_BOTTOM] = value;
          if (this._texture) {
            this._calculateSlicedUV();
          }
        }
        get insetLeft() {
          return this._capInsets[INSET_LEFT];
        }
        set insetLeft(value) {
          if (this._capInsets[INSET_LEFT] === value) {
            return;
          }
          this._capInsets[INSET_LEFT] = value;
          if (this._texture) {
            this._calculateSlicedUV();
          }
        }
        get insetRight() {
          return this._capInsets[INSET_RIGHT];
        }
        set insetRight(value) {
          if (this._capInsets[INSET_RIGHT] === value) {
            return;
          }
          this._capInsets[INSET_RIGHT] = value;
          if (this._texture) {
            this._calculateSlicedUV();
          }
        }
        get rect() {
          return this._rect;
        }
        set rect(value) {
          if (this._rect.equals(value)) {
            return;
          }
          this._rect.set(value);
          if (this._texture) {
            this._calculateUV();
          }
          this._calcTrimmedBorder();
        }
        get originalSize() {
          return this._originalSize;
        }
        set originalSize(value) {
          if (this._originalSize.equals(value)) {
            return;
          }
          this._originalSize.set(value);
          if (this._texture) {
            this._calculateUV();
          }
          this._calcTrimmedBorder();
        }
        get offset() {
          return this._offset;
        }
        set offset(value) {
          this._offset.set(value);
          this._calcTrimmedBorder();
        }
        get rotated() {
          return this._rotated;
        }
        set rotated(rotated) {
          if (this._rotated === rotated) {
            return;
          }
          this._rotated = rotated;
          if (this._texture) {
            this._calculateUV();
          }
        }
        get texture() {
          return this._texture;
        }
        set texture(value) {
          if (!value) {
            warnID(3122, this.name);
            return;
          }
          if (value === this._texture) {
            return;
          }
          this.reset({
            texture: value
          }, true);
        }
        get atlasUuid() {
          return this._atlasUuid;
        }
        set atlasUuid(value) {
          this._atlasUuid = value;
        }
        get width() {
          return this._texture.width;
        }
        get height() {
          return this._texture.height;
        }
        set _textureSource(value) {
          if (globalThis.Build) {
            this._texture = value;
            return;
          }
          if (value) {
            this._refreshTexture(value);
            this._calculateUV();
          }
        }
        get flipUVX() {
          return this._isFlipUVX;
        }
        set flipUVX(value) {
          this._isFlipUVX = value;
          this._calculateUV();
        }
        get flipUVY() {
          return this._isFlipUVY;
        }
        set flipUVY(value) {
          this._isFlipUVY = value;
          this._calculateUV();
        }
        get packable() {
          return this._packable;
        }
        set packable(value) {
          this._packable = value;
        }
        get original() {
          return this._original;
        }
        get pixelsToUnit() {
          return this._pixelsToUnit;
        }
        get pivot() {
          return this._pivot;
        }
        get mesh() {
          return this._mesh;
        }
        get trimmedBorder() {
          return this._trimmedBorder;
        }
        constructor() {
          super();
          this.vertices = null;
          this.uv = [];
          this.unbiasUV = [];
          this.uvSliced = [];
          this._rect = new Rect$1();
          this._trimmedBorder = new Vec4();
          this._offset = new Vec2();
          this._originalSize = new Size$1();
          this._rotated = false;
          this._capInsets = [0, 0, 0, 0];
          this._atlasUuid = '';
          this._texture = void 0;
          this._isFlipUVY = false;
          this._isFlipUVX = false;
          this._original = null;
          this._packable = true;
          this._pixelsToUnit = 100;
          this._pivot = new Vec2(0.5, 0.5);
          this._meshType = MeshType.RECT;
          this._extrude = 0;
          this._customOutLine = [];
          this._minPos = new Vec3();
          this._maxPos = new Vec3();
        }
        textureLoaded() {
          return !!this.texture;
        }
        isRotated() {
          return this._rotated;
        }
        setRotated(rotated) {
          this.rotated = rotated;
        }
        getRect(out) {
          if (out) {
            out.set(this._rect);
            return out;
          }
          return this._rect.clone();
        }
        setRect(rect) {
          this.rect = rect;
        }
        getOriginalSize(out) {
          if (out) {
            out.set(this._originalSize);
            return out;
          }
          return this._originalSize.clone();
        }
        setOriginalSize(size) {
          this.originalSize = size;
        }
        getOffset(out) {
          if (out) {
            out.set(this._offset);
            return out;
          }
          return this._offset.clone();
        }
        setOffset(offset) {
          this.offset = offset;
        }
        getGFXTexture() {
          return this._texture.getGFXTexture();
        }
        getGFXSampler() {
          return this._texture.getGFXSampler();
        }
        getHash() {
          return this._texture.getHash();
        }
        getSamplerInfo() {
          return this._texture.getSamplerInfo();
        }
        reset(info, clearData = false) {
          let calUV = false;
          if (clearData) {
            this._originalSize.set(0, 0);
            this._rect.set(0, 0, 0, 0);
            this._offset.set(0, 0);
            this._capInsets = [0, 0, 0, 0];
            this._rotated = false;
            calUV = true;
          }
          if (info) {
            if (info.texture) {
              this._rect.x = this._rect.y = 0;
              this._rect.width = info.texture.width;
              this._rect.height = info.texture.height;
              this._refreshTexture(info.texture);
              this.checkRect(this._texture);
            }
            if (info.originalSize) {
              this._originalSize.set(info.originalSize);
            }
            if (info.rect) {
              this._rect.set(info.rect);
            }
            if (info.offset) {
              this._offset.set(info.offset);
            }
            if (info.borderTop !== undefined) {
              this._capInsets[INSET_TOP] = info.borderTop;
            }
            if (info.borderBottom !== undefined) {
              this._capInsets[INSET_BOTTOM] = info.borderBottom;
            }
            if (info.borderLeft !== undefined) {
              this._capInsets[INSET_LEFT] = info.borderLeft;
            }
            if (info.borderRight !== undefined) {
              this._capInsets[INSET_RIGHT] = info.borderRight;
            }
            if (info.isRotate !== undefined) {
              this._rotated = !!info.isRotate;
            }
            if (info.isFlipUv !== undefined) {
              this._isFlipUVY = !!info.isFlipUv;
            }
            calUV = true;
          }
          if (calUV && this.texture) {
            this._calculateUV();
          }
          this._calcTrimmedBorder();
        }
        checkRect(texture) {
          const rect = this._rect;
          let maxX = rect.x;
          let maxY = rect.y;
          if (this._rotated) {
            maxX += rect.height;
            maxY += rect.width;
          } else {
            maxX += rect.width;
            maxY += rect.height;
          }
          if (maxX > texture.width) {
            errorID(3300, `${this.name}/${texture.name}`, maxX, texture.width);
            return false;
          }
          if (maxY > texture.height) {
            errorID(3301, `${this.name}/${texture.name}`, maxY, texture.height);
            return false;
          }
          return true;
        }
        _calcTrimmedBorder() {
          const ow = this._originalSize.width;
          const oh = this._originalSize.height;
          const rw = this._rect.width;
          const rh = this._rect.height;
          const halfTrimmedWidth = (ow - rw) * 0.5;
          const halfTrimmedHeight = (oh - rh) * 0.5;
          this._trimmedBorder.x = this._offset.x + halfTrimmedWidth;
          this._trimmedBorder.y = this._offset.x - halfTrimmedWidth;
          this._trimmedBorder.z = this._offset.y + halfTrimmedHeight;
          this._trimmedBorder.w = this._offset.y - halfTrimmedHeight;
        }
        ensureMeshData() {
          if (this._mesh) return;
          this._initVertices();
          this._createMesh();
        }
        destroy() {
          if (this._packable && dynamicAtlasManager) {
            dynamicAtlasManager.deleteAtlasSpriteFrame(this);
          }
          return super.destroy();
        }
        _calculateSlicedUV() {
          const rect = this._rect;
          const tex = this.texture;
          const atlasWidth = tex.width;
          const atlasHeight = tex.height;
          const leftWidth = this._capInsets[INSET_LEFT];
          const rightWidth = this._capInsets[INSET_RIGHT];
          const centerWidth = rect.width - leftWidth - rightWidth;
          const topHeight = this._capInsets[INSET_TOP];
          const bottomHeight = this._capInsets[INSET_BOTTOM];
          const centerHeight = rect.height - topHeight - bottomHeight;
          const uvSliced = this.uvSliced;
          uvSliced.length = 0;
          if (this._rotated) {
            temp_uvs[0].u = rect.x / atlasWidth;
            temp_uvs[1].u = (rect.x + bottomHeight) / atlasWidth;
            temp_uvs[2].u = (rect.x + bottomHeight + centerHeight) / atlasWidth;
            temp_uvs[3].u = (rect.x + rect.height) / atlasWidth;
            temp_uvs[3].v = rect.y / atlasHeight;
            temp_uvs[2].v = (rect.y + leftWidth) / atlasHeight;
            temp_uvs[1].v = (rect.y + leftWidth + centerWidth) / atlasHeight;
            temp_uvs[0].v = (rect.y + rect.width) / atlasHeight;
            for (let row = 0; row < 4; ++row) {
              const rowD = temp_uvs[row];
              for (let col = 0; col < 4; ++col) {
                const colD = temp_uvs[3 - col];
                uvSliced.push({
                  u: rowD.u,
                  v: colD.v
                });
              }
            }
          } else {
            temp_uvs[0].u = rect.x / atlasWidth;
            temp_uvs[1].u = (rect.x + leftWidth) / atlasWidth;
            temp_uvs[2].u = (rect.x + leftWidth + centerWidth) / atlasWidth;
            temp_uvs[3].u = (rect.x + rect.width) / atlasWidth;
            temp_uvs[3].v = rect.y / atlasHeight;
            temp_uvs[2].v = (rect.y + topHeight) / atlasHeight;
            temp_uvs[1].v = (rect.y + topHeight + centerHeight) / atlasHeight;
            temp_uvs[0].v = (rect.y + rect.height) / atlasHeight;
            for (let row = 0; row < 4; ++row) {
              const rowD = temp_uvs[row];
              for (let col = 0; col < 4; ++col) {
                const colD = temp_uvs[col];
                uvSliced.push({
                  u: colD.u,
                  v: rowD.v
                });
              }
            }
          }
          this.emit(SpriteFrame.EVENT_UV_UPDATED, this);
        }
        _calculateUV() {
          const rect = this._rect;
          const uv = this.uv;
          const unbiasUV = this.unbiasUV;
          const tex = this.texture;
          const texw = tex.width;
          const texh = tex.height;
          if (this._rotated) {
            const l = texw === 0 ? 0 : rect.x / texw;
            const r = texw === 0 ? 1 : (rect.x + rect.height) / texw;
            const t = texh === 0 ? 0 : rect.y / texh;
            const b = texh === 0 ? 1 : (rect.y + rect.width) / texh;
            if (this._isFlipUVX && this._isFlipUVY) {
              uv[0] = r;
              uv[1] = b;
              uv[2] = r;
              uv[3] = t;
              uv[4] = l;
              uv[5] = b;
              uv[6] = l;
              uv[7] = t;
            } else if (this._isFlipUVX) {
              uv[0] = r;
              uv[1] = t;
              uv[2] = r;
              uv[3] = b;
              uv[4] = l;
              uv[5] = t;
              uv[6] = l;
              uv[7] = b;
            } else if (this._isFlipUVY) {
              uv[0] = l;
              uv[1] = b;
              uv[2] = l;
              uv[3] = t;
              uv[4] = r;
              uv[5] = b;
              uv[6] = r;
              uv[7] = t;
            } else {
              uv[0] = l;
              uv[1] = t;
              uv[2] = l;
              uv[3] = b;
              uv[4] = r;
              uv[5] = t;
              uv[6] = r;
              uv[7] = b;
            }
            const ul = texw === 0 ? 0 : rect.x / texw;
            const ur = texw === 0 ? 1 : (rect.x + rect.height) / texw;
            const ut = texh === 0 ? 0 : rect.y / texh;
            const ub = texh === 0 ? 1 : (rect.y + rect.width) / texh;
            if (this._isFlipUVX && this._isFlipUVY) {
              unbiasUV[0] = ur;
              unbiasUV[1] = ub;
              unbiasUV[2] = ur;
              unbiasUV[3] = ut;
              unbiasUV[4] = ul;
              unbiasUV[5] = ub;
              unbiasUV[6] = ul;
              unbiasUV[7] = ut;
            } else if (this._isFlipUVX) {
              unbiasUV[0] = ur;
              unbiasUV[1] = ut;
              unbiasUV[2] = ur;
              unbiasUV[3] = ub;
              unbiasUV[4] = ul;
              unbiasUV[5] = ut;
              unbiasUV[6] = ul;
              unbiasUV[7] = ub;
            } else if (this._isFlipUVY) {
              unbiasUV[0] = ul;
              unbiasUV[1] = ub;
              unbiasUV[2] = ul;
              unbiasUV[3] = ut;
              unbiasUV[4] = ur;
              unbiasUV[5] = ub;
              unbiasUV[6] = ur;
              unbiasUV[7] = ut;
            } else {
              unbiasUV[0] = ul;
              unbiasUV[1] = ut;
              unbiasUV[2] = ul;
              unbiasUV[3] = ub;
              unbiasUV[4] = ur;
              unbiasUV[5] = ut;
              unbiasUV[6] = ur;
              unbiasUV[7] = ub;
            }
          } else {
            const l = texw === 0 ? 0 : rect.x / texw;
            const r = texw === 0 ? 1 : (rect.x + rect.width) / texw;
            const b = texh === 0 ? 1 : (rect.y + rect.height) / texh;
            const t = texh === 0 ? 0 : rect.y / texh;
            if (this._isFlipUVX && this._isFlipUVY) {
              uv[0] = r;
              uv[1] = t;
              uv[2] = l;
              uv[3] = t;
              uv[4] = r;
              uv[5] = b;
              uv[6] = l;
              uv[7] = b;
            } else if (this._isFlipUVX) {
              uv[0] = r;
              uv[1] = b;
              uv[2] = l;
              uv[3] = b;
              uv[4] = r;
              uv[5] = t;
              uv[6] = l;
              uv[7] = t;
            } else if (this._isFlipUVY) {
              uv[0] = l;
              uv[1] = t;
              uv[2] = r;
              uv[3] = t;
              uv[4] = l;
              uv[5] = b;
              uv[6] = r;
              uv[7] = b;
            } else {
              uv[0] = l;
              uv[1] = b;
              uv[2] = r;
              uv[3] = b;
              uv[4] = l;
              uv[5] = t;
              uv[6] = r;
              uv[7] = t;
            }
            const ul = texw === 0 ? 0 : rect.x / texw;
            const ur = texw === 0 ? 1 : (rect.x + rect.width) / texw;
            const ub = texh === 0 ? 1 : (rect.y + rect.height) / texh;
            const ut = texh === 0 ? 0 : rect.y / texh;
            if (this._isFlipUVX && this._isFlipUVY) {
              unbiasUV[0] = ur;
              unbiasUV[1] = ut;
              unbiasUV[2] = ul;
              unbiasUV[3] = ut;
              unbiasUV[4] = ur;
              unbiasUV[5] = ub;
              unbiasUV[6] = ul;
              unbiasUV[7] = ub;
            } else if (this._isFlipUVX) {
              unbiasUV[0] = ur;
              unbiasUV[1] = ub;
              unbiasUV[2] = ul;
              unbiasUV[3] = ub;
              unbiasUV[4] = ur;
              unbiasUV[5] = ut;
              unbiasUV[6] = ul;
              unbiasUV[7] = ut;
            } else if (this._isFlipUVY) {
              unbiasUV[0] = ul;
              unbiasUV[1] = ut;
              unbiasUV[2] = ur;
              unbiasUV[3] = ut;
              unbiasUV[4] = ul;
              unbiasUV[5] = ub;
              unbiasUV[6] = ur;
              unbiasUV[7] = ub;
            } else {
              unbiasUV[0] = ul;
              unbiasUV[1] = ub;
              unbiasUV[2] = ur;
              unbiasUV[3] = ub;
              unbiasUV[4] = ul;
              unbiasUV[5] = ut;
              unbiasUV[6] = ur;
              unbiasUV[7] = ut;
            }
          }
          this._calculateSlicedUV();
        }
        _setDynamicAtlasFrame(frame) {
          if (!frame) return;
          this._original = {
            _texture: this._texture,
            _x: this._rect.x,
            _y: this._rect.y
          };
          this._texture = frame.texture;
          this._rect.x = frame.x;
          this._rect.y = frame.y;
          this._calculateUV();
        }
        _resetDynamicAtlasFrame() {
          if (!this._original) return;
          this._rect.x = this._original._x;
          this._rect.y = this._original._y;
          this._texture = this._original._texture;
          this._original = null;
          this._calculateUV();
        }
        _checkPackable() {
          const dynamicAtlas = dynamicAtlasManager;
          if (!dynamicAtlas) return;
          const texture = this._texture;
          if (!(texture instanceof Texture2D$1) || texture.isCompressed) {
            this._packable = false;
            return;
          }
          const w = this.width;
          const h = this.height;
          if (!texture.image || w > dynamicAtlas.maxFrameSize || h > dynamicAtlas.maxFrameSize) {
            this._packable = false;
            return;
          }
          const CanvasElement = ccwindow$1.HTMLCanvasElement;
          if (texture.image && texture.image instanceof CanvasElement) {
            this._packable = true;
          }
        }
        _serialize(ctxForExporting) {
          return null;
        }
        _deserialize(serializeData, handle) {
          const data = serializeData;
          const rect = data.rect;
          if (rect) {
            this._rect = new Rect$1(rect.x, rect.y, rect.width, rect.height);
          }
          const offset = data.offset;
          if (data.offset) {
            this._offset = new Vec2(offset.x, offset.y);
          }
          const originalSize = data.originalSize;
          if (data.originalSize) {
            this._originalSize = new Size$1(originalSize.width, originalSize.height);
          }
          this._rotated = !!data.rotated;
          this._name = data.name;
          this._packable = !!data.packable;
          this._pixelsToUnit = data.pixelsToUnit;
          const pivot = data.pivot;
          if (pivot) {
            this._pivot = new Vec2(pivot.x, pivot.y);
          }
          this._meshType = data.meshType;
          const capInsets = data.capInsets;
          if (capInsets) {
            this._capInsets[INSET_LEFT] = capInsets[INSET_LEFT];
            this._capInsets[INSET_TOP] = capInsets[INSET_TOP];
            this._capInsets[INSET_RIGHT] = capInsets[INSET_RIGHT];
            this._capInsets[INSET_BOTTOM] = capInsets[INSET_BOTTOM];
          }
          const vertices = data.vertices;
          if (vertices) {
            if (!this.vertices) {
              this.vertices = {
                rawPosition: [],
                positions: [],
                indexes: vertices.indexes,
                uv: vertices.uv,
                nuv: vertices.nuv,
                minPos: new Vec3(vertices.minPos.x, vertices.minPos.y, vertices.minPos.z),
                maxPos: new Vec3(vertices.maxPos.x, vertices.maxPos.y, vertices.maxPos.z)
              };
            }
            this.vertices.rawPosition.length = 0;
            const rawPosition = vertices.rawPosition;
            for (let i = 0; i < rawPosition.length; i += 3) {
              this.vertices.rawPosition.push(new Vec3(rawPosition[i], rawPosition[i + 1], rawPosition[i + 2]));
            }
            this._updateMeshVertices();
          }
        }
        clone() {
          const sp = new SpriteFrame();
          const v = this.vertices;
          sp.vertices = v ? {
            rawPosition: v.rawPosition.slice(0),
            positions: v.positions.slice(0),
            indexes: v.indexes.slice(0),
            uv: v.uv.slice(0),
            nuv: v.nuv.slice(0),
            minPos: v.minPos.clone(),
            maxPos: v.minPos.clone()
          } : null;
          sp.uv.splice(0, sp.uv.length, ...this.uv);
          sp.unbiasUV.splice(0, sp.unbiasUV.length, ...this.unbiasUV);
          sp.uvSliced.splice(0, sp.uvSliced.length, ...this.uvSliced);
          sp._rect.set(this._rect);
          sp._offset.set(this._offset);
          sp._originalSize.set(this._originalSize);
          sp._rotated = this._rotated;
          sp._capInsets.splice(0, sp._capInsets.length, ...this._capInsets);
          sp._atlasUuid = this._atlasUuid;
          sp._texture = this._texture;
          sp._isFlipUVX = this._isFlipUVX;
          sp._isFlipUVY = this._isFlipUVY;
          sp._pixelsToUnit = this._pixelsToUnit;
          sp._pivot.set(this._pivot);
          sp._meshType = this._meshType;
          return sp;
        }
        _refreshTexture(texture) {
          this._texture = texture;
          const tex = this._texture;
          const config = {};
          let isReset = false;
          if (this._rect.width === 0 || this._rect.height === 0 || !this.checkRect(tex)) {
            config.rect = new Rect$1(0, 0, tex.width, tex.height);
            isReset = true;
          }
          if (this._originalSize.width === 0 || this._originalSize.height === 0 || isReset) {
            config.originalSize = new Size$1(tex.width, tex.height);
            isReset = true;
          }
          if (isReset) {
            this.reset(config);
          }
          this._checkPackable();
          if (this._mesh) {
            this._updateMesh();
          }
        }
        onLoaded() {
          this._calcTrimmedBorder();
        }
        initDefault(uuid) {
          super.initDefault(uuid);
          const texture = new Texture2D$1();
          texture.initDefault();
          this._refreshTexture(texture);
          this._calculateUV();
        }
        validate() {
          return this._texture && this._rect && this._rect.width !== 0 && this._rect.height !== 0;
        }
        _initVertices() {
          if (!this.vertices) {
            this.vertices = {
              rawPosition: [],
              positions: [],
              indexes: [],
              uv: [],
              nuv: [],
              minPos: new Vec3(),
              maxPos: new Vec3()
            };
          } else {
            this.vertices.rawPosition.length = 0;
            this.vertices.positions.length = 0;
            this.vertices.indexes.length = 0;
            this.vertices.uv.length = 0;
            this.vertices.nuv.length = 0;
            this.vertices.minPos.set(0, 0, 0);
            this.vertices.maxPos.set(0, 0, 0);
          }
          if (this._meshType === MeshType.POLYGON) ; else {
            const tex = this.texture;
            const texw = tex.width;
            const texh = tex.height;
            const rect = this.rect;
            const width = rect.width;
            const height = rect.height;
            const rectX = rect.x;
            const rectY = texh - rect.y - height;
            const halfWidth = width / 2;
            const halfHeight = height / 2;
            const l = texw === 0 ? 0 : rectX / texw;
            const r = texw === 0 ? 1 : (rectX + width) / texw;
            const t = texh === 0 ? 1 : (rectY + height) / texh;
            const b = texh === 0 ? 0 : rect.y / texh;
            temp_vec3.set(-halfWidth, -halfHeight, 0);
            this.vertices.rawPosition.push(temp_vec3.clone());
            this.vertices.uv.push(rectX);
            this.vertices.uv.push(rectY + height);
            this.vertices.nuv.push(l);
            this.vertices.nuv.push(b);
            this.vertices.minPos.set(temp_vec3);
            temp_vec3.set(halfWidth, -halfHeight, 0);
            this.vertices.rawPosition.push(temp_vec3.clone());
            this.vertices.uv.push(rectX + width);
            this.vertices.uv.push(rectY + height);
            this.vertices.nuv.push(r);
            this.vertices.nuv.push(b);
            temp_vec3.set(-halfWidth, halfHeight, 0);
            this.vertices.rawPosition.push(temp_vec3.clone());
            this.vertices.uv.push(rectX);
            this.vertices.uv.push(rectY);
            this.vertices.nuv.push(l);
            this.vertices.nuv.push(t);
            temp_vec3.set(halfWidth, halfHeight, 0);
            this.vertices.rawPosition.push(temp_vec3.clone());
            this.vertices.uv.push(rectX + width);
            this.vertices.uv.push(rectY);
            this.vertices.nuv.push(r);
            this.vertices.nuv.push(t);
            this.vertices.maxPos.set(temp_vec3);
            this.vertices.indexes.push(0);
            this.vertices.indexes.push(1);
            this.vertices.indexes.push(2);
            this.vertices.indexes.push(2);
            this.vertices.indexes.push(1);
            this.vertices.indexes.push(3);
          }
          this._updateMeshVertices();
        }
        _updateMeshVertices() {
          temp_matrix.identity();
          const units = 1 / this._pixelsToUnit;
          const PosX = -(this._pivot.x - 0.5) * this.rect.width * units;
          const PosY = -(this._pivot.y - 0.5) * this.rect.height * units;
          const temp_vec3 = new Vec3(PosX, PosY, 0);
          temp_matrix.transform(temp_vec3);
          temp_vec3.set(units, units, 1);
          temp_matrix.scale(temp_vec3);
          const vertices = this.vertices;
          for (let i = 0; i < vertices.rawPosition.length; i++) {
            const pos = vertices.rawPosition[i];
            Vec3.transformMat4(temp_vec3, pos, temp_matrix);
            Vec3.toArray(vertices.positions, temp_vec3, 3 * i);
          }
          Vec3.transformMat4(this._minPos, vertices.minPos, temp_matrix);
          Vec3.transformMat4(this._maxPos, vertices.maxPos, temp_matrix);
        }
        _createMesh() {
          this._mesh = createMesh({
            primitiveMode: PrimitiveMode.TRIANGLE_LIST,
            positions: this.vertices.positions,
            uvs: this.vertices.nuv,
            indices: this.vertices.indexes,
            minPos: this._minPos,
            maxPos: this._maxPos,
            attributes: [new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD, Format.RG32F)]
          });
        }
        _updateMesh() {
          if (this._mesh) {
            this._mesh.destroy();
          }
          this._initVertices();
          this._createMesh();
        }
      }, _class2$H.EVENT_UV_UPDATED = 'uv_updated', _class2$H.MeshType = MeshType, _class2$H)) || _class$M));
      legacyCC.SpriteFrame = SpriteFrame;

      removeProperty(TextureBase.prototype, 'TextureBase.prototype', [{
        name: 'hasPremultipliedAlpha'
      }, {
        name: 'setPremultiplyAlpha'
      }, {
        name: 'setFlipY'
      }]);
      replaceProperty(RenderTexture.prototype, 'RenderTexture.prototype', [{
        name: 'getGFXWindow',
        customFunction() {
          return this.window;
        }
      }]);

      const RenderingSubMesh = exports('RenderingSubMesh', jsb.RenderingSubMesh);
      const renderingSubMeshProto = RenderingSubMesh.prototype;
      renderingSubMeshProto._ctor = function (vertexBuffers, attributes, primitiveMode, indexBuffer = null, indirectBuffer = null) {
        jsb.Asset.prototype._ctor.apply(this, arguments);
        this._attributes = attributes;
        this._vertexBuffers = vertexBuffers;
        this._indexBuffer = indexBuffer;
        this._indirectBuffer = indirectBuffer;
      };
      Object.defineProperty(renderingSubMeshProto, 'geometricInfo', {
        configurable: true,
        enumerable: true,
        get() {
          let r = this.getGeometricInfo();
          if (!r.positions && !r.indices) {
            r.positions = new Float32Array();
            r.indices = new Uint8Array();
          }
          return r;
        }
      });
      Object.defineProperty(renderingSubMeshProto, 'attributes', {
        configurable: true,
        enumerable: true,
        get() {
          if (!this._attributes) {
            this._attributes = this.getAttributes();
          }
          return this._attributes;
        }
      });
      Object.defineProperty(renderingSubMeshProto, 'vertexBuffers', {
        configurable: true,
        enumerable: true,
        get() {
          if (!this._vertexBuffers) {
            this._vertexBuffers = this.getVertexBuffers();
          }
          return this._vertexBuffers;
        }
      });
      Object.defineProperty(renderingSubMeshProto, 'indexBuffer', {
        configurable: true,
        enumerable: true,
        get() {
          if (!this._indexBuffer) {
            this._indexBuffer = this.getIndexBuffer();
          }
          return this._indexBuffer;
        }
      });
      Object.defineProperty(renderingSubMeshProto, 'indirectBuffer', {
        configurable: true,
        enumerable: true,
        get() {
          if (!this._indirectBuffer) {
            this._indirectBuffer = this.getIndexBuffer();
          }
          return this._indirectBuffer;
        }
      });

      var _dec$N, _class$L, _class2$G, _initializer$D;
      let SpriteAtlas = exports('SpriteAtlas', (_dec$N = ccclass$3('cc.SpriteAtlas'), _dec$N(_class$L = (_class2$G = class SpriteAtlas extends Asset {
        constructor(...args) {
          super(...args);
          this.spriteFrames = _initializer$D && _initializer$D();
        }
        getTexture() {
          const keys = Object.keys(this.spriteFrames);
          if (keys.length > 0) {
            const spriteFrame = this.spriteFrames[keys[0]];
            return spriteFrame && spriteFrame.texture;
          } else {
            return null;
          }
        }
        getSpriteFrame(key) {
          const sf = this.spriteFrames[key];
          if (!sf) {
            return null;
          }
          if (!sf.name) {
            sf.name = key;
          }
          return sf;
        }
        getSpriteFrames() {
          const frames = [];
          const spriteFrames = this.spriteFrames;
          for (const key of Object.keys(spriteFrames)) {
            frames.push(spriteFrames[key]);
          }
          return frames;
        }
        _serialize(ctxForExporting) {
        }
        _deserialize(serializeData, handle) {
          const data = serializeData;
          this._name = data.name;
          const frames = data.spriteFrames;
          this.spriteFrames = createMap();
          for (let i = 0; i < frames.length; i += 2) {
            handle.result.push(this.spriteFrames, frames[i], frames[i + 1], getClassId(SpriteFrame));
          }
        }
      }, (_initializer$D = applyDecoratedInitializer(_class2$G.prototype, "spriteFrames", [serializable$3], function () {
        return createMap();
      })), _class2$G)) || _class$L));
      legacyCC.SpriteAtlas = SpriteAtlas;

      var _dec$M, _class$K;
      let Font = exports('Font', (_dec$M = ccclass$3('cc.Font'), _dec$M(_class$K = class Font extends Asset {}) || _class$K));
      legacyCC.Font = Font;

      var _dec$L, _class$J, _class2$F, _initializer$C;
      let TTFFont = exports('TTFFont', (_dec$L = ccclass$3('cc.TTFFont'), _dec$L(_class$J = (_class2$F = class TTFFont extends Font {
        constructor(...args) {
          super(...args);
          this._fontFamily = _initializer$C && _initializer$C();
        }
        get _nativeAsset() {
          return this._fontFamily;
        }
        set _nativeAsset(value) {
          this._fontFamily = value || 'Arial';
        }
        get _nativeDep() {
          return {
            uuid: this._uuid,
            __nativeName__: this._native,
            ext: extname(this._native),
            __isNative__: true
          };
        }
        initDefault(uuid) {
          this._fontFamily = 'Arial';
          super.initDefault(uuid);
        }
      }, (_initializer$C = applyDecoratedInitializer(_class2$F.prototype, "_fontFamily", [serializable$3], function () {
        return null;
      }), _applyDecoratedDescriptor(_class2$F.prototype, "_nativeAsset", [override, string], Object.getOwnPropertyDescriptor(_class2$F.prototype, "_nativeAsset"), _class2$F.prototype), _applyDecoratedDescriptor(_class2$F.prototype, "_nativeDep", [override], Object.getOwnPropertyDescriptor(_class2$F.prototype, "_nativeDep"), _class2$F.prototype)), _class2$F)) || _class$J));
      legacyCC.TTFFont = TTFFont;

      var _dec$K, _dec2$D, _class2$E, _class3$p, _initializer$B, _initializer2$v, _initializer3$p, _initializer4$m;
      class FontLetterDefinition$1 {
        constructor() {
          this.u = 0;
          this.v = 0;
          this.w = 0;
          this.h = 0;
          this.offsetX = 0;
          this.offsetY = 0;
          this.textureID = 0;
          this.valid = false;
          this.xAdvance = 0;
        }
      }
      class FontAtlas {
        constructor(texture) {
          this.letterDefinitions = {};
          this.texture = texture;
        }
        addLetterDefinitions(letter, letterDefinition) {
          this.letterDefinitions[letter] = letterDefinition;
        }
        cloneLetterDefinition() {
          const copyLetterDefinitions = {};
          for (const key of Object.keys(this.letterDefinitions)) {
            const value = new FontLetterDefinition$1();
            mixin(value, this.letterDefinitions[key]);
            copyLetterDefinitions[key] = value;
          }
          return copyLetterDefinitions;
        }
        getTexture() {
          return this.texture;
        }
        getLetter(key) {
          return this.letterDefinitions[key];
        }
        getLetterDefinitionForChar(char, labelInfo) {
          const key = char.charCodeAt(0);
          const hasKey = this.letterDefinitions.hasOwnProperty(key);
          let letter;
          if (hasKey) {
            letter = this.letterDefinitions[key];
          } else {
            letter = null;
          }
          return letter;
        }
        clear() {
          this.letterDefinitions = {};
        }
      }
      let BitmapFont = exports('BitmapFont', (_dec$K = ccclass$3('cc.BitmapFont'), _dec2$D = type$2(SpriteFrame), _dec$K(_class2$E = (_class3$p = class BitmapFont extends Font {
        constructor(...args) {
          super(...args);
          this.fntDataStr = _initializer$B && _initializer$B();
          this.spriteFrame = _initializer2$v && _initializer2$v();
          this.fontSize = _initializer3$p && _initializer3$p();
          this.fntConfig = _initializer4$m && _initializer4$m();
        }
        onLoaded() {
          const spriteFrame = this.spriteFrame;
          if (!this.fontDefDictionary && spriteFrame) {
            this.fontDefDictionary = new FontAtlas(spriteFrame.texture);
          }
          const fntConfig = this.fntConfig;
          if (!fntConfig) {
            warn('The fnt config is not exists!');
            return;
          }
          const fontDict = fntConfig.fontDefDictionary;
          for (const fontDef in fontDict) {
            const letter = new FontLetterDefinition$1();
            const rect = fontDict[fontDef].rect;
            letter.offsetX = fontDict[fontDef].xOffset;
            letter.offsetY = fontDict[fontDef].yOffset;
            letter.w = rect.width;
            letter.h = rect.height;
            letter.u = rect.x;
            letter.v = rect.y;
            letter.textureID = 0;
            letter.valid = true;
            letter.xAdvance = fontDict[fontDef].xAdvance;
            this.fontDefDictionary.addLetterDefinitions(fontDef, letter);
          }
        }
      }, (_initializer$B = applyDecoratedInitializer(_class3$p.prototype, "fntDataStr", [serializable$3], function () {
        return '';
      }), _initializer2$v = applyDecoratedInitializer(_class3$p.prototype, "spriteFrame", [_dec2$D], function () {
        return null;
      }), _initializer3$p = applyDecoratedInitializer(_class3$p.prototype, "fontSize", [serializable$3], function () {
        return -1;
      }), _initializer4$m = applyDecoratedInitializer(_class3$p.prototype, "fntConfig", [serializable$3], function () {
        return null;
      })), _class3$p)) || _class2$E));
      legacyCC.BitmapFont = BitmapFont;

      var _dec$J, _class$I;
      let LabelAtlas = exports('LabelAtlas', (_dec$J = ccclass$3('cc.LabelAtlas'), _dec$J(_class$I = class LabelAtlas extends BitmapFont {}) || _class$I));
      legacyCC.LabelAtlas = LabelAtlas;

      const BASELINE_RATIO = exports('BASELINE_RATIO', 0.26);
      let _BASELINE_OFFSET$1 = 0;
      const MIDDLE_RATIO = exports('MIDDLE_RATIO', (BASELINE_RATIO + 1) / 2 - BASELINE_RATIO);
      function getBaselineOffset() {
        return _BASELINE_OFFSET$1;
      }
      const MAX_CACHE_SIZE = 100;
      const pool$1 = new Pool$1(2);
      pool$1.get = function () {
        return this._get() || {
          key: '',
          value: 0,
          prev: null,
          next: null
        };
      };
      class LRUCache {
        constructor(size) {
          this.count = 0;
          this.limit = 0;
          this.datas = {};
          this.limit = size;
        }
        moveToHead(node) {
          node.next = this.head;
          node.prev = null;
          if (this.head) this.head.prev = node;
          this.head = node;
          if (!this.tail) this.tail = node;
          this.count++;
          this.datas[node.key] = node;
        }
        put(key, value) {
          const node = pool$1.get();
          node.key = key;
          node.value = value;
          if (this.count >= this.limit) {
            const discard = this.tail;
            delete this.datas[discard.key];
            this.count--;
            this.tail = discard.prev;
            this.tail.next = null;
            discard.prev = null;
            discard.next = null;
            pool$1.put(discard);
          }
          this.moveToHead(node);
        }
        remove(node) {
          if (node.prev) {
            node.prev.next = node.next;
          } else {
            this.head = node.next;
          }
          if (node.next) {
            node.next.prev = node.prev;
          } else {
            this.tail = node.prev;
          }
          delete this.datas[node.key];
          this.count--;
        }
        get(key) {
          const node = this.datas[key];
          if (node) {
            this.remove(node);
            this.moveToHead(node);
            return node.value;
          }
          return null;
        }
        clear() {
          this.count = 0;
          this.datas = {};
          this.head = null;
          this.tail = null;
        }
        has(key) {
          return !!this.datas[key];
        }
        delete(key) {
          const node = this.datas[key];
          this.remove(node);
        }
      } exports('LRUCache', LRUCache);
      const measureCache = new LRUCache(MAX_CACHE_SIZE);
      const WORD_REG = /([a-zA-Z0-9ÄÖÜäöüßéèçàùêâîôûа-яА-ЯЁё]+|\S)/;
      const SYMBOL_REG = /^[!,.:;'}\]%\?>、‘“》？。，！]/;
      const LAST_WORD_REG = /([a-zA-Z0-9ÄÖÜäöüßéèçàùêâîôûаíìÍÌïÁÀáàÉÈÒÓòóŐőÙÚŰúűñÑæÆœŒÃÂãÔõěščřžýáíéóúůťďňĚŠČŘŽÁÍÉÓÚŤżźśóńłęćąŻŹŚÓŃŁĘĆĄ-яА-ЯЁёáàảạãăắằẳẵặâấầẩẫậéèẻẽẹêếềểễệiíìỉĩịóòỏõọôốồổỗộơớờởỡợúùủũụưứừửữựýỳỷỹỵđÁÀẢẠÃĂẮẰẲẴẶÂẤẦẨẪẬÉÈẺẼẸÊẾỀỂỄỆIÍÌỈĨỊÓÒỎÕỌÔỐỒỔỖỘƠỚỜỞỠỢÚÙỦŨỤƯỨỪỬỮỰÝỲỶỸỴĐ]+|\S)$/;
      const LAST_ENGLISH_REG = /[a-zA-Z0-9ÄÖÜäöüßéèçàùêâîôûаíìÍÌïÁÀáàÉÈÒÓòóŐőÙÚŰúűñÑæÆœŒÃÂãÔõěščřžýáíéóúůťďňĚŠČŘŽÁÍÉÓÚŤżźśóńłęćąŻŹŚÓŃŁĘĆĄ-яА-ЯЁёáàảạãăắằẳẵặâấầẩẫậéèẻẽẹêếềểễệiíìỉĩịóòỏõọôốồổỗộơớờởỡợúùủũụưứừửữựýỳỷỹỵđÁÀẢẠÃĂẮẰẲẴẶÂẤẦẨẪẬÉÈẺẼẸÊẾỀỂỄỆIÍÌỈĨỊÓÒỎÕỌÔỐỒỔỖỘƠỚỜỞỠỢÚÙỦŨỤƯỨỪỬỮỰÝỲỶỸỴĐ]+$/;
      const FIRST_ENGLISH_REG = /^[a-zA-Z0-9ÄÖÜäöüßéèçàùêâîôûаíìÍÌïÁÀáàÉÈÒÓòóŐőÙÚŰúűñÑæÆœŒÃÂãÔõěščřžýáíéóúůťďňĚŠČŘŽÁÍÉÓÚŤżźśóńłęćąŻŹŚÓŃŁĘĆĄ-яА-ЯЁёáàảạãăắằẳẵặâấầẩẫậéèẻẽẹêếềểễệiíìỉĩịóòỏõọôốồổỗộơớờởỡợúùủũụưứừửữựýỳỷỹỵđÁÀẢẠÃĂẮẰẲẴẶÂẤẦẨẪẬÉÈẺẼẸÊẾỀỂỄỆIÍÌỈĨỊÓÒỎÕỌÔỐỒỔỖỘƠỚỜỞỠỢÚÙỦŨỤƯỨỪỬỮỰÝỲỶỸỴĐ]/;
      function isUnicodeCJK(ch) {
        const __CHINESE_REG = /^[\u4E00-\u9FFF\u3400-\u4DFF]+$/;
        const __JAPANESE_REG = /[\u3000-\u303F]|[\u3040-\u309F]|[\u30A0-\u30FF]|[\uFF00-\uFFEF]|[\u4E00-\u9FAF]|[\u2605-\u2606]|[\u2190-\u2195]|\u203B/g;
        const __KOREAN_REG = /^[\u1100-\u11FF]|[\u3130-\u318F]|[\uA960-\uA97F]|[\uAC00-\uD7AF]|[\uD7B0-\uD7FF]+$/;
        return __CHINESE_REG.test(ch) || __JAPANESE_REG.test(ch) || __KOREAN_REG.test(ch);
      }
      function isUnicodeSpace(ch) {
        const chCode = ch.charCodeAt(0);
        return chCode >= 9 && chCode <= 13 || chCode === 32 || chCode === 133 || chCode === 160 || chCode === 5760 || chCode >= 8192 && chCode <= 8202 || chCode === 8232 || chCode === 8233 || chCode === 8239 || chCode === 8287 || chCode === 12288;
      }
      function safeMeasureText(ctx, string, desc) {
        const font = desc || ctx.font;
        const key = `${font}\uD83C\uDFAE${string}`;
        const cache = measureCache.get(key);
        if (cache !== null) {
          return cache;
        }
        const metric = ctx.measureText(string);
        const width = metric && metric.width || 0;
        measureCache.put(key, width);
        return width;
      }
      function _safeSubstring(targetString, startIndex, endIndex) {
        let newStartIndex = startIndex;
        let newEndIndex = endIndex;
        const startChar = targetString[startIndex];
        if (startChar >= '\uDC00' && startChar <= '\uDFFF') {
          newStartIndex--;
        }
        if (endIndex !== undefined) {
          if (endIndex - 1 !== startIndex) {
            const endChar = targetString[endIndex - 1];
            if (endChar >= '\uD800' && endChar <= '\uDBFF') {
              newEndIndex--;
            }
          } else if (startChar >= '\uD800' && startChar <= '\uDBFF') {
            newEndIndex++;
          }
        }
        return targetString.substring(newStartIndex, newEndIndex);
      }
      function isEnglishWordPartAtFirst(stringToken) {
        return FIRST_ENGLISH_REG.test(stringToken);
      }
      function isEnglishWordPartAtLast(stringToken) {
        return LAST_ENGLISH_REG.test(stringToken);
      }
      function getEnglishWordPartAtFirst(stringToken) {
        const result = FIRST_ENGLISH_REG.exec(stringToken);
        return result;
      }
      function getEnglishWordPartAtLast(stringToken) {
        const result = LAST_ENGLISH_REG.exec(stringToken);
        return result;
      }
      function fragmentText(stringToken, allWidth, maxWidth, measureText) {
        const wrappedWords = [];
        if (stringToken.length === 0 || maxWidth < 0) {
          wrappedWords.push('');
          return wrappedWords;
        }
        let text = stringToken;
        while (allWidth > maxWidth && text.length > 1) {
          let fuzzyLen = text.length * (maxWidth / allWidth) | 0;
          let tmpText = _safeSubstring(text, fuzzyLen);
          let width = allWidth - measureText(tmpText);
          let sLine = tmpText;
          let pushNum = 0;
          let checkWhile = 0;
          const checkCount = 100;
          while (width > maxWidth && checkWhile++ < checkCount) {
            fuzzyLen *= maxWidth / width;
            fuzzyLen |= 0;
            tmpText = _safeSubstring(text, fuzzyLen);
            width = allWidth - measureText(tmpText);
          }
          checkWhile = 0;
          while (tmpText && width <= maxWidth && checkWhile++ < checkCount) {
            const exec = WORD_REG.exec(tmpText);
            pushNum = exec ? exec[0].length : 1;
            sLine = tmpText;
            fuzzyLen += pushNum;
            tmpText = _safeSubstring(text, fuzzyLen);
            width = allWidth - measureText(tmpText);
          }
          fuzzyLen -= pushNum;
          if (fuzzyLen === 0) {
            fuzzyLen = 1;
            sLine = _safeSubstring(text, 1);
          } else if (fuzzyLen === 1 && text[0] >= '\uD800' && text[0] <= '\uDBFF') {
            fuzzyLen = 2;
            sLine = _safeSubstring(text, 2);
          }
          let sText = _safeSubstring(text, 0, fuzzyLen);
          let result;
          {
            if (SYMBOL_REG.test(sLine || tmpText)) {
              result = LAST_WORD_REG.exec(sText);
              fuzzyLen -= result ? result[0].length : 0;
              if (fuzzyLen === 0) {
                fuzzyLen = 1;
              }
              sLine = _safeSubstring(text, fuzzyLen);
              sText = _safeSubstring(text, 0, fuzzyLen);
            }
          }
          if (FIRST_ENGLISH_REG.test(sLine)) {
            result = LAST_ENGLISH_REG.exec(sText);
            if (result && sText !== result[0]) {
              fuzzyLen -= result[0].length;
              sLine = _safeSubstring(text, fuzzyLen);
              sText = _safeSubstring(text, 0, fuzzyLen);
            }
          }
          if (wrappedWords.length === 0) {
            wrappedWords.push(sText);
          } else {
            sText = sText.trim();
            if (sText.length > 0) {
              wrappedWords.push(sText);
            }
          }
          text = sLine || tmpText;
          allWidth = measureText(text);
        }
        if (wrappedWords.length === 0) {
          wrappedWords.push(text);
        } else {
          text = text.trim();
          if (text.length > 0) {
            wrappedWords.push(text);
          }
        }
        return wrappedWords;
      }

      let _canvasPool;
      class CanvasPool {
        constructor() {
          this.pool = [];
        }
        static getInstance() {
          if (!_canvasPool) {
            _canvasPool = new CanvasPool();
          }
          return _canvasPool;
        }
        get() {
          let data = this.pool.pop();
          if (!data) {
            const canvas = ccwindow$1.document.createElement('canvas');
            const context = canvas.getContext('2d');
            data = {
              canvas,
              context
            };
          }
          return data;
        }
        put(canvas) {
          if (this.pool.length >= macro.MAX_LABEL_CANVAS_POOL_SIZE) {
            return;
          }
          this.pool.push(canvas);
        }
      }
      const WHITE$1 = Color$1.WHITE.clone();
      const space = 0;
      const bleed = 2;
      class FontLetterDefinition {
        constructor() {
          this.u = 0;
          this.v = 0;
          this.w = 0;
          this.h = 0;
          this.texture = null;
          this.offsetX = 0;
          this.offsetY = 0;
          this.valid = false;
          this.xAdvance = 0;
        }
      }
      const _backgroundStyle = `rgba(255, 255, 255, ${(1 / 255).toFixed(3)})`;
      const BASELINE_OFFSET = getBaselineOffset();
      class LetterTexture {
        constructor(char, labelInfo) {
          this.image = null;
          this.labelInfo = void 0;
          this.char = void 0;
          this.data = null;
          this.canvas = null;
          this.context = null;
          this.width = 0;
          this.height = 0;
          this.offsetY = 0;
          this.hash = void 0;
          this.char = char;
          this.labelInfo = labelInfo;
          this.hash = `${char.charCodeAt(0)}${labelInfo.hash}`;
        }
        updateRenderData() {
          this._updateProperties();
          this._updateTexture();
        }
        destroy() {
          this.image = null;
          CanvasPool.getInstance().put(this.data);
        }
        _updateProperties() {
          this.data = CanvasPool.getInstance().get();
          this.canvas = this.data.canvas;
          this.context = this.data.context;
          if (this.context) {
            const fontScale = this.labelInfo.fontScale;
            this.context.font = this.labelInfo.fontDesc;
            const width = safeMeasureText(this.context, this.char, this.labelInfo.fontDesc);
            const blank = this.labelInfo.margin * 2 + bleed;
            this.width = parseFloat(width.toFixed(2)) * fontScale + blank;
            this.height = (1 + BASELINE_RATIO) * this.labelInfo.fontSize * fontScale + blank;
            this.offsetY = -(this.labelInfo.fontSize * BASELINE_RATIO) * fontScale / 2;
          }
          if (this.canvas.width !== this.width) {
            this.canvas.width = this.width;
          }
          if (this.canvas.height !== this.height) {
            this.canvas.height = this.height;
          }
          if (!this.image) {
            this.image = new ImageAsset$1();
          }
          this.image.reset(this.canvas);
        }
        _updateTexture() {
          if (!this.context || !this.canvas) {
            return;
          }
          const context = this.context;
          const labelInfo = this.labelInfo;
          const width = this.canvas.width;
          const height = this.canvas.height;
          const fontScale = labelInfo.fontScale;
          context.textAlign = 'center';
          context.textBaseline = 'alphabetic';
          context.clearRect(0, 0, width, height);
          context.fillStyle = _backgroundStyle;
          context.fillRect(0, 0, width, height);
          context.font = labelInfo.fontDesc.replace(/(\d+)(\.\d+)?(px|em|rem|pt)/g, (w, m, n, u) => (+m * fontScale + (+n || 0) * fontScale).toString() + u);
          const fontSize = labelInfo.fontSize * fontScale;
          const startX = width / 2;
          const startY = height / 2 + fontSize * MIDDLE_RATIO + fontSize * BASELINE_OFFSET;
          const color = labelInfo.color;
          context.lineJoin = 'round';
          context.fillStyle = `rgba(${color.r}, ${color.g}, ${color.b}, ${1})`;
          if (labelInfo.isOutlined) {
            const strokeColor = labelInfo.out || WHITE$1;
            context.strokeStyle = `rgba(${strokeColor.r}, ${strokeColor.g}, ${strokeColor.b}, ${strokeColor.a / 255})`;
            context.lineWidth = labelInfo.margin * 2 * fontScale;
            context.strokeText(this.char, startX, startY);
          }
          context.fillText(this.char, startX, startY);
        }
      }
      class LetterRenderTexture extends Texture2D$1 {
        initWithSize(width, height, format = PixelFormat.RGBA8888) {
          this.reset({
            width,
            height,
            format
          });
        }
        drawTextureAt(image, x, y) {
          const gfxTexture = this.getGFXTexture();
          if (!image || !gfxTexture) {
            return;
          }
          const gfxDevice = this._getGFXDevice();
          if (!gfxDevice) {
            console.warn('Unable to get device');
            return;
          }
          const region = new BufferTextureCopy();
          region.texOffset.x = x;
          region.texOffset.y = y;
          region.texExtent.width = image.width;
          region.texExtent.height = image.height;
          gfxDevice.copyTexImagesToTexture([image.data], gfxTexture, [region]);
        }
      }
      class LetterAtlas {
        get width() {
          return this._width;
        }
        get height() {
          return this._height;
        }
        constructor(width, height) {
          this._x = space;
          this._y = space;
          this._nextY = space;
          this._width = 0;
          this._height = 0;
          this._halfBleed = 0;
          this._dirty = false;
          const texture = new LetterRenderTexture();
          texture.initWithSize(width, height);
          this.fontDefDictionary = new FontAtlas(texture);
          this._halfBleed = bleed / 2;
          this._width = width;
          this._height = height;
          director.on(Director.EVENT_BEFORE_SCENE_LAUNCH, this.beforeSceneLoad, this);
        }
        insertLetterTexture(letterTexture) {
          const texture = letterTexture.image;
          const device = director.root.device;
          if (!texture || !this.fontDefDictionary || !device) {
            return null;
          }
          const width = texture.width;
          const height = texture.height;
          if (this._x + width + space > this._width) {
            this._x = space;
            this._y = this._nextY;
          }
          if (this._y + height > this._nextY) {
            this._nextY = this._y + height + space;
          }
          if (this._nextY > this._height) {
            warnID(12100);
            return null;
          }
          this.fontDefDictionary.texture.drawTextureAt(texture, this._x, this._y);
          this._dirty = true;
          const letterDefinition = new FontLetterDefinition();
          letterDefinition.u = this._x + this._halfBleed;
          letterDefinition.v = this._y + this._halfBleed;
          letterDefinition.texture = this.fontDefDictionary.texture;
          letterDefinition.valid = true;
          letterDefinition.w = letterTexture.width - bleed;
          letterDefinition.h = letterTexture.height - bleed;
          letterDefinition.xAdvance = letterDefinition.w;
          letterDefinition.offsetY = letterTexture.offsetY;
          this._x += width + space;
          this.fontDefDictionary.addLetterDefinitions(letterTexture.hash, letterDefinition);
          return letterDefinition;
        }
        update() {
          if (!this._dirty) {
            return;
          }
          this._dirty = false;
        }
        reset() {
          this._x = space;
          this._y = space;
          this._nextY = space;
          this.fontDefDictionary.clear();
        }
        destroy() {
          this.reset();
          if (this.fontDefDictionary) {
            this.fontDefDictionary.texture.destroy();
            this.fontDefDictionary.texture = null;
          }
        }
        getTexture() {
          return this.fontDefDictionary.getTexture();
        }
        beforeSceneLoad() {
          this.clearAllCache();
        }
        clearAllCache() {
          this.destroy();
          const texture = new LetterRenderTexture();
          texture.initWithSize(this._width, this._height);
          this.fontDefDictionary.texture = texture;
        }
        getLetter(key) {
          return this.fontDefDictionary.letterDefinitions[key];
        }
        getLetterDefinitionForChar(char, labelInfo) {
          const hash = char.charCodeAt(0) + labelInfo.hash;
          let letter = this.fontDefDictionary.letterDefinitions[hash];
          if (!letter) {
            const temp = new LetterTexture(char, labelInfo);
            temp.updateRenderData();
            letter = this.insertLetterTexture(temp);
            temp.destroy();
          }
          return letter;
        }
      }
      const shareLabelInfo = {
        fontAtlas: null,
        fontSize: 0,
        lineHeight: 0,
        hAlign: 0,
        vAlign: 0,
        hash: '',
        fontFamily: '',
        fontDesc: 'Arial',
        color: Color$1.WHITE.clone(),
        isOutlined: false,
        out: Color$1.WHITE.clone(),
        margin: 0,
        fontScale: 1
      };
      function computeHash(labelInfo) {
        const hashData = '';
        const color = labelInfo.color.toHEX();
        let out = '';
        if (labelInfo.isOutlined && labelInfo.margin > 0) {
          out = out + labelInfo.margin + labelInfo.out.toHEX();
        }
        return hashData + labelInfo.fontSize + labelInfo.fontFamily + color + out;
      }

      const vfmt = [new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F)];
      const vfmtPosColor = [new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F), new Attribute(AttributeName.ATTR_COLOR, Format.RGBA32F)];
      const vfmtPosUvColor = [new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD, Format.RG32F), new Attribute(AttributeName.ATTR_COLOR, Format.RGBA32F)];
      const vfmtPosUvColor4B = [new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD, Format.RG32F), new Attribute(AttributeName.ATTR_COLOR, Format.RGBA8, true)];
      const vfmtPosUvTwoColor = [new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD, Format.RG32F), new Attribute(AttributeName.ATTR_COLOR, Format.RGBA32F), new Attribute(AttributeName.ATTR_COLOR2, Format.RGBA32F)];
      const vfmtPosUvTwoColor4B = [new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD, Format.RG32F), new Attribute(AttributeName.ATTR_COLOR, Format.RGBA8, true), new Attribute(AttributeName.ATTR_COLOR2, Format.RGBA8, true)];
      function getComponentPerVertex(attrs) {
        let count = 0;
        for (let i = 0; i < attrs.length; i++) {
          const attr = attrs[i];
          const info = FormatInfos[attr.format];
          count += info.count;
        }
        return count;
      }
      function getAttributeStride(attrs) {
        let count = 0;
        for (let i = 0; i < attrs.length; i++) {
          const attr = attrs[i];
          const info = FormatInfos[attr.format];
          count += info.size;
        }
        return count;
      }
      legacyCC.internal.vfmtPosUvColor = vfmtPosUvColor;
      legacyCC.internal.vfmtPosUvTwoColor = vfmtPosUvTwoColor;
      legacyCC.internal.vfmtPosUvColor4B = vfmtPosUvColor4B;
      legacyCC.internal.vfmtPosUvTwoColor4B = vfmtPosUvTwoColor4B;

      var vertexFormat = /*#__PURE__*/Object.freeze({
        __proto__: null,
        vfmt: vfmt,
        vfmtPosColor: vfmtPosColor,
        vfmtPosUvColor: vfmtPosUvColor,
        vfmtPosUvColor4B: vfmtPosUvColor4B,
        vfmtPosUvTwoColor: vfmtPosUvTwoColor,
        vfmtPosUvTwoColor4B: vfmtPosUvTwoColor4B,
        getComponentPerVertex: getComponentPerVertex,
        getAttributeStride: getAttributeStride
      });
      exports('UIVertexFormat', vertexFormat);

      const NativeRenderDrawInfo = n2d.RenderDrawInfo;
      n2d.Batcher2d;
      const NativeUIMeshBuffer = n2d.UIMeshBuffer;
      const NativeRenderEntity = n2d.RenderEntity;
      const NativeUIModelProxy = n2d.UIModelProxy;
      n2d.StencilManager;

      var MeshBufferSharedBufferView;
      (function (MeshBufferSharedBufferView) {
        MeshBufferSharedBufferView[MeshBufferSharedBufferView["byteOffset"] = 0] = "byteOffset";
        MeshBufferSharedBufferView[MeshBufferSharedBufferView["vertexOffset"] = 1] = "vertexOffset";
        MeshBufferSharedBufferView[MeshBufferSharedBufferView["indexOffset"] = 2] = "indexOffset";
        MeshBufferSharedBufferView[MeshBufferSharedBufferView["dirty"] = 3] = "dirty";
        MeshBufferSharedBufferView[MeshBufferSharedBufferView["count"] = 4] = "count";
      })(MeshBufferSharedBufferView || (MeshBufferSharedBufferView = {}));
      const IA_POOL_USED_SCALE = 1 / 2;
      class MeshBuffer {
        get attributes() {
          return this._attributes;
        }
        get vertexFormatBytes() {
          return this._vertexFormatBytes;
        }
        get byteOffset() {
          return this._byteOffset;
        }
        set byteOffset(val) {
          this._byteOffset = val;
          {
            this._sharedBuffer[MeshBufferSharedBufferView.byteOffset] = val;
          }
        }
        get vertexOffset() {
          return this._vertexOffset;
        }
        set vertexOffset(val) {
          this._vertexOffset = val;
          {
            this._sharedBuffer[MeshBufferSharedBufferView.vertexOffset] = val;
          }
        }
        get indexOffset() {
          return this._indexOffset;
        }
        set indexOffset(val) {
          this._indexOffset = val;
          {
            this._sharedBuffer[MeshBufferSharedBufferView.indexOffset] = val;
          }
        }
        get dirty() {
          return this._dirty;
        }
        set dirty(val) {
          this._dirty = val;
          {
            this._sharedBuffer[MeshBufferSharedBufferView.dirty] = val ? 1 : 0;
          }
        }
        get floatsPerVertex() {
          return this._floatsPerVertex;
        }
        set floatsPerVertex(val) {
          this._floatsPerVertex = val;
        }
        get vData() {
          return this._vData;
        }
        set vData(val) {
          this._vData = val;
          {
            this._nativeObj.vData = val;
          }
        }
        get iData() {
          return this._iData;
        }
        set iData(val) {
          this._iData = val;
          {
            this._nativeObj.iData = val;
          }
        }
        get nativeObj() {
          return this._nativeObj;
        }
        get sharedBuffer() {
          return this._sharedBuffer;
        }
        initSharedBuffer() {
          {
            this._sharedBuffer = new Uint32Array(MeshBufferSharedBufferView.count);
          }
        }
        syncSharedBufferToNative() {
          {
            this._nativeObj.syncSharedBufferToNative(this._sharedBuffer);
          }
        }
        constructor() {
          this._byteOffset = 0;
          this._vertexOffset = 0;
          this._indexOffset = 0;
          this._dirty = false;
          this._floatsPerVertex = 0;
          this._vData = null;
          this._iData = null;
          this._vertexFormatBytes = 0;
          this._initVDataCount = 0;
          this._initIDataCount = 0;
          this._attributes = null;
          this._iaPool = [];
          this._iaInfo = null;
          this._nextFreeIAHandle = 0;
          {
            this._nativeObj = new NativeUIMeshBuffer();
          }
          this.initSharedBuffer();
          this.syncSharedBufferToNative();
        }
        initialize(device, attrs, vFloatCount, iCount) {
          this._initVDataCount = vFloatCount;
          this._initIDataCount = iCount;
          this._attributes = attrs;
          this.floatsPerVertex = getAttributeStride(attrs) >> 2;
          assertIsTrue(this._initVDataCount / this._floatsPerVertex < 65536, getError(9005));
          if (!this.vData || !this.iData) {
            this.vData = new Float32Array(this._initVDataCount);
            this.iData = new Uint16Array(this._initIDataCount);
          }
          this._iaPool.push(this.createNewIA(device));
          {
            this._nativeObj.initialize(attrs);
          }
        }
        reset() {
          this._nextFreeIAHandle = 0;
          this.dirty = false;
        }
        destroy() {
          this.reset();
          this._attributes = null;
          this._iaInfo = null;
          this.vData = null;
          this.iData = null;
          for (let i = 0; i < this._iaPool.length; ++i) {
            const iaRef = this._iaPool[i];
            if (iaRef.vertexBuffers[0]) {
              iaRef.vertexBuffers[0].destroy();
            }
            if (iaRef.indexBuffer) {
              iaRef.indexBuffer.destroy();
            }
            iaRef.ia.destroy();
          }
          this._iaPool.length = 0;
        }
        setDirty() {
          this.dirty = true;
        }
        request(vertexCount, indexCount) {
          warnID(9002);
          return false;
        }
        requireFreeIA(device) {
          if (this._iaPool.length <= this._nextFreeIAHandle) {
            this._iaPool.push(this.createNewIA(device));
          }
          const ia = this._iaPool[this._nextFreeIAHandle++].ia;
          return ia;
        }
        recycleIA(ia) {
          const pool = this._iaPool;
          for (let i = 0; i < this._nextFreeIAHandle; ++i) {
            if (ia === pool[i].ia) {
              const iaRef = pool[i];
              pool[i] = pool[--this._nextFreeIAHandle];
              pool[this._nextFreeIAHandle] = iaRef;
              return;
            }
          }
        }
        checkCapacity(vertexCount, indexCount) {
          const maxVertex = (this.vertexOffset + vertexCount) * this._floatsPerVertex;
          const maxIndex = this.indexOffset + indexCount;
          if (maxVertex > this._initVDataCount || maxIndex > this._initIDataCount) {
            return false;
          }
          return true;
        }
        uploadBuffers() {
          if (this.byteOffset === 0 || !this._dirty) {
            return;
          }
          const iOS14 = sys.__isWebIOS14OrIPadOS14Env;
          const submitCount = iOS14 ? this._nextFreeIAHandle : 1;
          if (iOS14 && submitCount / this._iaPool.length < IA_POOL_USED_SCALE) {
            const count = submitCount / IA_POOL_USED_SCALE;
            const length = this._iaPool.length;
            for (let i = length - 1; i >= count; i--) {
              const iaRef = this._iaPool[i];
              if (iaRef.vertexBuffers[0]) {
                iaRef.vertexBuffers[0].destroy();
              }
              if (iaRef.indexBuffer) {
                iaRef.indexBuffer.destroy();
              }
              iaRef.ia.destroy();
            }
            this._iaPool.length = count;
          }
          const byteCount = this.byteOffset;
          const indexCount = this.indexOffset;
          for (let i = 0; i < submitCount; ++i) {
            const iaRef = this._iaPool[i];
            const verticesData = new Float32Array(this.vData.buffer, 0, byteCount >> 2);
            const indicesData = new Uint16Array(this.iData.buffer, 0, indexCount);
            const vertexBuffer = iaRef.vertexBuffers[0];
            if (byteCount > vertexBuffer.size) {
              vertexBuffer.resize(byteCount);
            }
            vertexBuffer.update(verticesData);
            if (indexCount * 2 > iaRef.indexBuffer.size) {
              iaRef.indexBuffer.resize(indexCount * 2);
            }
            iaRef.indexBuffer.update(indicesData);
          }
          this.dirty = false;
        }
        createNewIA(device) {
          let ia;
          let vertexBuffers;
          let indexBuffer;
          if (sys.__isWebIOS14OrIPadOS14Env || !this._iaPool[0]) {
            const vbStride = this._vertexFormatBytes = this._floatsPerVertex * Float32Array.BYTES_PER_ELEMENT;
            const ibStride = Uint16Array.BYTES_PER_ELEMENT;
            const vertexBuffer = device.createBuffer(new BufferInfo(BufferUsageBit.VERTEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, vbStride, vbStride));
            indexBuffer = device.createBuffer(new BufferInfo(BufferUsageBit.INDEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, ibStride, ibStride));
            vertexBuffers = [vertexBuffer];
            this._iaInfo = new InputAssemblerInfo(this._attributes, vertexBuffers, indexBuffer);
            ia = device.createInputAssembler(this._iaInfo);
          } else {
            ia = device.createInputAssembler(this._iaInfo);
            vertexBuffers = this._iaInfo.vertexBuffers;
            indexBuffer = this._iaInfo.indexBuffer;
          }
          return {
            ia,
            vertexBuffers,
            indexBuffer
          };
        }
      } exports('MeshBuffer', MeshBuffer);

      class BufferAccessor {
        get attributes() {
          return this._attributes;
        }
        get vertexFormatBytes() {
          return this._vertexFormatBytes;
        }
        get floatsPerVertex() {
          return this._floatsPerVertex;
        }
        constructor(device, attributes) {
          this._device = null;
          this._attributes = null;
          this._vertexFormatBytes = void 0;
          this._floatsPerVertex = void 0;
          this._buffers = [];
          this._device = device;
          this._attributes = attributes;
          this._floatsPerVertex = getAttributeStride(attributes) >> 2;
          this._vertexFormatBytes = this._floatsPerVertex * Float32Array.BYTES_PER_ELEMENT;
        }
        initialize() {}
        reset() {}
        request(vertexCount = 4, indexCount = 6) {}
        appendBuffers(vertices, indices) {}
        uploadBuffers() {}
        destroy() {
          this._attributes.length = 0;
        }
      }

      const _entryPool = new Pool(() => ({
        offset: 0,
        length: 0
      }), 32);
      class StaticVBChunk {
        get ib() {
          return this._ib;
        }
        constructor(vertexAccessor, bufferId, meshBuffer, vertexOffset, vb, indexCount) {
          this._ib = void 0;
          this.vertexAccessor = vertexAccessor;
          this.bufferId = bufferId;
          this.meshBuffer = meshBuffer;
          this.vertexOffset = vertexOffset;
          this.vb = vb;
          this.indexCount = indexCount;
          this._ib = new Uint16Array(indexCount);
          assertIsTrue(meshBuffer === vertexAccessor.getMeshBuffer(bufferId));
        }
        setIndexBuffer(indices) {
          {
            assertIsTrue(indices.length === this.ib.length);
            for (let i = 0; i < indices.length; ++i) {
              const vid = indices[i];
              this._ib[i] = this.vertexOffset + vid;
            }
          }
        }
      }
      class StaticVBAccessor extends BufferAccessor {
        get id() {
          return this._id;
        }
        constructor(device, attributes, vCount, iCount) {
          super(device, attributes);
          this._freeLists = [];
          this._vCount = 0;
          this._iCount = 0;
          this._id = 0;
          this._vCount = vCount || Math.floor(macro.BATCHER2D_MEM_INCREMENT * 1024 / this._vertexFormatBytes);
          this._iCount = iCount || this._vCount * StaticVBAccessor.IB_SCALE;
          this._id = StaticVBAccessor.generateID();
          this._allocateBuffer();
        }
        destroy() {
          for (let i = 0; i < this._buffers.length; ++i) {
            this._buffers[i].destroy();
            const freeList = this._freeLists[i];
            for (let j = 0; j < freeList.length; ++j) {
              _entryPool.free(freeList[j]);
            }
          }
          this._buffers.length = 0;
          this._freeLists.length = 0;
          super.destroy();
        }
        reset() {
          for (let i = 0; i < this._buffers.length; ++i) {
            const buffer = this._buffers[i];
            buffer.indexOffset = 0;
            buffer.reset();
          }
        }
        getVertexBuffer(bid) {
          return this._buffers[bid].vData;
        }
        getIndexBuffer(bid) {
          return this._buffers[bid].iData;
        }
        getMeshBuffer(bid) {
          return this._buffers[bid];
        }
        uploadBuffers() {
          for (let i = 0; i < this._buffers.length; ++i) {
            const firstEntry = this._freeLists[i][0];
            const buffer = this._buffers[i];
            if (!firstEntry || firstEntry.length < buffer.vData.byteLength) {
              buffer.uploadBuffers();
            }
          }
        }
        appendIndices(bufferId, indices) {
          const buf = this._buffers[bufferId];
          const iCount = indices.length;
          if (iCount) {
            const needLength = buf.indexOffset + indices.length;
            if (buf.iData.length < needLength) {
              const expansionLength = Math.floor(1.25 * needLength);
              const newIData = new Uint16Array(expansionLength);
              newIData.set(buf.iData);
              buf.iData = newIData;
            }
            buf.iData.set(indices, buf.indexOffset);
            buf.indexOffset += indices.length;
          }
        }
        allocateChunk(vertexCount, indexCount) {
          const byteLength = vertexCount * this.vertexFormatBytes;
          let buf = null;
          let freeList;
          let bid = 0;
          let eid = -1;
          let entry = null;
          for (let i = 0; i < this._buffers.length; ++i) {
            buf = this._buffers[i];
            freeList = this._freeLists[i];
            for (let e = 0; e < freeList.length; ++e) {
              if (freeList[e].length >= byteLength) {
                entry = freeList[e];
                bid = i;
                eid = e;
                break;
              }
            }
            if (entry) break;
          }
          if (!entry) {
            bid = this._allocateBuffer();
            buf = this._buffers[bid];
            if (buf && buf.checkCapacity(vertexCount, indexCount)) {
              eid = 0;
              entry = this._freeLists[bid][eid];
            }
          }
          if (entry) {
            const vertexOffset = entry.offset / this.vertexFormatBytes;
            assertIsTrue(Number.isInteger(vertexOffset));
            const vb = new Float32Array(buf.vData.buffer, entry.offset, byteLength >> 2).fill(0);
            this._allocateChunkFromEntry(bid, eid, entry, byteLength);
            return new StaticVBChunk(this, bid, buf, vertexOffset, vb, indexCount);
          } else {
            errorID(9004, byteLength);
            return null;
          }
        }
        recycleChunk(chunk) {
          const freeList = this._freeLists[chunk.bufferId];
          const buf = this._buffers[chunk.bufferId];
          let offset = chunk.vertexOffset * this.vertexFormatBytes;
          let bytes = chunk.vb.byteLength;
          if (bytes === 0) return;
          let recycled = false;
          let i = 0;
          let prevEntry = null;
          let nextEntry = freeList[i];
          while (nextEntry && nextEntry.offset < offset) {
            prevEntry = nextEntry;
            nextEntry = freeList[++i];
          }
          if (prevEntry) {
            const distance = offset - (prevEntry.offset + prevEntry.length);
            assertIsTrue(distance >= 0);
            if (distance === 0) {
              prevEntry.length += bytes;
              offset = prevEntry.offset;
              bytes = prevEntry.length;
              if (nextEntry && nextEntry.offset - (offset + bytes) === 0) {
                prevEntry.length += nextEntry.length;
                freeList.splice(i, 1);
                _entryPool.free(nextEntry);
                nextEntry = null;
              }
              recycled = true;
            }
          }
          if (!recycled && nextEntry) {
            const distance = nextEntry.offset - (offset + bytes);
            assertIsTrue(distance >= 0);
            if (distance === 0) {
              nextEntry.offset = offset;
              nextEntry.length += bytes;
            } else {
              const newEntry = _entryPool.alloc();
              newEntry.offset = offset;
              newEntry.length = bytes;
              freeList.splice(i, 0, newEntry);
            }
            recycled = true;
          }
          if (recycled) {
            if (offset + bytes === buf.byteOffset) {
              buf.byteOffset = offset;
            }
          } else {
            const newEntry = _entryPool.alloc();
            newEntry.offset = offset;
            newEntry.length = bytes;
            freeList.push(newEntry);
          }
        }
        _allocateChunkFromEntry(bid, eid, entry, bytes) {
          const remaining = entry.length - bytes;
          const offset = entry.offset + bytes;
          const buf = this._buffers[bid];
          if (buf.byteOffset < offset) {
            buf.byteOffset = offset;
          }
          assertID(remaining >= 0, 9004, bid, entry.offset, entry.length);
          if (remaining === 0) {
            this._freeLists[bid].splice(eid, 1);
            _entryPool.free(entry);
          } else {
            entry.offset += bytes;
            entry.length = remaining;
          }
        }
        _allocateBuffer() {
          assertID(this._buffers.length === this._freeLists.length, 9003);
          const buffer = new MeshBuffer();
          const vFloatCount = this._vCount * this._floatsPerVertex;
          buffer.initialize(this._device, this._attributes, vFloatCount, this._iCount);
          this._buffers.push(buffer);
          const entry = _entryPool.alloc();
          entry.offset = 0;
          entry.length = buffer.vData.byteLength;
          const freeList = [entry];
          this._freeLists.push(freeList);
          const batcher = director.root.batcher2D;
          batcher.syncMeshBuffersToNative(this.id, this._buffers);
          return this._buffers.length - 1;
        }
        static generateID() {
          return StaticVBAccessor.ID_COUNT++;
        }
      }
      StaticVBAccessor.IB_SCALE = 4;
      StaticVBAccessor.ID_COUNT = 0;

      let AttrUInt8ArrayView;
      (function (AttrUInt8ArrayView) {
        AttrUInt8ArrayView[AttrUInt8ArrayView["DrawInfoType"] = 0] = "DrawInfoType";
        AttrUInt8ArrayView[AttrUInt8ArrayView["VertDirty"] = 1] = "VertDirty";
        AttrUInt8ArrayView[AttrUInt8ArrayView["IsMeshBuffer"] = 2] = "IsMeshBuffer";
        AttrUInt8ArrayView[AttrUInt8ArrayView["Stride"] = 3] = "Stride";
        AttrUInt8ArrayView[AttrUInt8ArrayView["Count"] = 4] = "Count";
      })(AttrUInt8ArrayView || (AttrUInt8ArrayView = {}));
      let AttrUInt16ArrayView;
      (function (AttrUInt16ArrayView) {
        AttrUInt16ArrayView[AttrUInt16ArrayView["BufferID"] = 0] = "BufferID";
        AttrUInt16ArrayView[AttrUInt16ArrayView["AccessorID"] = 1] = "AccessorID";
        AttrUInt16ArrayView[AttrUInt16ArrayView["Count"] = 2] = "Count";
      })(AttrUInt16ArrayView || (AttrUInt16ArrayView = {}));
      let AttrUInt32ArrayView;
      (function (AttrUInt32ArrayView) {
        AttrUInt32ArrayView[AttrUInt32ArrayView["VertexOffset"] = 0] = "VertexOffset";
        AttrUInt32ArrayView[AttrUInt32ArrayView["IndexOffset"] = 1] = "IndexOffset";
        AttrUInt32ArrayView[AttrUInt32ArrayView["VBCount"] = 2] = "VBCount";
        AttrUInt32ArrayView[AttrUInt32ArrayView["IBCount"] = 3] = "IBCount";
        AttrUInt32ArrayView[AttrUInt32ArrayView["DataHash"] = 4] = "DataHash";
        AttrUInt32ArrayView[AttrUInt32ArrayView["Count"] = 5] = "Count";
      })(AttrUInt32ArrayView || (AttrUInt32ArrayView = {}));
      let RenderDrawInfoType;
      (function (RenderDrawInfoType) {
        RenderDrawInfoType[RenderDrawInfoType["COMP"] = 0] = "COMP";
        RenderDrawInfoType[RenderDrawInfoType["MODEL"] = 1] = "MODEL";
        RenderDrawInfoType[RenderDrawInfoType["MIDDLEWARE"] = 2] = "MIDDLEWARE";
        RenderDrawInfoType[RenderDrawInfoType["SUB_NODE"] = 3] = "SUB_NODE";
      })(RenderDrawInfoType || (RenderDrawInfoType = {}));
      class RenderDrawInfo {
        constructor(nativeDrawInfo) {
          this._accId = -1;
          this._bufferId = -1;
          this._vertexOffset = 0;
          this._indexOffset = 0;
          this._vb = null;
          this._ib = null;
          this._vData = null;
          this._iData = null;
          this._vertDirty = false;
          this._vbCount = 0;
          this._ibCount = 0;
          this._dataHash = 0;
          this._isMeshBuffer = false;
          this._material = null;
          this._texture = null;
          this._sampler = null;
          this._stride = 0;
          this._useLocal = false;
          this._model = null;
          this._drawInfoType = RenderDrawInfoType.COMP;
          this._subNode = null;
          this._uint8SharedBuffer = void 0;
          this._uint16SharedBuffer = void 0;
          this._uint32SharedBuffer = void 0;
          this.init(nativeDrawInfo);
          const attrSharedBuffer = this._nativeObj.getAttrSharedBufferForJS();
          let offset = 0;
          this._uint8SharedBuffer = new Uint8Array(attrSharedBuffer, offset, AttrUInt8ArrayView.Count);
          offset += AttrUInt8ArrayView.Count * Uint8Array.BYTES_PER_ELEMENT;
          this._uint16SharedBuffer = new Uint16Array(attrSharedBuffer, offset, AttrUInt16ArrayView.Count);
          offset += AttrUInt16ArrayView.Count * Uint16Array.BYTES_PER_ELEMENT;
          this._uint32SharedBuffer = new Uint32Array(attrSharedBuffer, offset, AttrUInt32ArrayView.Count);
        }
        get nativeObj() {
          return this._nativeObj;
        }
        get render2dBuffer() {
          return this._render2dBuffer;
        }
        init(nativeDrawInfo) {
          {
            if (nativeDrawInfo) {
              this._nativeObj = nativeDrawInfo;
            }
            if (!this._nativeObj) {
              this._nativeObj = new NativeRenderDrawInfo();
            }
          }
        }
        clear() {
          this._bufferId = 0;
          this._vertexOffset = 0;
          this._indexOffset = 0;
          this._vertDirty = false;
        }
        setAccId(accId) {
          {
            if (this._accId !== accId) {
              this._uint16SharedBuffer[AttrUInt16ArrayView.AccessorID] = accId;
            }
          }
          this._accId = accId;
        }
        setBufferId(bufferId) {
          {
            if (this._bufferId !== bufferId) {
              this._uint16SharedBuffer[AttrUInt16ArrayView.BufferID] = bufferId;
              this._nativeObj.changeMeshBuffer();
            }
          }
          this._bufferId = bufferId;
        }
        setAccAndBuffer(accId, bufferId) {
          {
            if (this._accId !== accId || this._bufferId !== bufferId) {
              this._uint16SharedBuffer[AttrUInt16ArrayView.AccessorID] = accId;
              this._uint16SharedBuffer[AttrUInt16ArrayView.BufferID] = bufferId;
              this._nativeObj.changeMeshBuffer();
            }
          }
          this._bufferId = bufferId;
          this._accId = accId;
        }
        setVertexOffset(vertexOffset) {
          this._vertexOffset = vertexOffset;
          {
            this._uint32SharedBuffer[AttrUInt32ArrayView.VertexOffset] = vertexOffset;
          }
        }
        setIndexOffset(indexOffset) {
          this._indexOffset = indexOffset;
          {
            this._uint32SharedBuffer[AttrUInt32ArrayView.IndexOffset] = indexOffset;
          }
        }
        setVB(vbBuffer) {
          {
            this._nativeObj.vbBuffer = vbBuffer;
          }
        }
        setIB(ibBuffer) {
          {
            this._nativeObj.ibBuffer = ibBuffer;
          }
        }
        setVData(vDataBuffer) {
          {
            this._nativeObj.vDataBuffer = vDataBuffer;
          }
        }
        setIData(iDataBuffer) {
          {
            this._nativeObj.iDataBuffer = iDataBuffer;
          }
        }
        setVBCount(vbCount) {
          {
            this._uint32SharedBuffer[AttrUInt32ArrayView.VBCount] = vbCount;
          }
          this._vbCount = vbCount;
        }
        setIBCount(ibCount) {
          {
            this._uint32SharedBuffer[AttrUInt32ArrayView.IBCount] = ibCount;
          }
        }
        setVertDirty(val) {
          {
            this._uint8SharedBuffer[AttrUInt8ArrayView.VertDirty] = val ? 1 : 0;
          }
          this._vertDirty = val;
        }
        setDataHash(dataHash) {
          {
            this._uint32SharedBuffer[AttrUInt32ArrayView.DataHash] = dataHash;
          }
          this._dataHash = dataHash;
        }
        setIsMeshBuffer(isMeshBuffer) {
          {
            this._uint8SharedBuffer[AttrUInt8ArrayView.IsMeshBuffer] = isMeshBuffer ? 1 : 0;
          }
          this._isMeshBuffer = isMeshBuffer;
        }
        setMaterial(material) {
          {
            if (this._material !== material) {
              this._nativeObj.material = material;
            }
          }
          this._material = material;
        }
        setTexture(texture) {
          {
            if (this._texture !== texture) {
              this._nativeObj.texture = texture;
            }
          }
          this._texture = texture;
        }
        setSampler(sampler) {
          {
            if (this._sampler !== sampler) {
              this._nativeObj.sampler = sampler;
            }
          }
          this._sampler = sampler;
        }
        setModel(model) {
          {
            if (this._model !== model) {
              this._nativeObj.model = model;
            }
          }
        }
        setDrawInfoType(drawInfoType) {
          {
            if (this._drawInfoType !== drawInfoType) {
              this._uint8SharedBuffer[AttrUInt8ArrayView.DrawInfoType] = drawInfoType;
            }
          }
          this._drawInfoType = drawInfoType;
        }
        setSubNode(node) {
          {
            if (this._subNode !== node) {
              this._nativeObj.subNode = node;
            }
          }
          this._subNode = node;
        }
        setStride(stride) {
          {
            this._uint8SharedBuffer[AttrUInt8ArrayView.Stride] = stride;
          }
          this._stride = stride;
        }
        initRender2dBuffer() {
          {
            this._render2dBuffer = new Float32Array(this._vbCount * this._stride);
            this._nativeObj.setRender2dBufferToNative(this._render2dBuffer);
          }
        }
        fillRender2dBuffer(vertexDataArr) {
          {
            const fillLength = Math.min(this._vbCount, vertexDataArr.length);
            let bufferOffset = 0;
            for (let i = 0; i < fillLength; i++) {
              const temp = vertexDataArr[i];
              this._render2dBuffer[bufferOffset] = temp.x;
              this._render2dBuffer[bufferOffset + 1] = temp.y;
              this._render2dBuffer[bufferOffset + 2] = temp.z;
              bufferOffset += this._stride;
            }
          }
        }
      }

      let Stage;
      (function (Stage) {
        Stage[Stage["DISABLED"] = 0] = "DISABLED";
        Stage[Stage["CLEAR"] = 1] = "CLEAR";
        Stage[Stage["ENTER_LEVEL"] = 2] = "ENTER_LEVEL";
        Stage[Stage["ENABLED"] = 3] = "ENABLED";
        Stage[Stage["EXIT_LEVEL"] = 4] = "EXIT_LEVEL";
        Stage[Stage["CLEAR_INVERTED"] = 5] = "CLEAR_INVERTED";
        Stage[Stage["ENTER_LEVEL_INVERTED"] = 6] = "ENTER_LEVEL_INVERTED";
      })(Stage || (Stage = {}));
      let StencilSharedBufferView;
      (function (StencilSharedBufferView) {
        StencilSharedBufferView[StencilSharedBufferView["stencilTest"] = 0] = "stencilTest";
        StencilSharedBufferView[StencilSharedBufferView["func"] = 1] = "func";
        StencilSharedBufferView[StencilSharedBufferView["stencilMask"] = 2] = "stencilMask";
        StencilSharedBufferView[StencilSharedBufferView["writeMask"] = 3] = "writeMask";
        StencilSharedBufferView[StencilSharedBufferView["failOp"] = 4] = "failOp";
        StencilSharedBufferView[StencilSharedBufferView["zFailOp"] = 5] = "zFailOp";
        StencilSharedBufferView[StencilSharedBufferView["passOp"] = 6] = "passOp";
        StencilSharedBufferView[StencilSharedBufferView["ref"] = 7] = "ref";
        StencilSharedBufferView[StencilSharedBufferView["count"] = 8] = "count";
      })(StencilSharedBufferView || (StencilSharedBufferView = {}));
      class StencilManager {
        constructor() {
          this._maskStack = [];
          this._stencilPattern = {
            stencilTest: true,
            func: ComparisonFunc.ALWAYS,
            stencilMask: 0xffff,
            writeMask: 0xffff,
            failOp: StencilOp.KEEP,
            zFailOp: StencilOp.KEEP,
            passOp: StencilOp.KEEP,
            ref: 1
          };
          this._stage = Stage.DISABLED;
          this.stencilStateMap = new Map();
          this.stencilStateMapWithDepth = new Map();
        }
        get stage() {
          return this._stage;
        }
        set stage(val) {
          this._stage = val;
        }
        get pattern() {
          return this._stencilPattern;
        }
        pushMask(mask) {
          this._maskStack.push(mask);
        }
        clear(comp) {
          const isInverted = comp.stencilStage !== Stage.ENTER_LEVEL;
          return isInverted ? Stage.CLEAR_INVERTED : Stage.CLEAR;
        }
        enableMask() {
          this.stage = Stage.ENABLED;
        }
        exitMask() {
          if (this._maskStack.length === 0) {
            return;
          }
          this._maskStack.pop();
          if (this._maskStack.length === 0) {
            this.stage = Stage.DISABLED;
          } else {
            this.stage = Stage.ENABLED;
          }
        }
        getWriteMask() {
          return 1 << this._maskStack.length - 1;
        }
        getExitWriteMask() {
          return 1 << this._maskStack.length;
        }
        getStencilRef() {
          let result = 0;
          for (let i = 0; i < this._maskStack.length; ++i) {
            result += 0x00000001 << i;
          }
          return result;
        }
        getMaskStackSize() {
          return this._maskStack.length;
        }
        reset() {
          this._maskStack.length = 0;
          this.stage = Stage.DISABLED;
        }
        destroy() {
          this.stencilStateMap.forEach((value, key) => {
            value.destroy();
          });
          this.stencilStateMap.clear();
        }
        getStencilStage(stage, mat) {
          let key = 0;
          let depthTest = false;
          let depthWrite = false;
          let depthFunc = ComparisonFunc.LESS;
          let cacheMap = this.stencilStateMap;
          if (mat && mat.passes[0]) {
            const pass = mat.passes[0];
            const dss = pass.depthStencilState;
            let depthTestValue = 0;
            let depthWriteValue = 0;
            if (dss.depthTest) depthTestValue = 1;
            if (dss.depthWrite) depthWriteValue = 1;
            key = depthTestValue | depthWriteValue << 1 | dss.depthFunc << 2 | stage << 6 | this._maskStack.length << 9;
            depthTest = dss.depthTest;
            depthWrite = dss.depthWrite;
            depthFunc = dss.depthFunc;
            cacheMap = this.stencilStateMapWithDepth;
          } else {
            key = stage << 16 | this._maskStack.length;
          }
          if (cacheMap && cacheMap.has(key)) {
            return cacheMap.get(key);
          }
          this.setStateFromStage(stage);
          const depthStencilState = new DepthStencilState(depthTest, depthWrite, depthFunc, this._stencilPattern.stencilTest, this._stencilPattern.func, this._stencilPattern.stencilMask, this._stencilPattern.writeMask, this._stencilPattern.failOp, this._stencilPattern.zFailOp, this._stencilPattern.passOp, this._stencilPattern.ref, this._stencilPattern.stencilTest, this._stencilPattern.func, this._stencilPattern.stencilMask, this._stencilPattern.writeMask, this._stencilPattern.failOp, this._stencilPattern.zFailOp, this._stencilPattern.passOp, this._stencilPattern.ref);
          cacheMap.set(key, depthStencilState);
          return depthStencilState;
        }
        getStencilHash(stage) {
          return stage << 8 | this._maskStack.length;
        }
        setStateFromStage(stage) {
          const pattern = this._stencilPattern;
          if (stage === Stage.DISABLED) {
            pattern.stencilTest = false;
            pattern.func = ComparisonFunc.ALWAYS;
            pattern.failOp = StencilOp.KEEP;
            pattern.stencilMask = pattern.writeMask = 0xffff;
            pattern.ref = 1;
          } else {
            pattern.stencilTest = true;
            if (stage === Stage.ENABLED) {
              pattern.func = ComparisonFunc.EQUAL;
              pattern.failOp = StencilOp.KEEP;
              pattern.stencilMask = pattern.ref = this.getStencilRef();
              pattern.writeMask = this.getWriteMask();
            } else if (stage === Stage.CLEAR) {
              pattern.func = ComparisonFunc.NEVER;
              pattern.failOp = StencilOp.ZERO;
              pattern.writeMask = pattern.stencilMask = pattern.ref = this.getWriteMask();
            } else if (stage === Stage.CLEAR_INVERTED) {
              pattern.func = ComparisonFunc.NEVER;
              pattern.failOp = StencilOp.REPLACE;
              pattern.writeMask = pattern.stencilMask = pattern.ref = this.getWriteMask();
            } else if (stage === Stage.ENTER_LEVEL) {
              pattern.func = ComparisonFunc.NEVER;
              pattern.failOp = StencilOp.REPLACE;
              pattern.writeMask = pattern.stencilMask = pattern.ref = this.getWriteMask();
            } else if (stage === Stage.ENTER_LEVEL_INVERTED) {
              pattern.func = ComparisonFunc.NEVER;
              pattern.failOp = StencilOp.ZERO;
              pattern.writeMask = pattern.stencilMask = pattern.ref = this.getWriteMask();
            }
          }
        }
      } exports('StencilManager', StencilManager);
      StencilManager.sharedManager = null;
      StencilManager.sharedManager = new StencilManager();

      let RenderEntityType;
      (function (RenderEntityType) {
        RenderEntityType[RenderEntityType["STATIC"] = 0] = "STATIC";
        RenderEntityType[RenderEntityType["DYNAMIC"] = 1] = "DYNAMIC";
        RenderEntityType[RenderEntityType["CROSSED"] = 2] = "CROSSED";
      })(RenderEntityType || (RenderEntityType = {}));
      let RenderEntityFloatSharedBufferView;
      (function (RenderEntityFloatSharedBufferView) {
        RenderEntityFloatSharedBufferView[RenderEntityFloatSharedBufferView["localOpacity"] = 0] = "localOpacity";
        RenderEntityFloatSharedBufferView[RenderEntityFloatSharedBufferView["count"] = 1] = "count";
      })(RenderEntityFloatSharedBufferView || (RenderEntityFloatSharedBufferView = {}));
      let RenderEntityUInt8SharedBufferView;
      (function (RenderEntityUInt8SharedBufferView) {
        RenderEntityUInt8SharedBufferView[RenderEntityUInt8SharedBufferView["colorR"] = 0] = "colorR";
        RenderEntityUInt8SharedBufferView[RenderEntityUInt8SharedBufferView["colorG"] = 1] = "colorG";
        RenderEntityUInt8SharedBufferView[RenderEntityUInt8SharedBufferView["colorB"] = 2] = "colorB";
        RenderEntityUInt8SharedBufferView[RenderEntityUInt8SharedBufferView["colorA"] = 3] = "colorA";
        RenderEntityUInt8SharedBufferView[RenderEntityUInt8SharedBufferView["maskMode"] = 4] = "maskMode";
        RenderEntityUInt8SharedBufferView[RenderEntityUInt8SharedBufferView["count"] = 5] = "count";
      })(RenderEntityUInt8SharedBufferView || (RenderEntityUInt8SharedBufferView = {}));
      let RenderEntityBoolSharedBufferView;
      (function (RenderEntityBoolSharedBufferView) {
        RenderEntityBoolSharedBufferView[RenderEntityBoolSharedBufferView["colorDirty"] = 0] = "colorDirty";
        RenderEntityBoolSharedBufferView[RenderEntityBoolSharedBufferView["enabled"] = 1] = "enabled";
        RenderEntityBoolSharedBufferView[RenderEntityBoolSharedBufferView["useLocal"] = 2] = "useLocal";
        RenderEntityBoolSharedBufferView[RenderEntityBoolSharedBufferView["count"] = 3] = "count";
      })(RenderEntityBoolSharedBufferView || (RenderEntityBoolSharedBufferView = {}));
      let MaskMode;
      (function (MaskMode) {
        MaskMode[MaskMode["NONE"] = 0] = "NONE";
        MaskMode[MaskMode["MASK"] = 1] = "MASK";
        MaskMode[MaskMode["MASK_INVERTED"] = 2] = "MASK_INVERTED";
        MaskMode[MaskMode["MASK_NODE"] = 3] = "MASK_NODE";
        MaskMode[MaskMode["MASK_NODE_INVERTED"] = 4] = "MASK_NODE_INVERTED";
      })(MaskMode || (MaskMode = {}));
      class RenderEntity {
        get nativeObj() {
          return this._nativeObj;
        }
        get renderDrawInfoArr() {
          return this._dynamicDrawInfoArr;
        }
        get renderEntityType() {
          return this._renderEntityType;
        }
        get color() {
          return this._color;
        }
        set color(val) {
          this._color = val;
          {
            this._uint8SharedBuffer[RenderEntityUInt8SharedBufferView.colorR] = val.r;
            this._uint8SharedBuffer[RenderEntityUInt8SharedBufferView.colorG] = val.g;
            this._uint8SharedBuffer[RenderEntityUInt8SharedBufferView.colorB] = val.b;
            this._uint8SharedBuffer[RenderEntityUInt8SharedBufferView.colorA] = val.a;
          }
        }
        get localOpacity() {
          return this._localOpacity;
        }
        set localOpacity(val) {
          this._localOpacity = val;
          {
            this._floatSharedBuffer[RenderEntityFloatSharedBufferView.localOpacity] = val;
          }
        }
        get colorDirty() {
          return this._colorDirty;
        }
        set colorDirty(val) {
          this._colorDirty = val;
          {
            this._boolSharedBuffer[RenderEntityBoolSharedBufferView.colorDirty] = val ? 1 : 0;
          }
        }
        get enabled() {
          return this._enabled;
        }
        set enabled(val) {
          this._enabled = val;
          {
            this._boolSharedBuffer[RenderEntityBoolSharedBufferView.enabled] = val ? 1 : 0;
          }
        }
        constructor(entityType) {
          this._renderEntityType = RenderEntityType.STATIC;
          this._dynamicDrawInfoArr = [];
          this._node = null;
          this._renderTransform = null;
          this._stencilStage = Stage.DISABLED;
          this._useLocal = false;
          this._maskMode = MaskMode.NONE;
          this._color = Color$1.WHITE;
          this._localOpacity = 255;
          this._colorDirty = true;
          this._enabled = false;
          {
            if (!this._nativeObj) {
              this._nativeObj = new NativeRenderEntity(entityType);
            }
            this._renderEntityType = entityType;
            this.initSharedBuffer();
          }
        }
        addDynamicRenderDrawInfo(renderDrawInfo) {
          {
            if (renderDrawInfo) {
              this._dynamicDrawInfoArr.push(renderDrawInfo);
              this._nativeObj.addDynamicRenderDrawInfo(renderDrawInfo.nativeObj);
            }
          }
        }
        removeDynamicRenderDrawInfo() {
          {
            this._dynamicDrawInfoArr.pop();
            this._nativeObj.removeDynamicRenderDrawInfo();
          }
        }
        clearDynamicRenderDrawInfos() {
          {
            this._dynamicDrawInfoArr.length = 0;
            this._nativeObj.clearDynamicRenderDrawInfos();
          }
        }
        clearStaticRenderDrawInfos() {
          {
            this._nativeObj.clearStaticRenderDrawInfos();
          }
        }
        setDynamicRenderDrawInfo(renderDrawInfo, index) {
          {
            if (renderDrawInfo) {
              if (this._dynamicDrawInfoArr.length < index + 1) {
                this._dynamicDrawInfoArr.push(renderDrawInfo);
                this._nativeObj.addDynamicRenderDrawInfo(renderDrawInfo.nativeObj);
              } else {
                this._dynamicDrawInfoArr[index] = renderDrawInfo;
                this._nativeObj.setDynamicRenderDrawInfo(renderDrawInfo.nativeObj, index);
              }
            }
          }
        }
        setMaskMode(mode) {
          {
            this._uint8SharedBuffer[RenderEntityUInt8SharedBufferView.maskMode] = mode;
          }
          this._maskMode = mode;
        }
        getStaticRenderDrawInfo() {
          {
            const nativeDrawInfo = this._nativeObj.getStaticRenderDrawInfo(this._nativeObj.staticDrawInfoSize++);
            const drawInfo = new RenderDrawInfo(nativeDrawInfo);
            return drawInfo;
          }
        }
        setNode(node) {
          {
            if (this._node !== node) {
              this._nativeObj.node = node;
            }
          }
          this._node = node;
        }
        setRenderTransform(renderTransform) {
          {
            if (this._renderTransform !== renderTransform) {
              this._nativeObj.renderTransform = renderTransform;
            }
          }
          this._renderTransform = renderTransform;
        }
        setStencilStage(stage) {
          {
            if (this._stencilStage !== stage) {
              this._nativeObj.stencilStage = stage;
            }
          }
          this._stencilStage = stage;
        }
        setUseLocal(useLocal) {
          {
            this._boolSharedBuffer[RenderEntityBoolSharedBufferView.useLocal] = useLocal ? 1 : 0;
          }
          this._useLocal = useLocal;
        }
        initSharedBuffer() {
          {
            const buffer = this._nativeObj.getEntitySharedBufferForJS();
            let offset = 0;
            this._floatSharedBuffer = new Float32Array(buffer, offset, RenderEntityFloatSharedBufferView.count);
            offset += RenderEntityFloatSharedBufferView.count * 4;
            this._uint8SharedBuffer = new Uint8Array(buffer, offset, RenderEntityUInt8SharedBufferView.count);
            offset += RenderEntityUInt8SharedBufferView.count * 1;
            this._boolSharedBuffer = new Uint8Array(buffer, offset, RenderEntityBoolSharedBufferView.count);
          }
        }
      }

      const DEFAULT_STRIDE = getAttributeStride(vfmtPosUvColor) >> 2;
      class BaseRenderData {
        get vertexCount() {
          return this._vc;
        }
        get indexCount() {
          return this._ic;
        }
        get stride() {
          return this._floatStride << 2;
        }
        get floatStride() {
          return this._floatStride;
        }
        get vertexFormat() {
          return this._vertexFormat;
        }
        get drawInfoType() {
          return this._drawInfoType;
        }
        set drawInfoType(type) {
          this._drawInfoType = type;
          if (this._renderDrawInfo) {
            this._renderDrawInfo.setDrawInfoType(type);
          }
        }
        get renderDrawInfo() {
          return this._renderDrawInfo;
        }
        get material() {
          return this._material;
        }
        set material(val) {
          this._material = val;
          if (this._renderDrawInfo) {
            this._renderDrawInfo.setMaterial(val);
          }
        }
        get dataHash() {
          return this._dataHash;
        }
        set dataHash(val) {
          this._dataHash = val;
          if (this._renderDrawInfo) {
            this._renderDrawInfo.setDataHash(val);
          }
        }
        get multiOwner() {
          return this._multiOwner;
        }
        set multiOwner(val) {
          this._multiOwner = val;
        }
        get batcher() {
          if (!this._batcher) {
            this._batcher = director.root.batcher2D;
          }
          return this._batcher;
        }
        constructor(vertexFormat = vfmtPosUvColor) {
          this.chunk = null;
          this._renderDrawInfo = null;
          this._material = null;
          this._dataHash = 0;
          this._isMeshBuffer = false;
          this._vc = 0;
          this._ic = 0;
          this._floatStride = 0;
          this._vertexFormat = vfmtPosUvColor;
          this._drawInfoType = RenderDrawInfoType.COMP;
          this._multiOwner = false;
          this._batcher = null;
          this._floatStride = vertexFormat === vfmtPosUvColor ? DEFAULT_STRIDE : getAttributeStride(vertexFormat) >> 2;
          this._vertexFormat = vertexFormat;
        }
        isValid() {
          return this._ic > 0 && this.chunk.vertexAccessor;
        }
        initRenderDrawInfo(comp, drawInfoType = RenderDrawInfoType.COMP) {
          {
            const renderEntity = comp.renderEntity;
            if (renderEntity.renderEntityType === RenderEntityType.STATIC) {
              if (!this._renderDrawInfo) {
                const drawInfo = renderEntity.getStaticRenderDrawInfo();
                if (drawInfo) {
                  this._renderDrawInfo = drawInfo;
                }
              }
            } else if (this.multiOwner === false) {
              if (!this._renderDrawInfo) {
                this._renderDrawInfo = new RenderDrawInfo();
                renderEntity.addDynamicRenderDrawInfo(this._renderDrawInfo);
              }
            }
            this.drawInfoType = drawInfoType;
            this.setRenderDrawInfoAttributes();
          }
        }
        removeRenderDrawInfo(comp) {
          {
            const renderEntity = comp.renderEntity;
            if (renderEntity.renderEntityType === RenderEntityType.DYNAMIC) {
              renderEntity.removeDynamicRenderDrawInfo();
            } else if (renderEntity.renderEntityType === RenderEntityType.STATIC) {
              renderEntity.clearStaticRenderDrawInfos();
            }
          }
        }
        setRenderDrawInfoAttributes() {
          {
            if (!this._renderDrawInfo) {
              return;
            }
            if (this.chunk) {
              this._renderDrawInfo.setBufferId(this.chunk.bufferId);
              this._renderDrawInfo.setVertexOffset(this.chunk.vertexOffset);
              this._renderDrawInfo.setVB(this.chunk.vb);
              this._renderDrawInfo.setIB(this.chunk.ib);
              if (this.chunk.meshBuffer) {
                this._renderDrawInfo.setIndexOffset(this.chunk.meshBuffer.indexOffset);
                this._renderDrawInfo.setVData(this.chunk.meshBuffer.vData.buffer);
                this._renderDrawInfo.setIData(this.chunk.meshBuffer.iData.buffer);
              }
            }
            this._renderDrawInfo.setVBCount(this._vc);
            this._renderDrawInfo.setIBCount(this._ic);
            this._renderDrawInfo.setDataHash(this.dataHash);
            this._renderDrawInfo.setIsMeshBuffer(this._isMeshBuffer);
            this._renderDrawInfo.setMaterial(this.material);
            this._renderDrawInfo.setDrawInfoType(this._drawInfoType);
          }
        }
      } exports('BaseRenderData', BaseRenderData);
      class RenderData extends BaseRenderData {
        static add(vertexFormat = vfmtPosUvColor, accessor) {
          const rd = new RenderData(vertexFormat, accessor);
          if (!accessor) {
            const batcher = director.root.batcher2D;
            accessor = batcher.switchBufferAccessor(rd._vertexFormat);
          }
          rd._accessor = accessor;
          return rd;
        }
        static remove(data) {
          data.clear();
          data._accessor = null;
        }
        get dataLength() {
          return this._data.length;
        }
        set dataLength(length) {
          const data = this._data;
          if (data.length !== length) {
            for (let i = data.length; i < length; i++) {
              data.push({
                x: 0,
                y: 0,
                z: 0,
                u: 0,
                v: 0,
                color: Color$1.WHITE.clone()
              });
            }
            data.length = length;
          }
          this.syncRender2dBuffer();
        }
        get data() {
          return this._data;
        }
        get vertDirty() {
          return this._vertDirty;
        }
        set vertDirty(val) {
          this._vertDirty = val;
          if (this._renderDrawInfo && val) {
            this._renderDrawInfo.setVertDirty(val);
          }
        }
        get textureHash() {
          return this._textureHash;
        }
        set textureHash(val) {
          this._textureHash = val;
        }
        set frame(val) {
          this._frame = val;
          if (this._renderDrawInfo) {
            if (this._frame) {
              this._renderDrawInfo.setTexture(this._frame.getGFXTexture());
              this._renderDrawInfo.setSampler(this._frame.getGFXSampler());
            } else {
              this._renderDrawInfo.setTexture(null);
              this._renderDrawInfo.setSampler(null);
            }
          }
        }
        get frame() {
          return this._frame;
        }
        get accessor() {
          return this._accessor;
        }
        constructor(vertexFormat = vfmtPosUvColor, accessor) {
          super(vertexFormat);
          this._vertDirty = true;
          this._textureHash = 0;
          this.indices = null;
          this.layer = 0;
          this.nodeDirty = true;
          this.passDirty = true;
          this.textureDirty = true;
          this.hashDirty = true;
          this._data = [];
          this._frame = null;
          this._accessor = null;
          this.vertexRow = 1;
          this.vertexCol = 1;
          if (!accessor) {
            accessor = this.batcher.switchBufferAccessor(this._vertexFormat);
          }
          this._accessor = accessor;
        }
        resize(vertexCount, indexCount) {
          if (vertexCount === this._vc && indexCount === this._ic && this.chunk) return;
          this._vc = vertexCount;
          this._ic = indexCount;
          if (this.chunk) {
            this._accessor.recycleChunk(this.chunk);
            this.chunk = null;
          }
          this.chunk = this._accessor.allocateChunk(vertexCount, indexCount);
          this.updateHash();
          if (this.multiOwner === false && this._renderDrawInfo) {
            this._renderDrawInfo.setDrawInfoType(this._drawInfoType);
            this._renderDrawInfo.setBufferId(this.chunk.bufferId);
            this._renderDrawInfo.setVertexOffset(this.chunk.vertexOffset);
            this._renderDrawInfo.setIndexOffset(this.chunk.meshBuffer.indexOffset);
            this._renderDrawInfo.setVB(this.chunk.vb);
            this._renderDrawInfo.setIB(this.chunk.ib);
            this._renderDrawInfo.setVData(this.chunk.meshBuffer.vData.buffer);
            this._renderDrawInfo.setIData(this.chunk.meshBuffer.iData.buffer);
            this._renderDrawInfo.setVBCount(this._vc);
            this._renderDrawInfo.setIBCount(this._ic);
          }
        }
        setRenderDrawInfoAttributes() {
          {
            if (!this._renderDrawInfo) {
              return;
            }
            this._renderDrawInfo.setAccId(this._accessor.id);
            super.setRenderDrawInfoAttributes();
            this._renderDrawInfo.setTexture(this.frame ? this.frame.getGFXTexture() : null);
            this._renderDrawInfo.setSampler(this.frame ? this.frame.getGFXSampler() : null);
          }
        }
        fillDrawInfoAttributes(drawInfo) {
          {
            if (!drawInfo) {
              return;
            }
            drawInfo.setDrawInfoType(this._drawInfoType);
            drawInfo.setAccAndBuffer(this._accessor.id, this.chunk.bufferId);
            drawInfo.setVertexOffset(this.chunk.vertexOffset);
            drawInfo.setIndexOffset(this.chunk.meshBuffer.indexOffset);
            drawInfo.setVB(this.chunk.vb);
            drawInfo.setIB(this.chunk.ib);
            drawInfo.setVData(this.chunk.meshBuffer.vData.buffer);
            drawInfo.setIData(this.chunk.meshBuffer.iData.buffer);
            drawInfo.setVBCount(this._vc);
            drawInfo.setIBCount(this._ic);
            drawInfo.setDataHash(this.dataHash);
            drawInfo.setIsMeshBuffer(this._isMeshBuffer);
          }
        }
        syncRender2dBuffer() {
          if (this.multiOwner === false) {
            if (!this._renderDrawInfo) {
              return;
            }
            this.renderDrawInfo.setStride(this.floatStride);
            this.renderDrawInfo.setVBCount(this.dataLength);
            this.renderDrawInfo.initRender2dBuffer();
          }
        }
        resizeAndCopy(vertexCount, indexCount) {
          if (vertexCount === this._vc && indexCount === this._ic && this.chunk) return;
          this._vc = vertexCount;
          this._ic = indexCount;
          const oldChunk = this.chunk;
          this.chunk = this._accessor.allocateChunk(vertexCount, indexCount);
          if (oldChunk) {
            this.chunk.vb.set(oldChunk.vb);
            this._accessor.recycleChunk(oldChunk);
          }
          this.updateHash();
        }
        getMeshBuffer() {
          if (this.chunk && this._accessor) {
            return this._accessor.getMeshBuffer(this.chunk.bufferId);
          } else {
            return null;
          }
        }
        updateNode(comp) {
          this.layer = comp.node.layer;
          this.nodeDirty = false;
          this.hashDirty = true;
        }
        updatePass(comp) {
          this.material = comp.getRenderMaterial(0);
          this.passDirty = false;
          this.hashDirty = true;
        }
        updateTexture(frame) {
          this.frame = frame;
          this.textureHash = frame.getHash();
          this.textureDirty = false;
          this.hashDirty = true;
        }
        updateHash() {
          const bid = this.chunk ? this.chunk.bufferId : -1;
          const hashString = `${bid}${this.layer} ${this.textureHash}`;
          this.dataHash = murmurhash2_32_gc(hashString, 666);
          this.hashDirty = false;
        }
        updateRenderData(comp, frame) {
          if (this.passDirty) {
            this.material = comp.getRenderMaterial(0);
            this.passDirty = false;
            this.hashDirty = true;
            if (this._renderDrawInfo) {
              this._renderDrawInfo.setMaterial(this.material);
            }
          }
          if (this.nodeDirty) {
            const renderScene = comp.node.scene ? comp._getRenderScene() : null;
            this.layer = comp.node.layer;
            if (renderScene !== null) {
              this.nodeDirty = false;
            }
            this.hashDirty = true;
          }
          if (this.textureDirty) {
            this.frame = frame;
            this.textureHash = frame.getHash();
            this.textureDirty = false;
            this.hashDirty = true;
            if (this._renderDrawInfo) {
              this._renderDrawInfo.setTexture(this.frame ? this.frame.getGFXTexture() : null);
              this._renderDrawInfo.setSampler(this.frame ? this.frame.getGFXSampler() : null);
            }
          }
          if (this.hashDirty) {
            this.updateHash();
            if (this._renderDrawInfo) {
              this._renderDrawInfo.setDataHash(this.dataHash);
            }
          }
          if (this.multiOwner === false) {
            {
              assert(this._renderDrawInfo.render2dBuffer.length === this._floatStride * this._data.length, 'Vertex count doesn\'t match.');
            }
            this._renderDrawInfo.fillRender2dBuffer(this._data);
          }
        }
        clear() {
          this.resize(0, 0);
          this._data.length = 0;
          this.indices = null;
          this.vertDirty = true;
          this.material = null;
          this.nodeDirty = true;
          this.passDirty = true;
          this.textureDirty = true;
          this.hashDirty = true;
          this.layer = 0;
          this.frame = null;
          this.textureHash = 0;
          this.dataHash = 0;
          if (this._renderDrawInfo) {
            this._renderDrawInfo.clear();
          }
        }
        static createStaticVBAccessor(attributes, vCount, iCount) {
          const device = director.root.device;
          const accessor = new StaticVBAccessor(device, attributes, vCount, iCount);
          return accessor;
        }
      } exports('RenderData', RenderData);
      class MeshRenderData extends BaseRenderData {
        static add(vertexFormat = vfmtPosUvColor) {
          const rd = new MeshRenderData();
          rd._floatStride = vertexFormat === vfmtPosUvColor ? DEFAULT_STRIDE : getAttributeStride(vertexFormat) >> 2;
          rd._vertexFormat = vertexFormat;
          return rd;
        }
        static remove(data) {
          data.clear();
        }
        set formatByte(value) {}
        get formatByte() {
          return this.stride;
        }
        get floatStride() {
          return this._floatStride;
        }
        get vDataOffset() {
          return this._byteLength >>> 2;
        }
        constructor(vertexFormat = vfmtPosUvColor) {
          super(vertexFormat);
          this._isMeshBuffer = true;
          this.vData = void 0;
          this.iData = void 0;
          this.vertexStart = 0;
          this.vertexRange = 0;
          this.indexStart = 0;
          this.indexRange = 0;
          this.lastFilledIndex = 0;
          this.lastFilledVertex = 0;
          this.frame = void 0;
          this._byteLength = 0;
          this._vertexBuffers = [];
          this._indexBuffer = null;
          this._iaPool = null;
          this._iaInfo = null;
          this.vData = new Float32Array(256 * this.stride);
          this.iData = new Uint16Array(256 * 6);
        }
        request(vertexCount, indexCount) {
          const byteOffset = this._byteLength + vertexCount * this.stride;
          const succeed = this.reserve(vertexCount, indexCount);
          if (!succeed) return false;
          this._vc += vertexCount;
          this._ic += indexCount;
          this._byteLength = byteOffset;
          this.vertexRange = this._vc;
          this.indexRange = this._ic;
          return true;
        }
        reserve(vertexCount, indexCount) {
          const newVBytes = this._byteLength + vertexCount * this.stride;
          const newICount = this.indexCount + indexCount;
          if (vertexCount + this.vertexCount > 65535) {
            return false;
          }
          let byteLength = this.vData.byteLength;
          let indicesLength = this.iData.length;
          let vCount = this.vData.length;
          let iCount = this.iData.length;
          if (newVBytes > byteLength || newICount > indicesLength) {
            while (byteLength < newVBytes || indicesLength < newICount) {
              vCount *= 2;
              iCount *= 2;
              byteLength = vCount * 4;
              indicesLength = iCount;
            }
            this._reallocBuffer(vCount, iCount);
          }
          return true;
        }
        resize(vertexCount, indexCount) {
          const byteLength = vertexCount * this.stride;
          assertIsTrue(vertexCount >= 0 && indexCount >= 0 && byteLength <= this.vData.byteLength && indexCount <= this.iData.length);
          this._vc = vertexCount;
          this._ic = indexCount;
          this._byteLength = byteLength;
          this.updateRange(0, vertexCount, 0, indexCount);
        }
        updateRange(vertOffset, vertexCount, indexOffset, indexCount) {
          assertIsTrue(vertexCount >= 0 && indexCount >= 0 && vertexCount <= this._vc && indexCount <= this._ic);
          this.vertexStart = vertOffset;
          this.indexStart = indexOffset;
          this.vertexRange = vertexCount;
          this.indexRange = indexCount;
        }
        requestIA(device) {
          this._initIAInfo(device);
          const ia = this._iaPool.add();
          ia.firstIndex = this.indexStart;
          ia.indexCount = this.indexRange;
          return ia;
        }
        uploadBuffers() {
          if (this._byteLength === 0 || !this._vertexBuffers[0] || !this._indexBuffer) {
            return;
          }
          const indexCount = this._ic;
          const verticesData = new Float32Array(this.vData.buffer, 0, this._byteLength >> 2);
          const indicesData = new Uint16Array(this.iData.buffer, 0, indexCount);
          const vertexBuffer = this._vertexBuffers[0];
          if (this._byteLength > vertexBuffer.size) {
            vertexBuffer.resize(this._byteLength);
          }
          vertexBuffer.update(verticesData);
          const indexBytes = indexCount << 1;
          if (indexBytes > this._indexBuffer.size) {
            this._indexBuffer.resize(indexBytes);
          }
          this._indexBuffer.update(indicesData);
        }
        freeIAPool() {
          if (this._iaPool) {
            this._iaPool.reset();
          }
        }
        reset() {
          this._vc = 0;
          this._ic = 0;
          this._byteLength = 0;
          this.vertexStart = 0;
          this.vertexRange = 0;
          this.indexStart = 0;
          this.indexRange = 0;
          this.lastFilledIndex = 0;
          this.lastFilledVertex = 0;
          this.material = null;
          this.freeIAPool();
        }
        clear() {
          this.reset();
          if (this._iaPool) {
            this._iaPool.destroy();
          }
          if (this._vertexBuffers[0]) {
            this._vertexBuffers[0].destroy();
            this._vertexBuffers = [];
          }
          this._iaInfo = null;
          this.vData = new Float32Array(256 * this.stride);
          this.iData = new Uint16Array(256 * 6);
        }
        _initIAInfo(device) {
          if (!this._iaInfo) {
            const vbStride = this.stride;
            const vbs = this._vertexBuffers;
            if (!vbs.length) {
              vbs.push(device.createBuffer(new BufferInfo(BufferUsageBit.VERTEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, vbStride, vbStride)));
            }
            const ibStride = Uint16Array.BYTES_PER_ELEMENT;
            if (!this._indexBuffer) {
              this._indexBuffer = device.createBuffer(new BufferInfo(BufferUsageBit.INDEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, ibStride, ibStride));
            }
            this._iaInfo = new InputAssemblerInfo(this._vertexFormat, vbs, this._indexBuffer);
            this._iaPool = new RecyclePool(() => device.createInputAssembler(this._iaInfo), 1, ia => {
              ia.destroy();
            });
          }
        }
        _reallocBuffer(vCount, iCount) {
          const oldVData = this.vData;
          this.vData = new Float32Array(vCount);
          if (oldVData) {
            this.vData.set(oldVData, 0);
          }
          const oldIData = this.iData;
          this.iData = new Uint16Array(iCount);
          if (oldIData) {
            this.iData.set(oldIData, 0);
          }
        }
        setRenderDrawInfoAttributes() {
          {
            var _this$frame, _this$frame2;
            if (!this._renderDrawInfo) {
              return;
            }
            this._renderDrawInfo.setVData(this.vData.buffer);
            this._renderDrawInfo.setIData(this.iData.buffer);
            this._renderDrawInfo.setVBCount(this._vc);
            this._renderDrawInfo.setIBCount(this._ic);
            this._renderDrawInfo.setVertexOffset(this.vertexStart);
            this._renderDrawInfo.setIndexOffset(this.indexStart);
            this._renderDrawInfo.setIsMeshBuffer(this._isMeshBuffer);
            this._renderDrawInfo.setMaterial(this.material);
            this._renderDrawInfo.setTexture((_this$frame = this.frame) === null || _this$frame === void 0 ? void 0 : _this$frame.getGFXTexture());
            this._renderDrawInfo.setSampler((_this$frame2 = this.frame) === null || _this$frame2 === void 0 ? void 0 : _this$frame2.getGFXSampler());
          }
        }
        particleInitRenderDrawInfo(entity) {
          {
            if (entity.renderEntityType === RenderEntityType.STATIC) {
              if (!this._renderDrawInfo) {
                const drawInfo = entity.getStaticRenderDrawInfo();
                if (drawInfo) {
                  this._renderDrawInfo = drawInfo;
                }
              }
            }
          }
        }
      } exports('MeshRenderData', MeshRenderData);

      var _dec$I, _dec2$C, _class$H, _class2$D, _initializer$A, _initializer2$u, _class3$o;
      const _vec2a = new Vec2();
      const _vec2b = new Vec2();
      const _vec3a = new Vec3();
      const _mat4_temp$1 = new Mat4();
      const _matrix$1 = new Mat4();
      const _worldMatrix$1 = new Mat4();
      const _zeroMatrix = new Mat4(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      const _rect = new Rect$1();
      let UITransform = (_dec$I = ccclass$3('cc.UITransform'), _dec2$C = executionOrder(110), _dec$I(_class$H = _dec2$C(_class$H = disallowMultiple$1(_class$H = (_class2$D = (_class3$o = class UITransform extends Component {
        constructor(...args) {
          super(...args);
          this._priority = 0;
          this._contentSize = _initializer$A && _initializer$A();
          this._anchorPoint = _initializer2$u && _initializer2$u();
        }
        get contentSize() {
          return this._contentSize;
        }
        set contentSize(value) {
          if (this._contentSize.equals(value)) {
            return;
          }
          {
            this._contentSize.set(value);
            this.node.emit(NodeEventType.SIZE_CHANGED);
          }
          this._markRenderDataDirty();
        }
        get width() {
          return this._contentSize.width;
        }
        set width(value) {
          if (this._contentSize.width === value) {
            return;
          }
          {
            this._contentSize.width = value;
            this.node.emit(NodeEventType.SIZE_CHANGED);
          }
          this._markRenderDataDirty();
        }
        get height() {
          return this._contentSize.height;
        }
        set height(value) {
          if (this.contentSize.height === value) {
            return;
          }
          {
            this._contentSize.height = value;
            this.node.emit(NodeEventType.SIZE_CHANGED);
          }
          this._markRenderDataDirty();
        }
        get anchorPoint() {
          return this._anchorPoint;
        }
        set anchorPoint(value) {
          if (this._anchorPoint.equals(value)) {
            return;
          }
          this._anchorPoint.set(value);
          this.node.emit(NodeEventType.ANCHOR_CHANGED, this._anchorPoint);
          this._markRenderDataDirty();
        }
        get anchorX() {
          return this._anchorPoint.x;
        }
        set anchorX(value) {
          if (this._anchorPoint.x === value) {
            return;
          }
          this._anchorPoint.x = value;
          this.node.emit(NodeEventType.ANCHOR_CHANGED, this._anchorPoint);
          this._markRenderDataDirty();
        }
        get anchorY() {
          return this._anchorPoint.y;
        }
        set anchorY(value) {
          if (this._anchorPoint.y === value) {
            return;
          }
          this._anchorPoint.y = value;
          this.node.emit(NodeEventType.ANCHOR_CHANGED, this._anchorPoint);
          this._markRenderDataDirty();
        }
        get priority() {
          return this._priority;
        }
        set priority(value) {
          if (this._priority === value) {
            return;
          }
          if (this.node.getComponent('cc.RenderRoot2D')) {
            warnID(6706);
            return;
          }
          this._priority = value;
          if (this.node.parent) {
            UITransform.insertChangeMap(this.node.parent);
          }
        }
        get visibility() {
          const camera = director.root.batcher2D.getFirstRenderCamera(this.node);
          return camera ? camera.visibility : 0;
        }
        get cameraPriority() {
          const camera = director.root.batcher2D.getFirstRenderCamera(this.node);
          return camera ? camera.priority : 0;
        }
        __preload() {
          this.node._uiProps.uiTransformComp = this;
        }
        onLoad() {
          if (this.node.parent) {
            UITransform.insertChangeMap(this.node.parent);
          }
        }
        onEnable() {
          this.node.on(NodeEventType.PARENT_CHANGED, this._parentChanged, this);
          this._markRenderDataDirty();
        }
        onDisable() {
          this.node.off(NodeEventType.PARENT_CHANGED, this._parentChanged, this);
        }
        onDestroy() {
          this.node._uiProps.uiTransformComp = null;
        }
        setContentSize(size, height) {
          const locContentSize = this._contentSize;
          let locWidth;
          let locHeight;
          if (height === undefined) {
            size = size;
            if (approx(size.width, locContentSize.width, EPSILON$2) && approx(size.height, locContentSize.height, EPSILON$2)) {
              return;
            }
            locWidth = size.width;
            locHeight = size.height;
          } else {
            size = size;
            if (approx(size, locContentSize.width, EPSILON$2) && approx(height, locContentSize.height, EPSILON$2)) {
              return;
            }
            locWidth = size;
            locHeight = height;
          }
          {
            locContentSize.width = locWidth;
            locContentSize.height = locHeight;
            this.node.emit(NodeEventType.SIZE_CHANGED);
          }
          this._markRenderDataDirty();
        }
        setAnchorPoint(point, y) {
          const locAnchorPoint = this._anchorPoint;
          if (y === undefined) {
            point = point;
            if (point.x === locAnchorPoint.x && point.y === locAnchorPoint.y) {
              return;
            }
            locAnchorPoint.x = point.x;
            locAnchorPoint.y = point.y;
          } else {
            if (point === locAnchorPoint.x && y === locAnchorPoint.y) {
              return;
            }
            locAnchorPoint.x = point;
            locAnchorPoint.y = y;
          }
          this.node.emit(NodeEventType.ANCHOR_CHANGED, this._anchorPoint);
          this._markRenderDataDirty();
        }
        isHit(uiPoint) {
          const w = this._contentSize.width;
          const h = this._contentSize.height;
          const v2WorldPt = _vec2a;
          const testPt = _vec2b;
          const cameras = this._getRenderScene().cameras;
          for (let i = 0; i < cameras.length; i++) {
            const camera = cameras[i];
            if (!(camera.visibility & this.node.layer)) continue;
            camera.node.getWorldRT(_mat4_temp$1);
            const m12 = _mat4_temp$1.m12;
            const m13 = _mat4_temp$1.m13;
            const center = visibleRect.center;
            _mat4_temp$1.m12 = center.x - (_mat4_temp$1.m00 * m12 + _mat4_temp$1.m04 * m13);
            _mat4_temp$1.m13 = center.y - (_mat4_temp$1.m01 * m12 + _mat4_temp$1.m05 * m13);
            Mat4.invert(_mat4_temp$1, _mat4_temp$1);
            Vec2.transformMat4(v2WorldPt, uiPoint, _mat4_temp$1);
            this.node.getWorldMatrix(_worldMatrix$1);
            Mat4.invert(_mat4_temp$1, _worldMatrix$1);
            if (Mat4.strictEquals(_mat4_temp$1, _zeroMatrix)) {
              continue;
            }
            Vec2.transformMat4(testPt, v2WorldPt, _mat4_temp$1);
            testPt.x += this._anchorPoint.x * w;
            testPt.y += this._anchorPoint.y * h;
            let hit = false;
            if (testPt.x >= 0 && testPt.y >= 0 && testPt.x <= w && testPt.y <= h) {
              hit = this._maskTest(v2WorldPt);
            }
            if (hit) {
              return true;
            }
          }
          return false;
        }
        hitTest(screenPoint, windowId = 0) {
          const w = this._contentSize.width;
          const h = this._contentSize.height;
          const v3WorldPt = _vec3a;
          const v2WorldPt = _vec2a;
          const testPt = _vec2b;
          const cameras = this._getRenderScene().cameras;
          for (let i = 0; i < cameras.length; i++) {
            const camera = cameras[i];
            if (!(camera.visibility & this.node.layer) || camera.window && !camera.window.swapchain) {
              continue;
            }
            if (camera.systemWindowId !== windowId) {
              continue;
            }
            Vec3.set(v3WorldPt, screenPoint.x, screenPoint.y, 0);
            camera.screenToWorld(v3WorldPt, v3WorldPt);
            Vec2.set(v2WorldPt, v3WorldPt.x, v3WorldPt.y);
            this.node.getWorldMatrix(_worldMatrix$1);
            Mat4.invert(_mat4_temp$1, _worldMatrix$1);
            if (Mat4.strictEquals(_mat4_temp$1, _zeroMatrix)) {
              continue;
            }
            Vec2.transformMat4(testPt, v2WorldPt, _mat4_temp$1);
            testPt.x += this._anchorPoint.x * w;
            testPt.y += this._anchorPoint.y * h;
            let hit = false;
            if (testPt.x >= 0 && testPt.y >= 0 && testPt.x <= w && testPt.y <= h) {
              hit = this._maskTest(v2WorldPt);
            }
            if (hit) {
              return true;
            }
          }
          return false;
        }
        _maskTest(pointInWorldSpace) {
          var _this$node, _this$node$eventProce;
          const maskList = (_this$node = this.node) === null || _this$node === void 0 ? void 0 : (_this$node$eventProce = _this$node.eventProcessor) === null || _this$node$eventProce === void 0 ? void 0 : _this$node$eventProce.maskList;
          if (maskList) {
            let parent = this.node;
            const length = maskList.length;
            for (let i = 0, j = 0; parent && j < length; ++i, parent = parent.parent) {
              const temp = maskList[j];
              if (i === temp.index) {
                if (parent === temp.comp.node) {
                  const comp = temp.comp;
                  if (comp && comp._enabled && !comp.isHit(pointInWorldSpace)) {
                    return false;
                  }
                  j++;
                } else {
                  maskList.length = j;
                  break;
                }
              } else if (i > temp.index) {
                maskList.length = j;
                break;
              }
            }
          }
          return true;
        }
        convertToNodeSpaceAR(worldPoint, out) {
          this.node.getWorldMatrix(_worldMatrix$1);
          Mat4.invert(_mat4_temp$1, _worldMatrix$1);
          if (!out) {
            out = new Vec3();
          }
          return Vec3.transformMat4(out, worldPoint, _mat4_temp$1);
        }
        convertToWorldSpaceAR(nodePoint, out) {
          this.node.getWorldMatrix(_worldMatrix$1);
          if (!out) {
            out = new Vec3();
          }
          return Vec3.transformMat4(out, nodePoint, _worldMatrix$1);
        }
        getBoundingBox() {
          const rect = new Rect$1();
          this._selfBoundingBox(rect);
          Mat4.fromSRT(_matrix$1, this.node.rotation, this.node.position, this.node.scale);
          rect.transformMat4(_matrix$1);
          return rect;
        }
        getBoundingBoxToWorld() {
          const rect = new Rect$1();
          const locChildren = this.node.children;
          for (let i = 0; i < locChildren.length; ++i) {
            const child = locChildren[i];
            if (child && child.active) {
              const uiTransform = child.getComponent(UITransform);
              if (uiTransform && uiTransform.contentSize.width && uiTransform.contentSize.height) {
                uiTransform._selfBoundingBox(_rect);
                _rect.transformMat4(child.worldMatrix);
                if (rect.width === 0) {
                  rect.set(_rect);
                } else {
                  Rect$1.union(rect, rect, _rect);
                }
              }
            }
          }
          if (this._contentSize.width && this._contentSize.height) {
            this._selfBoundingBox(_rect);
            _rect.transformMat4(this.node.worldMatrix);
            if (rect.width === 0) {
              rect.set(_rect);
            } else {
              Rect$1.union(rect, rect, _rect);
            }
          }
          return rect;
        }
        getBoundingBoxTo(targetMat) {
          const rect = new Rect$1();
          const locChildren = this.node.children;
          Mat4.invert(_mat4_temp$1, targetMat);
          for (let i = 0; i < locChildren.length; ++i) {
            const child = locChildren[i];
            if (child && child.active) {
              const uiTransform = child.getComponent(UITransform);
              if (uiTransform && uiTransform.contentSize.width && uiTransform.contentSize.height) {
                uiTransform._selfBoundingBox(_rect);
                Mat4.multiply(_matrix$1, child.worldMatrix, _mat4_temp$1);
                _rect.transformMat4(_matrix$1);
                if (rect.width === 0) {
                  rect.set(_rect);
                } else {
                  Rect$1.union(rect, rect, _rect);
                }
              }
            }
          }
          if (this._contentSize.width && this._contentSize.height) {
            this._selfBoundingBox(_rect);
            Mat4.multiply(_matrix$1, this.node.worldMatrix, _mat4_temp$1);
            _rect.transformMat4(_matrix$1);
            if (rect.width === 0) {
              rect.set(_rect);
            } else {
              Rect$1.union(rect, rect, _rect);
            }
          }
          return rect;
        }
        getComputeAABB(out) {
          const width = this._contentSize.width;
          const height = this._contentSize.height;
          _rect.set(-this._anchorPoint.x * width, -this._anchorPoint.y * height, width, height);
          _rect.transformMat4(this.node.worldMatrix);
          const px = _rect.x + _rect.width * 0.5;
          const py = _rect.y + _rect.height * 0.5;
          const pz = this.node.worldPosition.z;
          const w = _rect.width / 2;
          const h = _rect.height / 2;
          const l = 0.001;
          if (out != null) {
            AABB.set(out, px, py, pz, w, h, l);
            return out;
          } else {
            return new AABB(px, py, pz, w, h, l);
          }
        }
        _selfBoundingBox(out) {
          const width = this._contentSize.width;
          const height = this._contentSize.height;
          out.set(-this._anchorPoint.x * width, -this._anchorPoint.y * height, width, height);
          return out;
        }
        _parentChanged(node) {
          if (this.node.getComponent('cc.RenderRoot2D')) {
            return;
          }
          if (this.node.parent) {
            UITransform.insertChangeMap(this.node.parent);
          }
        }
        _markRenderDataDirty() {
          const uiComp = this.node._uiProps.uiComp;
          if (uiComp) {
            uiComp.markForUpdateRenderData();
          }
        }
        static insertChangeMap(node) {
          const key = node.uuid;
          if (!UITransform.priorityChangeNodeMap.has(key)) {
            UITransform.priorityChangeNodeMap.set(key, node);
          }
        }
        static _sortChildrenSibling(node) {
          const siblings = node.children;
          if (siblings) {
            siblings.sort((a, b) => {
              const aComp = a._uiProps.uiTransformComp;
              const bComp = b._uiProps.uiTransformComp;
              const ca = aComp ? aComp._priority : 0;
              const cb = bComp ? bComp._priority : 0;
              const diff = ca - cb;
              if (diff === 0) return a.getSiblingIndex() - b.getSiblingIndex();
              return diff;
            });
          }
        }
        static _sortSiblings() {
          UITransform.priorityChangeNodeMap.forEach((node, ID) => {
            UITransform._sortChildrenSibling(node);
            node._updateSiblingIndex();
            node.emit('childrenSiblingOrderChanged');
          });
          UITransform.priorityChangeNodeMap.clear();
        }
        static _cleanChangeMap() {
          UITransform.priorityChangeNodeMap.clear();
        }
      }, _class3$o.EventType = NodeEventType, _class3$o.priorityChangeNodeMap = new Map(), _class3$o), (_initializer$A = applyDecoratedInitializer(_class2$D.prototype, "_contentSize", [serializable$3], function () {
        return new Size$1(100, 100);
      }), _initializer2$u = applyDecoratedInitializer(_class2$D.prototype, "_anchorPoint", [serializable$3], function () {
        return new Vec2(0.5, 0.5);
      })), _class2$D)) || _class$H) || _class$H) || _class$H); exports({ UITransform: UITransform, UITransformComponent: UITransform });
      director.on(Director.EVENT_AFTER_UPDATE, UITransform._sortSiblings);
      director.on(Director.EVENT_BEFORE_SCENE_LAUNCH, UITransform._cleanChangeMap);

      const MaterialInstance = jsb.MaterialInstance;
      const materialInstanceProto = jsb.MaterialInstance.prototype;
      Object.defineProperty(materialInstanceProto, 'parent', {
        configurable: true,
        enumerable: true,
        get() {
          return this._parent;
        }
      });
      Object.defineProperty(materialInstanceProto, 'owner', {
        configurable: true,
        enumerable: true,
        get() {
          return this._owner;
        }
      });
      materialInstanceProto._ctor = function (info) {
        jsb.Material.prototype._ctor.apply(this, arguments);
        this._registerListeners();
        this._parent = info.parent;
        this._owner = info.owner || null;
        this._subModelIdx = info.subModelIdx || 0;
        this._passes = this.getPasses();
      };
      materialInstanceProto._onRebuildPSO = function () {
        if (this._owner) {
          this._owner._onRebuildPSO(this._subModelIdx, this);
        }
      };

      var _dec$H, _dec2$B, _dec3$u, _class$G, _class2$C, _initializer$z;
      const _matInsInfo = {
        parent: null,
        owner: null,
        subModelIdx: 0
      };
      const {
        ccclass: ccclass$2,
        serializable: serializable$2,
        disallowMultiple,
        type: type$1,
        displayOrder,
        displayName
      } = _decorator;
      let Renderer = exports('Renderer', (_dec$H = ccclass$2('cc.Renderer'), _dec2$B = type$1(Material), _dec3$u = type$1([Material]), _dec$H(_class$G = disallowMultiple(_class$G = (_class2$C = class Renderer extends Component {
        constructor(...args) {
          super(...args);
          this._materials = _initializer$z && _initializer$z();
          this._materialInstances = [];
        }
        get sharedMaterial() {
          return this.getSharedMaterial(0);
        }
        get sharedMaterials() {
          return this._materials;
        }
        set sharedMaterials(val) {
          for (let i = 0; i < val.length; i++) {
            if (val[i] !== this._materials[i]) {
              this.setSharedMaterial(val[i], i);
            }
          }
          if (val.length < this._materials.length) {
            for (let i = val.length; i < this._materials.length; i++) {
              this.setSharedMaterial(null, i);
            }
            this._materials.splice(val.length);
          }
        }
        get material() {
          return this.getMaterialInstance(0);
        }
        set material(val) {
          if (this._materials.length === 1 && !this._materialInstances[0] && this._materials[0] === val) {
            return;
          }
          this.setMaterialInstance(val, 0);
        }
        get materials() {
          for (let i = 0; i < this._materials.length; i++) {
            this._materialInstances[i] = this.getMaterialInstance(i);
          }
          return this._materialInstances;
        }
        set materials(val) {
          const newLength = val.length;
          const oldLength = this._materials.length;
          for (let i = newLength; i < oldLength; i++) {
            this.setMaterialInstance(null, i);
          }
          this._materials.length = newLength;
          this._materialInstances.length = newLength;
          for (let i = 0; i < newLength; i++) {
            if (this._materialInstances[i] != val[i]) {
              this.setMaterialInstance(val[i], i);
            }
          }
        }
        getMaterial(idx) {
          return this.getSharedMaterial(idx);
        }
        setMaterial(material, index) {
          this.setSharedMaterial(material, index);
        }
        getSharedMaterial(idx) {
          if (idx < 0 || idx >= this._materials.length) {
            return null;
          }
          return this._materials[idx];
        }
        setSharedMaterial(material, index) {
          if (material && material instanceof MaterialInstance) {
            errorID(12012);
          }
          this._materials[index] = material;
          const inst = this._materialInstances[index];
          if (inst) {
            inst.destroy();
            this._materialInstances[index] = null;
          }
          this._onMaterialModified(index, this._materials[index]);
        }
        getMaterialInstance(idx) {
          const mat = this._materials[idx];
          if (!mat) {
            return null;
          }
          if (!this._materialInstances[idx]) {
            _matInsInfo.parent = this._materials[idx];
            _matInsInfo.owner = this;
            _matInsInfo.subModelIdx = idx;
            const instantiated = new MaterialInstance(_matInsInfo);
            _matInsInfo.parent = null;
            _matInsInfo.owner = null;
            _matInsInfo.subModelIdx = 0;
            this.setMaterialInstance(instantiated, idx);
          }
          return this._materialInstances[idx];
        }
        setMaterialInstance(matInst, index) {
          if (typeof matInst === 'number') {
            warnID(12007);
            const temp = matInst;
            matInst = index;
            index = temp;
          }
          const curInst = this._materialInstances[index];
          if (matInst && matInst.parent) {
            if (matInst !== curInst) {
              this._materialInstances[index] = matInst;
              this._onMaterialModified(index, matInst);
            }
            return;
          }
          if (matInst !== this._materials[index] || curInst) {
            this.setSharedMaterial(matInst, index);
          }
        }
        getRenderMaterial(index) {
          return this._materialInstances[index] || this._materials[index];
        }
        _onMaterialModified(index, material) {}
        _onRebuildPSO(index, material) {}
        _clearMaterials() {}
      }, (_applyDecoratedDescriptor(_class2$C.prototype, "sharedMaterials", [_dec2$B], Object.getOwnPropertyDescriptor(_class2$C.prototype, "sharedMaterials"), _class2$C.prototype), _initializer$z = applyDecoratedInitializer(_class2$C.prototype, "_materials", [_dec3$u], function () {
        return [];
      })), _class2$C)) || _class$G) || _class$G));

      var _dec$G, _dec2$A, _dec3$t, _dec4$j, _class$F, _class2$B, _initializer$y, _initializer2$t, _initializer3$o, _initializer4$l, _initializer5$h, _class3$n;
      ccenum(BlendFactor);
      ccenum(BlendOp);
      ccenum(ColorMask);
      let InstanceMaterialType; exports('InstanceMaterialType', InstanceMaterialType);
      (function (InstanceMaterialType) {
        InstanceMaterialType[InstanceMaterialType["ADD_COLOR"] = 0] = "ADD_COLOR";
        InstanceMaterialType[InstanceMaterialType["ADD_COLOR_AND_TEXTURE"] = 1] = "ADD_COLOR_AND_TEXTURE";
        InstanceMaterialType[InstanceMaterialType["GRAYSCALE"] = 2] = "GRAYSCALE";
        InstanceMaterialType[InstanceMaterialType["USE_ALPHA_SEPARATED"] = 3] = "USE_ALPHA_SEPARATED";
        InstanceMaterialType[InstanceMaterialType["USE_ALPHA_SEPARATED_AND_GRAY"] = 4] = "USE_ALPHA_SEPARATED_AND_GRAY";
      })(InstanceMaterialType || (exports('InstanceMaterialType', InstanceMaterialType = {})));
      let UIRenderer = (_dec$G = ccclass$3('cc.UIRenderer'), _dec2$A = requireComponent(UITransform), _dec3$t = type$2(Material), _dec4$j = type$2(Material), _dec$G(_class$F = _dec2$A(_class$F = (_class2$B = (_class3$n = class UIRenderer extends Renderer {
        constructor() {
          super();
          this._renderData = null;
          this._materials = _initializer$y && _initializer$y();
          this._customMaterial = _initializer2$t && _initializer2$t();
          this._srcBlendFactor = _initializer3$o && _initializer3$o();
          this._dstBlendFactor = _initializer4$l && _initializer4$l();
          this._color = _initializer5$h && _initializer5$h();
          this._stencilStage = Stage.DISABLED;
          this._assembler = null;
          this._postAssembler = null;
          this._renderDataFlag = true;
          this._renderFlag = true;
          this._renderEntity = void 0;
          this._instanceMaterialType = -1;
          this._srcBlendFactorCache = BlendFactor.SRC_ALPHA;
          this._dstBlendFactorCache = BlendFactor.ONE_MINUS_SRC_ALPHA;
          this._dirtyVersion = -1;
          this._internalId = -1;
          this._flagChangedVersion = -1;
          this._useVertexOpacity = false;
          this._lastParent = null;
          this._renderEntity = this.createRenderEntity();
        }
        get sharedMaterials() {
          return this._materials;
        }
        set sharedMaterials(val) {
          for (let i = 0; i < val.length; i++) {
            if (val[i] !== this._materials[i]) {
              this.setSharedMaterial(val[i], i);
            }
          }
          if (val.length < this._materials.length) {
            for (let i = val.length; i < this._materials.length; i++) {
              this.setSharedMaterial(null, i);
            }
            this._materials.splice(val.length);
          }
        }
        get customMaterial() {
          return this._customMaterial;
        }
        set customMaterial(val) {
          this._customMaterial = val;
          this.updateMaterial();
        }
        get color() {
          return this._color;
        }
        set color(value) {
          if (this._color.equals(value)) {
            return;
          }
          this._color.set(value);
          this._updateColor();
        }
        get renderData() {
          return this._renderData;
        }
        setRenderData(renderData) {
          this._renderData = renderData;
        }
        get useVertexOpacity() {
          return this._useVertexOpacity;
        }
        get stencilStage() {
          return this._stencilStage;
        }
        set stencilStage(val) {
          this._stencilStage = val;
          this._renderEntity.setStencilStage(val);
        }
        get srcBlendFactor() {
          return this._srcBlendFactor;
        }
        set srcBlendFactor(srcBlendFactor) {
          this._srcBlendFactor = srcBlendFactor;
        }
        get batcher() {
          return director.root.batcher2D;
        }
        get renderEntity() {
          {
            assert(Boolean(this._renderEntity), 'this._renderEntity should not be invalid');
          }
          return this._renderEntity;
        }
        onLoad() {
          this._renderEntity.setNode(this.node);
        }
        __preload() {
          this.node._uiProps.uiComp = this;
          if (this._flushAssembler) {
            this._flushAssembler();
          }
        }
        onEnable() {
          this.node.on(NodeEventType.ANCHOR_CHANGED, this._nodeStateChange, this);
          this.node.on(NodeEventType.SIZE_CHANGED, this._nodeStateChange, this);
          this.node.on(NodeEventType.PARENT_CHANGED, this._colorDirty, this);
          this.updateMaterial();
          this._colorDirty();
          uiRendererManager.addRenderer(this);
          this.markForUpdateRenderData();
        }
        onRestore() {
          this.updateMaterial();
          this.markForUpdateRenderData();
        }
        onDisable() {
          this.node.off(NodeEventType.ANCHOR_CHANGED, this._nodeStateChange, this);
          this.node.off(NodeEventType.SIZE_CHANGED, this._nodeStateChange, this);
          this.node.off(NodeEventType.PARENT_CHANGED, this._colorDirty, this);
          uiRendererManager.removeRenderer(this);
          this._renderFlag = false;
          this._renderEntity.enabled = false;
        }
        onDestroy() {
          this._renderEntity.setNode(null);
          if (this.node._uiProps.uiComp === this) {
            this.node._uiProps.uiComp = null;
          }
          this.destroyRenderData();
          if (this._materialInstances) {
            for (let i = 0; i < this._materialInstances.length; i++) {
              const instance = this._materialInstances[i];
              if (instance) {
                instance.destroy();
              }
            }
          }
        }
        markForUpdateRenderData(enable = true) {
          if (enable) {
            const renderData = this._renderData;
            if (renderData) {
              renderData.vertDirty = true;
            }
            uiRendererManager.markDirtyRenderer(this);
          }
        }
        requestRenderData(drawInfoType = RenderDrawInfoType.COMP) {
          const data = RenderData.add();
          data.initRenderDrawInfo(this, drawInfoType);
          this._renderData = data;
          return data;
        }
        destroyRenderData() {
          if (!this._renderData) {
            return;
          }
          this._renderData.removeRenderDrawInfo(this);
          RenderData.remove(this._renderData);
          this._renderData = null;
        }
        updateRenderer() {
          if (this._assembler) {
            this._assembler.updateRenderData(this);
          }
          this._renderFlag = this._canRender();
          this._renderEntity.enabled = this._renderFlag;
        }
        fillBuffers(render) {
          if (this._renderFlag) {
            this._render(render);
          }
        }
        postUpdateAssembler(render) {
          if (this._postAssembler && this._renderFlag) {
            this._postRender(render);
          }
        }
        _render(render) {}
        _postRender(render) {}
        _canRender() {
          {
            assert(this.isValid, 'this component should not be invalid!');
          }
          return this.getSharedMaterial(0) !== null && this._enabled && this._color.a > 0;
        }
        _postCanRender() {}
        updateMaterial() {
          if (this._customMaterial) {
            if (this.getSharedMaterial(0) !== this._customMaterial) {
              this.setSharedMaterial(this._customMaterial, 0);
            }
            return;
          }
          const mat = this._updateBuiltinMaterial();
          this.setSharedMaterial(mat, 0);
          if (this.stencilStage === Stage.ENTER_LEVEL || this.stencilStage === Stage.ENTER_LEVEL_INVERTED) {
            this.getMaterialInstance(0).recompileShaders({
              USE_ALPHA_TEST: true
            });
          }
          this._updateBlendFunc();
        }
        _updateColor() {
          this.node._uiProps.colorDirty = true;
          this.setEntityColorDirty(true);
          this.setEntityColor(this._color);
          this.setEntityOpacity(this.node._uiProps.localOpacity);
          if (this._assembler) {
            this._assembler.updateColor(this);
            const renderFlag = this._renderFlag;
            this._renderFlag = this._canRender();
            this.setEntityEnabled(this._renderFlag);
            if (renderFlag !== this._renderFlag) {
              const renderData = this.renderData;
              if (renderData) {
                renderData.vertDirty = true;
              }
            }
          }
        }
        static setEntityColorDirtyRecursively(node, dirty) {
          const render = node._uiProps.uiComp;
          if (render && render.color) {
            render._renderEntity.colorDirty = dirty;
          }
          for (let i = 0; i < node.children.length; i++) {
            UIRenderer.setEntityColorDirtyRecursively(node.children[i], dirty);
          }
        }
        setEntityColorDirty(dirty) {
          {
            UIRenderer.setEntityColorDirtyRecursively(this.node, dirty);
          }
        }
        setEntityColor(color) {
          {
            this._renderEntity.color = color;
          }
        }
        setEntityOpacity(opacity) {
          {
            this._renderEntity.localOpacity = opacity;
          }
        }
        setEntityEnabled(enabled) {
          {
            this._renderEntity.enabled = enabled;
          }
        }
        _updateBlendFunc() {
          let target = this.getRenderMaterial(0).passes[0].blendState.targets[0];
          this._dstBlendFactorCache = target.blendDst;
          this._srcBlendFactorCache = target.blendSrc;
          if (this._dstBlendFactorCache !== this._dstBlendFactor || this._srcBlendFactorCache !== this._srcBlendFactor) {
            target = this.getMaterialInstance(0).passes[0].blendState.targets[0];
            target.blend = true;
            target.blendDstAlpha = BlendFactor.ONE_MINUS_SRC_ALPHA;
            target.blendDst = this._dstBlendFactor;
            target.blendSrc = this._srcBlendFactor;
            const targetPass = this.getMaterialInstance(0).passes[0];
            targetPass.blendState.setTarget(0, target);
            targetPass._updatePassHash();
            this._dstBlendFactorCache = this._dstBlendFactor;
            this._srcBlendFactorCache = this._srcBlendFactor;
          }
        }
        _nodeStateChange(transformType) {
          if (this._renderData) {
            this.markForUpdateRenderData();
          }
          for (let i = 0; i < this.node.children.length; ++i) {
            const child = this.node.children[i];
            const renderComp = child.getComponent(UIRenderer);
            if (renderComp) {
              renderComp.markForUpdateRenderData();
            }
          }
        }
        _colorDirty() {
          this.node._uiProps.colorDirty = true;
          this.setEntityColorDirty(true);
        }
        _onMaterialModified(idx, material) {
          if (this._renderData) {
            this.markForUpdateRenderData();
            this._renderData.passDirty = true;
          }
          super._onMaterialModified(idx, material);
        }
        _updateBuiltinMaterial() {
          let mat;
          switch (this._instanceMaterialType) {
            case InstanceMaterialType.ADD_COLOR:
              mat = builtinResMgr.get(`ui-base-material`);
              break;
            case InstanceMaterialType.GRAYSCALE:
              mat = builtinResMgr.get(`ui-sprite-gray-material`);
              break;
            case InstanceMaterialType.USE_ALPHA_SEPARATED:
              mat = builtinResMgr.get(`ui-sprite-alpha-sep-material`);
              break;
            case InstanceMaterialType.USE_ALPHA_SEPARATED_AND_GRAY:
              mat = builtinResMgr.get(`ui-sprite-gray-alpha-sep-material`);
              break;
            default:
              mat = builtinResMgr.get(`ui-sprite-material`);
              break;
          }
          return mat;
        }
        setNodeDirty() {
          if (this._renderData) {
            this._renderData.nodeDirty = true;
          }
        }
        setTextureDirty() {
          if (this._renderData) {
            this._renderData.textureDirty = true;
          }
        }
        createRenderEntity() {
          return new RenderEntity(RenderEntityType.STATIC);
        }
      }, _class3$n.BlendState = BlendFactor, _class3$n.Assembler = null, _class3$n.PostAssembler = null, _class3$n), (_applyDecoratedDescriptor(_class2$B.prototype, "sharedMaterials", [override], Object.getOwnPropertyDescriptor(_class2$B.prototype, "sharedMaterials"), _class2$B.prototype), _applyDecoratedDescriptor(_class2$B.prototype, "customMaterial", [_dec3$t], Object.getOwnPropertyDescriptor(_class2$B.prototype, "customMaterial"), _class2$B.prototype), _initializer$y = applyDecoratedInitializer(_class2$B.prototype, "_materials", [override], function () {
        return [];
      }), _initializer2$t = applyDecoratedInitializer(_class2$B.prototype, "_customMaterial", [_dec4$j], function () {
        return null;
      }), _initializer3$o = applyDecoratedInitializer(_class2$B.prototype, "_srcBlendFactor", [serializable$3], function () {
        return BlendFactor.SRC_ALPHA;
      }), _initializer4$l = applyDecoratedInitializer(_class2$B.prototype, "_dstBlendFactor", [serializable$3], function () {
        return BlendFactor.ONE_MINUS_SRC_ALPHA;
      }), _initializer5$h = applyDecoratedInitializer(_class2$B.prototype, "_color", [serializable$3], function () {
        return Color$1.WHITE.clone();
      })), _class2$B)) || _class$F) || _class$F); exports({ UIRenderer: UIRenderer, RenderComponent: UIRenderer, UIRenderable: UIRenderer, Renderable2D: UIRenderer });
      legacyCC.internal.UIRenderer = UIRenderer;

      class TextStyle {
        constructor() {
          this.isBold = false;
          this.isItalic = false;
          this.isUnderline = false;
          this.underlineHeight = 1;
          this.isOutlined = false;
          this.outlineColor = Color$1.WHITE.clone();
          this.outlineWidth = 1;
          this.hasShadow = false;
          this.shadowColor = Color$1.BLACK.clone();
          this.shadowBlur = 2;
          this.shadowOffsetX = 0;
          this.shadowOffsetY = 0;
          this.color = Color$1.WHITE.clone();
          this.fontSize = 40;
          this.actualFontSize = 0;
          this.isSystemFontUsed = false;
          this.originFontSize = 0;
          this.bmfontScale = 1.0;
          this.fontFamily = 'Arial';
          this.fontDesc = '';
          this.fntConfig = null;
          this.spriteFrame = null;
          this.fontScale = 1;
        }
        reset() {
          this.isBold = false;
          this.isItalic = false;
          this.isUnderline = false;
          this.underlineHeight = 1;
          this.isOutlined = false;
          this.outlineColor.set();
          this.outlineWidth = 1;
          this.hasShadow = false;
          this.shadowColor.set();
          this.shadowBlur = 2;
          this.shadowOffsetX = 0;
          this.shadowOffsetY = 0;
        }
      }

      class TextLayout {
        constructor() {
          this.horizontalAlign = 0;
          this.verticalAlign = 0;
          this.wrapping = true;
          this.overFlow = 0;
          this.lineHeight = 10;
          this.maxLineWidth = 0;
          this.spacingX = 0;
          this.textWidthTemp = 0;
          this.textHeightTemp = 0;
          this.textDimensions = new Size$1();
          this.horizontalKerning = [];
          this.numberOfLines = 1;
          this.linesOffsetX = [];
          this.letterOffsetY = 0;
          this.tailoredTopY = 0;
          this.tailoredBottomY = 0;
          this.textDesiredHeight = 0;
          this.linesWidth = [];
        }
        reset() {
          this.horizontalAlign = 0;
          this.verticalAlign = 0;
          this.wrapping = true;
          this.overFlow = 0;
          this.lineHeight = 10;
          this.maxLineWidth = 0;
          this.spacingX = 0;
          this.textWidthTemp = 0;
          this.textHeightTemp = 0;
          this.textDimensions.set();
          this.horizontalKerning.length = 0;
          this.numberOfLines = 1;
          this.linesOffsetX.length = 0;
          this.letterOffsetY = 0;
          this.tailoredTopY = 0;
          this.tailoredBottomY = 0;
          this.textDesiredHeight = 0;
          this.linesWidth.length = 0;
        }
      }

      class TextOutputLayoutData {
        constructor() {
          this.parsedString = [];
          this.nodeContentSize = Size$1.ZERO.clone();
          this.canvasSize = new Size$1();
          this.canvasPadding = new Rect$1();
          this.contentSizeExtend = Size$1.ZERO.clone();
          this.startPosition = Vec2.ZERO.clone();
        }
        reset() {
          this.parsedString.length = 0;
          this.nodeContentSize.set(0, 0);
          this.canvasSize.set();
          this.canvasPadding.set();
          this.contentSizeExtend.set();
          this.startPosition.set();
        }
      }
      class TextOutputRenderData {
        constructor() {
          this.quadCount = 0;
          this.vertexBuffer = [];
          this.texture = null;
          this.uiTransAnchorX = 0.5;
          this.uiTransAnchorY = 0.5;
        }
        reset() {
          this.quadCount = 0;
          this.vertexBuffer.length = 0;
          this.texture = null;
          this.uiTransAnchorX = 0.5;
          this.uiTransAnchorY = 0.5;
        }
      }

      var _dec$F, _dec2$z, _dec3$s, _dec4$i, _dec5$g, _dec6$a, _dec7$8, _class$E, _class2$A, _initializer$x, _initializer2$s, _initializer3$n, _initializer4$k, _initializer5$g, _initializer6$d, _initializer7$a, _initializer8$a, _initializer9$a, _initializer10$a, _initializer11$9, _initializer12$8, _initializer13$7, _initializer14$6, _initializer15$4, _initializer16$4, _initializer17$3, _class3$m;
      const tempColor$2 = Color$1.WHITE.clone();
      let HorizontalTextAlignment; exports('HorizontalTextAlignment', HorizontalTextAlignment);
      (function (HorizontalTextAlignment) {
        HorizontalTextAlignment[HorizontalTextAlignment["LEFT"] = 0] = "LEFT";
        HorizontalTextAlignment[HorizontalTextAlignment["CENTER"] = 1] = "CENTER";
        HorizontalTextAlignment[HorizontalTextAlignment["RIGHT"] = 2] = "RIGHT";
      })(HorizontalTextAlignment || (exports('HorizontalTextAlignment', HorizontalTextAlignment = {})));
      ccenum(HorizontalTextAlignment);
      let VerticalTextAlignment; exports('VerticalTextAlignment', VerticalTextAlignment);
      (function (VerticalTextAlignment) {
        VerticalTextAlignment[VerticalTextAlignment["TOP"] = 0] = "TOP";
        VerticalTextAlignment[VerticalTextAlignment["CENTER"] = 1] = "CENTER";
        VerticalTextAlignment[VerticalTextAlignment["BOTTOM"] = 2] = "BOTTOM";
      })(VerticalTextAlignment || (exports('VerticalTextAlignment', VerticalTextAlignment = {})));
      ccenum(VerticalTextAlignment);
      let Overflow$1; exports('Overflow', Overflow$1);
      (function (Overflow) {
        Overflow[Overflow["NONE"] = 0] = "NONE";
        Overflow[Overflow["CLAMP"] = 1] = "CLAMP";
        Overflow[Overflow["SHRINK"] = 2] = "SHRINK";
        Overflow[Overflow["RESIZE_HEIGHT"] = 3] = "RESIZE_HEIGHT";
      })(Overflow$1 || (exports('Overflow', Overflow$1 = {})));
      ccenum(Overflow$1);
      let CacheMode; exports('CacheMode', CacheMode);
      (function (CacheMode) {
        CacheMode[CacheMode["NONE"] = 0] = "NONE";
        CacheMode[CacheMode["BITMAP"] = 1] = "BITMAP";
        CacheMode[CacheMode["CHAR"] = 2] = "CHAR";
      })(CacheMode || (exports('CacheMode', CacheMode = {})));
      ccenum(CacheMode);
      let Label = (_dec$F = ccclass$3('cc.Label'), _dec2$z = executionOrder(110), _dec3$s = type$2(HorizontalTextAlignment), _dec4$i = type$2(VerticalTextAlignment), _dec5$g = type$2(Overflow$1), _dec6$a = type$2(Font), _dec7$8 = type$2(CacheMode), _dec$F(_class$E = _dec2$z(_class$E = (_class2$A = (_class3$m = class Label extends UIRenderer {
        get string() {
          return this._string;
        }
        set string(value) {
          if (value === null || value === undefined) {
            value = '';
          } else {
            value = value.toString();
          }
          if (this._string === value) {
            return;
          }
          this._string = value;
          this.markForUpdateRenderData();
        }
        get horizontalAlign() {
          return this._horizontalAlign;
        }
        set horizontalAlign(value) {
          if (this._horizontalAlign === value) {
            return;
          }
          this._horizontalAlign = value;
          this.markForUpdateRenderData();
        }
        get verticalAlign() {
          return this._verticalAlign;
        }
        set verticalAlign(value) {
          if (this._verticalAlign === value) {
            return;
          }
          this._verticalAlign = value;
          this.markForUpdateRenderData();
        }
        get actualFontSize() {
          return this._actualFontSize;
        }
        set actualFontSize(value) {
          this._actualFontSize = value;
        }
        get fontSize() {
          return this._fontSize;
        }
        set fontSize(value) {
          if (this._fontSize === value) {
            return;
          }
          this._fontSize = value;
          this.markForUpdateRenderData();
        }
        get lineHeight() {
          return this._lineHeight;
        }
        set lineHeight(value) {
          if (this._lineHeight === value) {
            return;
          }
          this._lineHeight = value;
          this.markForUpdateRenderData();
        }
        get spacingX() {
          return this._spacingX;
        }
        set spacingX(value) {
          if (this._spacingX === value) {
            return;
          }
          this._spacingX = value;
          this.markForUpdateRenderData();
        }
        get overflow() {
          return this._overflow;
        }
        set overflow(value) {
          if (this._overflow === value) {
            return;
          }
          this._overflow = value;
          this.markForUpdateRenderData();
        }
        get enableWrapText() {
          return this._enableWrapText;
        }
        set enableWrapText(value) {
          if (this._enableWrapText === value) {
            return;
          }
          this._enableWrapText = value;
          this.markForUpdateRenderData();
        }
        get useSystemFont() {
          return this._isSystemFontUsed;
        }
        set useSystemFont(value) {
          if (this._isSystemFontUsed === value) {
            return;
          }
          this.destroyRenderData();
          this._isSystemFontUsed = !!value;
          if (value) {
            this.font = null;
          }
          this._flushAssembler();
          this.markForUpdateRenderData();
        }
        get fontFamily() {
          return this._fontFamily;
        }
        set fontFamily(value) {
          if (this._fontFamily === value) {
            return;
          }
          this._fontFamily = value;
          this.markForUpdateRenderData();
        }
        get font() {
          return this._font;
        }
        set font(value) {
          if (this._font === value) {
            return;
          }
          this._isSystemFontUsed = !value;
          this._font = value;
          this.destroyRenderData();
          this._fontAtlas = null;
          this.updateRenderData(true);
        }
        get cacheMode() {
          return this._cacheMode;
        }
        set cacheMode(value) {
          if (this._cacheMode === value) {
            return;
          }
          if (this._cacheMode === CacheMode.BITMAP && !(this._font instanceof BitmapFont) && this._ttfSpriteFrame) {
            this._ttfSpriteFrame._resetDynamicAtlasFrame();
          }
          if (this._cacheMode === CacheMode.CHAR) {
            this._ttfSpriteFrame = null;
          }
          this._cacheMode = value;
          this.updateRenderData(true);
        }
        get isBold() {
          return this._isBold;
        }
        set isBold(value) {
          if (this._isBold === value) {
            return;
          }
          this._isBold = value;
          this.markForUpdateRenderData();
        }
        get isItalic() {
          return this._isItalic;
        }
        set isItalic(value) {
          if (this._isItalic === value) {
            return;
          }
          this._isItalic = value;
          this.markForUpdateRenderData();
        }
        get isUnderline() {
          return this._isUnderline;
        }
        set isUnderline(value) {
          if (this._isUnderline === value) {
            return;
          }
          this._isUnderline = value;
          this.markForUpdateRenderData();
        }
        get underlineHeight() {
          return this._underlineHeight;
        }
        set underlineHeight(value) {
          if (this._underlineHeight === value) return;
          this._underlineHeight = value;
          this.markForUpdateRenderData();
        }
        get spriteFrame() {
          return this._texture;
        }
        get ttfSpriteFrame() {
          return this._ttfSpriteFrame;
        }
        get assemblerData() {
          return this._assemblerData;
        }
        get fontAtlas() {
          return this._fontAtlas;
        }
        set fontAtlas(value) {
          this._fontAtlas = value;
        }
        get _bmFontOriginalSize() {
          if (this._font instanceof BitmapFont) {
            return this._font.fontSize;
          } else {
            return -1;
          }
        }
        get textStyle() {
          return this._textStyle;
        }
        get textLayout() {
          return this._textLayout;
        }
        get textRenderData() {
          return this._textRenderData;
        }
        get textLayoutData() {
          return this._textLayoutData;
        }
        get contentWidth() {
          return this._contentWidth;
        }
        set contentWidth(val) {
          this._contentWidth = val;
        }
        constructor() {
          super();
          this._string = _initializer$x && _initializer$x();
          this._horizontalAlign = _initializer2$s && _initializer2$s();
          this._verticalAlign = _initializer3$n && _initializer3$n();
          this._actualFontSize = _initializer4$k && _initializer4$k();
          this._fontSize = _initializer5$g && _initializer5$g();
          this._fontFamily = _initializer6$d && _initializer6$d();
          this._lineHeight = _initializer7$a && _initializer7$a();
          this._overflow = _initializer8$a && _initializer8$a();
          this._enableWrapText = _initializer9$a && _initializer9$a();
          this._font = _initializer10$a && _initializer10$a();
          this._isSystemFontUsed = _initializer11$9 && _initializer11$9();
          this._spacingX = _initializer12$8 && _initializer12$8();
          this._isItalic = _initializer13$7 && _initializer13$7();
          this._isBold = _initializer14$6 && _initializer14$6();
          this._isUnderline = _initializer15$4 && _initializer15$4();
          this._underlineHeight = _initializer16$4 && _initializer16$4();
          this._cacheMode = _initializer17$3 && _initializer17$3();
          this._N$file = null;
          this._texture = null;
          this._ttfSpriteFrame = null;
          this._userDefinedFont = null;
          this._assemblerData = null;
          this._fontAtlas = null;
          this._letterTexture = null;
          this._contentWidth = 0;
          this._textStyle = null;
          this._textLayout = null;
          this._textRenderData = null;
          this._textLayoutData = null;
          this._ttfSpriteFrame = null;
          this._textStyle = new TextStyle();
          this._textLayout = new TextLayout();
          this._textLayoutData = new TextOutputLayoutData();
          this._textRenderData = new TextOutputRenderData();
        }
        onEnable() {
          super.onEnable();
          if (!this._font && !this._isSystemFontUsed) {
            this.useSystemFont = true;
          }
          if (this._isSystemFontUsed && !this._fontFamily) {
            this.fontFamily = 'Arial';
          }
          this._applyFontTexture();
        }
        onDestroy() {
          if (this._assembler && this._assembler.resetAssemblerData) {
            this._assembler.resetAssemblerData(this._assemblerData);
          }
          this._assemblerData = null;
          if (this._ttfSpriteFrame) {
            this._ttfSpriteFrame._resetDynamicAtlasFrame();
            const tex = this._ttfSpriteFrame.texture;
            this._ttfSpriteFrame.destroy();
            if (tex) {
              const tex2d = tex;
              if (tex2d.image) {
                tex2d.image.destroy();
              }
              tex.destroy();
            }
            this._ttfSpriteFrame = null;
          }
          this._letterTexture = null;
          super.onDestroy();
        }
        updateRenderData(force = false) {
          if (force) {
            this._flushAssembler();
            if (this.renderData) this.renderData.vertDirty = true;
            this._applyFontTexture();
          }
          if (this._assembler) {
            this._assembler.updateRenderData(this);
          }
        }
        _render(render) {
          render.commitComp(this, this.renderData, this._texture, this._assembler, null);
        }
        _updateColor() {
          super._updateColor();
          this.markForUpdateRenderData();
        }
        setEntityColor(color) {
          {
            if (this._font instanceof BitmapFont) {
              this._renderEntity.color = color;
            } else {
              tempColor$2.set(255, 255, 255, color.a);
              this._renderEntity.color = tempColor$2;
            }
          }
        }
        _canRender() {
          if (!super._canRender() || !this._string) {
            return false;
          }
          const font = this._font;
          if (font && font instanceof BitmapFont) {
            const spriteFrame = font.spriteFrame;
            if (!spriteFrame || !spriteFrame.texture) {
              return false;
            }
          }
          return true;
        }
        _flushAssembler() {
          const assembler = Label.Assembler.getAssembler(this);
          if (this._assembler !== assembler) {
            this.destroyRenderData();
            this._assembler = assembler;
            this.textStyle.reset();
            this.textLayout.reset();
            this.textLayoutData.reset();
            this.textRenderData.reset();
          }
          if (!this.renderData) {
            if (this._assembler && this._assembler.createData) {
              this._renderData = this._assembler.createData(this);
              this.renderData.material = this.material;
              this._updateColor();
            }
          }
        }
        _applyFontTexture() {
          this.markForUpdateRenderData();
          const font = this._font;
          if (font instanceof BitmapFont) {
            const spriteFrame = font.spriteFrame;
            if (spriteFrame && spriteFrame.texture) {
              this._texture = spriteFrame;
              if (this.renderData) {
                this.renderData.textureDirty = true;
              }
              this.changeMaterialForDefine();
              if (this._assembler) {
                this._assembler.updateRenderData(this);
              }
            }
          } else {
            if (this.cacheMode === CacheMode.CHAR) {
              this._letterTexture = this._assembler.getAssemblerData();
              this._texture = this._letterTexture;
            } else if (!this._ttfSpriteFrame) {
              this._ttfSpriteFrame = new SpriteFrame();
              this._assemblerData = this._assembler.getAssemblerData();
              const image = new ImageAsset$1(this._assemblerData.canvas);
              const texture = new Texture2D$1();
              texture.image = image;
              this._ttfSpriteFrame.texture = texture;
            }
            if (this.cacheMode !== CacheMode.CHAR) {
              this._texture = this._ttfSpriteFrame;
            }
            this.changeMaterialForDefine();
          }
        }
        changeMaterialForDefine() {
          if (!this._texture) {
            return;
          }
          let value = false;
          if (this.cacheMode !== CacheMode.CHAR) {
            const spriteFrame = this._texture;
            const texture = spriteFrame.texture;
            if (texture instanceof TextureBase) {
              const format = texture.getPixelFormat();
              value = format === PixelFormat.RGBA_ETC1 || format === PixelFormat.RGB_A_PVRTC_4BPPV1 || format === PixelFormat.RGB_A_PVRTC_2BPPV1;
            }
          }
          if (value) {
            this._instanceMaterialType = InstanceMaterialType.USE_ALPHA_SEPARATED;
          } else {
            this._instanceMaterialType = InstanceMaterialType.ADD_COLOR_AND_TEXTURE;
          }
          this.updateMaterial();
        }
        _updateBlendFunc() {
          super._updateBlendFunc();
        }
      }, _class3$m.HorizontalAlign = HorizontalTextAlignment, _class3$m.VerticalAlign = VerticalTextAlignment, _class3$m.Overflow = Overflow$1, _class3$m.CacheMode = CacheMode, _class3$m._canvasPool = CanvasPool.getInstance(), _class3$m), (_applyDecoratedDescriptor(_class2$A.prototype, "horizontalAlign", [_dec3$s], Object.getOwnPropertyDescriptor(_class2$A.prototype, "horizontalAlign"), _class2$A.prototype), _applyDecoratedDescriptor(_class2$A.prototype, "verticalAlign", [_dec4$i], Object.getOwnPropertyDescriptor(_class2$A.prototype, "verticalAlign"), _class2$A.prototype), _applyDecoratedDescriptor(_class2$A.prototype, "overflow", [_dec5$g], Object.getOwnPropertyDescriptor(_class2$A.prototype, "overflow"), _class2$A.prototype), _applyDecoratedDescriptor(_class2$A.prototype, "font", [_dec6$a], Object.getOwnPropertyDescriptor(_class2$A.prototype, "font"), _class2$A.prototype), _applyDecoratedDescriptor(_class2$A.prototype, "cacheMode", [_dec7$8], Object.getOwnPropertyDescriptor(_class2$A.prototype, "cacheMode"), _class2$A.prototype), _initializer$x = applyDecoratedInitializer(_class2$A.prototype, "_string", [serializable$3], function () {
        return 'label';
      }), _initializer2$s = applyDecoratedInitializer(_class2$A.prototype, "_horizontalAlign", [serializable$3], function () {
        return HorizontalTextAlignment.CENTER;
      }), _initializer3$n = applyDecoratedInitializer(_class2$A.prototype, "_verticalAlign", [serializable$3], function () {
        return VerticalTextAlignment.CENTER;
      }), _initializer4$k = applyDecoratedInitializer(_class2$A.prototype, "_actualFontSize", [serializable$3], function () {
        return 0;
      }), _initializer5$g = applyDecoratedInitializer(_class2$A.prototype, "_fontSize", [serializable$3], function () {
        return 40;
      }), _initializer6$d = applyDecoratedInitializer(_class2$A.prototype, "_fontFamily", [serializable$3], function () {
        return 'Arial';
      }), _initializer7$a = applyDecoratedInitializer(_class2$A.prototype, "_lineHeight", [serializable$3], function () {
        return 40;
      }), _initializer8$a = applyDecoratedInitializer(_class2$A.prototype, "_overflow", [serializable$3], function () {
        return Overflow$1.NONE;
      }), _initializer9$a = applyDecoratedInitializer(_class2$A.prototype, "_enableWrapText", [serializable$3], function () {
        return true;
      }), _initializer10$a = applyDecoratedInitializer(_class2$A.prototype, "_font", [serializable$3], function () {
        return null;
      }), _initializer11$9 = applyDecoratedInitializer(_class2$A.prototype, "_isSystemFontUsed", [serializable$3], function () {
        return true;
      }), _initializer12$8 = applyDecoratedInitializer(_class2$A.prototype, "_spacingX", [serializable$3], function () {
        return 0;
      }), _initializer13$7 = applyDecoratedInitializer(_class2$A.prototype, "_isItalic", [serializable$3], function () {
        return false;
      }), _initializer14$6 = applyDecoratedInitializer(_class2$A.prototype, "_isBold", [serializable$3], function () {
        return false;
      }), _initializer15$4 = applyDecoratedInitializer(_class2$A.prototype, "_isUnderline", [serializable$3], function () {
        return false;
      }), _initializer16$4 = applyDecoratedInitializer(_class2$A.prototype, "_underlineHeight", [serializable$3], function () {
        return 2;
      }), _initializer17$3 = applyDecoratedInitializer(_class2$A.prototype, "_cacheMode", [serializable$3], function () {
        return CacheMode.NONE;
      })), _class2$A)) || _class$E) || _class$E); exports({ Label: Label, LabelComponent: Label });
      legacyCC.Label = Label;

      let _stageOffset = 0;
      const _name2stageID = {};
      var config = {
        addStage(name) {
          if (_name2stageID[name] !== undefined) {
            return;
          }
          const stageID = 1 << _stageOffset;
          _name2stageID[name] = stageID;
          _stageOffset += 1;
        },
        stageID(name) {
          const id = _name2stageID[name];
          if (id === undefined) {
            return -1;
          }
          return id;
        },
        stageIDs(nameList) {
          let key = 0;
          for (const name of nameList) {
            const id = _name2stageID[name];
            if (id !== undefined) {
              key |= id;
            }
          }
          return key;
        }
      };

      function createIA(device, data) {
        if (!data.positions) {
          console.error('The data must have positions field');
          return null;
        }
        const verts = [];
        const vcount = data.positions.length / 3;
        for (let i = 0; i < vcount; ++i) {
          verts.push(data.positions[3 * i], data.positions[3 * i + 1], data.positions[3 * i + 2]);
          if (data.normals) {
            verts.push(data.normals[3 * i], data.normals[3 * i + 1], data.normals[3 * i + 2]);
          }
          if (data.uvs) {
            verts.push(data.uvs[2 * i], data.uvs[2 * i + 1]);
          }
          if (data.colors) {
            verts.push(data.colors[3 * i], data.colors[3 * i + 1], data.colors[3 * i + 2]);
          }
        }
        const vfmt = [];
        vfmt.push(new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F));
        if (data.normals) {
          vfmt.push(new Attribute(AttributeName.ATTR_NORMAL, Format.RGB32F));
        }
        if (data.uvs) {
          vfmt.push(new Attribute(AttributeName.ATTR_TEX_COORD, Format.RG32F));
        }
        if (data.colors) {
          vfmt.push(new Attribute(AttributeName.ATTR_COLOR, Format.RGB32F));
        }
        const vb = device.createBuffer(new BufferInfo(BufferUsageBit.VERTEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, verts.length * 4, verts.length * 4 / vcount));
        vb.update(new Float32Array(verts));
        let ib = null;
        if (data.indices) {
          ib = device.createBuffer(new BufferInfo(BufferUsageBit.INDEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, data.indices.length * 2, 2));
          ib.update(new Uint16Array(data.indices));
        }
        return device.createInputAssembler(new InputAssemblerInfo(vfmt, [vb], ib));
      }

      let RenderQueue;
      (function (RenderQueue) {
        RenderQueue[RenderQueue["OPAQUE"] = 0] = "OPAQUE";
        RenderQueue[RenderQueue["TRANSPARENT"] = 1] = "TRANSPARENT";
        RenderQueue[RenderQueue["OVERLAY"] = 2] = "OVERLAY";
      })(RenderQueue || (RenderQueue = {}));
      let PassStage;
      (function (PassStage) {
        PassStage[PassStage["DEFAULT"] = 1] = "DEFAULT";
        PassStage[PassStage["FORWARD"] = 2] = "FORWARD";
        PassStage[PassStage["SHADOWCAST"] = 4] = "SHADOWCAST";
      })(PassStage || (PassStage = {}));

      const typeMask = 0xfc000000;
      const bindingMask = 0x03f00000;
      const countMask = 0x000ff000;
      const offsetMask = 0x00000fff;
      const genHandle = (binding, type, count, offset = 0) => type << 26 & typeMask | binding << 20 & bindingMask | count << 12 & countMask | offset & offsetMask;
      const getTypeFromHandle = handle => (handle & typeMask) >>> 26;
      const getBindingFromHandle = handle => (handle & bindingMask) >>> 20;
      const getCountFromHandle = handle => (handle & countMask) >>> 12;
      const getOffsetFromHandle = handle => handle & offsetMask;
      const customizeType = (handle, type) => handle & ~typeMask | type << 26 & typeMask;
      const type2reader = {
        [Type$1.UNKNOWN]: (a, v, idx = 0) => warnID(12010, idx),
        [Type$1.INT]: (a, v, idx = 0) => a[idx],
        [Type$1.INT2]: (a, v, idx = 0) => Vec2.fromArray(v, a, idx),
        [Type$1.INT3]: (a, v, idx = 0) => Vec3.fromArray(v, a, idx),
        [Type$1.INT4]: (a, v, idx = 0) => Vec4.fromArray(v, a, idx),
        [Type$1.FLOAT]: (a, v, idx = 0) => a[idx],
        [Type$1.FLOAT2]: (a, v, idx = 0) => Vec2.fromArray(v, a, idx),
        [Type$1.FLOAT3]: (a, v, idx = 0) => Vec3.fromArray(v, a, idx),
        [Type$1.FLOAT4]: (a, v, idx = 0) => Vec4.fromArray(v, a, idx),
        [Type$1.MAT3]: (a, v, idx = 0) => Mat3.fromArray(v, a, idx),
        [Type$1.MAT4]: (a, v, idx = 0) => Mat4.fromArray(v, a, idx)
      };
      const type2writer = {
        [Type$1.UNKNOWN]: (a, v, idx = 0) => warnID(12010, idx),
        [Type$1.INT]: (a, v, idx = 0) => a[idx] = v,
        [Type$1.INT2]: (a, v, idx = 0) => Vec2.toArray(a, v, idx),
        [Type$1.INT3]: (a, v, idx = 0) => Vec3.toArray(a, v, idx),
        [Type$1.INT4]: (a, v, idx = 0) => Vec4.toArray(a, v, idx),
        [Type$1.FLOAT]: (a, v, idx = 0) => a[idx] = v,
        [Type$1.FLOAT2]: (a, v, idx = 0) => Vec2.toArray(a, v, idx),
        [Type$1.FLOAT3]: (a, v, idx = 0) => Vec3.toArray(a, v, idx),
        [Type$1.FLOAT4]: (a, v, idx = 0) => Vec4.toArray(a, v, idx),
        [Type$1.MAT3]: (a, v, idx = 0) => Mat3.toArray(a, v, idx),
        [Type$1.MAT4]: (a, v, idx = 0) => Mat4.toArray(a, v, idx)
      };
      const type2validator = {
        [Type$1.INT]: v => typeof v === 'number',
        [Type$1.FLOAT]: v => typeof v === 'number',
        [Type$1.INT2]: v => !!(v instanceof Vec2),
        [Type$1.FLOAT2]: v => !!(v instanceof Vec2),
        [Type$1.INT3]: v => !!(v instanceof Vec3),
        [Type$1.FLOAT3]: v => !!(v instanceof Vec3),
        [Type$1.INT4]: v => !!(v instanceof Vec4),
        [Type$1.FLOAT4]: v => !!(v instanceof Vec4 || v instanceof Color$1 || v instanceof Quat),
        [Type$1.MAT3]: v => !!(v instanceof Mat3),
        [Type$1.MAT4]: v => !!(v instanceof Mat4)
      };
      const defaultValues = [Object.freeze([0]), Object.freeze([0, 0]), Object.freeze([0, 0, 0, 0]), Object.freeze([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])];
      function getDefaultFromType(type) {
        switch (type) {
          case Type$1.BOOL:
          case Type$1.INT:
          case Type$1.UINT:
          case Type$1.FLOAT:
            return defaultValues[0];
          case Type$1.BOOL2:
          case Type$1.INT2:
          case Type$1.UINT2:
          case Type$1.FLOAT2:
            return defaultValues[1];
          case Type$1.BOOL4:
          case Type$1.INT4:
          case Type$1.UINT4:
          case Type$1.FLOAT4:
            return defaultValues[2];
          case Type$1.MAT4:
            return defaultValues[3];
          case Type$1.SAMPLER2D:
            return 'default-texture';
          case Type$1.SAMPLER_CUBE:
            return 'default-cube-texture';
          case Type$1.SAMPLER2D_ARRAY:
            return 'default-array-texture';
          case Type$1.SAMPLER3D:
            return 'default-3d-texture';
        }
        return defaultValues[0];
      }
      function getStringFromType(type) {
        switch (type) {
          case Type$1.SAMPLER2D:
            return '-texture';
          case Type$1.SAMPLER_CUBE:
            return '-cube-texture';
          case Type$1.SAMPLER2D_ARRAY:
            return '-array-texture';
          case Type$1.SAMPLER3D:
            return '-3d-texture';
          default:
            return '-unknown';
        }
      }
      function overrideMacros(target, source) {
        const entries = Object.entries(source);
        let isDifferent = false;
        for (let i = 0; i < entries.length; i++) {
          if (target[entries[i][0]] !== entries[i][1]) {
            target[entries[i][0]] = entries[i][1];
            isDifferent = true;
          }
        }
        return isDifferent;
      }

      let BatchingSchemes;
      (function (BatchingSchemes) {
        BatchingSchemes[BatchingSchemes["NONE"] = 0] = "NONE";
        BatchingSchemes[BatchingSchemes["INSTANCING"] = 1] = "INSTANCING";
      })(BatchingSchemes || (BatchingSchemes = {}));
      const Pass = jsb.Pass;
      const proto = Pass.prototype;
      proto.getUniform = function getUniform(handle, out) {
        const val = this._getUniform(handle);
        if (typeof val === 'object') {
          if (val.type) {
            switch (val.type) {
              case MathType$1.VEC2:
                Vec2.copy(out, val);
                break;
              case MathType$1.VEC3:
                Vec3.copy(out, val);
                break;
              case MathType$1.VEC4:
                Vec4.copy(out, val);
                break;
              case MathType$1.COLOR:
                out.x = val.x;
                out.y = val.y;
                out.z = val.z;
                out.w = val.w;
                break;
              case MathType$1.MAT3:
                Mat3.copy(out, val);
                break;
              case MathType$1.MAT4:
                Mat4.copy(out, val);
                break;
              case MathType$1.QUATERNION:
                Quat.copy(out, val);
                break;
              default:
                console.error(`getUniform, unknown object type: ${val.type}`);
                break;
            }
          } else {
            console.error(`getUniform, unknown object: ${val}`);
          }
        } else if (typeof val === 'number') {
          out = val;
        } else {
          console.error(`getUniform, not supported: ${val}`);
        }
        return out;
      };

      function getDeviceShaderVersion(device) {
        switch (device.gfxAPI) {
          case API.GLES2:
          case API.WEBGL:
            return 'glsl1';
          case API.GLES3:
          case API.WEBGL2:
            return 'glsl3';
          default:
            return 'glsl4';
        }
      }
      const programLib = jsb.ProgramLib.getInstance();
      legacyCC.programLib = programLib;

      function nearestPOT(num) {
        --num;
        num |= num >> 16;
        num |= num >> 8;
        num |= num >> 4;
        num |= num >> 2;
        num |= num >> 1;
        ++num;
        return num;
      }
      function roundUp(n, alignment) {
        return Math.ceil(n / alignment) * alignment;
      }
      class TextureBufferPool {
        constructor(device) {
          this._device = void 0;
          this._format = Format.UNKNOWN;
          this._formatSize = 0;
          this._chunks = [];
          this._chunkCount = 0;
          this._handles = [];
          this._region0 = new BufferTextureCopy();
          this._region1 = new BufferTextureCopy();
          this._region2 = new BufferTextureCopy();
          this._roundUpFn = null;
          this._bufferViewCtor = Uint8Array;
          this._channels = 4;
          this._alignment = 1;
          this._device = device;
        }
        initialize(info) {
          const formatInfo = FormatInfos[info.format];
          this._format = info.format;
          this._formatSize = formatInfo.size;
          this._channels = formatInfo.count;
          this._bufferViewCtor = getTypedArrayConstructor(formatInfo);
          this._roundUpFn = info.roundUpFn || null;
          this._alignment = info.alignment || 1;
          if (info.inOrderFree) {
            this.alloc = this._McDonaldAlloc;
          }
        }
        destroy() {
          for (let i = 0; i < this._chunkCount; ++i) {
            const chunk = this._chunks[i];
            chunk.texture.destroy();
          }
          this._chunks.length = 0;
          this._handles.length = 0;
        }
        alloc(size, chunkIdx) {
          size = roundUp(size, this._alignment);
          let index = -1;
          let start = -1;
          if (chunkIdx !== undefined) {
            index = chunkIdx;
            start = this._findAvailableSpace(size, index);
          }
          if (start < 0) {
            for (let i = 0; i < this._chunkCount; ++i) {
              index = i;
              start = this._findAvailableSpace(size, index);
              if (start >= 0) {
                break;
              }
            }
          }
          if (start >= 0) {
            const chunk = this._chunks[index];
            chunk.start += size;
            const handle = {
              chunkIdx: index,
              start,
              end: start + size,
              texture: chunk.texture
            };
            this._handles.push(handle);
            return handle;
          }
          const targetSize = Math.sqrt(size / this._formatSize);
          const texLength = this._roundUpFn && this._roundUpFn(targetSize, this._formatSize) || Math.max(1024, nearestPOT(targetSize));
          const newChunk = this._chunks[this.createChunk(texLength)];
          newChunk.start += size;
          const texHandle = {
            chunkIdx: this._chunkCount - 1,
            start: 0,
            end: size,
            texture: newChunk.texture
          };
          this._handles.push(texHandle);
          return texHandle;
        }
        free(handle) {
          for (let i = 0; i < this._handles.length; ++i) {
            if (this._handles[i] === handle) {
              this._chunks[handle.chunkIdx].end = handle.end;
              this._handles.splice(i, 1);
              return;
            }
          }
        }
        createChunk(length) {
          const texSize = length * length * this._formatSize;
          debug(`TextureBufferPool: Allocate chunk ${this._chunkCount}, size: ${texSize}, format: ${this._format}`);
          const texture = this._device.createTexture(new TextureInfo(TextureType.TEX2D, TextureUsageBit.SAMPLED | TextureUsageBit.TRANSFER_DST, this._format, length, length));
          const chunk = {
            texture,
            size: texSize,
            start: 0,
            end: texSize
          };
          this._chunks[this._chunkCount] = chunk;
          return this._chunkCount++;
        }
        update(handle, buffer) {
          const buffers = [];
          const regions = [];
          const start = handle.start / this._formatSize;
          let remainSize = buffer.byteLength / this._formatSize;
          let offsetX = start % handle.texture.width;
          let offsetY = Math.floor(start / handle.texture.width);
          let copySize = Math.min(handle.texture.width - offsetX, remainSize);
          let begin = 0;
          if (offsetX > 0) {
            this._region0.texOffset.x = offsetX;
            this._region0.texOffset.y = offsetY;
            this._region0.texExtent.width = copySize;
            this._region0.texExtent.height = 1;
            buffers.push(new this._bufferViewCtor(buffer, begin * this._formatSize, copySize * this._channels));
            regions.push(this._region0);
            offsetX = 0;
            offsetY += 1;
            remainSize -= copySize;
            begin += copySize;
          }
          if (remainSize > 0) {
            this._region1.texOffset.x = offsetX;
            this._region1.texOffset.y = offsetY;
            if (remainSize > handle.texture.width) {
              this._region1.texExtent.width = handle.texture.width;
              this._region1.texExtent.height = Math.floor(remainSize / handle.texture.width);
              copySize = this._region1.texExtent.width * this._region1.texExtent.height;
            } else {
              copySize = remainSize;
              this._region1.texExtent.width = copySize;
              this._region1.texExtent.height = 1;
            }
            buffers.push(new this._bufferViewCtor(buffer, begin * this._formatSize, copySize * this._channels));
            regions.push(this._region1);
            offsetX = 0;
            offsetY += this._region1.texExtent.height;
            remainSize -= copySize;
            begin += copySize;
          }
          if (remainSize > 0) {
            this._region2.texOffset.x = offsetX;
            this._region2.texOffset.y = offsetY;
            this._region2.texExtent.width = remainSize;
            this._region2.texExtent.height = 1;
            buffers.push(new this._bufferViewCtor(buffer, begin * this._formatSize, remainSize * this._channels));
            regions.push(this._region2);
          }
          this._device.copyBuffersToTexture(buffers, handle.texture, regions);
        }
        _findAvailableSpace(size, chunkIdx) {
          const chunk = this._chunks[chunkIdx];
          let isFound = false;
          let start = chunk.start;
          if (start + size <= chunk.size) {
            isFound = true;
          } else {
            start = 0;
            const handles = this._handles.filter(h => h.chunkIdx === chunkIdx).sort((a, b) => a.start - b.start);
            for (let i = 0; i < handles.length; i++) {
              const handle = handles[i];
              if (start + size <= handle.start) {
                isFound = true;
                break;
              }
              start = handle.end;
            }
            if (!isFound && start + size <= chunk.size) {
              isFound = true;
            }
          }
          return isFound ? start : -1;
        }
        _McDonaldAlloc(size) {
          size = roundUp(size, this._alignment);
          for (let i = 0; i < this._chunkCount; ++i) {
            const chunk = this._chunks[i];
            let isFound = false;
            let start = chunk.start;
            if (start + size <= chunk.end) {
              isFound = true;
            } else if (start > chunk.end) {
              if (start + size <= chunk.size) {
                isFound = true;
              } else if (size <= chunk.end) {
                chunk.start = start = 0;
                isFound = true;
              }
            } else if (start === chunk.end) {
              chunk.start = start = 0;
              chunk.end = chunk.size;
              if (size <= chunk.end) {
                isFound = true;
              }
            }
            if (isFound) {
              chunk.start += size;
              const handle = {
                chunkIdx: i,
                start,
                end: start + size,
                texture: chunk.texture
              };
              this._handles.push(handle);
              return handle;
            }
          }
          const targetSize = Math.sqrt(size / this._formatSize);
          const texLength = this._roundUpFn && this._roundUpFn(targetSize, this._formatSize) || Math.max(1024, nearestPOT(targetSize));
          const newChunk = this._chunks[this.createChunk(texLength)];
          newChunk.start += size;
          const texHandle = {
            chunkIdx: this._chunkCount,
            start: 0,
            end: size,
            texture: newChunk.texture
          };
          this._handles.push(texHandle);
          return texHandle;
        }
      }

      class PassInstance extends Pass {
        get parent() {
          return this._parent;
        }
        constructor(parent, owner) {
          super(parent.root);
          this._parent = void 0;
          this._owner = void 0;
          this._dontNotify = false;
          this._parent = parent;
          this._owner = owner;
          this._doInit(this._parent, true);
          for (let i = 0; i < this._shaderInfo.blocks.length; i++) {
            const u = this._shaderInfo.blocks[i];
            const block = this._blocks[u.binding];
            const parentBlock = this._parent.blocks[u.binding];
            block.set(parentBlock);
          }
          this._rootBufferDirty = true;
          const paren = this._parent;
          for (let i = 0; i < this._shaderInfo.samplerTextures.length; i++) {
            const u = this._shaderInfo.samplerTextures[i];
            for (let j = 0; j < u.count; j++) {
              const sampler = paren._descriptorSet.getSampler(u.binding, j);
              const texture = paren._descriptorSet.getTexture(u.binding, j);
              this._descriptorSet.bindSampler(u.binding, sampler, j);
              this._descriptorSet.bindTexture(u.binding, texture, j);
            }
          }
          super.tryCompile();
        }
        overridePipelineStates(original, overrides) {
          this._bs.reset();
          this._rs.reset();
          this._dss.reset();
          Pass.fillPipelineInfo(this, original);
          Pass.fillPipelineInfo(this, overrides);
          this._onStateChange();
        }
        tryCompile(defineOverrides) {
          if (defineOverrides) {
            if (!overrideMacros(this._defines, defineOverrides)) {
              return false;
            }
          }
          const res = super.tryCompile();
          this._onStateChange();
          return res;
        }
        beginChangeStatesSilently() {
          this._dontNotify = true;
        }
        endChangeStatesSilently() {
          this._dontNotify = false;
        }
        _syncBatchingScheme() {
          this._defines.USE_INSTANCING = false;
          this._batchingScheme = BatchingSchemes.NONE;
        }
        _onStateChange() {
          this._hash = Pass.getPassHash(this);
          this._owner.onPassStateChange(this._dontNotify);
        }
      }

      const NativeBufferPool = jsb.NativeBufferPool;
      jsb.NativeObjectPool;
      jsb.NativeBufferAllocator;

      const contains = (a, t) => {
        for (let i = 0; i < a.length; ++i) {
          if (a[i] === t) return true;
        }
        return false;
      };
      var BufferDataType;
      (function (BufferDataType) {
        BufferDataType[BufferDataType["UINT32"] = 0] = "UINT32";
        BufferDataType[BufferDataType["FLOAT32"] = 1] = "FLOAT32";
        BufferDataType[BufferDataType["NEVER"] = 2] = "NEVER";
      })(BufferDataType || (BufferDataType = {}));
      class BufferPool {
        constructor(poolType, dataType, dataMembers, enumType, entryBits = 8) {
          this._dataType = void 0;
          this._dataMembers = void 0;
          this._elementCount = void 0;
          this._entryBits = void 0;
          this._stride = void 0;
          this._entriesPerChunk = void 0;
          this._entryMask = void 0;
          this._chunkMask = void 0;
          this._poolFlag = void 0;
          this._arrayBuffers = [];
          this._freeLists = [];
          this._uint32BufferViews = [];
          this._float32BufferViews = [];
          this._hasUint32 = false;
          this._hasFloat32 = false;
          this._nativePool = void 0;
          this._elementCount = enumType.COUNT;
          this._entryBits = entryBits;
          this._dataType = dataType;
          this._dataMembers = dataMembers;
          const bytesPerElement = 4;
          this._stride = bytesPerElement * this._elementCount;
          this._entriesPerChunk = 1 << entryBits;
          this._entryMask = this._entriesPerChunk - 1;
          this._poolFlag = 1 << 30;
          this._chunkMask = ~(this._entryMask | this._poolFlag);
          this._nativePool = new NativeBufferPool(poolType, entryBits, this._stride);
          let type = BufferDataType.NEVER;
          let hasFloat32 = false;
          let hasUint32 = false;
          for (const e in dataType) {
            hasFloat32 = this._hasFloat32;
            hasUint32 = this._hasUint32;
            if (hasUint32 && hasFloat32) {
              break;
            }
            type = dataType[e];
            if (!hasFloat32 && type === BufferDataType.FLOAT32) {
              this._hasFloat32 = true;
            } else if (!hasUint32 && type === BufferDataType.UINT32) {
              this._hasUint32 = true;
            }
          }
        }
        alloc() {
          let i = 0;
          for (; i < this._freeLists.length; i++) {
            const list = this._freeLists[i];
            if (list.length) {
              const j = list[list.length - 1];
              list.length--;
              return (i << this._entryBits) + j + this._poolFlag;
            }
          }
          const buffer = this._nativePool.allocateNewChunk();
          const float32BufferViews = [];
          const uint32BufferViews = [];
          const freeList = [];
          const hasFloat32 = this._hasFloat32;
          const hasUint32 = this._hasUint32;
          for (let j = 0; j < this._entriesPerChunk; j++) {
            if (hasFloat32) {
              float32BufferViews.push(new Float32Array(buffer, this._stride * j, this._elementCount));
            }
            if (hasUint32) {
              uint32BufferViews.push(new Uint32Array(buffer, this._stride * j, this._elementCount));
            }
            if (j) {
              freeList.push(j);
            }
          }
          if (hasUint32) {
            this._uint32BufferViews.push(uint32BufferViews);
          }
          if (hasFloat32) {
            this._float32BufferViews.push(float32BufferViews);
          }
          this._freeLists.push(freeList);
          this._arrayBuffers.push(buffer);
          const handle = (i << this._entryBits) + this._poolFlag;
          return handle;
        }
        getBuffer(handle) {
          const chunk = (this._chunkMask & handle) >> this._entryBits;
          const entry = this._entryMask & handle;
          const bufferViews = this._hasFloat32 ? this._float32BufferViews : this._uint32BufferViews;
          if ((!handle || chunk < 0 || chunk >= bufferViews.length || entry < 0 || entry >= this._entriesPerChunk || contains(this._freeLists[chunk], entry))) {
            console.warn('invalid buffer pool handle');
            return [];
          }
          return bufferViews[chunk][entry];
        }
        getTypedArray(handle, element) {
          const chunk = (this._chunkMask & handle) >> this._entryBits;
          const entry = this._entryMask & handle;
          const bufferViews = this._dataType[element] === BufferDataType.UINT32 ? this._uint32BufferViews : this._float32BufferViews;
          if ((!handle || chunk < 0 || chunk >= bufferViews.length || entry < 0 || entry >= this._entriesPerChunk || contains(this._freeLists[chunk], entry))) {
            console.warn('invalid buffer pool handle');
            return [];
          }
          const index = element;
          const view = bufferViews[chunk][entry];
          const count = this._dataMembers[element];
          return view.subarray(index, index + count);
        }
        free(handle) {
          const chunk = (this._chunkMask & handle) >> this._entryBits;
          const entry = this._entryMask & handle;
          if ((!handle || chunk < 0 || chunk >= this._freeLists.length || entry < 0 || entry >= this._entriesPerChunk || contains(this._freeLists[chunk], entry))) {
            console.warn('invalid buffer pool handle');
            return;
          }
          const bufferViews = this._hasUint32 ? this._uint32BufferViews : this._float32BufferViews;
          bufferViews[chunk][entry].fill(0);
          this._freeLists[chunk].push(entry);
        }
      }
      let PoolType;
      (function (PoolType) {
        PoolType[PoolType["NODE"] = 0] = "NODE";
        PoolType[PoolType["PASS"] = 1] = "PASS";
        PoolType[PoolType["AABB"] = 2] = "AABB";
        PoolType[PoolType["RENDER2D"] = 3] = "RENDER2D";
      })(PoolType || (PoolType = {}));
      const NULL_HANDLE = 0;
      let Render2dView;
      (function (Render2dView) {
        Render2dView[Render2dView["POSITION"] = 0] = "POSITION";
        Render2dView[Render2dView["UV"] = 3] = "UV";
        Render2dView[Render2dView["COLOR"] = 5] = "COLOR";
        Render2dView[Render2dView["COUNT"] = 9] = "COUNT";
      })(Render2dView || (Render2dView = {}));
      const Render2dViewDataType = {
        [Render2dView.POSITION]: BufferDataType.FLOAT32,
        [Render2dView.UV]: BufferDataType.FLOAT32,
        [Render2dView.COLOR]: BufferDataType.UINT32,
        [Render2dView.COUNT]: BufferDataType.NEVER
      };
      const Render2dViewDataMembers = {
        [Render2dView.POSITION]: Render2dView.UV - Render2dView.POSITION,
        [Render2dView.UV]: Render2dView.COLOR - Render2dView.UV,
        [Render2dView.COLOR]: Render2dView.COUNT - Render2dView.COLOR,
        [Render2dView.COUNT]: 1
      };
      const Render2dPool = new BufferPool(PoolType.RENDER2D, Render2dViewDataType, Render2dViewDataMembers, Render2dView);
      let NodeView;
      (function (NodeView) {
        NodeView[NodeView["DIRTY_FLAG"] = 0] = "DIRTY_FLAG";
        NodeView[NodeView["LAYER"] = 1] = "LAYER";
        NodeView[NodeView["WORLD_SCALE"] = 2] = "WORLD_SCALE";
        NodeView[NodeView["WORLD_POSITION"] = 5] = "WORLD_POSITION";
        NodeView[NodeView["WORLD_ROTATION"] = 8] = "WORLD_ROTATION";
        NodeView[NodeView["WORLD_MATRIX"] = 12] = "WORLD_MATRIX";
        NodeView[NodeView["LOCAL_SCALE"] = 28] = "LOCAL_SCALE";
        NodeView[NodeView["LOCAL_POSITION"] = 31] = "LOCAL_POSITION";
        NodeView[NodeView["LOCAL_ROTATION"] = 34] = "LOCAL_ROTATION";
        NodeView[NodeView["COUNT"] = 38] = "COUNT";
      })(NodeView || (NodeView = {}));
      const NodeViewDataType = {
        [NodeView.DIRTY_FLAG]: BufferDataType.UINT32,
        [NodeView.LAYER]: BufferDataType.UINT32,
        [NodeView.WORLD_SCALE]: BufferDataType.FLOAT32,
        [NodeView.WORLD_POSITION]: BufferDataType.FLOAT32,
        [NodeView.WORLD_ROTATION]: BufferDataType.FLOAT32,
        [NodeView.WORLD_MATRIX]: BufferDataType.FLOAT32,
        [NodeView.LOCAL_SCALE]: BufferDataType.FLOAT32,
        [NodeView.LOCAL_POSITION]: BufferDataType.FLOAT32,
        [NodeView.LOCAL_ROTATION]: BufferDataType.FLOAT32,
        [NodeView.COUNT]: BufferDataType.NEVER
      };
      const NodeViewDataMembers = {
        [NodeView.DIRTY_FLAG]: NodeView.LAYER - NodeView.DIRTY_FLAG,
        [NodeView.LAYER]: NodeView.WORLD_SCALE - NodeView.LAYER,
        [NodeView.WORLD_SCALE]: NodeView.WORLD_POSITION - NodeView.WORLD_SCALE,
        [NodeView.WORLD_POSITION]: NodeView.WORLD_ROTATION - NodeView.WORLD_POSITION,
        [NodeView.WORLD_ROTATION]: NodeView.WORLD_MATRIX - NodeView.WORLD_ROTATION,
        [NodeView.WORLD_MATRIX]: NodeView.LOCAL_SCALE - NodeView.WORLD_MATRIX,
        [NodeView.LOCAL_SCALE]: NodeView.LOCAL_POSITION - NodeView.LOCAL_SCALE,
        [NodeView.LOCAL_POSITION]: NodeView.LOCAL_ROTATION - NodeView.LOCAL_POSITION,
        [NodeView.LOCAL_ROTATION]: NodeView.COUNT - NodeView.LOCAL_ROTATION,
        [NodeView.COUNT]: 1
      };
      const NodePool$1 = new BufferPool(PoolType.NODE, NodeViewDataType, NodeViewDataMembers, NodeView);
      let PassView;
      (function (PassView) {
        PassView[PassView["PRIORITY"] = 0] = "PRIORITY";
        PassView[PassView["STAGE"] = 1] = "STAGE";
        PassView[PassView["PHASE"] = 2] = "PHASE";
        PassView[PassView["PRIMITIVE"] = 3] = "PRIMITIVE";
        PassView[PassView["BATCHING_SCHEME"] = 4] = "BATCHING_SCHEME";
        PassView[PassView["DYNAMIC_STATE"] = 5] = "DYNAMIC_STATE";
        PassView[PassView["HASH"] = 6] = "HASH";
        PassView[PassView["COUNT"] = 7] = "COUNT";
      })(PassView || (PassView = {}));
      const PassViewDataType = {
        [PassView.PRIORITY]: BufferDataType.UINT32,
        [PassView.STAGE]: BufferDataType.UINT32,
        [PassView.PHASE]: BufferDataType.UINT32,
        [PassView.PRIMITIVE]: BufferDataType.UINT32,
        [PassView.BATCHING_SCHEME]: BufferDataType.UINT32,
        [PassView.DYNAMIC_STATE]: BufferDataType.UINT32,
        [PassView.HASH]: BufferDataType.UINT32,
        [PassView.COUNT]: BufferDataType.NEVER
      };
      const PassViewDataMembers = {
        [PassView.PRIORITY]: PassView.STAGE - PassView.PRIORITY,
        [PassView.STAGE]: PassView.PHASE - PassView.STAGE,
        [PassView.PHASE]: PassView.PRIMITIVE - PassView.PHASE,
        [PassView.PRIMITIVE]: PassView.BATCHING_SCHEME - PassView.PRIMITIVE,
        [PassView.BATCHING_SCHEME]: PassView.DYNAMIC_STATE - PassView.BATCHING_SCHEME,
        [PassView.DYNAMIC_STATE]: PassView.HASH - PassView.DYNAMIC_STATE,
        [PassView.HASH]: PassView.COUNT - PassView.HASH,
        [PassView.COUNT]: 1
      };
      const PassPool = new BufferPool(PoolType.PASS, PassViewDataType, PassViewDataMembers, PassView);
      let AABBView;
      (function (AABBView) {
        AABBView[AABBView["CENTER"] = 0] = "CENTER";
        AABBView[AABBView["HALFEXTENTS"] = 3] = "HALFEXTENTS";
        AABBView[AABBView["COUNT"] = 6] = "COUNT";
      })(AABBView || (AABBView = {}));
      const AABBViewDataType = {
        [AABBView.CENTER]: BufferDataType.FLOAT32,
        [AABBView.HALFEXTENTS]: BufferDataType.FLOAT32,
        [AABBView.COUNT]: BufferDataType.NEVER
      };
      const AABBViewDataMembers = {
        [AABBView.CENTER]: AABBView.HALFEXTENTS - AABBView.CENTER,
        [AABBView.HALFEXTENTS]: AABBView.COUNT - AABBView.HALFEXTENTS,
        [AABBView.COUNT]: 1
      };
      const AABBPool = new BufferPool(PoolType.AABB, AABBViewDataType, AABBViewDataMembers, AABBView);

      const renderSceneProto = jsb.RenderScene.prototype;
      Object.defineProperty(renderSceneProto, 'mainLight', {
        enumerable: true,
        configurable: true,
        get() {
          return this.getMainLight();
        }
      });
      const RenderScene = jsb.RenderScene;

      Enum({
        Low_256x256: 256,
        Medium_512x512: 512,
        High_1024x1024: 1024,
        Ultra_2048x2048: 2048
      });
      const ShadowType = Enum({
        Planar: 0,
        ShadowMap: 1
      });
      Enum({
        HARD: 0,
        SOFT: 1,
        SOFT_2X: 2,
        SOFT_4X: 3
      });
      const CSMLevel = Enum({
        LEVEL_1: 1,
        LEVEL_2: 2,
        LEVEL_3: 3,
        LEVEL_4: 4
      });
      Enum({
        NONE: 1,
        RemoveDuplicates: 2,
        DisableRotationFix: 3
      });
      const SHADOW_TYPE_NONE = ShadowType.ShadowMap + 1;
      class Shadows {
        constructor() {
          this.fixedSphere = new Sphere(0.0, 0.0, 0.0, 0.01);
          this.maxReceived = 4;
          this._matLight = new Mat4();
          this._material = null;
          this._instancingMaterial = null;
          this._enabled = false;
          this._type = SHADOW_TYPE_NONE;
          this._distance = 0;
          this._normal = new Vec3(0, 1, 0);
          this._shadowColor = new Color$1(0, 0, 0, 76);
          this._size = new Vec2(1024, 1024);
          this._shadowMapDirty = false;
        }
        get enabled() {
          return this._enabled;
        }
        set enabled(val) {
          this._enabled = val;
          this.activate();
        }
        get type() {
          return this._type;
        }
        set type(val) {
          this._type = this.enabled ? val : SHADOW_TYPE_NONE;
          this.activate();
        }
        get normal() {
          return this._normal;
        }
        set normal(val) {
          Vec3.copy(this._normal, val);
        }
        get distance() {
          return this._distance;
        }
        set distance(val) {
          this._distance = val;
        }
        get shadowColor() {
          return this._shadowColor;
        }
        set shadowColor(color) {
          this._shadowColor = color;
        }
        get size() {
          return this._size;
        }
        set size(val) {
          this._size.set(val);
        }
        get shadowMapDirty() {
          return this._shadowMapDirty;
        }
        set shadowMapDirty(val) {
          this._shadowMapDirty = val;
        }
        get matLight() {
          return this._matLight;
        }
        get material() {
          return this._material;
        }
        get instancingMaterial() {
          return this._instancingMaterial;
        }
        getPlanarShader(patches) {
          if (!this._material) {
            this._material = new Material();
            this._material.initialize({
              effectName: 'pipeline/planar-shadow'
            });
          }
          const passes = this._material.passes;
          {
            assert(passes.length > 0, 'passes should not be empty!');
          }
          return passes.length > 0 ? passes[0].getShaderVariant(patches) : null;
        }
        initialize(shadowsInfo) {
          this._enabled = shadowsInfo.enabled;
          this._type = this.enabled ? shadowsInfo.type : SHADOW_TYPE_NONE;
          this.normal = shadowsInfo.planeDirection;
          this.distance = shadowsInfo.planeHeight;
          this.shadowColor = shadowsInfo.shadowColor;
          this.maxReceived = shadowsInfo.maxReceived;
          if (shadowsInfo.shadowMapSize !== this._size.x) {
            this.size.set(shadowsInfo.shadowMapSize, shadowsInfo.shadowMapSize);
            this._shadowMapDirty = true;
          }
        }
        activate() {
          if (this._enabled) {
            if (this.type === ShadowType.Planar) {
              this._updatePlanarInfo();
            } else {
              const root = legacyCC.director.root;
              const pipeline = root.pipeline;
              pipeline.macros.CC_SHADOW_TYPE = 2;
              root.onGlobalPipelineStateChanged();
            }
          } else {
            const root = legacyCC.director.root;
            const pipeline = root.pipeline;
            pipeline.macros.CC_SHADOW_TYPE = 0;
            root.onGlobalPipelineStateChanged();
          }
        }
        _updatePlanarInfo() {
          if (!this._material) {
            this._material = new Material();
            this._material.initialize({
              effectName: 'pipeline/planar-shadow'
            });
          }
          const root = legacyCC.director.root;
          const pipeline = root.pipeline;
          pipeline.macros.CC_SHADOW_TYPE = 1;
          root.onGlobalPipelineStateChanged();
        }
        destroy() {
          if (this._material) {
            this._material.destroy();
          }
          if (this._instancingMaterial) {
            this._instancingMaterial.destroy();
          }
          this.fixedSphere.destroy();
        }
      }
      Shadows.MAX_FAR = 2000.0;
      Shadows.COEFFICIENT_OF_EXPANSION = 2.0 * Math.sqrt(3.0);
      legacyCC.Shadows = Shadows;

      removeProperty(RenderScene.prototype, 'RenderScene.prototype', [{
        name: 'raycastUI2DNode'
      }, {
        name: 'raycastUINode'
      }]);
      removeProperty(RenderScene.prototype, 'RenderScene.prototype', [{
        name: 'raycastAll',
        suggest: 'using intersect.rayModel in geometry'
      }, {
        name: 'raycastAllModels',
        suggest: 'using intersect.rayModel in geometry'
      }, {
        name: 'raycastSingleModel',
        suggest: 'using intersect.rayModel in geometry'
      }, {
        name: 'raycastAllCanvas',
        suggest: 'using intersect.rayAABB in geometry'
      }, {
        name: 'rayResultCanvas'
      }, {
        name: 'rayResultModels'
      }, {
        name: 'rayResultAll'
      }, {
        name: 'rayResultSingleModel'
      }]);
      removeProperty(Model.prototype, 'Model.prototype', [{
        name: 'isInstancingEnabled'
      }, {
        name: 'instancedAttributes'
      }]);
      const CameraVisFlags = {};
      removeProperty(CameraVisFlags, 'CameraVisFlags', [{
        name: 'GENERAL'
      }]);
      replaceProperty(CameraVisFlags, 'CameraVisFlags', [{
        name: 'PROFILER',
        newName: 'PROFILER',
        target: Layers.BitMask,
        targetName: 'PROFILER'
      }, {
        name: 'GIZMOS',
        newName: 'GIZMOS',
        target: Layers.BitMask,
        targetName: 'GIZMOS'
      }, {
        name: 'EDITOR',
        newName: 'EDITOR',
        target: Layers.BitMask,
        targetName: 'EDITOR'
      }, {
        name: 'UI',
        newName: 'UI',
        target: Layers.BitMask,
        targetName: 'UI_3D'
      }, {
        name: 'UI2D',
        newName: 'UI2D',
        target: Layers.BitMask,
        targetName: 'UI_2D'
      }]);
      legacyCC.CameraVisFlags = CameraVisFlags;
      const VisibilityFlags = {};
      removeProperty(VisibilityFlags, 'VisibilityFlags', [{
        name: 'GENERAL'
      }]);
      replaceProperty(VisibilityFlags, 'VisibilityFlags', [{
        name: 'ALWALS',
        newName: 'ALWALS',
        target: Layers.Enum,
        targetName: 'ALWALS'
      }, {
        name: 'PROFILER',
        newName: 'PROFILER',
        target: Layers.Enum,
        targetName: 'PROFILER'
      }, {
        name: 'GIZMOS',
        newName: 'GIZMOS',
        target: Layers.Enum,
        targetName: 'GIZMOS'
      }, {
        name: 'EDITOR',
        newName: 'EDITOR',
        target: Layers.Enum,
        targetName: 'EDITOR'
      }, {
        name: 'UI',
        newName: 'UI',
        target: Layers.Enum,
        targetName: 'UI_3D'
      }, {
        name: 'UI2D',
        newName: 'UI2D',
        target: Layers.Enum,
        targetName: 'UI_2D'
      }]);
      legacyCC.VisibilityFlags = VisibilityFlags;
      replaceProperty(Pass.prototype, 'Pass.prototype', [{
        name: 'getBindingTypeFromHandle',
        newName: 'getDescriptorTypeFromHandle'
      }]);
      removeProperty(Camera$1.prototype, 'Camera.prototype', [{
        name: 'getSplitFrustum'
      }, {
        name: 'setMatView'
      }, {
        name: 'setMatViewInv'
      }, {
        name: 'setMatProjInv'
      }, {
        name: 'setMatViewProjInv'
      }, {
        name: 'setMatProj'
      }, {
        name: 'setMatViewProj'
      }, {
        name: 'getMatViewInv'
      }]);
      removeProperty(Shadows.prototype, 'Shadows.prototype', [{
        name: 'aspect'
      }, {
        name: 'selfShadow'
      }, {
        name: 'linear'
      }, {
        name: 'packing'
      }, {
        name: 'autoAdapt'
      }, {
        name: 'fixedArea'
      }, {
        name: 'pcf'
      }, {
        name: 'bias'
      }, {
        name: 'normalBias'
      }, {
        name: 'near'
      }, {
        name: 'far'
      }, {
        name: 'shadowDistance'
      }, {
        name: 'invisibleOcclusionRange'
      }, {
        name: 'orthoSize'
      }, {
        name: 'saturation'
      }]);
      removeProperty(SpotLight.prototype, 'SpotLight.prototype', [{
        name: 'aspect'
      }]);
      replaceProperty(SubModel.prototype, 'SubModel.prototype', [{
        name: 'subMeshData',
        newName: 'subMesh'
      }]);
      removeProperty(SubModel.prototype, 'SubModel.prototype', [{
        name: 'getSubModel',
        suggest: 'Use `subModels[i]` instead'
      }, {
        name: 'subModelNum',
        suggest: 'Use `subModels.length` instead'
      }]);

      const addStage = config.addStage;

      var renderer = /*#__PURE__*/Object.freeze({
        __proto__: null,
        addStage: addStage,
        scene: index,
        createIA: createIA,
        programLib: programLib,
        getDeviceShaderVersion: getDeviceShaderVersion,
        get RenderQueue () { return RenderQueue; },
        get PassStage () { return PassStage; },
        genHandle: genHandle,
        getTypeFromHandle: getTypeFromHandle,
        getBindingFromHandle: getBindingFromHandle,
        getCountFromHandle: getCountFromHandle,
        getOffsetFromHandle: getOffsetFromHandle,
        customizeType: customizeType,
        type2reader: type2reader,
        type2writer: type2writer,
        type2validator: type2validator,
        getDefaultFromType: getDefaultFromType,
        getStringFromType: getStringFromType,
        overrideMacros: overrideMacros,
        get BatchingSchemes () { return BatchingSchemes; },
        Pass: Pass,
        nearestPOT: nearestPOT,
        TextureBufferPool: TextureBufferPool,
        MaterialInstance: MaterialInstance,
        PassInstance: PassInstance,
        get PoolType () { return PoolType; },
        NULL_HANDLE: NULL_HANDLE,
        get Render2dView () { return Render2dView; },
        Render2dPool: Render2dPool,
        get NodeView () { return NodeView; },
        NodePool: NodePool$1,
        get PassView () { return PassView; },
        PassPool: PassPool,
        get AABBView () { return AABBView; },
        AABBPool: AABBPool,
        RenderScene: RenderScene,
        CameraVisFlags: CameraVisFlags,
        VisibilityFlags: VisibilityFlags
      });
      exports('renderer', renderer);

      let LineCap;
      (function (LineCap) {
        LineCap[LineCap["BUTT"] = 0] = "BUTT";
        LineCap[LineCap["ROUND"] = 1] = "ROUND";
        LineCap[LineCap["SQUARE"] = 2] = "SQUARE";
      })(LineCap || (LineCap = {}));
      ccenum(LineCap);
      let LineJoin;
      (function (LineJoin) {
        LineJoin[LineJoin["BEVEL"] = 0] = "BEVEL";
        LineJoin[LineJoin["ROUND"] = 1] = "ROUND";
        LineJoin[LineJoin["MITER"] = 2] = "MITER";
      })(LineJoin || (LineJoin = {}));
      ccenum(LineJoin);
      let PointFlags;
      (function (PointFlags) {
        PointFlags[PointFlags["PT_CORNER"] = 1] = "PT_CORNER";
        PointFlags[PointFlags["PT_LEFT"] = 2] = "PT_LEFT";
        PointFlags[PointFlags["PT_BEVEL"] = 4] = "PT_BEVEL";
        PointFlags[PointFlags["PT_INNERBEVEL"] = 8] = "PT_INNERBEVEL";
      })(PointFlags || (PointFlags = {}));
      ccenum(PointFlags);

      const PI$1 = Math.PI;
      const min$1 = Math.min;
      const max$1 = Math.max;
      const cos$1 = Math.cos;
      const sin$1 = Math.sin;
      const abs = Math.abs;
      const sign = Math.sign;
      const KAPPA90 = 0.5522847493;
      function arc(ctx, cx, cy, r, startAngle, endAngle, counterclockwise) {
        counterclockwise = counterclockwise || false;
        let a = 0;
        let da = 0;
        let hda = 0;
        let kappa = 0;
        let dx = 0;
        let dy = 0;
        let x = 0;
        let y = 0;
        let tanx = 0;
        let tany = 0;
        let px = 0;
        let py = 0;
        let ptanx = 0;
        let ptany = 0;
        let i = 0;
        let ndivs = 0;
        da = endAngle - startAngle;
        if (counterclockwise) {
          if (abs(da) >= PI$1 * 2) {
            da = PI$1 * 2;
          } else {
            while (da < 0) {
              da += PI$1 * 2;
            }
          }
        } else if (abs(da) >= PI$1 * 2) {
          da = -PI$1 * 2;
        } else {
          while (da > 0) {
            da -= PI$1 * 2;
          }
        }
        ndivs = max$1(1, min$1(abs(da) / (PI$1 * 0.5) + 0.5, 5)) | 0;
        hda = da / ndivs / 2.0;
        kappa = abs(4.0 / 3.0 * (1 - cos$1(hda)) / sin$1(hda));
        if (!counterclockwise) {
          kappa = -kappa;
        }
        for (i = 0; i <= ndivs; i++) {
          a = startAngle + da * (i / ndivs);
          dx = cos$1(a);
          dy = sin$1(a);
          x = cx + dx * r;
          y = cy + dy * r;
          tanx = -dy * r * kappa;
          tany = dx * r * kappa;
          if (i === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.bezierCurveTo(px + ptanx, py + ptany, x - tanx, y - tany, x, y);
          }
          px = x;
          py = y;
          ptanx = tanx;
          ptany = tany;
        }
      }
      function ellipse(ctx, cx, cy, rx, ry) {
        ctx.moveTo(cx - rx, cy);
        ctx.bezierCurveTo(cx - rx, cy + ry * KAPPA90, cx - rx * KAPPA90, cy + ry, cx, cy + ry);
        ctx.bezierCurveTo(cx + rx * KAPPA90, cy + ry, cx + rx, cy + ry * KAPPA90, cx + rx, cy);
        ctx.bezierCurveTo(cx + rx, cy - ry * KAPPA90, cx + rx * KAPPA90, cy - ry, cx, cy - ry);
        ctx.bezierCurveTo(cx - rx * KAPPA90, cy - ry, cx - rx, cy - ry * KAPPA90, cx - rx, cy);
        ctx.close();
      }
      function roundRect(ctx, x, y, w, h, r) {
        if (r < 0.1) {
          ctx.rect(x, y, w, h);
        } else {
          const rx = min$1(r, abs(w) * 0.5) * sign(w);
          const ry = min$1(r, abs(h) * 0.5) * sign(h);
          ctx.moveTo(x, y + ry);
          ctx.lineTo(x, y + h - ry);
          ctx.bezierCurveTo(x, y + h - ry * (1 - KAPPA90), x + rx * (1 - KAPPA90), y + h, x + rx, y + h);
          ctx.lineTo(x + w - rx, y + h);
          ctx.bezierCurveTo(x + w - rx * (1 - KAPPA90), y + h, x + w, y + h - ry * (1 - KAPPA90), x + w, y + h - ry);
          ctx.lineTo(x + w, y + ry);
          ctx.bezierCurveTo(x + w, y + ry * (1 - KAPPA90), x + w - rx * (1 - KAPPA90), y, x + w - rx, y);
          ctx.lineTo(x + rx, y);
          ctx.bezierCurveTo(x + rx * (1 - KAPPA90), y, x, y + ry * (1 - KAPPA90), x, y + ry);
          ctx.close();
        }
      }
      function tesselateBezier(ctx, x1, y1, x2, y2, x3, y3, x4, y4, level, type) {
        let x12 = 0;
        let y12 = 0;
        let x23 = 0;
        let y23 = 0;
        let x34 = 0;
        let y34 = 0;
        let x123 = 0;
        let y123 = 0;
        let x234 = 0;
        let y234 = 0;
        let x1234 = 0;
        let y1234 = 0;
        let dx = 0;
        let dy = 0;
        let d2 = 0;
        let d3 = 0;
        if (level > 10) {
          return;
        }
        x12 = (x1 + x2) * 0.5;
        y12 = (y1 + y2) * 0.5;
        x23 = (x2 + x3) * 0.5;
        y23 = (y2 + y3) * 0.5;
        x34 = (x3 + x4) * 0.5;
        y34 = (y3 + y4) * 0.5;
        x123 = (x12 + x23) * 0.5;
        y123 = (y12 + y23) * 0.5;
        dx = x4 - x1;
        dy = y4 - y1;
        d2 = abs((x2 - x4) * dy - (y2 - y4) * dx);
        d3 = abs((x3 - x4) * dy - (y3 - y4) * dx);
        if ((d2 + d3) * (d2 + d3) < ctx.tessTol * (dx * dx + dy * dy)) {
          ctx.addPoint(x4, y4, type === 0 ? type | PointFlags.PT_BEVEL : type);
          return;
        }
        x234 = (x23 + x34) * 0.5;
        y234 = (y23 + y34) * 0.5;
        x1234 = (x123 + x234) * 0.5;
        y1234 = (y123 + y234) * 0.5;
        tesselateBezier(ctx, x1, y1, x12, y12, x123, y123, x1234, y1234, level + 1, 0);
        tesselateBezier(ctx, x1234, y1234, x234, y234, x34, y34, x4, y4, level + 1, type);
      }

      class Point$1 extends Vec2 {
        constructor(...args) {
          super(...args);
          this.dx = 0;
          this.dy = 0;
          this.dmx = 0;
          this.dmy = 0;
          this.flags = 0;
          this.len = 0;
        }
        reset() {
          this.dx = 0;
          this.dy = 0;
          this.dmx = 0;
          this.dmy = 0;
          this.flags = 0;
          this.len = 0;
        }
      }
      class Path {
        constructor() {
          this.closed = false;
          this.bevel = 0;
          this.complex = true;
          this.points = [];
        }
        reset() {
          this.closed = false;
          this.bevel = 0;
          this.complex = true;
          this.points.length = 0;
        }
      }
      class Impl {
        constructor(comp) {
          this.dataOffset = 0;
          this.updatePathOffset = false;
          this.pathLength = 0;
          this.pathOffset = 0;
          this.paths = [];
          this.tessTol = 0.25;
          this.distTol = 0.01;
          this.fillColor = Color$1.WHITE.clone();
          this.lineCap = LineCap.BUTT;
          this.strokeColor = Color$1.BLACK.clone();
          this.lineJoin = LineJoin.MITER;
          this.lineWidth = 0;
          this.pointsOffset = 0;
          this._commandX = 0;
          this._commandY = 0;
          this._points = [];
          this._renderDataList = [];
          this._curPath = null;
          this._comp = void 0;
          this._comp = comp;
        }
        moveTo(x, y) {
          if (this.updatePathOffset) {
            this.pathOffset = this.pathLength;
            this.updatePathOffset = false;
          }
          this._addPath();
          this.addPoint(x, y, PointFlags.PT_CORNER);
          this._commandX = x;
          this._commandY = y;
        }
        lineTo(x, y) {
          this.addPoint(x, y, PointFlags.PT_CORNER);
          this._commandX = x;
          this._commandY = y;
        }
        bezierCurveTo(c1x, c1y, c2x, c2y, x, y) {
          const path = this._curPath;
          const last = path.points[path.points.length - 1];
          if (!last) {
            return;
          }
          if (last.x === c1x && last.y === c1y && c2x === x && c2y === y) {
            this.lineTo(x, y);
            return;
          }
          tesselateBezier(this, last.x, last.y, c1x, c1y, c2x, c2y, x, y, 0, PointFlags.PT_CORNER);
          this._commandX = x;
          this._commandY = y;
        }
        quadraticCurveTo(cx, cy, x, y) {
          const x0 = this._commandX;
          const y0 = this._commandY;
          this.bezierCurveTo(x0 + 2.0 / 3.0 * (cx - x0), y0 + 2.0 / 3.0 * (cy - y0), x + 2.0 / 3.0 * (cx - x), y + 2.0 / 3.0 * (cy - y), x, y);
        }
        arc(cx, cy, r, startAngle, endAngle, counterclockwise) {
          arc(this, cx, cy, r, startAngle, endAngle, counterclockwise);
        }
        ellipse(cx, cy, rx, ry) {
          ellipse(this, cx, cy, rx, ry);
          this._curPath.complex = false;
        }
        circle(cx, cy, r) {
          ellipse(this, cx, cy, r, r);
          this._curPath.complex = false;
        }
        rect(x, y, w, h) {
          this.moveTo(x, y);
          this.lineTo(x + w, y);
          this.lineTo(x + w, y + h);
          this.lineTo(x, y + h);
          this.close();
          this._curPath.complex = false;
        }
        roundRect(x, y, w, h, r) {
          roundRect(this, x, y, w, h, r);
          this._curPath.complex = false;
        }
        clear() {
          this.pathLength = 0;
          this.pathOffset = 0;
          this.pointsOffset = 0;
          this.dataOffset = 0;
          this._curPath = null;
          this.paths.length = 0;
          this._points.length = 0;
          const dataList = this._renderDataList;
          for (let i = 0, l = dataList.length; i < l; i++) {
            const data = dataList[i];
            if (!data) {
              continue;
            }
            MeshRenderData.remove(data);
            data.removeRenderDrawInfo(this._comp);
          }
          this._renderDataList.length = 0;
        }
        close() {
          this._curPath.closed = true;
        }
        requestRenderData() {
          const renderData = MeshRenderData.add();
          this._renderDataList.push(renderData);
          {
            renderData.initRenderDrawInfo(this._comp, RenderDrawInfoType.MODEL);
            renderData.material = this._comp.getMaterialInstance(0);
            this._comp.setRenderData(renderData);
          }
          return renderData;
        }
        getRenderDataList() {
          if (this._renderDataList.length === 0) {
            this.requestRenderData();
          }
          return this._renderDataList;
        }
        addPoint(x, y, flags) {
          const path = this._curPath;
          if (!path) {
            return;
          }
          const points = this._points;
          const pathPoints = path.points;
          const offset = this.pointsOffset++;
          let pt = points[offset];
          if (!pt) {
            pt = new Point$1(x, y);
            points.push(pt);
          } else {
            pt.x = x;
            pt.y = y;
          }
          pt.flags = flags;
          pathPoints.push(pt);
        }
        _addPath() {
          const offset = this.pathLength;
          let path = this.paths[offset];
          if (!path) {
            path = new Path();
            this.paths.push(path);
          } else {
            path.reset();
          }
          this.pathLength++;
          this._curPath = path;
          return path;
        }
      }

      var _dec$E, _dec2$y, _dec3$r, _dec4$h, _class$D, _class2$z, _initializer$w, _initializer2$r, _initializer3$m, _initializer4$j, _initializer5$f, _initializer6$c, _class3$l;
      const attributes = vfmtPosColor.concat([new Attribute('a_dist', Format.R32F)]);
      const componentPerVertex = getComponentPerVertex(attributes);
      const stride = getAttributeStride(attributes);
      let Graphics = (_dec$E = ccclass$3('cc.Graphics'), _dec2$y = executionOrder(110), _dec3$r = type$2(LineJoin), _dec4$h = type$2(LineCap), _dec$E(_class$D = _dec2$y(_class$D = (_class2$z = (_class3$l = class Graphics extends UIRenderer {
        get lineWidth() {
          return this._lineWidth;
        }
        set lineWidth(value) {
          this._lineWidth = value;
          if (!this.impl) {
            return;
          }
          this.impl.lineWidth = value;
        }
        get lineJoin() {
          return this._lineJoin;
        }
        set lineJoin(value) {
          this._lineJoin = value;
          if (!this.impl) {
            return;
          }
          this.impl.lineJoin = value;
        }
        get lineCap() {
          return this._lineCap;
        }
        set lineCap(value) {
          this._lineCap = value;
          if (!this.impl) {
            return;
          }
          this.impl.lineCap = value;
        }
        get strokeColor() {
          return this._strokeColor;
        }
        set strokeColor(value) {
          if (!this.impl) {
            return;
          }
          this._strokeColor.set(value);
          this.impl.strokeColor = this._strokeColor;
        }
        get fillColor() {
          return this._fillColor;
        }
        set fillColor(value) {
          if (!this.impl) {
            return;
          }
          this._fillColor.set(value);
          this.impl.fillColor = this._fillColor;
        }
        get miterLimit() {
          return this._miterLimit;
        }
        set miterLimit(value) {
          this._miterLimit = value;
        }
        get color() {
          return this._color;
        }
        set color(value) {
          if (this._color === value) {
            return;
          }
          this._color.set(value);
        }
        get graphicsNativeProxy() {
          return this._graphicsNativeProxy;
        }
        constructor() {
          super();
          this.impl = null;
          this.model = null;
          this._lineWidth = _initializer$w && _initializer$w();
          this._strokeColor = _initializer2$r && _initializer2$r();
          this._lineJoin = _initializer3$m && _initializer3$m();
          this._lineCap = _initializer4$j && _initializer4$j();
          this._fillColor = _initializer5$f && _initializer5$f();
          this._miterLimit = _initializer6$c && _initializer6$c();
          this._isDrawing = false;
          this._isNeedUploadData = true;
          this._graphicsUseSubMeshes = [];
          this._instanceMaterialType = InstanceMaterialType.ADD_COLOR;
          this.impl = new Impl(this);
          {
            this._graphicsNativeProxy = new NativeUIModelProxy();
          }
        }
        onRestore() {
          if (!this.impl) {
            this._flushAssembler();
          }
        }
        onLoad() {
          super.onLoad();
          {
            this._graphicsNativeProxy.initModel(this.node);
            this.model = this._graphicsNativeProxy.getModel();
          }
          this._flushAssembler();
        }
        onEnable() {
          super.onEnable();
          this._updateMtlForGraphics();
        }
        onDestroy() {
          this._sceneGetter = null;
          {
            this._graphicsNativeProxy.destroy();
            this.model = null;
          }
          if (this.impl) {
            this._isDrawing = false;
            this.impl.clear();
            this.impl = null;
          }
          super.onDestroy();
        }
        moveTo(x, y) {
          if (!this.impl) {
            return;
          }
          this.impl.moveTo(x, y);
        }
        lineTo(x, y) {
          if (!this.impl) {
            return;
          }
          this.impl.lineTo(x, y);
        }
        bezierCurveTo(c1x, c1y, c2x, c2y, x, y) {
          if (!this.impl) {
            return;
          }
          this.impl.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);
        }
        quadraticCurveTo(cx, cy, x, y) {
          if (!this.impl) {
            return;
          }
          this.impl.quadraticCurveTo(cx, cy, x, y);
        }
        arc(cx, cy, r, startAngle, endAngle, counterclockwise) {
          if (!this.impl) {
            return;
          }
          this.impl.arc(cx, cy, r, startAngle, endAngle, counterclockwise);
        }
        ellipse(cx, cy, rx, ry) {
          if (!this.impl) {
            return;
          }
          this.impl.ellipse(cx, cy, rx, ry);
        }
        circle(cx, cy, r) {
          if (!this.impl) {
            return;
          }
          this.impl.circle(cx, cy, r);
        }
        rect(x, y, w, h) {
          if (!this.impl) {
            return;
          }
          this.impl.rect(x, y, w, h);
        }
        roundRect(x, y, w, h, r) {
          if (!this.impl) {
            return;
          }
          this.impl.roundRect(x, y, w, h, r);
        }
        fillRect(x, y, w, h) {
          this.rect(x, y, w, h);
          this.fill();
        }
        clear() {
          if (!this.impl) {
            return;
          }
          this.impl.clear();
          this._isDrawing = false;
          {
            this._graphicsNativeProxy.clear();
          }
          this.markForUpdateRenderData();
        }
        close() {
          if (!this.impl) {
            return;
          }
          this.impl.close();
        }
        stroke() {
          if (!this._assembler) {
            this._flushAssembler();
          }
          this._isDrawing = true;
          this._isNeedUploadData = true;
          this._assembler.stroke(this);
        }
        fill() {
          if (!this._assembler) {
            this._flushAssembler();
          }
          this._isDrawing = true;
          this._isNeedUploadData = true;
          this._assembler.fill(this);
        }
        _updateMtlForGraphics() {
          let mat;
          if (this._customMaterial) {
            mat = this.getMaterialInstance(0);
          } else {
            mat = builtinResMgr.get('ui-graphics-material');
            this.setSharedMaterial(mat, 0);
            mat = this.getMaterialInstance(0);
            mat.recompileShaders({
              USE_LOCAL: true
            });
          }
        }
        activeSubModel(idx) {
          if (!this.model) {
            warnID(4500, this.node.name);
            return;
          }
          if (this.model.subModels.length <= idx) {
            const gfxDevice = deviceManager.gfxDevice;
            const vertexBuffer = gfxDevice.createBuffer(new BufferInfo(BufferUsageBit.VERTEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, 65535 * stride, stride));
            const indexBuffer = gfxDevice.createBuffer(new BufferInfo(BufferUsageBit.INDEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, 65535 * Uint16Array.BYTES_PER_ELEMENT * 2, Uint16Array.BYTES_PER_ELEMENT));
            const renderMesh = new RenderingSubMesh([vertexBuffer], attributes, PrimitiveMode.TRIANGLE_LIST, indexBuffer);
            renderMesh.subMeshIdx = 0;
            this.model.initSubModel(idx, renderMesh, this.getMaterialInstance(0));
            this._graphicsUseSubMeshes.push(renderMesh);
          }
        }
        _uploadData() {
          const impl = this.impl;
          if (!impl) {
            return;
          }
          const renderDataList = impl && impl.getRenderDataList();
          if (renderDataList.length <= 0 || !this.model) {
            return;
          }
          const subModelList = this.model.subModels;
          for (let i = 0; i < renderDataList.length; i++) {
            const renderData = renderDataList[i];
            const ia = subModelList[i].inputAssembler;
            if (renderData.lastFilledVertex === renderData.vertexStart) {
              continue;
            }
            const vb = new Float32Array(renderData.vData.buffer, 0, renderData.vertexStart * componentPerVertex);
            ia.vertexBuffers[0].update(vb);
            ia.vertexCount = renderData.vertexStart;
            const ib = new Uint16Array(renderData.iData.buffer, 0, renderData.indexStart);
            ia.indexBuffer.update(ib);
            ia.indexCount = renderData.indexStart;
            renderData.lastFilledVertex = renderData.vertexStart;
            renderData.lastFilledIndex = renderData.indexStart;
          }
          this._isNeedUploadData = false;
        }
        _render(render) {
          if (this._isNeedUploadData) {
            if (this.impl) {
              const renderDataList = this.impl.getRenderDataList();
              const len = this.model.subModels.length;
              if (renderDataList.length > len) {
                for (let i = len; i < renderDataList.length; i++) {
                  this.activeSubModel(i);
                }
              }
            }
            this._uploadData();
          }
          render.commitModel(this, this.model, this.getMaterialInstance(0));
        }
        _flushAssembler() {
          const assembler = Graphics.Assembler.getAssembler(this);
          if (this._assembler !== assembler) {
            this._assembler = assembler;
          }
        }
        _canRender() {
          if (!super._canRender()) {
            return false;
          }
          {
            return this._isDrawing;
          }
        }
        updateRenderer() {
          super.updateRenderer();
          {
            if (this._isNeedUploadData) {
              if (this.impl) {
                const renderDataList = this.impl.getRenderDataList();
                for (let i = 0; i < renderDataList.length; i++) {
                  renderDataList[i].setRenderDrawInfoAttributes();
                }
                this._graphicsNativeProxy.activeSubModels();
              }
              this._graphicsNativeProxy.uploadData();
              this._isNeedUploadData = false;
            }
          }
        }
        createRenderEntity() {
          return new RenderEntity(RenderEntityType.DYNAMIC);
        }
      }, _class3$l.LineJoin = LineJoin, _class3$l.LineCap = LineCap, _class3$l), (_applyDecoratedDescriptor(_class2$z.prototype, "lineJoin", [_dec3$r], Object.getOwnPropertyDescriptor(_class2$z.prototype, "lineJoin"), _class2$z.prototype), _applyDecoratedDescriptor(_class2$z.prototype, "lineCap", [_dec4$h], Object.getOwnPropertyDescriptor(_class2$z.prototype, "lineCap"), _class2$z.prototype), _applyDecoratedDescriptor(_class2$z.prototype, "color", [override], Object.getOwnPropertyDescriptor(_class2$z.prototype, "color"), _class2$z.prototype), _initializer$w = applyDecoratedInitializer(_class2$z.prototype, "_lineWidth", [serializable$3], function () {
        return 1;
      }), _initializer2$r = applyDecoratedInitializer(_class2$z.prototype, "_strokeColor", [serializable$3], function () {
        return Color$1.BLACK.clone();
      }), _initializer3$m = applyDecoratedInitializer(_class2$z.prototype, "_lineJoin", [serializable$3], function () {
        return LineJoin.MITER;
      }), _initializer4$j = applyDecoratedInitializer(_class2$z.prototype, "_lineCap", [serializable$3], function () {
        return LineCap.BUTT;
      }), _initializer5$f = applyDecoratedInitializer(_class2$z.prototype, "_fillColor", [serializable$3], function () {
        return Color$1.WHITE.clone();
      }), _initializer6$c = applyDecoratedInitializer(_class2$z.prototype, "_miterLimit", [serializable$3], function () {
        return 10;
      })), _class2$z)) || _class$D) || _class$D); exports({ Graphics: Graphics, GraphicsComponent: Graphics });
      legacyCC.Graphics = Graphics;

      var _dec$D, _dec2$x, _dec3$q, _dec4$g, _dec5$f, _dec6$9, _dec7$7, _class$C, _class2$y, _initializer$v, _initializer2$q, _initializer3$l, _initializer4$i, _initializer5$e, _initializer6$b, _initializer7$9, _initializer8$9, _initializer9$9, _initializer10$9, _class3$k;
      let SpriteType$1;
      (function (SpriteType) {
        SpriteType[SpriteType["SIMPLE"] = 0] = "SIMPLE";
        SpriteType[SpriteType["SLICED"] = 1] = "SLICED";
        SpriteType[SpriteType["TILED"] = 2] = "TILED";
        SpriteType[SpriteType["FILLED"] = 3] = "FILLED";
      })(SpriteType$1 || (SpriteType$1 = {}));
      ccenum(SpriteType$1);
      var FillType$2;
      (function (FillType) {
        FillType[FillType["HORIZONTAL"] = 0] = "HORIZONTAL";
        FillType[FillType["VERTICAL"] = 1] = "VERTICAL";
        FillType[FillType["RADIAL"] = 2] = "RADIAL";
      })(FillType$2 || (FillType$2 = {}));
      ccenum(FillType$2);
      var SizeMode$1;
      (function (SizeMode) {
        SizeMode[SizeMode["CUSTOM"] = 0] = "CUSTOM";
        SizeMode[SizeMode["TRIMMED"] = 1] = "TRIMMED";
        SizeMode[SizeMode["RAW"] = 2] = "RAW";
      })(SizeMode$1 || (SizeMode$1 = {}));
      ccenum(SizeMode$1);
      var EventType$5;
      (function (EventType) {
        EventType["SPRITE_FRAME_CHANGED"] = "spriteframe-changed";
      })(EventType$5 || (EventType$5 = {}));
      let Sprite = (_dec$D = ccclass$3('cc.Sprite'), _dec2$x = executionOrder(110), _dec3$q = type$2(SpriteAtlas), _dec4$g = type$2(SpriteFrame), _dec5$f = type$2(SpriteType$1), _dec6$9 = type$2(FillType$2), _dec7$7 = type$2(SizeMode$1), _dec$D(_class$C = _dec2$x(_class$C = (_class2$y = (_class3$k = class Sprite extends UIRenderer {
        constructor(...args) {
          super(...args);
          this._spriteFrame = _initializer$v && _initializer$v();
          this._type = _initializer2$q && _initializer2$q();
          this._fillType = _initializer3$l && _initializer3$l();
          this._sizeMode = _initializer4$i && _initializer4$i();
          this._fillCenter = _initializer5$e && _initializer5$e();
          this._fillStart = _initializer6$b && _initializer6$b();
          this._fillRange = _initializer7$9 && _initializer7$9();
          this._isTrimmedMode = _initializer8$9 && _initializer8$9();
          this._useGrayscale = _initializer9$9 && _initializer9$9();
          this._atlas = _initializer10$9 && _initializer10$9();
        }
        get spriteAtlas() {
          return this._atlas;
        }
        set spriteAtlas(value) {
          if (this._atlas === value) {
            return;
          }
          this._atlas = value;
        }
        get spriteFrame() {
          return this._spriteFrame;
        }
        set spriteFrame(value) {
          if (this._spriteFrame === value) {
            return;
          }
          const lastSprite = this._spriteFrame;
          this._spriteFrame = value;
          this.markForUpdateRenderData();
          this._applySpriteFrame(lastSprite);
        }
        get type() {
          return this._type;
        }
        set type(value) {
          if (this._type !== value) {
            this._type = value;
            this._flushAssembler();
          }
        }
        get fillType() {
          return this._fillType;
        }
        set fillType(value) {
          if (this._fillType !== value) {
            if (value === FillType$2.RADIAL || this._fillType === FillType$2.RADIAL) {
              this.destroyRenderData();
            } else if (this.renderData) {
              this.markForUpdateRenderData(true);
            }
          }
          this._fillType = value;
          this._flushAssembler();
        }
        get fillCenter() {
          return this._fillCenter;
        }
        set fillCenter(value) {
          this._fillCenter.x = value.x;
          this._fillCenter.y = value.y;
          if (this._type === SpriteType$1.FILLED && this.renderData) {
            this.markForUpdateRenderData();
          }
        }
        get fillStart() {
          return this._fillStart;
        }
        set fillStart(value) {
          this._fillStart = clamp$1(value, 0, 1);
          if (this._type === SpriteType$1.FILLED && this.renderData) {
            this.markForUpdateRenderData();
            this._updateUVs();
          }
        }
        get fillRange() {
          return this._fillRange;
        }
        set fillRange(value) {
          this._fillRange = clamp$1(value, -1, 1);
          if (this._type === SpriteType$1.FILLED && this.renderData) {
            this.markForUpdateRenderData();
            this._updateUVs();
          }
        }
        get trim() {
          return this._isTrimmedMode;
        }
        set trim(value) {
          if (this._isTrimmedMode === value) {
            return;
          }
          this._isTrimmedMode = value;
          if (this._type === SpriteType$1.SIMPLE && this.renderData) {
            this.markForUpdateRenderData(true);
          }
        }
        get grayscale() {
          return this._useGrayscale;
        }
        set grayscale(value) {
          if (this._useGrayscale === value) {
            return;
          }
          this._useGrayscale = value;
          this.changeMaterialForDefine();
          this.updateMaterial();
        }
        get sizeMode() {
          return this._sizeMode;
        }
        set sizeMode(value) {
          if (this._sizeMode === value) {
            return;
          }
          this._sizeMode = value;
          if (value !== SizeMode$1.CUSTOM) {
            this._applySpriteSize();
          }
        }
        __preload() {
          this.changeMaterialForDefine();
          super.__preload();
        }
        onEnable() {
          super.onEnable();
          this._activateMaterial();
          const spriteFrame = this._spriteFrame;
          if (spriteFrame) {
            this._updateUVs();
            if (this._type === SpriteType$1.SLICED) {
              spriteFrame.on(SpriteFrame.EVENT_UV_UPDATED, this._updateUVs, this);
            }
          }
        }
        onDisable() {
          super.onDisable();
          if (this._spriteFrame && this._type === SpriteType$1.SLICED) {
            this._spriteFrame.off(SpriteFrame.EVENT_UV_UPDATED, this._updateUVs, this);
          }
        }
        onDestroy() {
          super.onDestroy();
        }
        changeSpriteFrameFromAtlas(name) {
          if (!this._atlas) {
            console.warn('SpriteAtlas is null.');
            return;
          }
          const sprite = this._atlas.getSpriteFrame(name);
          this.spriteFrame = sprite;
        }
        changeMaterialForDefine() {
          let texture;
          const lastInstanceMaterialType = this._instanceMaterialType;
          if (this._spriteFrame) {
            texture = this._spriteFrame.texture;
          }
          let value = false;
          if (texture instanceof TextureBase) {
            const format = texture.getPixelFormat();
            value = format === PixelFormat.RGBA_ETC1 || format === PixelFormat.RGB_A_PVRTC_4BPPV1 || format === PixelFormat.RGB_A_PVRTC_2BPPV1;
          }
          if (value && this.grayscale) {
            this._instanceMaterialType = InstanceMaterialType.USE_ALPHA_SEPARATED_AND_GRAY;
          } else if (value) {
            this._instanceMaterialType = InstanceMaterialType.USE_ALPHA_SEPARATED;
          } else if (this.grayscale) {
            this._instanceMaterialType = InstanceMaterialType.GRAYSCALE;
          } else {
            this._instanceMaterialType = InstanceMaterialType.ADD_COLOR_AND_TEXTURE;
          }
          if (lastInstanceMaterialType !== this._instanceMaterialType) {
            this.updateMaterial();
          }
        }
        _updateBuiltinMaterial() {
          let mat = super._updateBuiltinMaterial();
          if (this.spriteFrame && this.spriteFrame.texture instanceof RenderTexture) {
            const defines = {
              SAMPLE_FROM_RT: true,
              ...mat.passes[0].defines
            };
            const renderMat = new Material();
            renderMat.initialize({
              effectAsset: mat.effectAsset,
              defines
            });
            mat = renderMat;
          }
          return mat;
        }
        _render(render) {
          render.commitComp(this, this.renderData, this._spriteFrame, this._assembler, null);
        }
        _canRender() {
          if (!super._canRender()) {
            return false;
          }
          const spriteFrame = this._spriteFrame;
          if (!spriteFrame || !spriteFrame.texture) {
            return false;
          }
          return true;
        }
        _flushAssembler() {
          const assembler = Sprite.Assembler.getAssembler(this);
          if (this._assembler !== assembler) {
            this.destroyRenderData();
            this._assembler = assembler;
          }
          if (!this._renderData) {
            if (this._assembler && this._assembler.createData) {
              this._renderData = this._assembler.createData(this);
              this._renderData.material = this.getRenderMaterial(0);
              this.markForUpdateRenderData();
              if (this.spriteFrame) {
                this._assembler.updateUVs(this);
              }
              this._updateColor();
            }
          }
          if (this._spriteFrame) {
            if (this._type === SpriteType$1.SLICED) {
              this._spriteFrame.on(SpriteFrame.EVENT_UV_UPDATED, this._updateUVs, this);
            } else {
              this._spriteFrame.off(SpriteFrame.EVENT_UV_UPDATED, this._updateUVs, this);
            }
          }
        }
        _applySpriteSize() {
          if (this._spriteFrame) {
            {
              if (SizeMode$1.RAW === this._sizeMode) {
                const size = this._spriteFrame.originalSize;
                this.node._uiProps.uiTransformComp.setContentSize(size);
              } else if (SizeMode$1.TRIMMED === this._sizeMode) {
                const rect = this._spriteFrame.rect;
                this.node._uiProps.uiTransformComp.setContentSize(rect.width, rect.height);
              }
            }
          }
        }
        _resized() {
          {
            return;
          }
        }
        _activateMaterial() {
          const spriteFrame = this._spriteFrame;
          const material = this.getRenderMaterial(0);
          if (spriteFrame) {
            if (material) {
              this.markForUpdateRenderData();
            }
          }
          if (this.renderData) {
            this.renderData.material = material;
          }
        }
        _updateUVs() {
          if (this._assembler) {
            this._assembler.updateUVs(this);
          }
        }
        _applySpriteFrame(oldFrame) {
          const spriteFrame = this._spriteFrame;
          if (oldFrame && this._type === SpriteType$1.SLICED) {
            oldFrame.off(SpriteFrame.EVENT_UV_UPDATED, this._updateUVs, this);
          }
          let textureChanged = false;
          if (spriteFrame) {
            if (!oldFrame || oldFrame.texture !== spriteFrame.texture) {
              textureChanged = true;
            }
            if (textureChanged) {
              if (this.renderData) this.renderData.textureDirty = true;
              this.changeMaterialForDefine();
            }
            this._applySpriteSize();
            if (this._type === SpriteType$1.SLICED) {
              spriteFrame.on(SpriteFrame.EVENT_UV_UPDATED, this._updateUVs, this);
            }
          }
        }
      }, _class3$k.FillType = FillType$2, _class3$k.Type = SpriteType$1, _class3$k.SizeMode = SizeMode$1, _class3$k.EventType = EventType$5, _class3$k), (_applyDecoratedDescriptor(_class2$y.prototype, "spriteAtlas", [_dec3$q], Object.getOwnPropertyDescriptor(_class2$y.prototype, "spriteAtlas"), _class2$y.prototype), _applyDecoratedDescriptor(_class2$y.prototype, "spriteFrame", [_dec4$g], Object.getOwnPropertyDescriptor(_class2$y.prototype, "spriteFrame"), _class2$y.prototype), _applyDecoratedDescriptor(_class2$y.prototype, "type", [_dec5$f], Object.getOwnPropertyDescriptor(_class2$y.prototype, "type"), _class2$y.prototype), _applyDecoratedDescriptor(_class2$y.prototype, "fillType", [_dec6$9], Object.getOwnPropertyDescriptor(_class2$y.prototype, "fillType"), _class2$y.prototype), _applyDecoratedDescriptor(_class2$y.prototype, "sizeMode", [_dec7$7], Object.getOwnPropertyDescriptor(_class2$y.prototype, "sizeMode"), _class2$y.prototype), _initializer$v = applyDecoratedInitializer(_class2$y.prototype, "_spriteFrame", [serializable$3], function () {
        return null;
      }), _initializer2$q = applyDecoratedInitializer(_class2$y.prototype, "_type", [serializable$3], function () {
        return SpriteType$1.SIMPLE;
      }), _initializer3$l = applyDecoratedInitializer(_class2$y.prototype, "_fillType", [serializable$3], function () {
        return FillType$2.HORIZONTAL;
      }), _initializer4$i = applyDecoratedInitializer(_class2$y.prototype, "_sizeMode", [serializable$3], function () {
        return SizeMode$1.TRIMMED;
      }), _initializer5$e = applyDecoratedInitializer(_class2$y.prototype, "_fillCenter", [serializable$3], function () {
        return new Vec2(0, 0);
      }), _initializer6$b = applyDecoratedInitializer(_class2$y.prototype, "_fillStart", [serializable$3], function () {
        return 0;
      }), _initializer7$9 = applyDecoratedInitializer(_class2$y.prototype, "_fillRange", [serializable$3], function () {
        return 0;
      }), _initializer8$9 = applyDecoratedInitializer(_class2$y.prototype, "_isTrimmedMode", [serializable$3], function () {
        return true;
      }), _initializer9$9 = applyDecoratedInitializer(_class2$y.prototype, "_useGrayscale", [serializable$3], function () {
        return false;
      }), _initializer10$9 = applyDecoratedInitializer(_class2$y.prototype, "_atlas", [serializable$3], function () {
        return null;
      })), _class2$y)) || _class$C) || _class$C); exports({ Sprite: Sprite, SpriteComponent: Sprite });
      legacyCC.Sprite = Sprite;

      var _dec$C, _dec2$w, _dec3$p, _class$B, _class2$x, _initializer$u, _initializer2$p, _initializer3$k, _initializer4$h, _class3$j;
      const _worldMatrix = new Mat4();
      const _vec2_temp = new Vec2();
      const _mat4_temp = new Mat4();
      const _circlePoints = [];
      function _calculateCircle(center, radius, segments) {
        _circlePoints.length = 0;
        const anglePerStep = Math.PI * 2 / segments;
        for (let step = 0; step < segments; ++step) {
          _circlePoints.push(new Vec3(radius.x * Math.cos(anglePerStep * step) + center.x, radius.y * Math.sin(anglePerStep * step) + center.y, 0));
        }
        return _circlePoints;
      }
      let MaskType;
      (function (MaskType) {
        MaskType[MaskType["GRAPHICS_RECT"] = 0] = "GRAPHICS_RECT";
        MaskType[MaskType["GRAPHICS_ELLIPSE"] = 1] = "GRAPHICS_ELLIPSE";
        MaskType[MaskType["GRAPHICS_STENCIL"] = 2] = "GRAPHICS_STENCIL";
        MaskType[MaskType["SPRITE_STENCIL"] = 3] = "SPRITE_STENCIL";
      })(MaskType || (MaskType = {}));
      ccenum(MaskType);
      const SEGMENTS_MIN = 3;
      const SEGMENTS_MAX = 10000;
      let Mask = (_dec$C = ccclass$3('cc.Mask'), _dec2$w = executionOrder(110), _dec3$p = type$2(MaskType), _dec$C(_class$B = _dec2$w(_class$B = (_class2$x = (_class3$j = class Mask extends Component {
        constructor(...args) {
          super(...args);
          this._type = _initializer$u && _initializer$u();
          this._inverted = _initializer2$p && _initializer2$p();
          this._segments = _initializer3$k && _initializer3$k();
          this._alphaThreshold = _initializer4$h && _initializer4$h();
          this._sprite = null;
          this._graphics = null;
          this._stencilStage = Stage.DISABLED;
        }
        get type() {
          return this._type;
        }
        set type(value) {
          if (this._type === value) {
            return;
          }
          this._type = value;
          if (this._type !== MaskType.SPRITE_STENCIL) {
            if (this._sprite) {
              this.node.removeComponent(Sprite);
              this._sprite._destroyImmediate();
              this._sprite = null;
            }
            this._changeRenderType();
            this._updateGraphics();
            {
              this.subComp.renderEntity.setMaskMode(this._inverted ? MaskMode.MASK_INVERTED : MaskMode.MASK);
            }
          } else {
            if (this._graphics) {
              this._graphics.clear();
              this.node.removeComponent(Graphics);
              this._graphics._destroyImmediate();
              this._graphics = null;
            }
            this._changeRenderType();
            {
              this.subComp.renderEntity.setMaskMode(this._inverted ? MaskMode.MASK_INVERTED : MaskMode.MASK);
            }
          }
        }
        get inverted() {
          return this._inverted;
        }
        set inverted(value) {
          this._inverted = value;
          this.subComp.stencilStage = this.inverted ? Stage.ENTER_LEVEL_INVERTED : Stage.ENTER_LEVEL;
          {
            this.subComp.renderEntity.setMaskMode(this._inverted ? MaskMode.MASK_INVERTED : MaskMode.MASK);
          }
        }
        get segments() {
          return this._segments;
        }
        set segments(value) {
          if (this._segments === value) {
            return;
          }
          this._segments = clamp$1(value, SEGMENTS_MIN, SEGMENTS_MAX);
          this._updateGraphics();
        }
        get spriteFrame() {
          if (this._sprite) {
            return this._sprite.spriteFrame;
          }
          return null;
        }
        set spriteFrame(value) {
          if (this._sprite) {
            this._sprite.spriteFrame = value;
          } else {
            error('please change type to sprite_stencil first');
          }
        }
        get alphaThreshold() {
          return this._alphaThreshold;
        }
        set alphaThreshold(value) {
          if (this._alphaThreshold === value) {
            return;
          }
          this._alphaThreshold = value;
          if (this.type === MaskType.SPRITE_STENCIL && this._sprite) {
            const mat = this._sprite.getMaterialInstance(0);
            mat.setProperty('alphaThreshold', this._alphaThreshold);
          }
        }
        get subComp() {
          return this._graphics || this._sprite;
        }
        onLoad() {
          this._changeRenderType();
          {
            if (this.subComp) {
              this.subComp.renderEntity.setMaskMode(this._inverted ? MaskMode.MASK_INVERTED : MaskMode.MASK);
            }
          }
        }
        onEnable() {
          this._changeRenderType();
          this._updateGraphics();
          this._enableRender();
          this.node.on(NodeEventType.ANCHOR_CHANGED, this._nodeStateChange, this);
          this.node.on(NodeEventType.SIZE_CHANGED, this._nodeStateChange, this);
        }
        onRestore() {
          this._changeRenderType();
          this._updateGraphics();
        }
        onDisable() {
          this._disableRender();
          this.node.off(NodeEventType.ANCHOR_CHANGED, this._nodeStateChange, this);
          this.node.off(NodeEventType.SIZE_CHANGED, this._nodeStateChange, this);
        }
        onDestroy() {
          this._removeMaskNode();
        }
        isHit(worldPt) {
          const uiTrans = this.node._uiProps.uiTransformComp;
          const size = uiTrans.contentSize;
          const w = size.width;
          const h = size.height;
          const testPt = _vec2_temp;
          this.node.getWorldMatrix(_worldMatrix);
          Mat4.invert(_mat4_temp, _worldMatrix);
          Vec2.transformMat4(testPt, worldPt, _mat4_temp);
          const ap = uiTrans.anchorPoint;
          testPt.x += ap.x * w;
          testPt.y += ap.y * h;
          let result = false;
          if (this.type === MaskType.GRAPHICS_RECT || this.type === MaskType.GRAPHICS_STENCIL || this.type === MaskType.SPRITE_STENCIL) {
            result = testPt.x >= 0 && testPt.y >= 0 && testPt.x <= w && testPt.y <= h;
          } else if (this.type === MaskType.GRAPHICS_ELLIPSE) {
            const rx = w / 2;
            const ry = h / 2;
            const px = testPt.x - 0.5 * w;
            const py = testPt.y - 0.5 * h;
            result = px * px / (rx * rx) + py * py / (ry * ry) < 1;
          }
          if (this._inverted) {
            result = !result;
          }
          return result;
        }
        _nodeStateChange(type) {
          this._updateGraphics();
        }
        _changeRenderType() {
          const isGraphics = this._type !== MaskType.SPRITE_STENCIL;
          if (isGraphics) {
            this._createGraphics();
          } else {
            this._createSprite();
          }
        }
        _createSprite() {
          if (!this._sprite) {
            let sprite = this._sprite = this.node.getComponent(Sprite);
            if (!sprite) {
              const node = this.node;
              sprite = this._sprite = node.addComponent(Sprite);
            }
          }
          this._sprite.stencilStage = this.inverted ? Stage.ENTER_LEVEL_INVERTED : Stage.ENTER_LEVEL;
          this._sprite.updateMaterial();
        }
        _createGraphics() {
          if (!this._graphics) {
            let graphics = this._graphics = this.node.getComponent(Graphics);
            if (!graphics) {
              const node = this.node;
              graphics = this._graphics = node.addComponent(Graphics);
            }
            graphics.lineWidth = 1;
            const color = Color$1.WHITE.clone();
            color.a = 0;
            graphics.fillColor = color;
          }
          this._graphics.stencilStage = this.inverted ? Stage.ENTER_LEVEL_INVERTED : Stage.ENTER_LEVEL;
        }
        _updateGraphics() {
          if (!this._graphics || this._type !== MaskType.GRAPHICS_RECT && this._type !== MaskType.GRAPHICS_ELLIPSE) {
            return;
          }
          const uiTrans = this.node._uiProps.uiTransformComp;
          const graphics = this._graphics;
          graphics.clear();
          const size = uiTrans.contentSize;
          const width = size.width;
          const height = size.height;
          const ap = uiTrans.anchorPoint;
          const x = -width * ap.x;
          const y = -height * ap.y;
          if (this._type === MaskType.GRAPHICS_RECT) {
            graphics.rect(x, y, width, height);
          } else if (this._type === MaskType.GRAPHICS_ELLIPSE) {
            const center = new Vec3(x + width / 2, y + height / 2, 0);
            const radius = new Vec3(width / 2, height / 2, 0);
            const points = _calculateCircle(center, radius, this._segments);
            for (let i = 0; i < points.length; ++i) {
              const point = points[i];
              if (i === 0) {
                graphics.moveTo(point.x, point.y);
              } else {
                graphics.lineTo(point.x, point.y);
              }
            }
            graphics.close();
          }
          graphics.fill();
        }
        _enableRender() {
          if (this.subComp) {
            this.subComp.enabled = true;
          }
        }
        _disableRender() {
          if (this.subComp) {
            this.subComp.stencilStage = Stage.DISABLED;
            this.subComp.updateMaterial();
            if (this.node.activeInHierarchy) {
              this.subComp.enabled = false;
            }
          }
        }
        _removeMaskNode() {
          if (this._sprite) {
            this._sprite = null;
          }
          if (this._graphics) {
            this._graphics = null;
          }
        }
        get customMaterial() {
          warnID(9007);
          if (this.subComp) {
            return this.subComp.customMaterial;
          }
          return null;
        }
        set customMaterial(val) {
          warnID(9007);
          if (this.subComp) {
            this.subComp.customMaterial = val;
          }
        }
        get color() {
          warnID(9007);
          if (this.subComp) {
            return this.subComp.color;
          }
          return null;
        }
        set color(value) {
          warnID(9007);
          if (this.subComp && value) {
            this.subComp.color = value;
          }
        }
        markForUpdateRenderData(enable = true) {
          warnID(9007);
          if (this.subComp) {
            this.subComp.markForUpdateRenderData(enable);
          }
        }
        requestRenderData(any) {
          warnID(9007);
        }
        destroyRenderData() {
          warnID(9007);
        }
        updateRenderer() {
          warnID(9007);
          if (this.subComp) {
            this.subComp.updateRenderer();
          }
        }
        fillBuffers(render) {
          warnID(9007);
        }
        postUpdateAssembler(render) {
          warnID(9007);
        }
        setNodeDirty() {
          warnID(9007);
          if (this.subComp) {
            this.subComp.setNodeDirty();
          }
        }
        setTextureDirty() {
          warnID(9007);
          if (this.subComp) {
            this.subComp.setTextureDirty();
          }
        }
        get sharedMaterial() {
          warnID(9007);
          if (this.subComp) {
            return this.subComp.sharedMaterial;
          }
          return null;
        }
        get sharedMaterials() {
          warnID(9007);
          if (this.subComp) {
            return this.subComp.sharedMaterials;
          }
          return null;
        }
        set sharedMaterials(val) {
          warnID(9007);
          if (this.subComp && val) {
            this.subComp.sharedMaterials = val;
          }
        }
        get material() {
          warnID(9007);
          if (this.subComp) {
            return this.subComp.material;
          }
          return null;
        }
        set material(val) {
          warnID(9007);
          if (this.subComp) {
            this.subComp.material = val;
          }
        }
        get materials() {
          warnID(9007);
          if (this.subComp) {
            return this.subComp.materials;
          }
          return [null];
        }
        set materials(val) {
          warnID(9007);
          if (this.subComp) {
            this.subComp.materials = val;
          }
        }
        getMaterial(idx) {
          warnID(9007);
          if (this.subComp) {
            return this.subComp.getSharedMaterial(idx);
          }
          return null;
        }
        setMaterial(material, index) {
          warnID(9007);
          if (this.subComp) {
            this.subComp.setMaterial(material, index);
          }
        }
        getMaterialInstance(idx) {
          warnID(9007);
          if (this.subComp) {
            return this.subComp.getMaterialInstance(idx);
          }
          return null;
        }
        setMaterialInstance(matInst, index) {
          warnID(9007);
          if (this.subComp) {
            this.subComp.setMaterialInstance(matInst, index);
          }
        }
        getRenderMaterial(index) {
          warnID(9007);
          if (this.subComp) {
            return this.subComp.getRenderMaterial(index);
          }
          return null;
        }
      }, _class3$j.Type = MaskType, _class3$j), (_applyDecoratedDescriptor(_class2$x.prototype, "type", [_dec3$p], Object.getOwnPropertyDescriptor(_class2$x.prototype, "type"), _class2$x.prototype), _initializer$u = applyDecoratedInitializer(_class2$x.prototype, "_type", [serializable$3], function () {
        return MaskType.GRAPHICS_RECT;
      }), _initializer2$p = applyDecoratedInitializer(_class2$x.prototype, "_inverted", [serializable$3], function () {
        return false;
      }), _initializer3$k = applyDecoratedInitializer(_class2$x.prototype, "_segments", [serializable$3], function () {
        return 64;
      }), _initializer4$h = applyDecoratedInitializer(_class2$x.prototype, "_alphaThreshold", [serializable$3], function () {
        return 0.1;
      })), _class2$x)) || _class$B) || _class$B); exports({ Mask: Mask, MaskComponent: Mask });
      NodeEventProcessor._maskComp = Mask;
      legacyCC.Mask = Mask;

      const eventRegx = /^(click)(\s)*=|(param)(\s)*=/;
      const imageAttrReg = /(\s)*src(\s)*=|(\s)*height(\s)*=|(\s)*width(\s)*=|(\s)*align(\s)*=|(\s)*offset(\s)*=|(\s)*click(\s)*=|(\s)*param(\s)*=/;
      class HtmlTextParser {
        constructor() {
          this._specialSymbolArray = [];
          this._stack = [];
          this._resultObjectArray = [];
          this._specialSymbolArray.push([/&lt;/g, '<']);
          this._specialSymbolArray.push([/&gt;/g, '>']);
          this._specialSymbolArray.push([/&amp;/g, '&']);
          this._specialSymbolArray.push([/&quot;/g, '"']);
          this._specialSymbolArray.push([/&apos;/g, '\'']);
        }
        parse(htmlString) {
          this._resultObjectArray.length = 0;
          this._stack.length = 0;
          let startIndex = 0;
          const length = htmlString.length;
          while (startIndex < length) {
            let tagEndIndex = htmlString.indexOf('>', startIndex);
            let tagBeginIndex = -1;
            if (tagEndIndex >= 0) {
              tagBeginIndex = htmlString.lastIndexOf('<', tagEndIndex);
              const noTagBegin = tagBeginIndex < startIndex - 1;
              if (noTagBegin) {
                tagBeginIndex = htmlString.indexOf('<', tagEndIndex + 1);
                tagEndIndex = htmlString.indexOf('>', tagBeginIndex + 1);
              }
            }
            if (tagBeginIndex < 0) {
              this._stack.pop();
              this._processResult(htmlString.substring(startIndex));
              startIndex = length;
            } else {
              let newStr = htmlString.substring(startIndex, tagBeginIndex);
              const tagStr = htmlString.substring(tagBeginIndex + 1, tagEndIndex);
              if (tagStr === '') newStr = htmlString.substring(startIndex, tagEndIndex + 1);
              this._processResult(newStr);
              if (tagEndIndex === -1) {
                tagEndIndex = tagBeginIndex;
              } else if (htmlString.charAt(tagBeginIndex + 1) === '/') {
                this._stack.pop();
              } else {
                this._addToStack(tagStr);
              }
              startIndex = tagEndIndex + 1;
            }
          }
          return this._resultObjectArray;
        }
        _attributeToObject(attribute) {
          attribute = attribute.trim();
          const obj = {};
          let header = /^(color|size)(\s)*=/.exec(attribute);
          let tagName = '';
          let nextSpace = 0;
          let eventHanlderString = '';
          if (header) {
            tagName = header[0];
            attribute = attribute.substring(tagName.length).trim();
            if (attribute === '') {
              return obj;
            }
            nextSpace = attribute.indexOf(' ');
            switch (tagName[0]) {
              case 'c':
                if (nextSpace > -1) {
                  obj.color = attribute.substring(0, nextSpace).trim();
                } else {
                  obj.color = attribute;
                }
                break;
              case 's':
                obj.size = parseInt(attribute);
                break;
            }
            if (nextSpace > -1) {
              eventHanlderString = attribute.substring(nextSpace + 1).trim();
              obj.event = this._processEventHandler(eventHanlderString);
            }
            return obj;
          }
          header = /^(br(\s)*\/)/.exec(attribute);
          if (header && header[0].length > 0) {
            tagName = header[0].trim();
            if (tagName.startsWith('br') && tagName[tagName.length - 1] === '/') {
              obj.isNewLine = true;
              this._resultObjectArray.push({
                text: '',
                style: {
                  isNewLine: true
                }
              });
              return obj;
            }
          }
          header = /^(img(\s)*src(\s)*=[^>]+\/)/.exec(attribute);
          let remainingArgument = '';
          let rightQuot = -1;
          if (header && header[0].length > 0) {
            tagName = header[0].trim();
            if (tagName.startsWith('img') && tagName[tagName.length - 1] === '/') {
              header = imageAttrReg.exec(attribute);
              let tagValue;
              let isValidImageTag = false;
              while (header) {
                attribute = attribute.substring(attribute.indexOf(header[0]));
                tagName = attribute.substr(0, header[0].length);
                const originTagNameLength = tagName.length;
                tagName = tagName.replace(/[^a-zA-Z]/g, '').trim();
                tagName = tagName.toLowerCase();
                remainingArgument = attribute.substring(originTagNameLength).trim();
                if (tagName === 'src') {
                  rightQuot = this.getRightQuotationIndex(remainingArgument);
                } else {
                  rightQuot = -1;
                }
                nextSpace = remainingArgument.indexOf(' ', rightQuot + 1 >= remainingArgument.length ? -1 : rightQuot + 1);
                tagValue = nextSpace > -1 ? remainingArgument.substr(0, nextSpace) : remainingArgument;
                attribute = remainingArgument.substring(nextSpace).trim();
                if (tagValue.endsWith('/')) {
                  tagValue = tagValue.slice(0, -1);
                }
                if (tagName === 'src') {
                  switch (tagValue.charCodeAt(0)) {
                    case 34:
                    case 39:
                      isValidImageTag = true;
                      tagValue = tagValue.slice(1, -1);
                      break;
                  }
                  obj.isImage = true;
                  obj.src = tagValue;
                } else if (tagName === 'height') {
                  obj.imageHeight = parseInt(tagValue);
                } else if (tagName === 'width') {
                  obj.imageWidth = parseInt(tagValue);
                } else if (tagName === 'align') {
                  switch (tagValue.charCodeAt(0)) {
                    case 34:
                    case 39:
                      tagValue = tagValue.slice(1, -1);
                      break;
                  }
                  obj.imageAlign = tagValue.toLowerCase();
                } else if (tagName === 'offset') {
                  obj.imageOffset = tagValue;
                } else if (tagName === 'click') {
                  obj.event = this._processEventHandler(`${tagName}=${tagValue}`);
                }
                if (obj.event && tagName === 'param') {
                  obj.event[tagName] = tagValue.replace(/^"|"$/g, '');
                }
                header = imageAttrReg.exec(attribute);
              }
              if (isValidImageTag && obj.isImage) {
                this._resultObjectArray.push({
                  text: '',
                  style: obj
                });
              }
              return {};
            }
          }
          header = /^(outline(\s)*[^>]*)/.exec(attribute);
          if (header) {
            attribute = header[0].substring('outline'.length).trim();
            const defaultOutlineObject = {
              color: '#ffffff',
              width: 1
            };
            if (attribute) {
              const outlineAttrReg = /(\s)*color(\s)*=|(\s)*width(\s)*=|(\s)*click(\s)*=|(\s)*param(\s)*=/;
              header = outlineAttrReg.exec(attribute);
              let tagValue;
              while (header) {
                attribute = attribute.substring(attribute.indexOf(header[0]));
                tagName = attribute.substr(0, header[0].length);
                remainingArgument = attribute.substring(tagName.length).trim();
                nextSpace = remainingArgument.indexOf(' ');
                if (nextSpace > -1) {
                  tagValue = remainingArgument.substr(0, nextSpace);
                } else {
                  tagValue = remainingArgument;
                }
                tagName = tagName.replace(/[^a-zA-Z]/g, '').trim();
                tagName = tagName.toLowerCase();
                attribute = remainingArgument.substring(nextSpace).trim();
                if (tagName === 'click') {
                  obj.event = this._processEventHandler(`${tagName}=${tagValue}`);
                } else if (tagName === 'color') {
                  defaultOutlineObject.color = tagValue;
                } else if (tagName === 'width') {
                  defaultOutlineObject.width = parseInt(tagValue);
                }
                if (obj.event && tagName === 'param') {
                  obj.event[tagName] = tagValue.replace(/^"|"$/g, '');
                }
                header = outlineAttrReg.exec(attribute);
              }
            }
            obj.outline = defaultOutlineObject;
          }
          header = /^(on|u|b|i)(\s)*/.exec(attribute);
          if (header && header[0].length > 0) {
            tagName = header[0];
            attribute = attribute.substring(tagName.length).trim();
            switch (tagName[0]) {
              case 'u':
                obj.underline = true;
                break;
              case 'i':
                obj.italic = true;
                break;
              case 'b':
                obj.bold = true;
                break;
            }
            if (attribute === '') {
              return obj;
            }
            obj.event = this._processEventHandler(attribute);
          }
          return obj;
        }
        getRightQuotationIndex(remainingArgument) {
          let leftQuot = -1;
          let rightQuot = -1;
          const leftSingleQuot = remainingArgument.indexOf('\'');
          const leftDoubleQuot = remainingArgument.indexOf('"');
          const useSingleQuot = leftSingleQuot > -1 && (leftSingleQuot < leftDoubleQuot || leftDoubleQuot === -1);
          const useDoubleQuot = leftDoubleQuot > -1 && (leftDoubleQuot < leftSingleQuot || leftSingleQuot === -1);
          if (useSingleQuot) {
            leftQuot = leftSingleQuot;
            rightQuot = remainingArgument.indexOf('\'', leftQuot + 1 >= remainingArgument.length ? -1 : leftQuot + 1);
          } else if (useDoubleQuot) {
            leftQuot = leftDoubleQuot;
            rightQuot = remainingArgument.indexOf('"', leftQuot + 1 >= remainingArgument.length ? -1 : leftQuot + 1);
          }
          return rightQuot;
        }
        _processEventHandler(eventString) {
          const obj = {};
          let index = 0;
          let isValidTag = false;
          let eventNames = eventRegx.exec(eventString);
          while (eventNames) {
            let eventName = eventNames[0];
            let eventValue = '';
            isValidTag = false;
            eventString = eventString.substring(eventName.length).trim();
            if (eventString.charAt(0) === '"') {
              index = eventString.indexOf('"', 1);
              if (index > -1) {
                eventValue = eventString.substring(1, index).trim();
                isValidTag = true;
              }
              index++;
            } else if (eventString.charAt(0) === '\'') {
              index = eventString.indexOf('\'', 1);
              if (index > -1) {
                eventValue = eventString.substring(1, index).trim();
                isValidTag = true;
              }
              index++;
            } else {
              const match = /(\S)+/.exec(eventString);
              if (match) {
                eventValue = match[0];
              } else {
                eventValue = '';
              }
              index = eventValue.length;
            }
            if (isValidTag) {
              eventName = eventName.substring(0, eventName.length - 1).trim();
              obj[eventName] = eventValue;
            }
            eventString = eventString.substring(index).trim();
            eventNames = eventRegx.exec(eventString);
          }
          return obj;
        }
        _addToStack(attribute) {
          const obj = this._attributeToObject(attribute);
          if (this._stack.length === 0) {
            this._stack.push(obj);
          } else {
            if (obj.isNewLine || obj.isImage) {
              return;
            }
            const previousTagObj = this._stack[this._stack.length - 1];
            for (const key in previousTagObj) {
              if (!obj[key]) {
                obj[key] = previousTagObj[key];
              }
            }
            this._stack.push(obj);
          }
        }
        _processResult(value) {
          if (value.length === 0) {
            return;
          }
          value = this._escapeSpecialSymbol(value);
          if (this._stack.length > 0) {
            this._resultObjectArray.push({
              text: value,
              style: this._stack[this._stack.length - 1]
            });
          } else {
            this._resultObjectArray.push({
              text: value
            });
          }
        }
        _escapeSpecialSymbol(str) {
          for (const symbolArr of this._specialSymbolArray) {
            const key = symbolArr[0];
            const value = symbolArr[1];
            str = str.replace(key, value);
          }
          return str;
        }
      } exports('HtmlTextParser', HtmlTextParser);

      var _dec$B, _dec2$v, _dec3$o, _class$A, _class2$w, _initializer$t, _initializer2$o;
      let LabelOutline = (_dec$B = ccclass$3('cc.LabelOutline'), _dec2$v = executionOrder(110), _dec3$o = requireComponent(Label), _dec$B(_class$A = _dec2$v(_class$A = _dec3$o(_class$A = (_class2$w = class LabelOutline extends Component {
        constructor(...args) {
          super(...args);
          this._color = _initializer$t && _initializer$t();
          this._width = _initializer2$o && _initializer2$o();
        }
        get color() {
          return this._color;
        }
        set color(value) {
          if (this._color === value) {
            return;
          }
          this._color.set(value);
          this._updateRenderData();
        }
        get width() {
          return this._width;
        }
        set width(value) {
          if (this._width === value) {
            return;
          }
          this._width = value;
          this._updateRenderData();
        }
        onEnable() {
          this._updateRenderData();
        }
        onDisable() {
          this._updateRenderData();
        }
        _updateRenderData() {
          const label = this.node.getComponent(Label);
          if (label) {
            label.updateRenderData(true);
          }
        }
      }, (_initializer$t = applyDecoratedInitializer(_class2$w.prototype, "_color", [serializable$3], function () {
        return new Color$1(0, 0, 0, 255);
      }), _initializer2$o = applyDecoratedInitializer(_class2$w.prototype, "_width", [serializable$3], function () {
        return 2;
      })), _class2$w)) || _class$A) || _class$A) || _class$A); exports({ LabelOutline: LabelOutline, LabelOutlineComponent: LabelOutline });
      legacyCC.LabelOutline = LabelOutline;

      deprecateModuleExportedName({
        RenderComponent: {
          newName: 'UIRenderer',
          since: '1.2.0',
          removed: true
        },
        UITransformComponent: {
          newName: 'UITransform',
          since: '1.2.0',
          removed: false
        },
        CanvasComponent: {
          newName: 'Canvas',
          since: '1.2.0',
          removed: false
        }
      });

      deprecateModuleExportedName({
        UIRenderable: {
          newName: 'UIRenderer',
          since: '3.0.0',
          removed: true
        }
      });

      deprecateModuleExportedName({
        Renderable2D: {
          newName: 'UIRenderer',
          since: '3.6.0',
          removed: false
        }
      });

      var _dec$A, _class$z, _class2$v, _initializer$s, _initializer2$n, _initializer3$j, _class3$i;
      let PostProcess = (_dec$A = ccclass$3('cc.PostProcess'), _dec$A(_class$z = disallowMultiple$1(_class$z = (_class2$v = (_class3$i = class PostProcess extends Component {
        constructor(...args) {
          super(...args);
          this.global = _initializer$s && _initializer$s();
          this._shadingScale = _initializer2$n && _initializer2$n();
          this.enableShadingScaleInEditor = _initializer3$j && _initializer3$j();
          this.settings = new Map();
        }
        get shadingScale() {
          return this._shadingScale;
        }
        set shadingScale(v) {
          this._shadingScale = v;
        }
        addSetting(setting) {
          this.settings.set(setting.constructor, setting);
        }
        removeSetting(setting) {
          this.settings.delete(setting.constructor);
        }
        getSetting(ctor) {
          return this.settings.get(ctor);
        }
        onEnable() {
          PostProcess.all.push(this);
        }
        onDisable() {
          const idx = PostProcess.all.indexOf(this);
          if (idx !== -1) {
            PostProcess.all.splice(idx, 1);
          }
        }
      }, _class3$i.all = [], _class3$i), (_initializer$s = applyDecoratedInitializer(_class2$v.prototype, "global", [property, serializable$3], function () {
        return true;
      }), _initializer2$n = applyDecoratedInitializer(_class2$v.prototype, "_shadingScale", [serializable$3], function () {
        return 1;
      }), _applyDecoratedDescriptor(_class2$v.prototype, "shadingScale", [property], Object.getOwnPropertyDescriptor(_class2$v.prototype, "shadingScale"), _class2$v.prototype), _initializer3$j = applyDecoratedInitializer(_class2$v.prototype, "enableShadingScaleInEditor", [property, serializable$3], function () {
        return false;
      })), _class2$v)) || _class$z) || _class$z);

      var _dec$z, _dec2$u, _dec3$n, _dec4$f, _dec5$e, _dec6$8, _dec7$6, _dec8$5, _dec9$4, _dec10$2, _class$y, _class2$u, _initializer$r, _initializer2$m, _initializer3$i, _initializer4$g, _initializer5$d, _initializer6$a, _initializer7$8, _initializer8$8, _initializer9$8, _initializer10$8, _initializer11$8, _initializer12$7, _initializer13$6, _initializer14$5, _initializer15$3, _initializer16$3, _initializer17$2, _initializer18$2, _initializer19$1, _initializer20$1, _initializer21$1, _initializer22$1, _class3$h;
      const _temp_vec3_1 = new Vec3();
      const ProjectionType = Enum(CameraProjection);
      const FOVAxis = Enum(CameraFOVAxis);
      const Aperture = Enum(CameraAperture);
      const Shutter = Enum(CameraShutter);
      const ISO = Enum(CameraISO);
      const ClearFlag = Enum({
        SKYBOX: SKYBOX_FLAG | ClearFlagBit.DEPTH_STENCIL,
        SOLID_COLOR: ClearFlagBit.ALL,
        DEPTH_ONLY: ClearFlagBit.DEPTH_STENCIL,
        DONT_CLEAR: ClearFlagBit.NONE
      });
      let Camera = (_dec$z = ccclass$3('cc.Camera'), _dec2$u = type$2(Layers.BitMask), _dec3$n = type$2(ClearFlag), _dec4$f = type$2(ProjectionType), _dec5$e = type$2(FOVAxis), _dec6$8 = type$2(Aperture), _dec7$6 = type$2(Shutter), _dec8$5 = type$2(ISO), _dec9$4 = type$2(RenderTexture), _dec10$2 = type$2(PostProcess), _dec$z(_class$y = (_class2$u = (_class3$h = class Camera extends Component {
        constructor(...args) {
          super(...args);
          this._projection = _initializer$r && _initializer$r();
          this._priority = _initializer2$m && _initializer2$m();
          this._fov = _initializer3$i && _initializer3$i();
          this._fovAxis = _initializer4$g && _initializer4$g();
          this._orthoHeight = _initializer5$d && _initializer5$d();
          this._near = _initializer6$a && _initializer6$a();
          this._far = _initializer7$8 && _initializer7$8();
          this._color = _initializer8$8 && _initializer8$8();
          this._depth = _initializer9$8 && _initializer9$8();
          this._stencil = _initializer10$8 && _initializer10$8();
          this._clearFlags = _initializer11$8 && _initializer11$8();
          this._rect = _initializer12$7 && _initializer12$7();
          this._aperture = _initializer13$6 && _initializer13$6();
          this._shutter = _initializer14$5 && _initializer14$5();
          this._iso = _initializer15$3 && _initializer15$3();
          this._screenScale = _initializer16$3 && _initializer16$3();
          this._visibility = _initializer17$2 && _initializer17$2();
          this._targetTexture = _initializer18$2 && _initializer18$2();
          this._postProcess = _initializer19$1 && _initializer19$1();
          this._usePostProcess = _initializer20$1 && _initializer20$1();
          this._camera = null;
          this._inEditorMode = false;
          this._flows = undefined;
          this._cameraType = _initializer21$1 && _initializer21$1();
          this._trackingType = _initializer22$1 && _initializer22$1();
        }
        get camera() {
          return this._camera;
        }
        get priority() {
          return this._priority;
        }
        set priority(val) {
          this._priority = val;
          if (this._camera) {
            this._camera.priority = val;
          }
        }
        get visibility() {
          return this._visibility;
        }
        set visibility(val) {
          this._visibility = val;
          if (this._camera) {
            this._camera.visibility = val;
          }
        }
        get clearFlags() {
          return this._clearFlags;
        }
        set clearFlags(val) {
          this._clearFlags = val;
          if (this._camera) {
            this._camera.clearFlag = val;
          }
        }
        get clearColor() {
          return this._color;
        }
        set clearColor(val) {
          this._color.set(val);
          if (this._camera) {
            this._camera.clearColor = this._color;
          }
        }
        get clearDepth() {
          return this._depth;
        }
        set clearDepth(val) {
          this._depth = val;
          if (this._camera) {
            this._camera.clearDepth = val;
          }
        }
        get clearStencil() {
          return this._stencil;
        }
        set clearStencil(val) {
          this._stencil = val;
          if (this._camera) {
            this._camera.clearStencil = val;
          }
        }
        get projection() {
          return this._projection;
        }
        set projection(val) {
          this._projection = val;
          if (this._camera) {
            this._camera.projectionType = val;
          }
        }
        get fovAxis() {
          return this._fovAxis;
        }
        set fovAxis(val) {
          if (val === this._fovAxis) {
            return;
          }
          this._fovAxis = val;
          if (this._camera) {
            this._camera.fovAxis = val;
            if (val === CameraFOVAxis.VERTICAL) {
              this.fov = this._fov * this._camera.aspect;
            } else {
              this.fov = this._fov / this._camera.aspect;
            }
          }
        }
        get fov() {
          return this._fov;
        }
        set fov(val) {
          this._fov = val;
          if (this._camera) {
            this._camera.fov = toRadian(val);
          }
        }
        get orthoHeight() {
          return this._orthoHeight;
        }
        set orthoHeight(val) {
          this._orthoHeight = val;
          if (this._camera) {
            this._camera.orthoHeight = val;
          }
        }
        get near() {
          return this._near;
        }
        set near(val) {
          this._near = val;
          if (this._camera) {
            this._camera.nearClip = val;
          }
        }
        get far() {
          return this._far;
        }
        set far(val) {
          this._far = val;
          if (this._camera) {
            this._camera.farClip = val;
          }
        }
        get aperture() {
          return this._aperture;
        }
        set aperture(val) {
          this._aperture = val;
          if (this._camera) {
            this._camera.aperture = val;
          }
        }
        get shutter() {
          return this._shutter;
        }
        set shutter(val) {
          this._shutter = val;
          if (this._camera) {
            this._camera.shutter = val;
          }
        }
        get iso() {
          return this._iso;
        }
        set iso(val) {
          this._iso = val;
          if (this._camera) {
            this._camera.iso = val;
          }
        }
        get rect() {
          return this._rect;
        }
        set rect(val) {
          this._rect = val;
          if (this._camera) {
            this._camera.setViewportInOrientedSpace(val);
          }
        }
        get targetTexture() {
          return this._targetTexture;
        }
        set targetTexture(value) {
          if (this._targetTexture === value) {
            return;
          }
          const old = this._targetTexture;
          this._targetTexture = value;
          this._checkTargetTextureEvent(old);
          this._updateTargetTexture();
          if (!value && this._camera) {
            this._camera.changeTargetWindow(null);
            this._camera.isWindowSize = true;
          }
          this.node.emit(Camera.TARGET_TEXTURE_CHANGE, this);
        }
        get usePostProcess() {
          return this._usePostProcess;
        }
        set usePostProcess(v) {
          this._usePostProcess = v;
          if (this._camera) {
            this._camera.usePostProcess = v;
          }
        }
        get postProcess() {
          return this._postProcess;
        }
        set postProcess(v) {
          this._postProcess = v;
          if (this._camera) {
            this._camera.postProcess = v;
          }
        }
        get screenScale() {
          return this._screenScale;
        }
        set screenScale(val) {
          this._screenScale = val;
          if (this._camera) {
            this._camera.screenScale = val;
          }
        }
        get inEditorMode() {
          return this._inEditorMode;
        }
        set inEditorMode(value) {
          this._inEditorMode = value;
          if (this._camera) {
            this._camera.changeTargetWindow(value ? legacyCC.director.root && legacyCC.director.root.mainWindow : legacyCC.director.root && legacyCC.director.root.tempWindow);
          }
        }
        get cameraType() {
          return this._cameraType;
        }
        set cameraType(val) {
          if (this._cameraType === val) {
            return;
          }
          this._cameraType = val;
          if (this.camera) {
            this.camera.cameraType = val;
          }
        }
        get trackingType() {
          return this._trackingType;
        }
        set trackingType(val) {
          if (this._trackingType === val) {
            return;
          }
          this._trackingType = val;
          if (this.camera) {
            this.camera.trackingType = val;
          }
        }
        onLoad() {
          this._createCamera();
        }
        onEnable() {
          this.node.hasChangedFlags |= TransformBit.POSITION;
          if (this._camera) {
            this._attachToScene();
          }
        }
        onDisable() {
          if (this._camera) {
            this._detachFromScene();
          }
        }
        onDestroy() {
          if (this._camera) {
            this._camera.destroy();
            this._camera = null;
          }
          if (this._targetTexture) {
            this._targetTexture.off('resize');
          }
        }
        screenPointToRay(x, y, out) {
          if (!out) {
            out = Ray.create();
          }
          if (this._camera) {
            this._camera.screenPointToRay(out, x, y);
          }
          return out;
        }
        worldToScreen(worldPos, out) {
          if (!out) {
            out = new Vec3();
          }
          if (this._camera) {
            this._camera.worldToScreen(out, worldPos);
          }
          return out;
        }
        screenToWorld(screenPos, out) {
          if (!out) {
            out = this.node.getWorldPosition();
          }
          if (this._camera) {
            this._camera.screenToWorld(out, screenPos);
          }
          return out;
        }
        convertToUINode(wpos, uiNode, out) {
          if (!out) {
            out = new Vec3();
          }
          if (!this._camera) {
            return out;
          }
          this.worldToScreen(wpos, _temp_vec3_1);
          const cmp = uiNode.getComponent('cc.UITransform');
          const designSize = legacyCC.view.getVisibleSize();
          const xoffset = _temp_vec3_1.x - this._camera.width * 0.5;
          const yoffset = _temp_vec3_1.y - this._camera.height * 0.5;
          _temp_vec3_1.x = xoffset / legacyCC.view.getScaleX() + designSize.width * 0.5;
          _temp_vec3_1.y = yoffset / legacyCC.view.getScaleY() + designSize.height * 0.5;
          if (cmp) {
            cmp.convertToNodeSpaceAR(_temp_vec3_1, out);
          }
          return out;
        }
        _createCamera() {
          if (!this._camera) {
            this._camera = legacyCC.director.root.createCamera();
            this._camera.initialize({
              name: this.node.name,
              node: this.node,
              projection: this._projection,
              window: this._inEditorMode ? legacyCC.director.root && legacyCC.director.root.mainWindow : legacyCC.director.root && legacyCC.director.root.tempWindow,
              priority: this._priority,
              cameraType: this.cameraType,
              trackingType: this.trackingType
            });
            this._camera.setViewportInOrientedSpace(this._rect);
            this._camera.fovAxis = this._fovAxis;
            this._camera.fov = toRadian(this._fov);
            this._camera.orthoHeight = this._orthoHeight;
            this._camera.nearClip = this._near;
            this._camera.farClip = this._far;
            this._camera.clearColor = this._color;
            this._camera.clearDepth = this._depth;
            this._camera.clearStencil = this._stencil;
            this._camera.clearFlag = this._clearFlags;
            this._camera.visibility = this._visibility;
            this._camera.aperture = this._aperture;
            this._camera.shutter = this._shutter;
            this._camera.iso = this._iso;
            this._camera.postProcess = this._postProcess;
            this._camera.usePostProcess = this._usePostProcess;
          }
          this._updateTargetTexture();
        }
        _attachToScene() {
          if (!this.node.scene || !this._camera) {
            return;
          }
          if (this._camera && this._camera.scene) {
            this._camera.scene.removeCamera(this._camera);
          }
          const rs = this._getRenderScene();
          rs.addCamera(this._camera);
        }
        _detachFromScene() {
          if (this._camera && this._camera.scene) {
            this._camera.scene.removeCamera(this._camera);
          }
        }
        _checkTargetTextureEvent(old) {
          if (old) {
            old.off('resize');
          }
          if (this._targetTexture) {
            this._targetTexture.on('resize', window => {
              if (this._camera) {
                this._camera.setFixedSize(window.width, window.height);
              }
            }, this);
          }
        }
        _updateTargetTexture() {
          if (!this._camera) {
            return;
          }
          if (this._targetTexture) {
            const window = this._targetTexture.window;
            this._camera.changeTargetWindow(window);
            this._camera.setFixedSize(window.width, window.height);
          }
        }
      }, _class3$h.ProjectionType = ProjectionType, _class3$h.FOVAxis = FOVAxis, _class3$h.ClearFlag = ClearFlag, _class3$h.Aperture = Aperture, _class3$h.Shutter = Shutter, _class3$h.ISO = ISO, _class3$h.TARGET_TEXTURE_CHANGE = 'tex-change', _class3$h), (_initializer$r = applyDecoratedInitializer(_class2$u.prototype, "_projection", [serializable$3], function () {
        return ProjectionType.PERSPECTIVE;
      }), _initializer2$m = applyDecoratedInitializer(_class2$u.prototype, "_priority", [serializable$3], function () {
        return 0;
      }), _initializer3$i = applyDecoratedInitializer(_class2$u.prototype, "_fov", [serializable$3], function () {
        return 45;
      }), _initializer4$g = applyDecoratedInitializer(_class2$u.prototype, "_fovAxis", [serializable$3], function () {
        return FOVAxis.VERTICAL;
      }), _initializer5$d = applyDecoratedInitializer(_class2$u.prototype, "_orthoHeight", [serializable$3], function () {
        return 10;
      }), _initializer6$a = applyDecoratedInitializer(_class2$u.prototype, "_near", [serializable$3], function () {
        return 1;
      }), _initializer7$8 = applyDecoratedInitializer(_class2$u.prototype, "_far", [serializable$3], function () {
        return 1000;
      }), _initializer8$8 = applyDecoratedInitializer(_class2$u.prototype, "_color", [serializable$3], function () {
        return new Color$1('#333333');
      }), _initializer9$8 = applyDecoratedInitializer(_class2$u.prototype, "_depth", [serializable$3], function () {
        return 1;
      }), _initializer10$8 = applyDecoratedInitializer(_class2$u.prototype, "_stencil", [serializable$3], function () {
        return 0;
      }), _initializer11$8 = applyDecoratedInitializer(_class2$u.prototype, "_clearFlags", [serializable$3], function () {
        return ClearFlag.SOLID_COLOR;
      }), _initializer12$7 = applyDecoratedInitializer(_class2$u.prototype, "_rect", [serializable$3], function () {
        return new Rect$1(0, 0, 1, 1);
      }), _initializer13$6 = applyDecoratedInitializer(_class2$u.prototype, "_aperture", [serializable$3], function () {
        return Aperture.F16_0;
      }), _initializer14$5 = applyDecoratedInitializer(_class2$u.prototype, "_shutter", [serializable$3], function () {
        return Shutter.D125;
      }), _initializer15$3 = applyDecoratedInitializer(_class2$u.prototype, "_iso", [serializable$3], function () {
        return ISO.ISO100;
      }), _initializer16$3 = applyDecoratedInitializer(_class2$u.prototype, "_screenScale", [serializable$3], function () {
        return 1;
      }), _initializer17$2 = applyDecoratedInitializer(_class2$u.prototype, "_visibility", [serializable$3], function () {
        return CAMERA_DEFAULT_MASK;
      }), _initializer18$2 = applyDecoratedInitializer(_class2$u.prototype, "_targetTexture", [serializable$3], function () {
        return null;
      }), _initializer19$1 = applyDecoratedInitializer(_class2$u.prototype, "_postProcess", [serializable$3], function () {
        return null;
      }), _initializer20$1 = applyDecoratedInitializer(_class2$u.prototype, "_usePostProcess", [serializable$3], function () {
        return false;
      }), _initializer21$1 = applyDecoratedInitializer(_class2$u.prototype, "_cameraType", [serializable$3], function () {
        return CameraType.DEFAULT;
      }), _initializer22$1 = applyDecoratedInitializer(_class2$u.prototype, "_trackingType", [serializable$3], function () {
        return TrackingType.NO_TRACKING;
      }), _applyDecoratedDescriptor(_class2$u.prototype, "visibility", [_dec2$u], Object.getOwnPropertyDescriptor(_class2$u.prototype, "visibility"), _class2$u.prototype), _applyDecoratedDescriptor(_class2$u.prototype, "clearFlags", [_dec3$n], Object.getOwnPropertyDescriptor(_class2$u.prototype, "clearFlags"), _class2$u.prototype), _applyDecoratedDescriptor(_class2$u.prototype, "projection", [_dec4$f], Object.getOwnPropertyDescriptor(_class2$u.prototype, "projection"), _class2$u.prototype), _applyDecoratedDescriptor(_class2$u.prototype, "fovAxis", [_dec5$e], Object.getOwnPropertyDescriptor(_class2$u.prototype, "fovAxis"), _class2$u.prototype), _applyDecoratedDescriptor(_class2$u.prototype, "aperture", [_dec6$8], Object.getOwnPropertyDescriptor(_class2$u.prototype, "aperture"), _class2$u.prototype), _applyDecoratedDescriptor(_class2$u.prototype, "shutter", [_dec7$6], Object.getOwnPropertyDescriptor(_class2$u.prototype, "shutter"), _class2$u.prototype), _applyDecoratedDescriptor(_class2$u.prototype, "iso", [_dec8$5], Object.getOwnPropertyDescriptor(_class2$u.prototype, "iso"), _class2$u.prototype), _applyDecoratedDescriptor(_class2$u.prototype, "targetTexture", [_dec9$4], Object.getOwnPropertyDescriptor(_class2$u.prototype, "targetTexture"), _class2$u.prototype), _applyDecoratedDescriptor(_class2$u.prototype, "usePostProcess", [property], Object.getOwnPropertyDescriptor(_class2$u.prototype, "usePostProcess"), _class2$u.prototype), _applyDecoratedDescriptor(_class2$u.prototype, "postProcess", [_dec10$2], Object.getOwnPropertyDescriptor(_class2$u.prototype, "postProcess"), _class2$u.prototype)), _class2$u)) || _class$y); exports({ Camera: Camera, CameraComponent: Camera });
      legacyCC.Camera = Camera;

      const localWinSize = new Size$1();
      const orientationMap = {
        [macro.ORIENTATION_AUTO]: Orientation.AUTO,
        [macro.ORIENTATION_LANDSCAPE]: Orientation.LANDSCAPE,
        [macro.ORIENTATION_PORTRAIT]: Orientation.PORTRAIT
      };
      class View extends Eventify(System) {
        constructor() {
          super();
          this._designResolutionSize = void 0;
          this._scaleX = void 0;
          this._scaleY = void 0;
          this._viewportRect = void 0;
          this._visibleRect = void 0;
          this._autoFullScreen = void 0;
          this._retinaEnabled = void 0;
          this._resizeCallback = void 0;
          this._resolutionPolicy = void 0;
          this._rpExactFit = void 0;
          this._rpShowAll = void 0;
          this._rpNoBorder = void 0;
          this._rpFixedHeight = void 0;
          this._rpFixedWidth = void 0;
          const _strategyer = ContainerStrategy;
          const _strategy = ContentStrategy;
          this._designResolutionSize = new Size$1(0, 0);
          this._scaleX = 1;
          this._scaleY = 1;
          this._viewportRect = new Rect$1(0, 0, 0, 0);
          this._visibleRect = new Rect$1(0, 0, 0, 0);
          this._autoFullScreen = false;
          this._retinaEnabled = false;
          this._resizeCallback = null;
          this._rpExactFit = new ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.EXACT_FIT);
          this._rpShowAll = new ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.SHOW_ALL);
          this._rpNoBorder = new ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.NO_BORDER);
          this._rpFixedHeight = new ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.FIXED_HEIGHT);
          this._rpFixedWidth = new ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.FIXED_WIDTH);
          this._resolutionPolicy = this._rpShowAll;
        }
        init() {
          const windowSize = screen.windowSize;
          const w = windowSize.width;
          const h = windowSize.height;
          this._designResolutionSize.width = w;
          this._designResolutionSize.height = h;
          this._viewportRect.width = w;
          this._viewportRect.height = h;
          this._visibleRect.width = w;
          this._visibleRect.height = h;
          localWinSize.width = this._visibleRect.width;
          localWinSize.height = this._visibleRect.height;
          if (visibleRect) {
            visibleRect.init(this._visibleRect);
          }
          {
            this.resizeWithBrowserSize(true);
            const designResolution = settings.querySettings(Settings.Category.SCREEN, 'designResolution');
            if (designResolution) {
              this.setDesignResolutionSize(Number(designResolution.width), Number(designResolution.height), designResolution.policy || ResolutionPolicy.FIXED_HEIGHT);
            }
          }
          screen.on('window-resize', this._updateAdaptResult, this);
          screen.on('orientation-change', this._updateAdaptResult, this);
          screen.on('fullscreen-change', this._updateAdaptResult, this);
        }
        resizeWithBrowserSize(enabled) {
          screenAdapter.handleResizeEvent = enabled;
        }
        setResizeCallback(callback) {
          if (typeof callback === 'function' || callback == null) {
            this._resizeCallback = callback;
          }
        }
        setOrientation(orientation) {
          screenAdapter.orientation = orientationMap[orientation];
        }
        adjustViewportMeta(enabled) {}
        enableRetina(enabled) {
          this._retinaEnabled = !!enabled;
        }
        isRetinaEnabled() {
          return this._retinaEnabled;
        }
        enableAutoFullScreen(enabled) {
          if (enabled === this._autoFullScreen) {
            return;
          }
          this._autoFullScreen = enabled;
          if (enabled) {
            screen.requestFullScreen().catch(e => {});
          }
        }
        isAutoFullScreenEnabled() {
          return this._autoFullScreen;
        }
        setCanvasSize(width, height) {
          screenAdapter.resolutionScale = 1;
          const dpr = screenAdapter.devicePixelRatio;
          const windowSize = new Size$1(width * dpr, height * dpr);
          screen.windowSize = windowSize;
        }
        getCanvasSize() {
          return screen.windowSize;
        }
        getFrameSize() {
          const dpr = screenAdapter.devicePixelRatio;
          const sizeInCssPixels = screen.windowSize;
          sizeInCssPixels.width /= dpr;
          sizeInCssPixels.height /= dpr;
          return sizeInCssPixels;
        }
        setFrameSize(width, height) {
          const dpr = screenAdapter.devicePixelRatio;
          screen.windowSize = new Size$1(width * dpr, height * dpr);
        }
        getVisibleSize() {
          return new Size$1(this._visibleRect.width, this._visibleRect.height);
        }
        getVisibleSizeInPixel() {
          return new Size$1(this._visibleRect.width * this._scaleX, this._visibleRect.height * this._scaleY);
        }
        getVisibleOrigin() {
          return new Vec2(this._visibleRect.x, this._visibleRect.y);
        }
        getVisibleOriginInPixel() {
          return new Vec2(this._visibleRect.x * this._scaleX, this._visibleRect.y * this._scaleY);
        }
        getResolutionPolicy() {
          return this._resolutionPolicy;
        }
        _updateResolutionPolicy(resolutionPolicy) {
          if (resolutionPolicy instanceof ResolutionPolicy) {
            this._resolutionPolicy = resolutionPolicy;
          } else {
            const _locPolicy = ResolutionPolicy;
            if (resolutionPolicy === _locPolicy.EXACT_FIT) {
              this._resolutionPolicy = this._rpExactFit;
            }
            if (resolutionPolicy === _locPolicy.SHOW_ALL) {
              this._resolutionPolicy = this._rpShowAll;
            }
            if (resolutionPolicy === _locPolicy.NO_BORDER) {
              this._resolutionPolicy = this._rpNoBorder;
            }
            if (resolutionPolicy === _locPolicy.FIXED_HEIGHT) {
              this._resolutionPolicy = this._rpFixedHeight;
            }
            if (resolutionPolicy === _locPolicy.FIXED_WIDTH) {
              this._resolutionPolicy = this._rpFixedWidth;
            }
          }
        }
        setResolutionPolicy(resolutionPolicy) {
          this._updateResolutionPolicy(resolutionPolicy);
          const designedResolution = view.getDesignResolutionSize();
          view.setDesignResolutionSize(designedResolution.width, designedResolution.height, resolutionPolicy);
        }
        setDesignResolutionSize(width, height, resolutionPolicy) {
          if (!(width > 0 && height > 0)) {
            errorID(2200);
            return;
          }
          this._updateResolutionPolicy(resolutionPolicy);
          const policy = this._resolutionPolicy;
          if (policy) {
            policy.preApply(this);
          }
          this._designResolutionSize.width = width;
          this._designResolutionSize.height = height;
          const result = policy.apply(this, this._designResolutionSize);
          if (result.scale && result.scale.length === 2) {
            this._scaleX = result.scale[0];
            this._scaleY = result.scale[1];
          }
          if (result.viewport) {
            const vp = this._viewportRect;
            const vb = this._visibleRect;
            const rv = result.viewport;
            vp.x = rv.x;
            vp.y = rv.y;
            vp.width = rv.width;
            vp.height = rv.height;
            vb.x = 0;
            vb.y = 0;
            vb.width = rv.width / this._scaleX;
            vb.height = rv.height / this._scaleY;
          }
          policy.postApply(this);
          localWinSize.width = this._visibleRect.width;
          localWinSize.height = this._visibleRect.height;
          if (visibleRect) {
            visibleRect.init(this._visibleRect);
          }
          this.emit('design-resolution-changed');
        }
        getDesignResolutionSize() {
          return new Size$1(this._designResolutionSize.width, this._designResolutionSize.height);
        }
        setRealPixelResolution(width, height, resolutionPolicy) {
          this.setDesignResolutionSize(width, height, resolutionPolicy);
        }
        getViewportRect() {
          return this._viewportRect;
        }
        getScaleX() {
          return this._scaleX;
        }
        getScaleY() {
          return this._scaleY;
        }
        getDevicePixelRatio() {
          return screenAdapter.devicePixelRatio;
        }
        convertToLocationInView(tx, ty, relatedPos, out = new Vec2()) {
          const x = screenAdapter.devicePixelRatio * (tx - relatedPos.left);
          const y = screenAdapter.devicePixelRatio * (relatedPos.top + relatedPos.height - ty);
          if (screenAdapter.isFrameRotated) {
            out.x = screen.windowSize.width - y;
            out.y = x;
          } else {
            out.x = x;
            out.y = y;
          }
          return out;
        }
        _convertToUISpace(point) {
          const viewport = this._viewportRect;
          point.x = (point.x - viewport.x) / this._scaleX;
          point.y = (point.y - viewport.y) / this._scaleY;
        }
        _updateAdaptResult(width, height, windowId) {
          var _this$_resizeCallback;
          legacyCC.director.root.resize(width, height, windowId === undefined || windowId === 0 ? 1 : windowId);
          const w = this._designResolutionSize.width;
          const h = this._designResolutionSize.height;
          if (width > 0) {
            this.setDesignResolutionSize(w, h, this._resolutionPolicy);
          }
          this.emit('canvas-resize');
          (_this$_resizeCallback = this._resizeCallback) === null || _this$_resizeCallback === void 0 ? void 0 : _this$_resizeCallback.call(this);
        }
      } exports('View', View);
      View.instance = void 0;
      class ContainerStrategy {
        constructor() {
          this.name = 'ContainerStrategy';
        }
        preApply(_view) {}
        apply(_view, designedResolution) {}
        postApply(_view) {}
        _setupCanvas() {
          const locCanvas = legacyCC.game.canvas;
          if (locCanvas) {
            const windowSize = screen.windowSize;
            if (locCanvas.width !== windowSize.width) {
              locCanvas.width = windowSize.width;
            }
            if (locCanvas.height !== windowSize.height) {
              locCanvas.height = windowSize.height;
            }
          }
        }
      }
      ContainerStrategy.EQUAL_TO_FRAME = void 0;
      ContainerStrategy.PROPORTION_TO_FRAME = void 0;
      class ContentStrategy {
        constructor() {
          this.name = 'ContentStrategy';
          this._result = void 0;
          this._result = {
            scale: [1, 1],
            viewport: null
          };
        }
        preApply(_view) {}
        apply(_view, designedResolution) {
          return {
            scale: [1, 1]
          };
        }
        postApply(_view) {}
        _buildResult(containerW, containerH, contentW, contentH, scaleX, scaleY) {
          if (Math.abs(containerW - contentW) < 2) {
            contentW = containerW;
          }
          if (Math.abs(containerH - contentH) < 2) {
            contentH = containerH;
          }
          const viewport = new Rect$1(Math.round((containerW - contentW) / 2), Math.round((containerH - contentH) / 2), contentW, contentH);
          this._result.scale = [scaleX, scaleY];
          this._result.viewport = viewport;
          return this._result;
        }
      }
      ContentStrategy.EXACT_FIT = void 0;
      ContentStrategy.SHOW_ALL = void 0;
      ContentStrategy.NO_BORDER = void 0;
      ContentStrategy.FIXED_HEIGHT = void 0;
      ContentStrategy.FIXED_WIDTH = void 0;
      (() => {
        class EqualToFrame extends ContainerStrategy {
          constructor(...args) {
            super(...args);
            this.name = 'EqualToFrame';
          }
          apply(_view, designedResolution) {
            screenAdapter.isProportionalToFrame = false;
            this._setupCanvas();
          }
        }
        class ProportionalToFrame extends ContainerStrategy {
          constructor(...args) {
            super(...args);
            this.name = 'ProportionalToFrame';
          }
          apply(_view, designedResolution) {
            screenAdapter.isProportionalToFrame = true;
            this._setupCanvas();
          }
        }
        ContainerStrategy.EQUAL_TO_FRAME = new EqualToFrame();
        ContainerStrategy.PROPORTION_TO_FRAME = new ProportionalToFrame();
        class ExactFit extends ContentStrategy {
          constructor(...args) {
            super(...args);
            this.name = 'ExactFit';
          }
          apply(_view, designedResolution) {
            const windowSize = screen.windowSize;
            const containerW = windowSize.width;
            const containerH = windowSize.height;
            const scaleX = containerW / designedResolution.width;
            const scaleY = containerH / designedResolution.height;
            return this._buildResult(containerW, containerH, containerW, containerH, scaleX, scaleY);
          }
        }
        class ShowAll extends ContentStrategy {
          constructor(...args) {
            super(...args);
            this.name = 'ShowAll';
          }
          apply(_view, designedResolution) {
            const windowSize = screen.windowSize;
            const containerW = windowSize.width;
            const containerH = windowSize.height;
            const designW = designedResolution.width;
            const designH = designedResolution.height;
            const scaleX = containerW / designW;
            const scaleY = containerH / designH;
            let scale = 0;
            let contentW;
            let contentH;
            if (scaleX < scaleY) {
              scale = scaleX;
              contentW = containerW;
              contentH = designH * scale;
            } else {
              scale = scaleY;
              contentW = designW * scale;
              contentH = containerH;
            }
            return this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
          }
        }
        class NoBorder extends ContentStrategy {
          constructor(...args) {
            super(...args);
            this.name = 'NoBorder';
          }
          apply(_view, designedResolution) {
            const windowSize = screen.windowSize;
            const containerW = windowSize.width;
            const containerH = windowSize.height;
            const designW = designedResolution.width;
            const designH = designedResolution.height;
            const scaleX = containerW / designW;
            const scaleY = containerH / designH;
            let scale;
            let contentW;
            let contentH;
            if (scaleX < scaleY) {
              scale = scaleY;
              contentW = designW * scale;
              contentH = containerH;
            } else {
              scale = scaleX;
              contentW = containerW;
              contentH = designH * scale;
            }
            return this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
          }
        }
        class FixedHeight extends ContentStrategy {
          constructor(...args) {
            super(...args);
            this.name = 'FixedHeight';
          }
          apply(_view, designedResolution) {
            const windowSize = screen.windowSize;
            const containerW = windowSize.width;
            const containerH = windowSize.height;
            const designH = designedResolution.height;
            const scale = containerH / designH;
            const contentW = containerW;
            const contentH = containerH;
            return this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
          }
        }
        class FixedWidth extends ContentStrategy {
          constructor(...args) {
            super(...args);
            this.name = 'FixedWidth';
          }
          apply(_view, designedResolution) {
            const windowSize = screen.windowSize;
            const containerW = windowSize.width;
            const containerH = windowSize.height;
            const designW = designedResolution.width;
            const scale = containerW / designW;
            const contentW = containerW;
            const contentH = containerH;
            return this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
          }
        }
        ContentStrategy.EXACT_FIT = new ExactFit();
        ContentStrategy.SHOW_ALL = new ShowAll();
        ContentStrategy.NO_BORDER = new NoBorder();
        ContentStrategy.FIXED_HEIGHT = new FixedHeight();
        ContentStrategy.FIXED_WIDTH = new FixedWidth();
      })();
      class ResolutionPolicy {
        constructor(containerStg, contentStg) {
          this.name = 'ResolutionPolicy';
          this._containerStrategy = void 0;
          this._contentStrategy = void 0;
          this._containerStrategy = null;
          this._contentStrategy = null;
          this.setContainerStrategy(containerStg);
          this.setContentStrategy(contentStg);
        }
        get canvasSize() {
          return screen.windowSize;
        }
        preApply(_view) {
          this._contentStrategy.preApply(_view);
        }
        apply(_view, designedResolution) {
          this._containerStrategy.apply(_view, designedResolution);
          return this._contentStrategy.apply(_view, designedResolution);
        }
        postApply(_view) {
          this._contentStrategy.postApply(_view);
        }
        setContainerStrategy(containerStg) {
          if (containerStg instanceof ContainerStrategy) {
            this._containerStrategy = containerStg;
          }
        }
        setContentStrategy(contentStg) {
          if (contentStg instanceof ContentStrategy) {
            this._contentStrategy = contentStg;
          }
        }
      } exports('ResolutionPolicy', ResolutionPolicy);
      ResolutionPolicy.EXACT_FIT = 0;
      ResolutionPolicy.NO_BORDER = 1;
      ResolutionPolicy.SHOW_ALL = 2;
      ResolutionPolicy.FIXED_HEIGHT = 3;
      ResolutionPolicy.FIXED_WIDTH = 4;
      ResolutionPolicy.UNKNOWN = 5;
      ResolutionPolicy.ContainerStrategy = ContainerStrategy;
      ResolutionPolicy.ContentStrategy = ContentStrategy;
      legacyCC.ResolutionPolicy = ResolutionPolicy;
      const view = exports('view', View.instance = legacyCC.view = new View());
      director.registerSystem('view', view, 0);
      legacyCC.winSize = localWinSize;

      var _dec$y, _dec2$t, _dec3$m, _class$x;
      let RenderRoot2D = exports('RenderRoot2D', (_dec$y = ccclass$3('cc.RenderRoot2D'), _dec2$t = executionOrder(100), _dec3$m = requireComponent(UITransform), _dec$y(_class$x = _dec2$t(_class$x = _dec3$m(_class$x = disallowMultiple$1(_class$x = class RenderRoot2D extends Component {
        onEnable() {
          legacyCC.director.root.batcher2D.addScreen(this);
        }
        onDisable() {
          legacyCC.director.root.batcher2D.removeScreen(this);
        }
        onDestroy() {
          legacyCC.director.root.batcher2D.removeScreen(this);
        }
      }) || _class$x) || _class$x) || _class$x) || _class$x));

      var _dec$x, _dec2$s, _dec3$l, _dec4$e, _class$w, _class2$t, _initializer$q, _initializer2$l;
      const _worldPos = new Vec3();
      const RenderMode = Enum({
        OVERLAY: 0,
        INTERSPERSE: 1
      });
      let Canvas = (_dec$x = ccclass$3('cc.Canvas'), _dec2$s = executionOrder(100), _dec3$l = type$2(Camera), _dec4$e = type$2(Camera), _dec$x(_class$w = _dec2$s(_class$w = disallowMultiple$1(_class$w = (_class2$t = class Canvas extends RenderRoot2D {
        get renderMode() {
          return this._renderMode;
        }
        set renderMode(val) {
          this._renderMode = val;
          if (this._cameraComponent) {
            this._cameraComponent.priority = this._getViewPriority();
          }
        }
        get cameraComponent() {
          return this._cameraComponent;
        }
        set cameraComponent(value) {
          if (this._cameraComponent === value) {
            return;
          }
          this._cameraComponent = value;
          this._onResizeCamera();
        }
        get alignCanvasWithScreen() {
          return this._alignCanvasWithScreen;
        }
        set alignCanvasWithScreen(value) {
          this._alignCanvasWithScreen = value;
          this._onResizeCamera();
        }
        constructor() {
          super();
          this._cameraComponent = _initializer$q && _initializer$q();
          this._alignCanvasWithScreen = _initializer2$l && _initializer2$l();
          this._thisOnCameraResized = void 0;
          this.fitDesignResolution_EDITOR = void 0;
          this._pos = new Vec3();
          this._renderMode = RenderMode.OVERLAY;
          this._thisOnCameraResized = this._onResizeCamera.bind(this);
        }
        __preload() {
          const widget = this.getComponent('cc.Widget');
          if (widget) {
            widget.updateAlignment();
          }
          {
            if (this._cameraComponent) {
              this._cameraComponent._createCamera();
              this._cameraComponent.node.on(Camera.TARGET_TEXTURE_CHANGE, this._thisOnCameraResized);
            }
          }
          this._onResizeCamera();
          {
            this.node.on(NodeEventType.TRANSFORM_CHANGED, this._thisOnCameraResized);
          }
        }
        onEnable() {
          super.onEnable();
          if (this._cameraComponent) {
            this._cameraComponent.node.on(Camera.TARGET_TEXTURE_CHANGE, this._thisOnCameraResized);
          }
        }
        onDisable() {
          super.onDisable();
          if (this._cameraComponent) {
            this._cameraComponent.node.off(Camera.TARGET_TEXTURE_CHANGE, this._thisOnCameraResized);
          }
        }
        onDestroy() {
          super.onDestroy();
          this.node.off(NodeEventType.TRANSFORM_CHANGED, this._thisOnCameraResized);
        }
        _onResizeCamera() {
          if (this._cameraComponent && this._alignCanvasWithScreen) {
            if (this._cameraComponent.targetTexture) {
              this._cameraComponent.orthoHeight = visibleRect.height / 2;
            } else {
              const size = screen.windowSize;
              this._cameraComponent.orthoHeight = size.height / view.getScaleY() / 2;
            }
            this.node.getWorldPosition(_worldPos);
            this._cameraComponent.node.setWorldPosition(_worldPos.x, _worldPos.y, 1000);
          }
        }
        _getViewPriority() {
          if (this._cameraComponent) {
            var _this$cameraComponent;
            let priority = (_this$cameraComponent = this.cameraComponent) === null || _this$cameraComponent === void 0 ? void 0 : _this$cameraComponent.priority;
            priority = this._renderMode === RenderMode.OVERLAY ? priority | 1 << 30 : priority & ~(1 << 30);
            return priority;
          }
          return 0;
        }
      }, (_applyDecoratedDescriptor(_class2$t.prototype, "cameraComponent", [_dec3$l], Object.getOwnPropertyDescriptor(_class2$t.prototype, "cameraComponent"), _class2$t.prototype), _initializer$q = applyDecoratedInitializer(_class2$t.prototype, "_cameraComponent", [_dec4$e], function () {
        return null;
      }), _initializer2$l = applyDecoratedInitializer(_class2$t.prototype, "_alignCanvasWithScreen", [serializable$3], function () {
        return true;
      })), _class2$t)) || _class$w) || _class$w) || _class$w); exports({ Canvas: Canvas, CanvasComponent: Canvas });
      legacyCC.Canvas = Canvas;

      var _dec$w, _dec2$r, _dec3$k, _class$v;
      let UIComponent = exports('UIComponent', (_dec$w = ccclass$3('cc.UIComponent'), _dec2$r = requireComponent(UITransform), _dec3$k = executionOrder(110), _dec$w(_class$v = _dec2$r(_class$v = _dec3$k(_class$v = disallowMultiple$1(_class$v = class UIComponent extends Component {
        constructor(...args) {
          super(...args);
          this._lastParent = null;
          this.stencilStage = Stage.DISABLED;
        }
        __preload() {
          this.node._uiProps.uiComp = this;
        }
        onEnable() {}
        onDisable() {}
        onDestroy() {
          if (this.node._uiProps.uiComp === this) {
            this.node._uiProps.uiComp = null;
          }
        }
        postUpdateAssembler(render) {}
        markForUpdateRenderData(enable = true) {}
        setNodeDirty() {}
        setTextureDirty() {}
      }) || _class$v) || _class$v) || _class$v) || _class$v));

      removeProperty(UIComponent.prototype, 'UIComponent', [{
        name: '_visibility'
      }, {
        name: 'setVisibility'
      }]);
      replaceProperty(Canvas.prototype, 'Canvas.prototype', [{
        name: 'camera',
        newName: 'cameraComponent.camera',
        customGetter() {
          var _this$_cameraComponen;
          return (_this$_cameraComponen = this._cameraComponent) === null || _this$_cameraComponen === void 0 ? void 0 : _this$_cameraComponen.camera;
        }
      }, {
        name: 'clearFlag',
        newName: 'cameraComponent.clearFlags',
        customGetter() {
          return this._cameraComponent ? this._cameraComponent.clearFlags : 0;
        },
        customSetter(val) {
          if (this._cameraComponent) this._cameraComponent.clearFlags = val;
        }
      }, {
        name: 'color',
        newName: 'cameraComponent.clearColor',
        customGetter() {
          return this._cameraComponent ? this._cameraComponent.clearColor : Color$1.BLACK;
        },
        customSetter(val) {
          if (this._cameraComponent) this._cameraComponent.clearColor = val;
        }
      }, {
        name: 'priority',
        newName: 'cameraComponent.priority',
        customGetter() {
          return this._cameraComponent ? this._cameraComponent.priority : 0;
        },
        customSetter(val) {
          if (this._cameraComponent) this._cameraComponent.priority = val;
        }
      }, {
        name: 'targetTexture',
        newName: 'cameraComponent.targetTexture',
        customGetter() {
          return this._cameraComponent ? this._cameraComponent.targetTexture : null;
        },
        customSetter(value) {
          if (this._cameraComponent) this._cameraComponent.targetTexture = value;
        }
      }, {
        name: 'visibility',
        newName: 'cameraComponent.visibility',
        customGetter() {
          return this._cameraComponent ? this._cameraComponent.visibility : 0;
        }
      }]);
      markAsWarning(UITransform.prototype, 'UITransform.prototype', [{
        name: 'priority',
        suggest: `Please use setSiblingIndex to change index of the current node in its parent's children array.`
      }]);
      legacyCC.UITransformComponent = UITransform;
      setClassAlias(UITransform, 'cc.UITransformComponent');
      setClassAlias(UIRenderer, 'cc.RenderComponent');
      legacyCC.CanvasComponent = Canvas;
      setClassAlias(Canvas, 'cc.CanvasComponent');
      legacyCC.internal.Renderable2D = UIRenderer;
      setClassAlias(UIRenderer, 'cc.Renderable2D');

      function rayAABB2(ray, min, max) {
        const o = ray.o;
        const d = ray.d;
        const ix = 1 / d.x;
        const iy = 1 / d.y;
        const iz = 1 / d.z;
        const t1 = (min.x - o.x) * ix;
        const t2 = (max.x - o.x) * ix;
        const t3 = (min.y - o.y) * iy;
        const t4 = (max.y - o.y) * iy;
        const t5 = (min.z - o.z) * iz;
        const t6 = (max.z - o.z) * iz;
        const tmin = Math.max(Math.max(Math.min(t1, t2), Math.min(t3, t4)), Math.min(t5, t6));
        const tmax = Math.min(Math.min(Math.max(t1, t2), Math.max(t3, t4)), Math.max(t5, t6));
        if (tmax < 0 || tmin > tmax) {
          return 0;
        }
        return tmin > 0 ? tmin : tmax;
      }
      const raySubMesh = function () {
        const tri = Triangle.create();
        const deOpt = {
          distance: Infinity,
          doubleSided: false,
          mode: ERaycastMode.ANY
        };
        let minDis = 0;
        const fillResult = (m, d, i0, i1, i2, r) => {
          if (m === ERaycastMode.CLOSEST) {
            if (minDis > d || minDis === 0) {
              minDis = d;
              if (r) {
                if (r.length === 0) {
                  r.push({
                    distance: d,
                    vertexIndex0: i0 / 3,
                    vertexIndex1: i1 / 3,
                    vertexIndex2: i2 / 3
                  });
                } else {
                  r[0].distance = d;
                  r[0].vertexIndex0 = i0 / 3;
                  r[0].vertexIndex1 = i1 / 3;
                  r[0].vertexIndex2 = i2 / 3;
                }
              }
            }
          } else {
            minDis = d;
            if (r) r.push({
              distance: d,
              vertexIndex0: i0 / 3,
              vertexIndex1: i1 / 3,
              vertexIndex2: i2 / 3
            });
          }
        };
        const narrowphase = (vb, ib, pm, ray, opt) => {
          if (pm === PrimitiveMode.TRIANGLE_LIST) {
            const cnt = ib.length;
            for (let j = 0; j < cnt; j += 3) {
              const i0 = ib[j] * 3;
              const i1 = ib[j + 1] * 3;
              const i2 = ib[j + 2] * 3;
              Vec3.set(tri.a, vb[i0], vb[i0 + 1], vb[i0 + 2]);
              Vec3.set(tri.b, vb[i1], vb[i1 + 1], vb[i1 + 2]);
              Vec3.set(tri.c, vb[i2], vb[i2 + 1], vb[i2 + 2]);
              const dist = intersect.rayTriangle(ray, tri, opt.doubleSided);
              if (dist === 0 || dist > opt.distance) continue;
              fillResult(opt.mode, dist, i0, i1, i2, opt.result);
              if (opt.mode === ERaycastMode.ANY) return dist;
            }
          } else if (pm === PrimitiveMode.TRIANGLE_STRIP) {
            const cnt = ib.length - 2;
            let rev = 0;
            for (let j = 0; j < cnt; j += 1) {
              const i0 = ib[j - rev] * 3;
              const i1 = ib[j + rev + 1] * 3;
              const i2 = ib[j + 2] * 3;
              Vec3.set(tri.a, vb[i0], vb[i0 + 1], vb[i0 + 2]);
              Vec3.set(tri.b, vb[i1], vb[i1 + 1], vb[i1 + 2]);
              Vec3.set(tri.c, vb[i2], vb[i2 + 1], vb[i2 + 2]);
              rev = ~rev;
              const dist = intersect.rayTriangle(ray, tri, opt.doubleSided);
              if (dist === 0 || dist > opt.distance) continue;
              fillResult(opt.mode, dist, i0, i1, i2, opt.result);
              if (opt.mode === ERaycastMode.ANY) return dist;
            }
          } else if (pm === PrimitiveMode.TRIANGLE_FAN) {
            const cnt = ib.length - 1;
            const i0 = ib[0] * 3;
            Vec3.set(tri.a, vb[i0], vb[i0 + 1], vb[i0 + 2]);
            for (let j = 1; j < cnt; j += 1) {
              const i1 = ib[j] * 3;
              const i2 = ib[j + 1] * 3;
              Vec3.set(tri.b, vb[i1], vb[i1 + 1], vb[i1 + 2]);
              Vec3.set(tri.c, vb[i2], vb[i2 + 1], vb[i2 + 2]);
              const dist = intersect.rayTriangle(ray, tri, opt.doubleSided);
              if (dist === 0 || dist > opt.distance) continue;
              fillResult(opt.mode, dist, i0, i1, i2, opt.result);
              if (opt.mode === ERaycastMode.ANY) return dist;
            }
          }
          return minDis;
        };
        return function (ray, submesh, options) {
          minDis = 0;
          if (submesh.geometricInfo.positions.length === 0) return minDis;
          const opt = options === undefined ? deOpt : options;
          const min = submesh.geometricInfo.boundingBox.min;
          const max = submesh.geometricInfo.boundingBox.max;
          if (rayAABB2(ray, min, max)) {
            const pm = submesh.primitiveMode;
            const {
              positions: vb,
              indices: ib
            } = submesh.geometricInfo;
            narrowphase(vb, ib, pm, ray, opt);
          }
          return minDis;
        };
      }();
      const rayMesh = function () {
        let minDis = 0;
        const deOpt = {
          distance: Infinity,
          doubleSided: false,
          mode: ERaycastMode.ANY
        };
        return function (ray, mesh, options) {
          minDis = 0;
          const opt = options === undefined ? deOpt : options;
          const length = mesh.renderingSubMeshes.length;
          const min = mesh.struct.minPosition;
          const max = mesh.struct.maxPosition;
          if (min && max && !rayAABB2(ray, min, max)) return minDis;
          for (let i = 0; i < length; i++) {
            const sm = mesh.renderingSubMeshes[i];
            const dis = raySubMesh(ray, sm, opt);
            if (dis) {
              if (opt.mode === ERaycastMode.CLOSEST) {
                if (minDis === 0 || minDis > dis) {
                  minDis = dis;
                  if (opt.subIndices) opt.subIndices[0] = i;
                }
              } else {
                minDis = dis;
                if (opt.subIndices) opt.subIndices.push(i);
                if (opt.mode === ERaycastMode.ANY) {
                  return dis;
                }
              }
            }
          }
          if (minDis && opt.mode === ERaycastMode.CLOSEST) {
            if (opt.result) {
              opt.result[0].distance = minDis;
              opt.result.length = 1;
            }
            if (opt.subIndices) opt.subIndices.length = 1;
          }
          return minDis;
        };
      }();
      const rayModel = function () {
        let minDis = 0;
        const deOpt = {
          distance: Infinity,
          doubleSided: false,
          mode: ERaycastMode.ANY
        };
        const modelRay = new Ray();
        const m4 = new Mat4();
        return function (r, model, options) {
          minDis = 0;
          const opt = options === undefined ? deOpt : options;
          const wb = model.worldBounds;
          if (wb && !intersect.rayAABB(r, wb)) return minDis;
          Ray.copy(modelRay, r);
          if (model.node) {
            Mat4.invert(m4, model.node.getWorldMatrix(m4));
            Vec3.transformMat4(modelRay.o, r.o, m4);
            Vec3.transformMat4Normal(modelRay.d, r.d, m4);
          }
          const subModels = model.subModels;
          for (let i = 0; i < subModels.length; i++) {
            const subMesh = subModels[i].subMesh;
            const dis = raySubMesh(modelRay, subMesh, opt);
            if (dis) {
              if (opt.mode === ERaycastMode.CLOSEST) {
                if (minDis === 0 || minDis > dis) {
                  minDis = dis;
                  if (opt.subIndices) opt.subIndices[0] = i;
                }
              } else {
                minDis = dis;
                if (opt.subIndices) opt.subIndices.push(i);
                if (opt.mode === ERaycastMode.ANY) {
                  return dis;
                }
              }
            }
          }
          if (minDis && opt.mode === ERaycastMode.CLOSEST) {
            if (opt.result) {
              opt.result[0].distance = minDis;
              opt.result.length = 1;
            }
            if (opt.subIndices) opt.subIndices.length = 1;
          }
          return minDis;
        };
      }();
      intersect.rayModel = rayModel;
      intersect.raySubMesh = raySubMesh;
      intersect.rayMesh = rayMesh;

      var _dec$v, _class$u, _class2$s, _initializer$p;
      getPhaseID('specular-pass');
      let ModelRenderer = (_dec$v = ccclass$3('cc.ModelRenderer'), _dec$v(_class$u = (_class2$s = class ModelRenderer extends Renderer {
        constructor(...args) {
          super(...args);
          this._visFlags = _initializer$p && _initializer$p();
          this._models = [];
          this._priority = 0;
        }
        get visibility() {
          return this._visFlags;
        }
        set visibility(val) {
          this._visFlags = val;
          this._onVisibilityChange(val);
        }
        get priority() {
          return this._priority;
        }
        set priority(val) {
          if (val === this._priority) return;
          this._priority = val;
          this._updatePriority();
        }
        _collectModels() {
          return this._models;
        }
        onEnable() {
          this._updatePriority();
        }
        _attachToScene() {}
        _detachFromScene() {}
        _onVisibilityChange(val) {}
        _updatePriority() {
          if (this._models.length > 0) {
            for (let i = 0; i < this._models.length; i++) {
              this._models[i].priority = this._priority;
            }
          }
        }
      }, (_initializer$p = applyDecoratedInitializer(_class2$s.prototype, "_visFlags", [serializable$3], function () {
        return Layers.Enum.NONE;
      })), _class2$s)) || _class$u); exports({ ModelRenderer: ModelRenderer, RenderableComponent: ModelRenderer });

      var _dec$u, _dec2$q, _class$t, _class2$r, _initializer$o;
      const {
        ccclass: ccclass$1,
        serializable: serializable$1,
        type,
        visible
      } = _decorator;
      let PrefabLink = exports('PrefabLink', (_dec$u = ccclass$1('cc.PrefabLink'), _dec2$q = type(Prefab), _dec$u(_class$t = (_class2$r = class PrefabLink extends Component {
        constructor(...args) {
          super(...args);
          this.prefab = _initializer$o && _initializer$o();
        }
      }, (_initializer$o = applyDecoratedInitializer(_class2$r.prototype, "prefab", [_dec2$q, serializable$1], function () {
        return null;
      })), _class2$r)) || _class$t));

      replaceProperty(Camera, 'Camera', [{
        name: 'CameraClearFlag',
        newName: 'ClearFlag'
      }]);
      replaceProperty(Camera.prototype, 'Camera.prototype', [{
        name: 'color',
        newName: 'clearColor'
      }, {
        name: 'depth',
        newName: 'clearDepth'
      }, {
        name: 'stencil',
        newName: 'clearStencil'
      }]);
      markAsWarning(Renderer.prototype, 'Renderer.prototype', [{
        name: 'getMaterial',
        suggest: 'please use renderer.getSharedMaterial instead.'
      }]);
      legacyCC.CameraComponent = Camera;
      setClassAlias(Camera, 'cc.CameraComponent');
      legacyCC.RenderableComponent = ModelRenderer;
      setClassAlias(ModelRenderer, 'cc.RenderableComponent');

      var _dec$t, _dec2$p, _dec3$j, _class$s, _class2$q, _initializer$n, _initializer2$k, _initializer3$h, _initializer4$f, _initializer5$c, _initializer6$9;
      var SpriteMode;
      (function (SpriteMode) {
        SpriteMode[SpriteMode["SIMPLE"] = 0] = "SIMPLE";
        SpriteMode[SpriteMode["SLICED"] = 1] = "SLICED";
        SpriteMode[SpriteMode["TILED"] = 2] = "TILED";
      })(SpriteMode || (SpriteMode = {}));
      let SpriteRenderer = exports('SpriteRenderer', (_dec$t = ccclass$3('cc.SpriteRenderer'), _dec2$p = executionOrder(100), _dec3$j = type$2(SpriteFrame), _dec$t(_class$s = _dec2$p(_class$s = (_class2$q = class SpriteRenderer extends ModelRenderer {
        constructor(...args) {
          super(...args);
          this._spriteFrame = _initializer$n && _initializer$n();
          this._mode = _initializer2$k && _initializer2$k();
          this._color = _initializer3$h && _initializer3$h();
          this._flipX = _initializer4$f && _initializer4$f();
          this._flipY = _initializer5$c && _initializer5$c();
          this._size = _initializer6$9 && _initializer6$9();
          this._model = null;
        }
        get spriteFrame() {
          return this._spriteFrame;
        }
        set spriteFrame(value) {
          if (this._spriteFrame === value) {
            return;
          }
          this._spriteFrame;
          this._spriteFrame = value;
          if (this._spriteFrame) {
            this._spriteFrame.ensureMeshData();
            const mesh = this._spriteFrame.mesh;
            mesh.initialize();
          }
          this._updateModels();
          if (this.enabledInHierarchy) {
            this._attachToScene();
          }
        }
        get model() {
          return this._model;
        }
        onLoad() {
          if (this._spriteFrame) {
            if (!this._spriteFrame.mesh) {
              this._spriteFrame.ensureMeshData();
            }
            this._spriteFrame.mesh.initialize();
          }
          this._updateModels();
        }
        onRestore() {
          this._updateModels();
          if (this.enabledInHierarchy) {
            this._attachToScene();
          }
        }
        onEnable() {
          super.onEnable();
          if (!this._model) {
            this._updateModels();
          }
          this._attachToScene();
        }
        onDisable() {
          if (this._model) {
            this._detachFromScene();
          }
        }
        onDestroy() {
          if (this._model) {
            legacyCC.director.root.destroyModel(this._model);
            this._model = null;
            this._models.length = 0;
          }
        }
        _updateModels() {
          if (!this._spriteFrame) {
            return;
          }
          const model = this._model;
          if (model) {
            model.destroy();
            model.initialize();
            model.node = model.transform = this.node;
          } else {
            this._createModel();
          }
          if (this._model) {
            const mesh = this._spriteFrame.mesh;
            this._model.createBoundingShape(mesh.struct.minPosition, mesh.struct.maxPosition);
            this._updateModelParams();
            this._onUpdateLocalDescriptorSet();
          }
        }
        _createModel() {
          const model = this._model = legacyCC.director.root.createModel(Model);
          model.visFlags = this.visibility;
          model.node = model.transform = this.node;
          this._models.length = 0;
          this._models.push(this._model);
        }
        _updateModelParams() {
          if (!this._spriteFrame || !this._model) {
            return;
          }
          this._spriteFrame.ensureMeshData();
          const mesh = this._spriteFrame.mesh;
          this.node.hasChangedFlags |= TransformBit.POSITION;
          this._model.transform.hasChangedFlags |= TransformBit.POSITION;
          const meshCount = mesh ? mesh.renderingSubMeshes.length : 0;
          const renderingMesh = mesh.renderingSubMeshes;
          if (renderingMesh) {
            for (let i = 0; i < meshCount; ++i) {
              let material = this.getRenderMaterial(i);
              if (material && !material.isValid) {
                material = null;
              }
              const subMeshData = renderingMesh[i];
              if (subMeshData) {
                this._model.initSubModel(i, subMeshData, material || this._getBuiltinMaterial());
              }
            }
          }
          this._model.enabled = true;
        }
        _getBuiltinMaterial() {
          return builtinResMgr.get('missing-material');
        }
        _onMaterialModified(idx, material) {
          super._onMaterialModified(idx, material);
          if (!this._spriteFrame || !this._model || !this._model.inited) {
            return;
          }
          this._onRebuildPSO(idx, material || this._getBuiltinMaterial());
        }
        _onRebuildPSO(idx, material) {
          if (!this._model || !this._model.inited) {
            return;
          }
          this._model.setSubModelMaterial(idx, material);
          this._onUpdateLocalDescriptorSet();
        }
        _onUpdateLocalDescriptorSet() {
          if (!this._spriteFrame || !this._model || !this._model.inited) {
            return;
          }
          const texture = this._spriteFrame.getGFXTexture();
          const sampler = this._spriteFrame.getGFXSampler();
          const subModels = this._model.subModels;
          const binding = ModelLocalBindings.SAMPLER_SPRITE;
          for (let i = 0; i < subModels.length; i++) {
            const {
              descriptorSet
            } = subModels[i];
            descriptorSet.bindTexture(binding, texture);
            descriptorSet.bindSampler(binding, sampler);
            descriptorSet.update();
          }
        }
        _attachToScene() {
          if (!this.node.scene || !this._model) {
            return;
          }
          const renderScene = this._getRenderScene();
          if (this._model.scene !== null) {
            this._detachFromScene();
          }
          renderScene.addModel(this._model);
        }
        _detachFromScene() {
          if (this._model && this._model.scene) {
            this._model.scene.removeModel(this._model);
          }
        }
      }, (_applyDecoratedDescriptor(_class2$q.prototype, "spriteFrame", [_dec3$j], Object.getOwnPropertyDescriptor(_class2$q.prototype, "spriteFrame"), _class2$q.prototype), _initializer$n = applyDecoratedInitializer(_class2$q.prototype, "_spriteFrame", [serializable$3], function () {
        return null;
      }), _initializer2$k = applyDecoratedInitializer(_class2$q.prototype, "_mode", [serializable$3], function () {
        return SpriteMode.SIMPLE;
      }), _initializer3$h = applyDecoratedInitializer(_class2$q.prototype, "_color", [serializable$3], function () {
        return Color$1.WHITE.clone();
      }), _initializer4$f = applyDecoratedInitializer(_class2$q.prototype, "_flipX", [serializable$3], function () {
        return false;
      }), _initializer5$c = applyDecoratedInitializer(_class2$q.prototype, "_flipY", [serializable$3], function () {
        return false;
      }), _initializer6$9 = applyDecoratedInitializer(_class2$q.prototype, "_size", [serializable$3], function () {
        return new Vec2();
      })), _class2$q)) || _class$s) || _class$s));

      var _dec$s, _dec2$o, _dec3$i, _dec4$d, _dec5$d, _dec6$7, _dec7$5, _dec8$4, _class$r, _class2$p, _initializer$m, _initializer2$j, _initializer3$g, _initializer4$e, _initializer5$b, _initializer6$8, _initializer7$7, _initializer8$7, _initializer9$7, _initializer10$7, _initializer11$7, _initializer12$6, _initializer13$5, _initializer14$4, _class3$g;
      const _htmlTextParser = new HtmlTextParser();
      const RichTextChildName = 'RICHTEXT_CHILD';
      const RichTextChildImageName = 'RICHTEXT_Image_CHILD';
      const _tempSize = new Vec2();
      const _tempSizeLeft = new Vec2();
      const labelPool = new Pool$1(seg => {
        if (!legacyCC.isValid(seg.node)) {
          return false;
        } else {
          const outline = seg.node.getComponent(LabelOutline);
          if (outline) {
            outline.width = 0;
          }
        }
        return true;
      }, 20);
      const imagePool = new Pool$1(seg => {
        return legacyCC.isValid(seg.node);
      }, 10);
      function createSegment(type) {
        return {
          node: new Node$1(type),
          comp: null,
          lineCount: 0,
          styleIndex: 0,
          imageOffset: '',
          clickParam: '',
          clickHandler: '',
          type
        };
      }
      function getSegmentByPool(type, content) {
        let seg;
        if (type === RichTextChildName) {
          seg = labelPool._get();
        } else if (type === RichTextChildImageName) {
          seg = imagePool._get();
        }
        seg = seg || createSegment(type);
        let node = seg.node;
        if (!node) {
          node = new Node$1(type);
        }
        node.hideFlags |= CCObject.Flags.DontSave | CCObject.Flags.HideInHierarchy;
        node.active = true;
        if (type === RichTextChildImageName) {
          seg.comp = node.getComponent(Sprite) || node.addComponent(Sprite);
          seg.comp.spriteFrame = content;
          seg.comp.type = Sprite.Type.SLICED;
          seg.comp.sizeMode = Sprite.SizeMode.CUSTOM;
        } else {
          seg.comp = node.getComponent(Label) || node.addComponent(Label);
          seg.comp.string = content;
          seg.comp.horizontalAlign = HorizontalTextAlignment.LEFT;
          seg.comp.verticalAlign = VerticalTextAlignment.TOP;
          seg.comp.underlineHeight = 2;
        }
        node.setPosition(0, 0, 0);
        const trans = node._uiProps.uiTransformComp;
        trans.setAnchorPoint(0.5, 0.5);
        seg.node = node;
        seg.lineCount = 0;
        seg.styleIndex = 0;
        seg.imageOffset = '';
        seg.clickParam = '';
        seg.clickHandler = '';
        return seg;
      }
      let RichText = (_dec$s = ccclass$3('cc.RichText'), _dec2$o = executionOrder(110), _dec3$i = type$2(HorizontalTextAlignment), _dec4$d = type$2(VerticalTextAlignment), _dec5$d = type$2(Color$1), _dec6$7 = type$2(Font), _dec7$5 = type$2(CacheMode), _dec8$4 = type$2(SpriteAtlas), _dec$s(_class$r = _dec2$o(_class$r = (_class2$p = (_class3$g = class RichText extends Component {
        get string() {
          return this._string;
        }
        set string(value) {
          if (this._string === value) {
            return;
          }
          this._string = value;
          this._updateRichTextStatus();
        }
        get horizontalAlign() {
          return this._horizontalAlign;
        }
        set horizontalAlign(value) {
          if (this.horizontalAlign === value) {
            return;
          }
          this._horizontalAlign = value;
          this._layoutDirty = true;
          this._updateRichTextStatus();
        }
        get verticalAlign() {
          return this._verticalAlign;
        }
        set verticalAlign(value) {
          if (this._verticalAlign === value) {
            return;
          }
          this._verticalAlign = value;
          this._layoutDirty = true;
          this._updateRichTextStatus();
        }
        get fontSize() {
          return this._fontSize;
        }
        set fontSize(value) {
          if (this._fontSize === value) {
            return;
          }
          this._fontSize = value;
          this._layoutDirty = true;
          this._updateRichTextStatus();
        }
        get fontColor() {
          return this._fontColor;
        }
        set fontColor(value) {
          if (this._fontColor === value) {
            return;
          }
          this._fontColor = value;
          this._updateTextDefaultColor();
        }
        get fontFamily() {
          return this._fontFamily;
        }
        set fontFamily(value) {
          if (this._fontFamily === value) return;
          this._fontFamily = value;
          this._layoutDirty = true;
          this._updateRichTextStatus();
        }
        get font() {
          return this._font;
        }
        set font(value) {
          if (this._font === value) {
            return;
          }
          this._font = value;
          this._layoutDirty = true;
          if (this._font) {
            this.useSystemFont = false;
            this._onTTFLoaded();
          } else {
            this.useSystemFont = true;
          }
          this._updateRichTextStatus();
        }
        get useSystemFont() {
          return this._isSystemFontUsed;
        }
        set useSystemFont(value) {
          if (this._isSystemFontUsed === value) {
            return;
          }
          this._isSystemFontUsed = value;
          this._layoutDirty = true;
          this._updateRichTextStatus();
        }
        get cacheMode() {
          return this._cacheMode;
        }
        set cacheMode(value) {
          if (this._cacheMode === value) {
            return;
          }
          this._cacheMode = value;
          this._updateRichTextStatus();
        }
        get maxWidth() {
          return this._maxWidth;
        }
        set maxWidth(value) {
          if (this._maxWidth === value) {
            return;
          }
          this._maxWidth = value;
          this._layoutDirty = true;
          this._updateRichTextStatus();
        }
        get lineHeight() {
          return this._lineHeight;
        }
        set lineHeight(value) {
          if (this._lineHeight === value) {
            return;
          }
          this._lineHeight = value;
          this._layoutDirty = true;
          this._updateRichTextStatus();
        }
        get imageAtlas() {
          return this._imageAtlas;
        }
        set imageAtlas(value) {
          if (this._imageAtlas === value) {
            return;
          }
          this._imageAtlas = value;
          this._layoutDirty = true;
          this._updateRichTextStatus();
        }
        get handleTouchEvent() {
          return this._handleTouchEvent;
        }
        set handleTouchEvent(value) {
          if (this._handleTouchEvent === value) {
            return;
          }
          this._handleTouchEvent = value;
          if (this.enabledInHierarchy) {
            if (this.handleTouchEvent) {
              this._addEventListeners();
            } else {
              this._removeEventListeners();
            }
          }
        }
        constructor() {
          super();
          this._lineHeight = _initializer$m && _initializer$m();
          this._string = _initializer2$j && _initializer2$j();
          this._horizontalAlign = _initializer3$g && _initializer3$g();
          this._verticalAlign = _initializer4$e && _initializer4$e();
          this._fontSize = _initializer5$b && _initializer5$b();
          this._fontColor = _initializer6$8 && _initializer6$8();
          this._maxWidth = _initializer7$7 && _initializer7$7();
          this._fontFamily = _initializer8$7 && _initializer8$7();
          this._font = _initializer9$7 && _initializer9$7();
          this._isSystemFontUsed = _initializer10$7 && _initializer10$7();
          this._userDefinedFont = _initializer11$7 && _initializer11$7();
          this._cacheMode = _initializer12$6 && _initializer12$6();
          this._imageAtlas = _initializer13$5 && _initializer13$5();
          this._handleTouchEvent = _initializer14$4 && _initializer14$4();
          this._textArray = [];
          this._segments = [];
          this._labelSegmentsCache = [];
          this._linesWidth = [];
          this._lineCount = 1;
          this._labelWidth = 0;
          this._labelHeight = 0;
          this._layoutDirty = true;
          this._lineOffsetX = 0;
          this._updateRichTextStatus = void 0;
          this._labelChildrenNum = 0;
          this._updateRichTextStatus = this._updateRichText;
        }
        onLoad() {
          this.node.on(NodeEventType.LAYER_CHANGED, this._applyLayer, this);
          this.node.on(NodeEventType.ANCHOR_CHANGED, this._updateRichTextPosition, this);
        }
        onEnable() {
          if (this.handleTouchEvent) {
            this._addEventListeners();
          }
          this._updateRichText();
          this._activateChildren(true);
        }
        onDisable() {
          if (this.handleTouchEvent) {
            this._removeEventListeners();
          }
          this._activateChildren(false);
        }
        onRestore() {
          {
            return;
          }
        }
        onDestroy() {
          for (const seg of this._segments) {
            seg.node.removeFromParent();
            if (seg.type === RichTextChildName) {
              labelPool.put(seg);
            } else if (seg.type === RichTextChildImageName) {
              imagePool.put(seg);
            }
          }
          this.node.off(NodeEventType.ANCHOR_CHANGED, this._updateRichTextPosition, this);
          this.node.off(NodeEventType.LAYER_CHANGED, this._applyLayer, this);
        }
        _addEventListeners() {
          this.node.on(NodeEventType.TOUCH_END, this._onTouchEnded, this);
        }
        _removeEventListeners() {
          this.node.off(NodeEventType.TOUCH_END, this._onTouchEnded, this);
        }
        _updateLabelSegmentTextAttributes() {
          this._segments.forEach(item => {
            this._applyTextAttribute(item);
          });
        }
        _createFontLabel(str) {
          return getSegmentByPool(RichTextChildName, str);
        }
        _createImage(spriteFrame) {
          return getSegmentByPool(RichTextChildImageName, spriteFrame);
        }
        _onTTFLoaded() {
          if (this._font instanceof TTFFont) {
            this._layoutDirty = true;
            this._updateRichText();
          } else {
            this._layoutDirty = true;
            this._updateRichText();
          }
        }
        splitLongStringApproximatelyIn2048(text, styleIndex) {
          const approxSize = text.length * this.fontSize;
          const partStringArr = [];
          if (approxSize <= 2048 * 0.8) {
            partStringArr.push(text);
            return partStringArr;
          }
          this._calculateSize(_tempSize, styleIndex, text);
          if (_tempSize.x < 2048) {
            partStringArr.push(text);
          } else {
            const multilineTexts = text.split('\n');
            for (let i = 0; i < multilineTexts.length; i++) {
              this._calculateSize(_tempSize, styleIndex, multilineTexts[i]);
              if (_tempSize.x < 2048) {
                partStringArr.push(multilineTexts[i]);
              } else {
                const thisPartSplitResultArr = this.splitLongStringOver2048(multilineTexts[i], styleIndex);
                partStringArr.push(...thisPartSplitResultArr);
              }
            }
          }
          return partStringArr;
        }
        splitLongStringOver2048(text, styleIndex) {
          const partStringArr = [];
          const longStr = text;
          let curStart = 0;
          let curEnd = longStr.length / 2;
          let curString = longStr.substring(curStart, curEnd);
          let leftString = longStr.substring(curEnd);
          const curStringSize = this._calculateSize(_tempSize, styleIndex, curString);
          const leftStringSize = this._calculateSize(_tempSizeLeft, styleIndex, leftString);
          let maxWidth = this._maxWidth;
          if (this._maxWidth === 0) {
            maxWidth = 2047.9;
          }
          const lineCountForOnePart = 1;
          const sizeForOnePart = lineCountForOnePart * maxWidth;
          while (curStringSize.x > sizeForOnePart) {
            curEnd /= 2;
            if (curEnd < 1) {
              curEnd *= 2;
              break;
            }
            curString = curString.substring(curStart, curEnd);
            leftString = longStr.substring(curEnd);
            this._calculateSize(curStringSize, styleIndex, curString);
          }
          let leftTryTimes = 1000;
          let curWordStep = 1;
          while (leftTryTimes && curStart < text.length) {
            while (leftTryTimes && curStringSize.x < sizeForOnePart) {
              const nextPartExec = getEnglishWordPartAtFirst(leftString);
              if (nextPartExec && nextPartExec.length > 0) {
                curWordStep = nextPartExec[0].length;
              }
              curEnd += curWordStep;
              curString = longStr.substring(curStart, curEnd);
              leftString = longStr.substring(curEnd);
              this._calculateSize(curStringSize, styleIndex, curString);
              leftTryTimes--;
            }
            while (leftTryTimes && curString.length >= 2 && curStringSize.x > sizeForOnePart) {
              curEnd -= curWordStep;
              curString = longStr.substring(curStart, curEnd);
              this._calculateSize(curStringSize, styleIndex, curString);
              curWordStep = 1;
              leftTryTimes--;
            }
            if (curString.length >= 2) {
              const lastWordExec = getEnglishWordPartAtLast(curString);
              if (lastWordExec && lastWordExec.length > 0 && curString !== lastWordExec[0]) {
                curEnd -= lastWordExec[0].length;
                curString = longStr.substring(curStart, curEnd);
              }
            }
            partStringArr.push(curString);
            const partStep = curString.length;
            curStart = curEnd;
            curEnd += partStep;
            curString = longStr.substring(curStart, curEnd);
            leftString = longStr.substring(curEnd);
            this._calculateSize(leftStringSize, styleIndex, leftString);
            this._calculateSize(curStringSize, styleIndex, curString);
            leftTryTimes--;
            if (leftStringSize.x < 2048 && curStringSize.x < sizeForOnePart) {
              partStringArr.push(curString);
              curStart = text.length;
              curEnd = text.length;
              curString = leftString;
              if (leftString !== '') {
                partStringArr.push(curString);
              }
              break;
            }
          }
          return partStringArr;
        }
        _measureText(styleIndex, string) {
          const func = s => {
            const width = this._calculateSize(_tempSize, styleIndex, s).x;
            return width;
          };
          if (string) {
            return func(string);
          } else {
            return func;
          }
        }
        _calculateSize(out, styleIndex, s) {
          let label;
          if (this._labelSegmentsCache.length === 0) {
            label = this._createFontLabel(s);
            this._labelSegmentsCache.push(label);
          } else {
            label = this._labelSegmentsCache[0];
            label.node.getComponent(Label).string = s;
          }
          label.styleIndex = styleIndex;
          this._applyTextAttribute(label);
          const size = label.node._uiProps.uiTransformComp.contentSize;
          Vec2.set(out, size.x, size.y);
          return out;
        }
        _onTouchEnded(event) {
          const components = this.node.getComponents(Component);
          for (const seg of this._segments) {
            const clickHandler = seg.clickHandler;
            const clickParam = seg.clickParam;
            if (clickHandler && this._containsTouchLocation(seg, event.touch.getUILocation())) {
              components.forEach(component => {
                const func = component[clickHandler];
                if (component.enabledInHierarchy && func) {
                  func.call(component, event, clickParam);
                }
              });
              event.propagationStopped = true;
            }
          }
        }
        _containsTouchLocation(label, point) {
          const comp = label.node.getComponent(UITransform);
          if (!comp) {
            return false;
          }
          const myRect = comp.getBoundingBoxToWorld();
          return myRect.contains(point);
        }
        _resetState() {
          const children = this.node.children;
          for (let i = children.length - 1; i >= 0; i--) {
            const child = children[i];
            if (child.name === RichTextChildName || child.name === RichTextChildImageName) {
              {
                assert(child.parent === this.node);
              }
              child.parent = null;
              const segment = createSegment(child.name);
              segment.node = child;
              if (child.name === RichTextChildName) {
                segment.comp = child.getComponent(Label);
                labelPool.put(segment);
              } else {
                segment.comp = child.getComponent(Sprite);
                imagePool.put(segment);
              }
              this._labelChildrenNum--;
            }
          }
          this._segments.length = 0;
          this._labelSegmentsCache.length = 0;
          this._linesWidth.length = 0;
          this._lineOffsetX = 0;
          this._lineCount = 1;
          this._labelWidth = 0;
          this._labelHeight = 0;
          this._layoutDirty = true;
        }
        _activateChildren(active) {
          for (let i = this.node.children.length - 1; i >= 0; i--) {
            const child = this.node.children[i];
            if (child.name === RichTextChildName || child.name === RichTextChildImageName) {
              child.active = active;
            }
          }
        }
        _addLabelSegment(stringToken, styleIndex) {
          let labelSegment;
          if (this._labelSegmentsCache.length === 0) {
            labelSegment = this._createFontLabel(stringToken);
          } else {
            labelSegment = this._labelSegmentsCache.pop();
            const label = labelSegment.node.getComponent(Label);
            if (label) {
              label.string = stringToken;
            }
          }
          const labelComp = labelSegment.comp;
          if (labelComp.verticalAlign !== this._verticalAlign) {
            labelComp.verticalAlign = this._verticalAlign;
          }
          labelSegment.styleIndex = styleIndex;
          labelSegment.lineCount = this._lineCount;
          labelSegment.node._uiProps.uiTransformComp.setAnchorPoint(0, 0);
          labelSegment.node.layer = this.node.layer;
          this.node.insertChild(labelSegment.node, this._labelChildrenNum++);
          this._applyTextAttribute(labelSegment);
          this._segments.push(labelSegment);
          return labelSegment;
        }
        _updateRichTextWithMaxWidth(labelString, labelWidth, styleIndex) {
          let fragmentWidth = labelWidth;
          let labelSegment;
          if (this._lineOffsetX > 0 && fragmentWidth + this._lineOffsetX > this._maxWidth) {
            let checkStartIndex = 0;
            while (this._lineOffsetX <= this._maxWidth) {
              const checkEndIndex = this._getFirstWordLen(labelString, checkStartIndex, labelString.length);
              const checkString = labelString.substr(checkStartIndex, checkEndIndex);
              const checkStringWidth = this._measureText(styleIndex, checkString);
              if (this._lineOffsetX + checkStringWidth <= this._maxWidth) {
                this._lineOffsetX += checkStringWidth;
                checkStartIndex += checkEndIndex;
              } else {
                if (checkStartIndex > 0) {
                  const remainingString = labelString.substr(0, checkStartIndex);
                  this._addLabelSegment(remainingString, styleIndex);
                  labelString = labelString.substr(checkStartIndex, labelString.length);
                  fragmentWidth = this._measureText(styleIndex, labelString);
                }
                this._updateLineInfo();
                break;
              }
            }
          }
          if (fragmentWidth > this._maxWidth) {
            const fragments = fragmentText(labelString, fragmentWidth, this._maxWidth, this._measureText(styleIndex));
            for (let k = 0; k < fragments.length; ++k) {
              const splitString = fragments[k];
              labelSegment = this._addLabelSegment(splitString, styleIndex);
              const labelSize = labelSegment.node._uiProps.uiTransformComp.contentSize;
              this._lineOffsetX += labelSize.width;
              if (fragments.length > 1 && k < fragments.length - 1) {
                this._updateLineInfo();
              }
            }
          } else {
            this._lineOffsetX += fragmentWidth;
            this._addLabelSegment(labelString, styleIndex);
          }
        }
        _isLastComponentCR(stringToken) {
          return stringToken.length - 1 === stringToken.lastIndexOf('\n');
        }
        _updateLineInfo() {
          this._linesWidth.push(this._lineOffsetX);
          this._lineOffsetX = 0;
          this._lineCount++;
        }
        _needsUpdateTextLayout(newTextArray) {
          if (this._layoutDirty || !this._textArray || !newTextArray) {
            return true;
          }
          if (this._textArray.length !== newTextArray.length) {
            return true;
          }
          for (let i = 0; i < this._textArray.length; i++) {
            const oldItem = this._textArray[i];
            const newItem = newTextArray[i];
            if (oldItem.text !== newItem.text) {
              return true;
            } else {
              const oldStyle = oldItem.style;
              const newStyle = newItem.style;
              if (oldStyle) {
                if (newStyle) {
                  if (!!newStyle.outline !== !!oldStyle.outline) {
                    return true;
                  }
                  if (oldStyle.size !== newStyle.size || oldStyle.italic !== newStyle.italic || oldStyle.isImage !== newStyle.isImage) {
                    return true;
                  }
                  if (oldStyle.src !== newStyle.src || oldStyle.imageAlign !== newStyle.imageAlign || oldStyle.imageHeight !== newStyle.imageHeight || oldStyle.imageWidth !== newStyle.imageWidth || oldStyle.imageOffset !== newStyle.imageOffset) {
                    return true;
                  }
                } else if (oldStyle.size || oldStyle.italic || oldStyle.isImage || oldStyle.outline) {
                  return true;
                }
              } else if (newStyle) {
                if (newStyle.size || newStyle.italic || newStyle.isImage || newStyle.outline) {
                  return true;
                }
              }
            }
          }
          return false;
        }
        _addRichTextImageElement(richTextElement) {
          if (!richTextElement.style) {
            return;
          }
          const style = richTextElement.style;
          const spriteFrameName = style.src;
          const spriteFrame = this._imageAtlas && spriteFrameName && this._imageAtlas.getSpriteFrame(spriteFrameName);
          if (!spriteFrame) {
            warnID(4400);
          } else {
            const segment = this._createImage(spriteFrame);
            segment.comp;
            switch (style.imageAlign) {
              case 'top':
                segment.node._uiProps.uiTransformComp.setAnchorPoint(0, 1);
                break;
              case 'center':
                segment.node._uiProps.uiTransformComp.setAnchorPoint(0, 0.5);
                break;
              default:
                segment.node._uiProps.uiTransformComp.setAnchorPoint(0, 0);
                break;
            }
            if (style.imageOffset) {
              segment.imageOffset = style.imageOffset;
            }
            segment.node.layer = this.node.layer;
            this.node.insertChild(segment.node, this._labelChildrenNum++);
            this._segments.push(segment);
            const spriteRect = spriteFrame.rect.clone();
            let scaleFactor = 1;
            let spriteWidth = spriteRect.width;
            let spriteHeight = spriteRect.height;
            const expectWidth = style.imageWidth || 0;
            const expectHeight = style.imageHeight || 0;
            if (expectHeight > 0) {
              scaleFactor = expectHeight / spriteHeight;
              spriteWidth *= scaleFactor;
              spriteHeight *= scaleFactor;
            } else {
              scaleFactor = this._lineHeight / spriteHeight;
              spriteWidth *= scaleFactor;
              spriteHeight *= scaleFactor;
            }
            if (expectWidth > 0) {
              spriteWidth = expectWidth;
            }
            if (this._maxWidth > 0) {
              if (this._lineOffsetX + spriteWidth > this._maxWidth) {
                this._updateLineInfo();
              }
              this._lineOffsetX += spriteWidth;
            } else {
              this._lineOffsetX += spriteWidth;
              if (this._lineOffsetX > this._labelWidth) {
                this._labelWidth = this._lineOffsetX;
              }
            }
            segment.node._uiProps.uiTransformComp.setContentSize(spriteWidth, spriteHeight);
            segment.lineCount = this._lineCount;
            segment.clickHandler = '';
            segment.clickParam = '';
            const event = style.event;
            if (event) {
              segment.clickHandler = event.click;
              segment.clickParam = event.param;
            }
          }
        }
        _updateTextDefaultColor() {
          for (let i = 0; i < this._segments.length; ++i) {
            var _this$_textArray$segm, _this$_textArray$segm2;
            const segment = this._segments[i];
            const label = segment.node.getComponent(Label);
            if (!label) {
              continue;
            }
            if ((_this$_textArray$segm = this._textArray[segment.styleIndex]) !== null && _this$_textArray$segm !== void 0 && (_this$_textArray$segm2 = _this$_textArray$segm.style) !== null && _this$_textArray$segm2 !== void 0 && _this$_textArray$segm2.color) {
              continue;
            }
            label.color = this._fontColor;
          }
        }
        _updateRichText() {
          if (!this.enabledInHierarchy) {
            return;
          }
          const newTextArray = _htmlTextParser.parse(this._string);
          if (!this._needsUpdateTextLayout(newTextArray)) {
            this._textArray = newTextArray.slice();
            this._updateLabelSegmentTextAttributes();
            return;
          }
          this._textArray = newTextArray.slice();
          this._resetState();
          let lastEmptyLine = false;
          let label;
          for (let i = 0; i < this._textArray.length; ++i) {
            const richTextElement = this._textArray[i];
            let text = richTextElement.text;
            if (text === undefined) {
              continue;
            }
            if (text === '') {
              if (richTextElement.style && richTextElement.style.isNewLine) {
                this._updateLineInfo();
                continue;
              }
              if (richTextElement.style && richTextElement.style.isImage && this._imageAtlas) {
                this._addRichTextImageElement(richTextElement);
                continue;
              }
            }
            const splitArr = this.splitLongStringApproximatelyIn2048(text, i);
            text = splitArr.join('\n');
            const multilineTexts = text.split('\n');
            for (let j = 0; j < multilineTexts.length; ++j) {
              const labelString = multilineTexts[j];
              if (labelString === '') {
                if (this._isLastComponentCR(text) && j === multilineTexts.length - 1) {
                  continue;
                }
                this._updateLineInfo();
                lastEmptyLine = true;
                continue;
              }
              lastEmptyLine = false;
              if (this._maxWidth > 0) {
                const labelWidth = this._measureText(i, labelString);
                this._updateRichTextWithMaxWidth(labelString, labelWidth, i);
                if (multilineTexts.length > 1 && j < multilineTexts.length - 1) {
                  this._updateLineInfo();
                }
              } else {
                label = this._addLabelSegment(labelString, i);
                this._lineOffsetX += label.node._uiProps.uiTransformComp.width;
                if (this._lineOffsetX > this._labelWidth) {
                  this._labelWidth = this._lineOffsetX;
                }
                if (multilineTexts.length > 1 && j < multilineTexts.length - 1) {
                  this._updateLineInfo();
                }
              }
            }
          }
          if (!lastEmptyLine) {
            this._linesWidth.push(this._lineOffsetX);
          }
          if (this._maxWidth > 0) {
            this._labelWidth = this._maxWidth;
          }
          this._labelHeight = (this._lineCount + BASELINE_RATIO) * this._lineHeight;
          this.node._uiProps.uiTransformComp.setContentSize(this._labelWidth, this._labelHeight);
          this._updateRichTextPosition();
          this._layoutDirty = false;
        }
        _getFirstWordLen(text, startIndex, textLen) {
          let character = text.charAt(startIndex);
          if (isUnicodeCJK(character) || isUnicodeSpace(character)) {
            return 1;
          }
          let len = 1;
          for (let index = startIndex + 1; index < textLen; ++index) {
            character = text.charAt(index);
            if (isUnicodeSpace(character) || isUnicodeCJK(character)) {
              break;
            }
            len++;
          }
          return len;
        }
        _updateRichTextPosition() {
          let nextTokenX = 0;
          let nextLineIndex = 1;
          const totalLineCount = this._lineCount;
          const trans = this.node._uiProps.uiTransformComp;
          const anchorX = trans.anchorX;
          const anchorY = trans.anchorY;
          for (let i = 0; i < this._segments.length; ++i) {
            const segment = this._segments[i];
            const lineCount = segment.lineCount;
            if (lineCount > nextLineIndex) {
              nextTokenX = 0;
              nextLineIndex = lineCount;
            }
            let lineOffsetX = this._labelWidth * (this._horizontalAlign * 0.5 - anchorX);
            switch (this._horizontalAlign) {
              case HorizontalTextAlignment.LEFT:
                break;
              case HorizontalTextAlignment.CENTER:
                lineOffsetX -= this._linesWidth[lineCount - 1] / 2;
                break;
              case HorizontalTextAlignment.RIGHT:
                lineOffsetX -= this._linesWidth[lineCount - 1];
                break;
            }
            const pos = segment.node.position;
            segment.node.setPosition(nextTokenX + lineOffsetX, this._lineHeight * (totalLineCount - lineCount) - this._labelHeight * anchorY, pos.z);
            if (lineCount === nextLineIndex) {
              nextTokenX += segment.node._uiProps.uiTransformComp.width;
            }
            const sprite = segment.node.getComponent(Sprite);
            if (sprite) {
              const position = segment.node.position.clone();
              const lineHeightSet = this._lineHeight;
              const lineHeightReal = this._lineHeight * (1 + BASELINE_RATIO);
              switch (segment.node._uiProps.uiTransformComp.anchorY) {
                case 1:
                  position.y += lineHeightSet + (lineHeightReal - lineHeightSet) / 2;
                  break;
                case 0.5:
                  position.y += lineHeightReal / 2;
                  break;
                default:
                  position.y += (lineHeightReal - lineHeightSet) / 2;
                  break;
              }
              if (segment.imageOffset) {
                const offsets = segment.imageOffset.split(',');
                if (offsets.length === 1 && offsets[0]) {
                  const offsetY = parseFloat(offsets[0]);
                  if (Number.isInteger(offsetY)) position.y += offsetY;
                } else if (offsets.length === 2) {
                  const offsetX = parseFloat(offsets[0]);
                  const offsetY = parseFloat(offsets[1]);
                  if (Number.isInteger(offsetX)) position.x += offsetX;
                  if (Number.isInteger(offsetY)) position.y += offsetY;
                }
              }
              segment.node.position = position;
            }
            const outline = segment.node.getComponent(LabelOutline);
            if (outline) {
              const position = segment.node.position.clone();
              position.y -= outline.width;
              segment.node.position = position;
            }
          }
        }
        _convertLiteralColorValue(color) {
          const colorValue = color.toUpperCase();
          if (Color$1[colorValue]) {
            const colorUse = Color$1[colorValue];
            return colorUse;
          } else {
            const out = new Color$1();
            return out.fromHEX(color);
          }
        }
        _applyTextAttribute(labelSeg) {
          const label = labelSeg.node.getComponent(Label);
          if (!label) {
            return;
          }
          this._resetLabelState(label);
          const index = labelSeg.styleIndex;
          let textStyle;
          if (this._textArray[index]) {
            textStyle = this._textArray[index].style;
          }
          if (textStyle) {
            if (textStyle.color) {
              label.color = this._convertLiteralColorValue(textStyle.color);
            } else {
              label.color = this._fontColor;
            }
            label.isBold = !!textStyle.bold;
            label.isItalic = !!textStyle.italic;
            label.isUnderline = !!textStyle.underline;
            if (textStyle.outline) {
              let labelOutline = labelSeg.node.getComponent(LabelOutline);
              if (!labelOutline) {
                labelOutline = labelSeg.node.addComponent(LabelOutline);
              }
              labelOutline.color = this._convertLiteralColorValue(textStyle.outline.color);
              labelOutline.width = textStyle.outline.width;
            }
            label.fontSize = textStyle.size || this._fontSize;
            labelSeg.clickHandler = '';
            labelSeg.clickParam = '';
            const event = textStyle.event;
            if (event) {
              labelSeg.clickHandler = event.click || '';
              labelSeg.clickParam = event.param || '';
            }
          }
          label.cacheMode = this._cacheMode;
          const isAsset = this._font instanceof Font;
          if (isAsset && !this._isSystemFontUsed) {
            label.font = this._font;
          } else {
            label.fontFamily = this._fontFamily;
          }
          label.useSystemFont = this._isSystemFontUsed;
          label.lineHeight = this._lineHeight;
          label.updateRenderData(true);
        }
        _applyLayer() {
          for (const seg of this._segments) {
            seg.node.layer = this.node.layer;
          }
        }
        _resetLabelState(label) {
          label.fontSize = this._fontSize;
          label.color = this._fontColor;
          label.isBold = false;
          label.isItalic = false;
          label.isUnderline = false;
        }
      }, _class3$g.HorizontalAlign = HorizontalTextAlignment, _class3$g.VerticalAlign = VerticalTextAlignment, _class3$g), (_applyDecoratedDescriptor(_class2$p.prototype, "horizontalAlign", [_dec3$i], Object.getOwnPropertyDescriptor(_class2$p.prototype, "horizontalAlign"), _class2$p.prototype), _applyDecoratedDescriptor(_class2$p.prototype, "verticalAlign", [_dec4$d], Object.getOwnPropertyDescriptor(_class2$p.prototype, "verticalAlign"), _class2$p.prototype), _applyDecoratedDescriptor(_class2$p.prototype, "fontColor", [_dec5$d], Object.getOwnPropertyDescriptor(_class2$p.prototype, "fontColor"), _class2$p.prototype), _applyDecoratedDescriptor(_class2$p.prototype, "font", [_dec6$7], Object.getOwnPropertyDescriptor(_class2$p.prototype, "font"), _class2$p.prototype), _applyDecoratedDescriptor(_class2$p.prototype, "cacheMode", [_dec7$5], Object.getOwnPropertyDescriptor(_class2$p.prototype, "cacheMode"), _class2$p.prototype), _applyDecoratedDescriptor(_class2$p.prototype, "imageAtlas", [_dec8$4], Object.getOwnPropertyDescriptor(_class2$p.prototype, "imageAtlas"), _class2$p.prototype), _initializer$m = applyDecoratedInitializer(_class2$p.prototype, "_lineHeight", [serializable$3], function () {
        return 40;
      }), _initializer2$j = applyDecoratedInitializer(_class2$p.prototype, "_string", [serializable$3], function () {
        return '<color=#00ff00>Rich</color><color=#0fffff>Text</color>';
      }), _initializer3$g = applyDecoratedInitializer(_class2$p.prototype, "_horizontalAlign", [serializable$3], function () {
        return HorizontalTextAlignment.LEFT;
      }), _initializer4$e = applyDecoratedInitializer(_class2$p.prototype, "_verticalAlign", [serializable$3], function () {
        return VerticalTextAlignment.TOP;
      }), _initializer5$b = applyDecoratedInitializer(_class2$p.prototype, "_fontSize", [serializable$3], function () {
        return 40;
      }), _initializer6$8 = applyDecoratedInitializer(_class2$p.prototype, "_fontColor", [serializable$3], function () {
        return Color$1.WHITE.clone();
      }), _initializer7$7 = applyDecoratedInitializer(_class2$p.prototype, "_maxWidth", [serializable$3], function () {
        return 0;
      }), _initializer8$7 = applyDecoratedInitializer(_class2$p.prototype, "_fontFamily", [serializable$3], function () {
        return 'Arial';
      }), _initializer9$7 = applyDecoratedInitializer(_class2$p.prototype, "_font", [serializable$3], function () {
        return null;
      }), _initializer10$7 = applyDecoratedInitializer(_class2$p.prototype, "_isSystemFontUsed", [serializable$3], function () {
        return true;
      }), _initializer11$7 = applyDecoratedInitializer(_class2$p.prototype, "_userDefinedFont", [serializable$3], function () {
        return null;
      }), _initializer12$6 = applyDecoratedInitializer(_class2$p.prototype, "_cacheMode", [serializable$3], function () {
        return CacheMode.NONE;
      }), _initializer13$5 = applyDecoratedInitializer(_class2$p.prototype, "_imageAtlas", [serializable$3], function () {
        return null;
      }), _initializer14$4 = applyDecoratedInitializer(_class2$p.prototype, "_handleTouchEvent", [serializable$3], function () {
        return true;
      })), _class2$p)) || _class$r) || _class$r); exports({ RichText: RichText, RichTextComponent: RichText });
      legacyCC.RichText = RichText;

      var _dec$r, _dec2$n, _class$q;
      let UIMeshRenderer = (_dec$r = ccclass$3('cc.UIMeshRenderer'), _dec2$n = executionOrder(110), _dec$r(_class$q = _dec2$n(_class$q = class UIMeshRenderer extends Component {
        constructor() {
          super();
          this._modelComponent = null;
          this._dirtyVersion = -1;
          this._internalId = -1;
          this.stencilStage = Stage.DISABLED;
          this._renderData = null;
          this._renderEntity = new RenderEntity(RenderEntityType.DYNAMIC);
          {
            this._UIModelNativeProxy = new NativeUIModelProxy();
          }
        }
        get modelComponent() {
          return this._modelComponent;
        }
        __preload() {
          this.node._uiProps.uiComp = this;
        }
        onEnable() {
          uiRendererManager.addRenderer(this);
          this.markForUpdateRenderData();
        }
        onDisable() {
          uiRendererManager.removeRenderer(this);
          this.renderEntity.enabled = this._canRender();
        }
        onLoad() {
          if (!this.node._uiProps.uiTransformComp) {
            this.node.addComponent('cc.UITransform');
          }
          this._modelComponent = this.getComponent('cc.ModelRenderer');
          if (!this._modelComponent) {
            warn(`node '${this.node && this.node.name}' doesn't have any renderable component`);
            return;
          }
          {
            this._UIModelNativeProxy.attachNode(this.node);
          }
          this.renderEntity.setNode(this.node);
        }
        onDestroy() {
          this.renderEntity.setNode(null);
          if (this.node._uiProps.uiComp === this) {
            this.node._uiProps.uiComp = null;
          }
          this._modelComponent = this.getComponent('cc.ModelRenderer');
          if (!this._modelComponent) {
            return;
          }
          this._modelComponent._sceneGetter = null;
        }
        _render(render) {
          if (this._modelComponent) {
            const models = this._modelComponent._collectModels();
            this._modelComponent._detachFromScene();
            for (let i = 0; i < models.length; i++) {
              if (models[i].enabled) {
                render.commitModel(this, models[i], this._modelComponent.material);
              }
            }
            return true;
          }
          return false;
        }
        fillBuffers(render) {
          if (this.enabled) {
            this._render(render);
          }
        }
        updateRenderer() {
          {
            this.renderEntity.enabled = this._canRender();
            if (this._modelComponent) {
              const models = this._modelComponent._collectModels();
              this._modelComponent._detachFromScene();
              this._UIModelNativeProxy.clearModels();
              this._renderEntity.clearDynamicRenderDrawInfos();
              for (let i = 0; i < models.length; i++) {
                if (models[i].enabled) {
                  this._uploadRenderData(i);
                  this._UIModelNativeProxy.updateModels(models[i]);
                }
              }
              this._UIModelNativeProxy.attachDrawInfo();
            }
          }
        }
        _uploadRenderData(index) {
          {
            const renderData = MeshRenderData.add();
            renderData.initRenderDrawInfo(this, RenderDrawInfoType.MODEL);
            this._renderData = renderData;
            this._renderData.material = this._modelComponent.getMaterialInstance(index);
          }
        }
        postUpdateAssembler(render) {}
        update() {
          {
            if (this._modelComponent) {
              this.markForUpdateRenderData();
            }
          }
          this._fitUIRenderQueue();
        }
        _fitUIRenderQueue() {
          if (!this._modelComponent) {
            return;
          }
          const matNum = this._modelComponent.sharedMaterials.length;
          for (let i = 0; i < matNum; i++) {
            const material = this._modelComponent.getMaterialInstance(i);
            if (material == null) {
              continue;
            }
            const passes = material.passes;
            const passNum = passes.length;
            for (let j = 0; j < passNum; j++) {
              const pass = passes[j];
              pass.setPriority(RenderPriority.MAX - 11);
              material.recompileShaders({
                CC_FORCE_FORWARD_SHADING: true
              }, j);
            }
          }
        }
        markForUpdateRenderData(enable = true) {
          uiRendererManager.markDirtyRenderer(this);
        }
        setNodeDirty() {}
        setTextureDirty() {}
        _canRender() {
          return this.enabled && this._modelComponent !== null;
        }
        get renderEntity() {
          {
            assert(Boolean(this._renderEntity), 'this._renderEntity should not be invalid');
          }
          return this._renderEntity;
        }
        get renderData() {
          return this._renderData;
        }
      }) || _class$q) || _class$q); exports({ UIMeshRenderer: UIMeshRenderer, UIModelComponent: UIMeshRenderer });
      legacyCC.UIMeshRenderer = UIMeshRenderer;

      const UI_VIS_FLAG = Layers.Enum.NONE | Layers.Enum.UI_3D;
      class DrawBatch2D {
        constructor() {
          this.model = null;
          this.texture = null;
          this.sampler = null;
          this.useLocalData = null;
          this.isStatic = false;
          this.textureHash = 0;
          this.samplerHash = 0;
          this._passes = [];
          this._shaders = [];
          this._visFlags = UI_VIS_FLAG;
          this._inputAssembler = null;
          this._descriptorSet = null;
        }
        get inputAssembler() {
          return this._inputAssembler;
        }
        set inputAssembler(ia) {
          this._inputAssembler = ia;
        }
        get descriptorSet() {
          return this._descriptorSet;
        }
        set descriptorSet(ds) {
          this._descriptorSet = ds;
        }
        get visFlags() {
          return this._visFlags;
        }
        set visFlags(vis) {
          this._visFlags = vis;
        }
        get passes() {
          return this._passes;
        }
        get shaders() {
          return this._shaders;
        }
        destroy(ui) {
          this._passes = [];
        }
        clear() {
          this._inputAssembler = null;
          this._descriptorSet = null;
          this.texture = null;
          this.sampler = null;
          this.textureHash = 0;
          this.samplerHash = 0;
          this.model = null;
          this.isStatic = false;
          this.useLocalData = null;
          this.visFlags = UI_VIS_FLAG;
        }
        fillPasses(mat, dss, dssHash, patches) {
          if (mat) {
            const passes = mat.passes;
            if (!passes) {
              return;
            }
            this._shaders.length = passes.length;
            for (let i = 0; i < passes.length; i++) {
              if (!this._passes[i]) {
                this._passes[i] = new Pass(legacyCC.director.root);
              }
              const mtlPass = passes[i];
              const passInUse = this._passes[i];
              mtlPass.update();
              if (!dss) {
                dss = mtlPass.depthStencilState;
                dssHash = 0;
              }
              passInUse._initPassFromTarget(mtlPass, dss, dssHash);
              this._shaders[i] = passInUse.getShaderVariant(patches);
            }
          }
        }
      }

      var _dec$q, _dec2$m, _class$p, _class2$o;
      let UIStaticBatch = (_dec$q = ccclass$3('cc.UIStaticBatch'), _dec2$m = executionOrder(110), _dec$q(_class$p = _dec2$m(_class$p = (_class2$o = class UIStaticBatch extends UIRenderer {
        constructor(...args) {
          super(...args);
          this._init = false;
          this._bufferAccessor = null;
          this._dirty = true;
          this._uiDrawBatchList = [];
        }
        get color() {
          return this._color;
        }
        set color(value) {
          if (this._color === value) {
            return;
          }
          this._color.set(value);
        }
        get drawBatchList() {
          return this._uiDrawBatchList;
        }
        postUpdateAssembler(render) {}
        markAsDirty() {}
        _requireDrawBatch() {
          const batch = new DrawBatch2D();
          batch.isStatic = true;
          this._uiDrawBatchList.push(batch);
          return batch;
        }
        _clearData() {
          if (this._bufferAccessor) {
            this._bufferAccessor.reset();
            const ui = this._getBatcher();
            for (let i = 0; i < this._uiDrawBatchList.length; i++) {
              const element = this._uiDrawBatchList[i];
              element.destroy(ui);
            }
          }
          this._uiDrawBatchList.length = 0;
          this._init = false;
        }
        _getBatcher() {
          if (director.root && director.root.batcher2D) {
            return director.root.batcher2D;
          }
          warnID(9301);
          return null;
        }
      }, (_applyDecoratedDescriptor(_class2$o.prototype, "color", [override], Object.getOwnPropertyDescriptor(_class2$o.prototype, "color"), _class2$o.prototype)), _class2$o)) || _class$p) || _class$p); exports({ UIStaticBatch: UIStaticBatch, UIStaticBatchComponent: UIStaticBatch });

      var _dec$p, _dec2$l, _dec3$h, _class$o, _class2$n, _initializer$l, _initializer2$i, _initializer3$f;
      let LabelShadow = exports('LabelShadow', (_dec$p = ccclass$3('cc.LabelShadow'), _dec2$l = executionOrder(110), _dec3$h = requireComponent(Label), _dec$p(_class$o = _dec2$l(_class$o = _dec3$h(_class$o = (_class2$n = class LabelShadow extends Component {
        constructor(...args) {
          super(...args);
          this._color = _initializer$l && _initializer$l();
          this._offset = _initializer2$i && _initializer2$i();
          this._blur = _initializer3$f && _initializer3$f();
        }
        get color() {
          return this._color;
        }
        set color(value) {
          if (this._color === value) {
            return;
          }
          this._color.set(value);
          this._updateRenderData();
        }
        get offset() {
          return this._offset;
        }
        set offset(value) {
          this._offset = value;
          this._updateRenderData();
        }
        get blur() {
          return this._blur;
        }
        set blur(value) {
          this._blur = value;
          this._updateRenderData();
        }
        onEnable() {
          this._updateRenderData();
        }
        onDisable() {
          this._updateRenderData();
        }
        _updateRenderData() {
          const label = this.node.getComponent(Label);
          if (label) {
            label.updateRenderData(true);
          }
        }
      }, (_initializer$l = applyDecoratedInitializer(_class2$n.prototype, "_color", [serializable$3], function () {
        return new Color$1(0, 0, 0, 255);
      }), _initializer2$i = applyDecoratedInitializer(_class2$n.prototype, "_offset", [serializable$3], function () {
        return new Vec2(2, 2);
      }), _initializer3$f = applyDecoratedInitializer(_class2$n.prototype, "_blur", [serializable$3], function () {
        return 2;
      })), _class2$n)) || _class$o) || _class$o) || _class$o));

      var _dec$o, _dec2$k, _class$n, _class2$m, _initializer$k;
      let UIOpacity = (_dec$o = ccclass$3('cc.UIOpacity'), _dec2$k = executionOrder(110), _dec$o(_class$n = _dec2$k(_class$n = disallowMultiple$1(_class$n = (_class2$m = class UIOpacity extends Component {
        constructor(...args) {
          super(...args);
          this._opacity = _initializer$k && _initializer$k();
        }
        get opacity() {
          return this._opacity;
        }
        set opacity(value) {
          if (this._opacity === value) {
            return;
          }
          value = clampf(value, 0, 255);
          this._opacity = value;
          this.node._uiProps.localOpacity = value / 255;
          this.setEntityLocalOpacityDirtyRecursively(true);
        }
        setEntityLocalOpacityDirtyRecursively(dirty) {
          {
            UIOpacity.setEntityLocalOpacityDirtyRecursively(this.node, dirty, 1);
          }
        }
        static setEntityLocalOpacityDirtyRecursively(node, dirty, interruptParentOpacity) {
          if (!node.isValid) {
            return;
          }
          const render = node._uiProps.uiComp;
          const uiOp = node.getComponent(UIOpacity);
          let interruptOpacity = interruptParentOpacity;
          if (render && render.color) {
            render.renderEntity.colorDirty = dirty;
            if (uiOp) {
              render.renderEntity.localOpacity = interruptOpacity * uiOp.opacity / 255;
            } else {
              render.renderEntity.localOpacity = interruptOpacity;
            }
            interruptOpacity = 1;
          } else if (uiOp) {
            interruptOpacity = interruptOpacity * uiOp.opacity / 255;
          }
          for (let i = 0; i < node.children.length; i++) {
            UIOpacity.setEntityLocalOpacityDirtyRecursively(node.children[i], dirty || interruptOpacity < 1, interruptOpacity);
          }
        }
        onEnable() {
          this.node._uiProps.localOpacity = this._opacity / 255;
          this.setEntityLocalOpacityDirtyRecursively(true);
        }
        onDisable() {
          this.node._uiProps.localOpacity = 1;
          this.setEntityLocalOpacityDirtyRecursively(true);
        }
      }, (_initializer$k = applyDecoratedInitializer(_class2$m.prototype, "_opacity", [serializable$3], function () {
        return 255;
      })), _class2$m)) || _class$n) || _class$n) || _class$n); exports({ UIOpacity: UIOpacity, UIOpacityComponent: UIOpacity });

      legacyCC.MaskComponent = Mask;
      setClassAlias(Mask, 'cc.MaskComponent');
      legacyCC.LabelComponent = Label;
      setClassAlias(Label, 'cc.LabelComponent');
      legacyCC.LabelOutlineComponent = LabelOutline;
      setClassAlias(LabelOutline, 'cc.LabelOutlineComponent');
      legacyCC.RichTextComponent = RichText;
      setClassAlias(RichText, 'cc.RichTextComponent');
      legacyCC.SpriteComponent = Sprite;
      setClassAlias(Sprite, 'cc.SpriteComponent');
      legacyCC.UIModelComponent = UIMeshRenderer;
      setClassAlias(UIMeshRenderer, 'cc.UIModelComponent');
      legacyCC.GraphicsComponent = Graphics;
      setClassAlias(Graphics, 'cc.GraphicsComponent');
      setClassAlias(UIStaticBatch, 'cc.UIStaticBatchComponent');
      setClassAlias(UIOpacity, 'cc.UIOpacityComponent');
      replaceProperty(Mask.prototype, 'Mask', [{
        name: 'graphics',
        newName: 'subComp',
        target: Mask.prototype,
        targetName: 'Mask'
      }]);
      replaceProperty(MaskType, 'MaskType', [{
        name: 'RECT',
        newName: 'GRAPHICS_RECT',
        target: MaskType,
        targetName: 'MaskType'
      }, {
        name: 'ELLIPSE',
        newName: 'GRAPHICS_ELLIPSE',
        target: MaskType,
        targetName: 'MaskType'
      }, {
        name: 'IMAGE_STENCIL',
        newName: 'SPRITE_STENCIL',
        target: MaskType,
        targetName: 'MaskType'
      }]);

      class Aim {
        constructor(i, x, y) {
          this.i = void 0;
          this.x = void 0;
          this.y = void 0;
          this.prev = null;
          this.next = null;
          this.z = null;
          this.prevZ = null;
          this.nextZ = null;
          this.steiner = false;
          this.i = i;
          this.x = x;
          this.y = y;
        }
      }
      function linkedList(datas, start, end, dim, clockwise) {
        let i = 0;
        let last = null;
        if (clockwise === signedArea(datas, start, end, dim) > 0) {
          for (i = start; i < end; i += dim) {
            last = insertNode(i, datas[i], datas[i + 1], last);
          }
        } else {
          for (i = end - dim; i >= start; i -= dim) {
            last = insertNode(i, datas[i], datas[i + 1], last);
          }
        }
        if (last && equals(last, last.next)) {
          removeNode(last);
          last = last.next;
        }
        return last;
      }
      function filterPoints(start, end = null) {
        if (!start) {
          return start;
        }
        if (!end) {
          end = start;
        }
        let p = start;
        let again = false;
        do {
          again = false;
          if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next) {
              return null;
            }
            again = true;
          } else {
            p = p.next;
          }
        } while (again || p !== end);
        return end;
      }
      function earcutLinked(ear, triangles, dim, minX, minY, size, pass = 0) {
        if (!ear) {
          return;
        }
        if (!pass && size) {
          indexCurve(ear, minX, minY, size);
        }
        let stop = ear;
        let prev = null;
        let next = null;
        while (ear.prev !== ear.next) {
          prev = ear.prev;
          next = ear.next;
          if (size ? isEarHashed(ear, minX, minY, size) : isEar(ear)) {
            triangles.push(prev.i / dim);
            triangles.push(ear.i / dim);
            triangles.push(next.i / dim);
            removeNode(ear);
            ear = next.next;
            stop = next.next;
            continue;
          }
          ear = next;
          if (ear === stop) {
            if (!pass) {
              earcutLinked(filterPoints(ear), triangles, dim, minX, minY, size, 1);
            } else if (pass === 1) {
              ear = cureLocalIntersections(ear, triangles, dim);
              earcutLinked(ear, triangles, dim, minX, minY, size, 2);
            } else if (pass === 2) {
              splitEarcut(ear, triangles, dim, minX, minY, size);
            }
            break;
          }
        }
      }
      function isEar(ear) {
        const a = ear.prev;
        const b = ear;
        const c = ear.next;
        if (area(a, b, c) >= 0) {
          return false;
        }
        let p = ear.next.next;
        while (p !== ear.prev) {
          if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) {
            return false;
          }
          p = p.next;
        }
        return true;
      }
      function isEarHashed(ear, minX, minY, size) {
        const a = ear.prev;
        const b = ear;
        const c = ear.next;
        if (area(a, b, c) >= 0) {
          return false;
        }
        const minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x;
        const minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y;
        const maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x;
        const maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y;
        const minZ = zOrder(minTX, minTY, minX, minY, size);
        const maxZ = zOrder(maxTX, maxTY, minX, minY, size);
        let p = ear.nextZ;
        while (p && p.z <= maxZ) {
          if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) {
            return false;
          }
          p = p.nextZ;
        }
        p = ear.prevZ;
        while (p && p.z >= minZ) {
          if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) {
            return false;
          }
          p = p.prevZ;
        }
        return true;
      }
      function cureLocalIntersections(start, triangles, dim) {
        let p = start;
        do {
          const a = p.prev;
          const b = p.next.next;
          if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
            triangles.push(a.i / dim);
            triangles.push(p.i / dim);
            triangles.push(b.i / dim);
            removeNode(p);
            removeNode(p.next);
            p = start = b;
          }
          p = p.next;
        } while (p !== start);
        return p;
      }
      function splitEarcut(start, triangles, dim, minX, minY, size) {
        let a = start;
        do {
          let b = a.next.next;
          while (b !== a.prev) {
            if (a.i !== b.i && isValidDiagonal(a, b)) {
              let c = splitPolygon(a, b);
              a = filterPoints(a, a.next);
              c = filterPoints(c, c.next);
              earcutLinked(a, triangles, dim, minX, minY, size);
              earcutLinked(c, triangles, dim, minX, minY, size);
              return;
            }
            b = b.next;
          }
          a = a.next;
        } while (a !== start);
      }
      function eliminateHoles(datas, holeIndices, outerNode, dim) {
        const queue = [];
        let i = 0;
        let len = 0;
        let start = 0;
        let end = 0;
        let list = null;
        for (i = 0, len = holeIndices.length; i < len; i++) {
          start = holeIndices[i] * dim;
          end = i < len - 1 ? holeIndices[i + 1] * dim : datas.length;
          list = linkedList(datas, start, end, dim, false);
          if (!list) {
            continue;
          }
          if (list === list.next) {
            list.steiner = true;
          }
          queue.push(getLeftmost(list));
        }
        queue.sort(compareX);
        if (!outerNode) {
          return outerNode;
        }
        for (i = 0; i < queue.length; i++) {
          eliminateHole(queue[i], outerNode);
          outerNode = filterPoints(outerNode, outerNode.next);
        }
        return outerNode;
      }
      function compareX(a, b) {
        return a.x - b.x;
      }
      function eliminateHole(hole, outerNode) {
        outerNode = findHoleBridge(hole, outerNode);
        if (outerNode) {
          const b = splitPolygon(outerNode, hole);
          filterPoints(b, b.next);
        }
      }
      function findHoleBridge(hole, outerNode) {
        let p = outerNode;
        const hx = hole.x;
        const hy = hole.y;
        let qx = -Infinity;
        let m = null;
        do {
          if (hy <= p.y && hy >= p.next.y) {
            const x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
              qx = x;
              if (x === hx) {
                if (hy === p.y) {
                  return p;
                }
                if (hy === p.next.y) {
                  return p.next;
                }
              }
              m = p.x < p.next.x ? p : p.next;
            }
          }
          p = p.next;
        } while (p !== outerNode);
        if (!m) {
          return null;
        }
        if (hx === qx) {
          return m.prev;
        }
        const stop = m;
        const mx = m.x;
        const my = m.y;
        let tanMin = Infinity;
        let tan;
        p = m.next;
        while (p !== stop) {
          if (hx >= p.x && p.x >= mx && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
            tan = Math.abs(hy - p.y) / (hx - p.x);
            if ((tan < tanMin || tan === tanMin && p.x > m.x) && locallyInside(p, hole)) {
              m = p;
              tanMin = tan;
            }
          }
          p = p.next;
        }
        return m;
      }
      function indexCurve(start, minX, minY, size) {
        let p = start;
        do {
          if (p.z === null) {
            p.z = zOrder(p.x, p.y, minX, minY, size);
          }
          p.prevZ = p.prev;
          p.nextZ = p.next;
          p = p.next;
        } while (p !== start);
        p.prevZ.nextZ = null;
        p.prevZ = null;
        sortLinked(p);
      }
      function sortLinked(list) {
        let i = 0;
        let p = null;
        let q = null;
        let e = null;
        let tail = null;
        let numMerges = 0;
        let pSize = 0;
        let qSize = 0;
        let inSize = 1;
        do {
          p = list;
          list = null;
          tail = null;
          numMerges = 0;
          while (p) {
            numMerges++;
            q = p;
            pSize = 0;
            for (i = 0; i < inSize; i++) {
              pSize++;
              q = q.nextZ;
              if (!q) {
                break;
              }
            }
            qSize = inSize;
            while (pSize > 0 || qSize > 0 && q) {
              if (pSize === 0) {
                e = q;
                q = q.nextZ;
                qSize--;
              } else if (qSize === 0 || !q) {
                e = p;
                p = p.nextZ;
                pSize--;
              } else if (p.z <= q.z) {
                e = p;
                p = p.nextZ;
                pSize--;
              } else {
                e = q;
                q = q.nextZ;
                qSize--;
              }
              if (tail) {
                tail.nextZ = e;
              } else {
                list = e;
              }
              e.prevZ = tail;
              tail = e;
            }
            p = q;
          }
          tail.nextZ = null;
          inSize *= 2;
        } while (numMerges > 1);
        return list;
      }
      function zOrder(x, y, minX, minY, size) {
        x = 32767 * (x - minX) / size;
        y = 32767 * (y - minY) / size;
        x = (x | x << 8) & 0x00FF00FF;
        x = (x | x << 4) & 0x0F0F0F0F;
        x = (x | x << 2) & 0x33333333;
        x = (x | x << 1) & 0x55555555;
        y = (y | y << 8) & 0x00FF00FF;
        y = (y | y << 4) & 0x0F0F0F0F;
        y = (y | y << 2) & 0x33333333;
        y = (y | y << 1) & 0x55555555;
        return x | y << 1;
      }
      function getLeftmost(start) {
        let p = start;
        let leftmost = start;
        do {
          if (p.x < leftmost.x) {
            leftmost = p;
          }
          p = p.next;
        } while (p !== start);
        return leftmost;
      }
      function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
        return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
      }
      function isValidDiagonal(a, b) {
        return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);
      }
      function area(p, q, r) {
        return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
      }
      function equals(p1, p2) {
        return p1.x === p2.x && p1.y === p2.y;
      }
      function intersects(p1, q1, p2, q2) {
        if (equals(p1, q1) && equals(p2, q2) || equals(p1, q2) && equals(p2, q1)) {
          return true;
        }
        return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 && area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;
      }
      function intersectsPolygon(a, b) {
        let p = a;
        do {
          if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) {
            return true;
          }
          p = p.next;
        } while (p !== a);
        return false;
      }
      function locallyInside(a, b) {
        return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
      }
      function middleInside(a, b) {
        let p = a;
        let inside = false;
        const px = (a.x + b.x) / 2;
        const py = (a.y + b.y) / 2;
        do {
          if (p.y > py !== p.next.y > py && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) {
            inside = !inside;
          }
          p = p.next;
        } while (p !== a);
        return inside;
      }
      function splitPolygon(a, b) {
        const a2 = new Aim(a.i, a.x, a.y);
        const b2 = new Aim(b.i, b.x, b.y);
        const an = a.next;
        const bp = b.prev;
        a.next = b;
        b.prev = a;
        a2.next = an;
        an.prev = a2;
        b2.next = a2;
        a2.prev = b2;
        bp.next = b2;
        b2.prev = bp;
        return b2;
      }
      function insertNode(i, x, y, last) {
        const p = new Aim(i, x, y);
        if (!last) {
          p.prev = p;
          p.next = p;
        } else {
          p.next = last.next;
          p.prev = last;
          last.next.prev = p;
          last.next = p;
        }
        return p;
      }
      function removeNode(p) {
        p.next.prev = p.prev;
        p.prev.next = p.next;
        if (p.prevZ) {
          p.prevZ.nextZ = p.nextZ;
        }
        if (p.nextZ) {
          p.nextZ.prevZ = p.prevZ;
        }
      }
      function signedArea(datas, start, end, dim) {
        let sum = 0;
        for (let i = start, j = end - dim; i < end; i += dim) {
          sum += (datas[j] - datas[i]) * (datas[i + 1] + datas[j + 1]);
          j = i;
        }
        return sum;
      }
      function earcut(datas, holeIndices, dim) {
        dim = dim || 3;
        const hasHoles = holeIndices ? holeIndices.length : 0;
        const outerLen = hasHoles ? holeIndices[0] * dim : datas.length;
        let outerNode = linkedList(datas, 0, outerLen, dim, true);
        const triangles = [];
        if (!outerNode) {
          return triangles;
        }
        let minX = 0;
        let minY = 0;
        let maxX = 0;
        let maxY = 0;
        let x = 0;
        let y = 0;
        let size = 0;
        if (hasHoles) {
          outerNode = eliminateHoles(datas, holeIndices, outerNode, dim);
        }
        if (datas.length > 80 * dim) {
          minX = maxX = datas[0];
          minY = maxY = datas[1];
          for (let i = dim; i < outerLen; i += dim) {
            x = datas[i];
            y = datas[i + 1];
            if (x < minX) {
              minX = x;
            }
            if (y < minY) {
              minY = y;
            }
            if (x > maxX) {
              maxX = x;
            }
            if (y > maxY) {
              maxY = y;
            }
          }
          size = Math.max(maxX - minX, maxY - minY);
        }
        earcutLinked(outerNode, triangles, dim, minX, minY, size);
        return triangles;
      }

      const MAX_VERTEX = 65535;
      const MAX_INDICES = MAX_VERTEX * 2;
      const PI = Math.PI;
      const min = Math.min;
      const max = Math.max;
      const ceil = Math.ceil;
      const acos = Math.acos;
      const cos = Math.cos;
      const sin = Math.sin;
      const atan2 = Math.atan2;
      const attrBytes = 8;
      let _renderData = null;
      let _impl = null;
      const _curColor = new Color$1();
      const vec3_temps = [];
      for (let i = 0; i < 4; i++) {
        vec3_temps.push(new Vec3());
      }
      function curveDivs(r, arc, tol) {
        const da = acos(r / (r + tol)) * 2.0;
        return max(2, ceil(arc / da));
      }
      function clamp(v, minNum, maxNum) {
        if (v < minNum) {
          return minNum;
        } else if (v > maxNum) {
          return maxNum;
        }
        return v;
      }
      const graphicsAssembler = {
        useModel: true,
        updateRenderData(graphics) {
          {
            if (graphics.renderData) {
              graphics.renderData.material = graphics.getMaterialInstance(0);
            }
          }
        },
        fillBuffers(graphics, renderer) {},
        renderIA(graphics, renderer) {},
        getRenderData(graphics, vertexCount) {
          if (!_impl) {
            return null;
          }
          const renderDataList = _impl.getRenderDataList();
          let renderData = renderDataList[_impl.dataOffset];
          if (!renderData) {
            return null;
          }
          let meshBuffer = renderData;
          const maxVertexCount = meshBuffer ? meshBuffer.vertexStart + vertexCount : 0;
          if (maxVertexCount > MAX_VERTEX || maxVertexCount * 3 > MAX_INDICES) {
            ++_impl.dataOffset;
            if (_impl.dataOffset < renderDataList.length) {
              renderData = renderDataList[_impl.dataOffset];
            } else {
              renderData = _impl.requestRenderData();
              renderDataList[_impl.dataOffset] = renderData;
            }
            meshBuffer = renderData;
          }
          if (meshBuffer && meshBuffer.vertexCount < maxVertexCount) {
            meshBuffer.request(vertexCount, vertexCount * 3);
          }
          return renderData;
        },
        stroke(graphics) {
          Color$1.copy(_curColor, graphics.strokeColor);
          if (!graphics.impl) {
            return;
          }
          this._flattenPaths(graphics.impl);
          this._expandStroke(graphics);
          graphics.impl.updatePathOffset = true;
          this.end(graphics);
        },
        fill(graphics) {
          Color$1.copy(_curColor, graphics.fillColor);
          this._expandFill(graphics);
          if (graphics.impl) {
            graphics.impl.updatePathOffset = true;
          }
          this.end(graphics);
        },
        end(graphics) {
          graphics.markForUpdateRenderData();
        },
        _expandStroke(graphics) {
          const w = graphics.lineWidth * 0.5;
          const lineCap = graphics.lineCap;
          const lineJoin = graphics.lineJoin;
          const miterLimit = graphics.miterLimit;
          _impl = graphics.impl;
          if (!_impl) {
            return;
          }
          const nCap = curveDivs(w, PI, _impl.tessTol);
          this._calculateJoins(_impl, w, lineJoin, miterLimit);
          const paths = _impl.paths;
          let vertexCount = 0;
          for (let i = _impl.pathOffset, l = _impl.pathLength; i < l; i++) {
            const path = paths[i];
            const pointsLength = path.points.length;
            if (lineJoin === LineJoin.ROUND) {
              vertexCount += (pointsLength + path.bevel * (nCap + 2) + 1) * 2;
            } else {
              vertexCount += (pointsLength + path.bevel * 5 + 1) * 2;
            }
            if (!path.closed) {
              if (lineCap === LineCap.ROUND) {
                vertexCount += (nCap * 2 + 2) * 2;
              } else {
                vertexCount += (3 + 3) * 2;
              }
            }
          }
          const meshBuffer = _renderData = this.getRenderData(graphics, vertexCount);
          if (!meshBuffer) {
            return;
          }
          const vData = meshBuffer.vData;
          const iData = meshBuffer.iData;
          for (let i = _impl.pathOffset, l = _impl.pathLength; i < l; i++) {
            const path = paths[i];
            const pts = path.points;
            const pointsLength = pts.length;
            const offset = meshBuffer.vertexStart;
            let p0;
            let p1;
            let start = 0;
            let end = 0;
            const loop = path.closed;
            if (loop) {
              p0 = pts[pointsLength - 1];
              p1 = pts[0];
              start = 0;
              end = pointsLength;
            } else {
              p0 = pts[0];
              p1 = pts[1];
              start = 1;
              end = pointsLength - 1;
            }
            p1 = p1 || p0;
            if (!loop) {
              const dPos = new Point$1(p1.x, p1.y);
              dPos.subtract(p0);
              dPos.normalize();
              const dx = dPos.x;
              const dy = dPos.y;
              if (lineCap === LineCap.BUTT) {
                this._buttCapStart(p0, dx, dy, w, 0);
              } else if (lineCap === LineCap.SQUARE) {
                this._buttCapStart(p0, dx, dy, w, w);
              } else if (lineCap === LineCap.ROUND) {
                this._roundCapStart(p0, dx, dy, w, nCap);
              }
            }
            for (let j = start; j < end; ++j) {
              if (lineJoin === LineJoin.ROUND) {
                this._roundJoin(p0, p1, w, w, nCap);
              } else if ((p1.flags & (PointFlags.PT_BEVEL | PointFlags.PT_INNERBEVEL)) !== 0) {
                this._bevelJoin(p0, p1, w, w);
              } else {
                this._vSet(p1.x + p1.dmx * w, p1.y + p1.dmy * w, 1);
                this._vSet(p1.x - p1.dmx * w, p1.y - p1.dmy * w, -1);
              }
              p0 = p1;
              p1 = pts[j + 1];
            }
            if (loop) {
              const vDataOffset = offset * attrBytes;
              this._vSet(vData[vDataOffset], vData[vDataOffset + 1], 1);
              this._vSet(vData[vDataOffset + attrBytes], vData[vDataOffset + attrBytes + 1], -1);
            } else {
              const dPos = new Point$1(p1.x, p1.y);
              dPos.subtract(p0);
              dPos.normalize();
              const dx = dPos.x;
              const dy = dPos.y;
              if (lineCap === LineCap.BUTT) {
                this._buttCapEnd(p1, dx, dy, w, 0);
              } else if (lineCap === LineCap.SQUARE) {
                this._buttCapEnd(p1, dx, dy, w, w);
              } else if (lineCap === LineCap.ROUND) {
                this._roundCapEnd(p1, dx, dy, w, nCap);
              }
            }
            let indicesOffset = meshBuffer.indexStart;
            for (let begin = offset + 2, over = meshBuffer.vertexStart; begin < over; begin++) {
              iData[indicesOffset++] = begin - 2;
              iData[indicesOffset++] = begin - 1;
              iData[indicesOffset++] = begin;
            }
            meshBuffer.indexStart = indicesOffset;
          }
          _renderData = null;
          _impl = null;
        },
        _expandFill(graphics) {
          _impl = graphics.impl;
          if (!_impl) {
            return;
          }
          const paths = _impl.paths;
          let vertexCount = 0;
          for (let i = _impl.pathOffset, l = _impl.pathLength; i < l; i++) {
            const path = paths[i];
            const pointsLength = path.points.length;
            vertexCount += pointsLength;
          }
          const renderData = _renderData = this.getRenderData(graphics, vertexCount);
          if (!renderData) {
            return;
          }
          const meshBuffer = renderData;
          const vData = meshBuffer.vData;
          const iData = meshBuffer.iData;
          for (let i = _impl.pathOffset, l = _impl.pathLength; i < l; i++) {
            const path = paths[i];
            const pts = path.points;
            const pointsLength = pts.length;
            if (pointsLength === 0) {
              continue;
            }
            const vertexOffset = renderData.vertexStart;
            for (let j = 0; j < pointsLength; ++j) {
              this._vSet(pts[j].x, pts[j].y);
            }
            let indicesOffset = renderData.indexStart;
            if (path.complex) {
              const earcutData = [];
              for (let j = vertexOffset, end = renderData.vertexStart; j < end; j++) {
                let vDataOffset = j * attrBytes;
                earcutData.push(vData[vDataOffset++]);
                earcutData.push(vData[vDataOffset++]);
                earcutData.push(vData[vDataOffset++]);
              }
              const newIndices = earcut(earcutData, null, 3);
              if (!newIndices || newIndices.length === 0) {
                continue;
              }
              for (let j = 0, nIndices = newIndices.length; j < nIndices; j++) {
                iData[indicesOffset++] = newIndices[j] + vertexOffset;
              }
            } else {
              const first = vertexOffset;
              for (let start = vertexOffset + 2, end = meshBuffer.vertexStart; start < end; start++) {
                iData[indicesOffset++] = first;
                iData[indicesOffset++] = start - 1;
                iData[indicesOffset++] = start;
              }
            }
            meshBuffer.indexStart = indicesOffset;
          }
          _renderData = null;
          _impl = null;
        },
        _calculateJoins(impl, w, lineJoin, miterLimit) {
          let iw = 0.0;
          if (w > 0.0) {
            iw = 1 / w;
          }
          const paths = impl.paths;
          for (let i = impl.pathOffset, l = impl.pathLength; i < l; i++) {
            const path = paths[i];
            const pts = path.points;
            const ptsLength = pts.length;
            let p0 = pts[ptsLength - 1];
            let p1 = pts[0];
            path.bevel = 0;
            for (let j = 0; j < ptsLength; j++) {
              let dmr2 = 0;
              let cross = 0;
              let limit = 0;
              const dlx0 = p0.dy;
              const dly0 = -p0.dx;
              const dlx1 = p1.dy;
              const dly1 = -p1.dx;
              p1.dmx = (dlx0 + dlx1) * 0.5;
              p1.dmy = (dly0 + dly1) * 0.5;
              dmr2 = p1.dmx * p1.dmx + p1.dmy * p1.dmy;
              if (dmr2 > 0.000001) {
                let scale = 1 / dmr2;
                if (scale > 600) {
                  scale = 600;
                }
                p1.dmx *= scale;
                p1.dmy *= scale;
              }
              cross = p1.dx * p0.dy - p0.dx * p1.dy;
              if (cross > 0) {
                p1.flags |= PointFlags.PT_LEFT;
              }
              limit = max(11, min(p0.len, p1.len) * iw);
              if (dmr2 * limit * limit < 1) {
                p1.flags |= PointFlags.PT_INNERBEVEL;
              }
              if (p1.flags & PointFlags.PT_CORNER) {
                if (dmr2 * miterLimit * miterLimit < 1 || lineJoin === LineJoin.BEVEL || lineJoin === LineJoin.ROUND) {
                  p1.flags |= PointFlags.PT_BEVEL;
                }
              }
              if ((p1.flags & (PointFlags.PT_BEVEL | PointFlags.PT_INNERBEVEL)) !== 0) {
                path.bevel++;
              }
              p0 = p1;
              p1 = pts[j + 1];
            }
          }
        },
        _flattenPaths(impl) {
          const paths = impl.paths;
          for (let i = impl.pathOffset, l = impl.pathLength; i < l; i++) {
            const path = paths[i];
            const pts = path.points;
            let p0 = pts[pts.length - 1];
            let p1 = pts[0];
            if (pts.length > 2 && p0.equals(p1)) {
              path.closed = true;
              pts.pop();
              p0 = pts[pts.length - 1];
            }
            for (let j = 0, size = pts.length; j < size; j++) {
              const dPos = new Point$1(p1.x, p1.y);
              dPos.subtract(p0);
              p0.len = dPos.length();
              if (dPos.x || dPos.y) {
                dPos.normalize();
              }
              p0.dx = dPos.x;
              p0.dy = dPos.y;
              p0 = p1;
              p1 = pts[j + 1];
            }
          }
        },
        _chooseBevel(bevel, p0, p1, w) {
          const x = p1.x;
          const y = p1.y;
          let x0 = 0;
          let y0 = 0;
          let x1 = 0;
          let y1 = 0;
          if (bevel !== 0) {
            x0 = x + p0.dy * w;
            y0 = y - p0.dx * w;
            x1 = x + p1.dy * w;
            y1 = y - p1.dx * w;
          } else {
            x0 = x1 = x + p1.dmx * w;
            y0 = y1 = y + p1.dmy * w;
          }
          return [x0, y0, x1, y1];
        },
        _buttCapStart(p, dx, dy, w, d) {
          const px = p.x - dx * d;
          const py = p.y - dy * d;
          const dlx = dy;
          const dly = -dx;
          this._vSet(px + dlx * w, py + dly * w, 1);
          this._vSet(px - dlx * w, py - dly * w, -1);
        },
        _buttCapEnd(p, dx, dy, w, d) {
          const px = p.x + dx * d;
          const py = p.y + dy * d;
          const dlx = dy;
          const dly = -dx;
          this._vSet(px + dlx * w, py + dly * w, 1);
          this._vSet(px - dlx * w, py - dly * w, -1);
        },
        _roundCapStart(p, dx, dy, w, nCap) {
          const px = p.x;
          const py = p.y;
          const dlx = dy;
          const dly = -dx;
          for (let i = 0; i < nCap; i++) {
            const a = i / (nCap - 1) * PI;
            const ax = cos(a) * w;
            const ay = sin(a) * w;
            this._vSet(px - dlx * ax - dx * ay, py - dly * ax - dy * ay, 1);
            this._vSet(px, py, 0);
          }
          this._vSet(px + dlx * w, py + dly * w, 1);
          this._vSet(px - dlx * w, py - dly * w, -1);
        },
        _roundCapEnd(p, dx, dy, w, nCap) {
          const px = p.x;
          const py = p.y;
          const dlx = dy;
          const dly = -dx;
          this._vSet(px + dlx * w, py + dly * w, 1);
          this._vSet(px - dlx * w, py - dly * w, -1);
          for (let i = 0; i < nCap; i++) {
            const a = i / (nCap - 1) * PI;
            const ax = cos(a) * w;
            const ay = sin(a) * w;
            this._vSet(px, py, 0);
            this._vSet(px - dlx * ax + dx * ay, py - dly * ax + dy * ay, 1);
          }
        },
        _roundJoin(p0, p1, lw, rw, nCap) {
          const dlx0 = p0.dy;
          const dly0 = -p0.dx;
          const dlx1 = p1.dy;
          const dly1 = -p1.dx;
          const p1x = p1.x;
          const p1y = p1.y;
          if ((p1.flags & PointFlags.PT_LEFT) !== 0) {
            const out = this._chooseBevel(p1.flags & PointFlags.PT_INNERBEVEL, p0, p1, lw);
            const lx0 = out[0];
            const ly0 = out[1];
            const lx1 = out[2];
            const ly1 = out[3];
            const a0 = atan2(-dly0, -dlx0);
            let a1 = atan2(-dly1, -dlx1);
            if (a1 > a0) {
              a1 -= PI * 2;
            }
            this._vSet(lx0, ly0, 1);
            this._vSet(p1x - dlx0 * rw, p1.y - dly0 * rw, -1);
            const n = clamp(ceil((a0 - a1) / PI) * nCap, 2, nCap);
            for (let i = 0; i < n; i++) {
              const u = i / (n - 1);
              const a = a0 + u * (a1 - a0);
              const rx = p1x + cos(a) * rw;
              const ry = p1y + sin(a) * rw;
              this._vSet(p1x, p1y, 0);
              this._vSet(rx, ry, -1);
            }
            this._vSet(lx1, ly1, 1);
            this._vSet(p1x - dlx1 * rw, p1y - dly1 * rw, -1);
          } else {
            const out = this._chooseBevel(p1.flags & PointFlags.PT_INNERBEVEL, p0, p1, -rw);
            const rx0 = out[0];
            const ry0 = out[1];
            const rx1 = out[2];
            const ry1 = out[3];
            const a0 = atan2(dly0, dlx0);
            let a1 = atan2(dly1, dlx1);
            if (a1 < a0) {
              a1 += PI * 2;
            }
            this._vSet(p1x + dlx0 * rw, p1y + dly0 * rw, 1);
            this._vSet(rx0, ry0, -1);
            const n = clamp(ceil((a1 - a0) / PI) * nCap, 2, nCap);
            for (let i = 0; i < n; i++) {
              const u = i / (n - 1);
              const a = a0 + u * (a1 - a0);
              const lx = p1x + cos(a) * lw;
              const ly = p1y + sin(a) * lw;
              this._vSet(lx, ly, 1);
              this._vSet(p1x, p1y, 0);
            }
            this._vSet(p1x + dlx1 * rw, p1y + dly1 * rw, 1);
            this._vSet(rx1, ry1, -1);
          }
        },
        _bevelJoin(p0, p1, lw, rw) {
          let rx0 = 0;
          let ry0 = 0;
          let rx1 = 0;
          let ry1 = 0;
          let lx0 = 0;
          let ly0 = 0;
          let lx1 = 0;
          let ly1 = 0;
          const dlx0 = p0.dy;
          const dly0 = -p0.dx;
          const dlx1 = p1.dy;
          const dly1 = -p1.dx;
          if (p1.flags & PointFlags.PT_LEFT) {
            const out = this._chooseBevel(p1.flags & PointFlags.PT_INNERBEVEL, p0, p1, lw);
            lx0 = out[0];
            ly0 = out[1];
            lx1 = out[2];
            ly1 = out[3];
            this._vSet(lx0, ly0, 1);
            this._vSet(p1.x - dlx0 * rw, p1.y - dly0 * rw, -1);
            this._vSet(lx1, ly1, 1);
            this._vSet(p1.x - dlx1 * rw, p1.y - dly1 * rw, -1);
          } else {
            const out = this._chooseBevel(p1.flags & PointFlags.PT_INNERBEVEL, p0, p1, -rw);
            rx0 = out[0];
            ry0 = out[1];
            rx1 = out[2];
            ry1 = out[3];
            this._vSet(p1.x + dlx0 * lw, p1.y + dly0 * lw, 1);
            this._vSet(rx0, ry0, -1);
            this._vSet(p1.x + dlx1 * lw, p1.y + dly1 * lw, 1);
            this._vSet(rx1, ry1, -1);
          }
        },
        _vSet(x, y, distance = 0) {
          if (!_renderData) {
            return;
          }
          const meshBuffer = _renderData;
          let dataOffset = meshBuffer.vertexStart * attrBytes;
          const vData = meshBuffer.vData;
          vData[dataOffset++] = x;
          vData[dataOffset++] = y;
          vData[dataOffset++] = 0;
          Color$1.toArray(vData, _curColor, dataOffset);
          dataOffset += 4;
          vData[dataOffset++] = distance;
          meshBuffer.vertexStart++;
        }
      };

      const graphicsAssemblerManager = exports('graphicsAssembler', {
        getAssembler(sprite) {
          return graphicsAssembler;
        }
      });
      Graphics.Assembler = graphicsAssemblerManager;

      const Alignment = ['left', 'center', 'right'];
      const MAX_SIZE = 2048;
      const _BASELINE_OFFSET = getBaselineOffset();
      const _invisibleAlpha = (1 / 255).toFixed(3);
      const MAX_CALCULATION_NUM = 3;
      class LetterInfo {
        constructor() {
          this.char = '';
          this.valid = true;
          this.x = 0;
          this.y = 0;
          this.line = 0;
          this.hash = '';
        }
      }
      class TextProcessing {
        constructor() {
          this._context = null;
          this._canvas = null;
          this._canvasData = null;
          this._lettersInfo = [];
          this._tmpRect = new Rect$1();
          this._maxFontSize = 100;
          this._fontScale = 1;
          this._canvasData = CanvasPool.getInstance().get();
          this._canvas = this._canvasData.canvas;
          this._context = this._canvasData.context;
        }
        destroy() {
          CanvasPool.getInstance().put(this._canvasData);
          this._lettersInfo.length = 0;
        }
        processingString(isBmFont, style, layout, outputLayoutData, inputString, out) {
          if (!isBmFont) {
            let loopTime = 0;
            this._fontScale = this._getStyleFontScale(style.fontSize, style.fontScale);
            this._updatePaddingRect(style, outputLayoutData);
            this._calculateLabelFont(style, layout, outputLayoutData, inputString);
            while ((outputLayoutData.canvasSize.width > MAX_SIZE || outputLayoutData.canvasSize.height > MAX_SIZE) && loopTime <= MAX_CALCULATION_NUM) {
              loopTime++;
              if (loopTime > MAX_CALCULATION_NUM) {
                this._fontScale = 1;
              } else {
                const maxValue = Math.max(outputLayoutData.canvasSize.width, outputLayoutData.canvasSize.height);
                const canvasScaleToMaxSizeRatio = MAX_SIZE / maxValue;
                this._fontScale *= canvasScaleToMaxSizeRatio;
                this._fontScale = Math.max(1, this._fontScale);
              }
              this._updatePaddingRect(style, outputLayoutData);
              this._calculateLabelFont(style, layout, outputLayoutData, inputString);
            }
          } else {
            if (!style.fntConfig) {
              this._fontScale = this._getStyleFontScale(style.originFontSize, style.fontScale);
            } else {
              this._fontScale = 1;
            }
            shareLabelInfo.fontScale = this._fontScale;
            this._setupBMFontOverflowMetrics(layout, outputLayoutData);
            this._updateFontScale(style);
            this._computeHorizontalKerningForText(style, layout, inputString);
            this._alignText(style, layout, outputLayoutData, inputString);
          }
          if (out) {
            out = outputLayoutData.parsedString;
          }
        }
        generateRenderInfo(isBmFont, style, layout, outputLayoutData, outputRenderData, inputString, callback) {
          if (!isBmFont) {
            this._updateLabelDimensions(style, layout, outputLayoutData);
            this._updateTexture(style, layout, outputLayoutData, outputRenderData);
            this.generateVertexData(isBmFont, style, layout, outputLayoutData, outputRenderData, inputString, callback);
          } else {
            this._computeAlignmentOffset(style, layout, outputLayoutData);
            this.generateVertexData(isBmFont, style, layout, outputLayoutData, outputRenderData, inputString, callback);
          }
        }
        setCanvasUsed(canvas, content) {
          this._canvas = canvas;
          this._context = content;
        }
        _getStyleFontScale(fontSize, fontScale) {
          let scale = fontScale;
          if (scale * fontSize > this._maxFontSize && fontSize < this._maxFontSize) {
            scale = this._maxFontSize / fontSize;
          }
          if (scale < 1) {
            scale = 1;
          }
          return scale;
        }
        _calculateLabelFont(style, layout, outputLayoutData, inputString) {
          if (!this._context) {
            return;
          }
          style.actualFontSize = style.fontSize * this._fontScale;
          const paragraphedStrings = inputString.split('\n');
          const _splitStrings = outputLayoutData.parsedString = paragraphedStrings;
          const _fontDesc = this._getFontDesc(style.actualFontSize, style.fontFamily, style.isBold, style.isItalic);
          this._context.font = style.fontDesc = _fontDesc;
          switch (layout.overFlow) {
            case Overflow$1.NONE:
              {
                let canvasSizeX = 0;
                let canvasSizeY = 0;
                for (let i = 0; i < paragraphedStrings.length; ++i) {
                  const paraLength = safeMeasureText(this._context, paragraphedStrings[i], _fontDesc);
                  canvasSizeX = canvasSizeX > paraLength ? canvasSizeX : paraLength;
                }
                canvasSizeY = (_splitStrings.length + BASELINE_RATIO) * this._getLineHeight(layout.lineHeight, style.actualFontSize, style.fontSize);
                const rawWidth = canvasSizeX;
                const rawHeight = canvasSizeY;
                outputLayoutData.canvasSize.width = rawWidth + outputLayoutData.canvasPadding.width * this._fontScale;
                outputLayoutData.canvasSize.height = rawHeight + outputLayoutData.canvasPadding.height * this._fontScale;
                outputLayoutData.nodeContentSize.width = (rawWidth + outputLayoutData.contentSizeExtend.width * this._fontScale) / this._fontScale;
                outputLayoutData.nodeContentSize.height = (rawHeight + outputLayoutData.contentSizeExtend.height * this._fontScale) / this._fontScale;
                break;
              }
            case Overflow$1.SHRINK:
              {
                this._calculateShrinkFont(paragraphedStrings, style, layout, outputLayoutData);
                this._calculateWrapText(paragraphedStrings, style, layout, outputLayoutData);
                outputLayoutData.canvasSize.width = outputLayoutData.nodeContentSize.width * this._fontScale;
                outputLayoutData.canvasSize.height = outputLayoutData.nodeContentSize.height * this._fontScale;
                break;
              }
            case Overflow$1.CLAMP:
              {
                this._calculateWrapText(paragraphedStrings, style, layout, outputLayoutData);
                outputLayoutData.canvasSize.width = outputLayoutData.nodeContentSize.width * this._fontScale;
                outputLayoutData.canvasSize.height = outputLayoutData.nodeContentSize.height * this._fontScale;
                break;
              }
            case Overflow$1.RESIZE_HEIGHT:
              {
                this._calculateWrapText(paragraphedStrings, style, layout, outputLayoutData);
                const rawHeight = (outputLayoutData.parsedString.length + BASELINE_RATIO) * this._getLineHeight(layout.lineHeight, style.actualFontSize, style.fontSize);
                outputLayoutData.canvasSize.width = outputLayoutData.nodeContentSize.width * this._fontScale;
                outputLayoutData.canvasSize.height = rawHeight + outputLayoutData.canvasPadding.height * this._fontScale;
                outputLayoutData.nodeContentSize.height = (rawHeight + outputLayoutData.contentSizeExtend.height * this._fontScale) / this._fontScale;
                break;
              }
          }
        }
        _getFontDesc(fontSize, fontFamily, isBold, isItalic) {
          let fontDesc = `${fontSize.toString()}px `;
          fontDesc += fontFamily;
          if (isBold) {
            fontDesc = `bold ${fontDesc}`;
          }
          if (isItalic) {
            fontDesc = `italic ${fontDesc}`;
          }
          return fontDesc;
        }
        _getLineHeight(lineHeight, fontSize, drawFontsize) {
          let nodeSpacingY = lineHeight;
          if (nodeSpacingY === 0) {
            nodeSpacingY = fontSize;
          } else {
            nodeSpacingY = nodeSpacingY * fontSize / drawFontsize;
          }
          return nodeSpacingY;
        }
        _calculateShrinkFont(paragraphedStrings, style, layout, outputLayoutData) {
          if (!this._context) return;
          let _fontDesc = this._getFontDesc(style.actualFontSize, style.fontFamily, style.isBold, style.isItalic);
          this._context.font = _fontDesc;
          const paragraphLength = this._calculateParagraphLength(paragraphedStrings, this._context, _fontDesc);
          let i = 0;
          let totalHeight = 0;
          let maxLength = 0;
          let _fontSize = style.actualFontSize;
          if (layout.wrapping) {
            const canvasWidthNoMargin = outputLayoutData.nodeContentSize.width * this._fontScale;
            const canvasHeightNoMargin = outputLayoutData.nodeContentSize.height * this._fontScale;
            if (canvasWidthNoMargin < 0 || canvasHeightNoMargin < 0) {
              return;
            }
            totalHeight = canvasHeightNoMargin + 1;
            const actualFontSize = style.actualFontSize + 1;
            let textFragment = [];
            let left = 0;
            let right = actualFontSize | 0;
            let mid = 0;
            while (left < right) {
              mid = left + right + 1 >> 1;
              if (mid <= 0) {
                logID(4003);
                break;
              }
              _fontSize = mid;
              _fontDesc = this._getFontDesc(_fontSize, style.fontFamily, style.isBold, style.isItalic);
              this._context.font = _fontDesc;
              const lineHeight = this._getLineHeight(layout.lineHeight, _fontSize, style.fontSize);
              totalHeight = 0;
              for (i = 0; i < paragraphedStrings.length; ++i) {
                const allWidth = safeMeasureText(this._context, paragraphedStrings[i], _fontDesc);
                textFragment = fragmentText(paragraphedStrings[i], allWidth, canvasWidthNoMargin, this._measureText(this._context, _fontDesc));
                totalHeight += textFragment.length * lineHeight;
              }
              if (totalHeight > canvasHeightNoMargin) {
                right = mid - 1;
              } else {
                left = mid;
              }
            }
            if (left === 0) {
              logID(4003);
            } else {
              _fontSize = left;
              _fontDesc = this._getFontDesc(_fontSize, style.fontFamily, style.isBold, style.isItalic);
              this._context.font = _fontDesc;
            }
          } else {
            totalHeight = paragraphedStrings.length * this._getLineHeight(layout.lineHeight, _fontSize, style.fontSize);
            for (i = 0; i < paragraphedStrings.length; ++i) {
              if (maxLength < paragraphLength[i]) {
                maxLength = paragraphLength[i];
              }
            }
            const scaleX = (outputLayoutData.canvasSize.width - outputLayoutData.canvasPadding.width) * this._fontScale / maxLength;
            const scaleY = outputLayoutData.canvasSize.height * this._fontScale / totalHeight;
            _fontSize = style.actualFontSize * Math.min(1, scaleX, scaleY) | 0;
            _fontDesc = this._getFontDesc(_fontSize, style.fontFamily, style.isBold, style.isItalic);
            this._context.font = _fontDesc;
          }
          style.actualFontSize = _fontSize;
          style.fontDesc = _fontDesc;
        }
        _calculateWrapText(paragraphedStrings, style, layout, outputLayoutData) {
          if (!layout.wrapping || !this._context) return;
          let _splitStrings = [];
          const canvasWidthNoMargin = outputLayoutData.nodeContentSize.width * this._fontScale;
          const _fontDesc = this._getFontDesc(style.actualFontSize, style.fontFamily, style.isBold, style.isItalic);
          this._context.font = _fontDesc;
          for (let i = 0; i < paragraphedStrings.length; ++i) {
            const allWidth = safeMeasureText(this._context, paragraphedStrings[i], _fontDesc);
            const textFragment = fragmentText(paragraphedStrings[i], allWidth, canvasWidthNoMargin, this._measureText(this._context, _fontDesc));
            _splitStrings = _splitStrings.concat(textFragment);
          }
          outputLayoutData.parsedString = _splitStrings;
          style.fontDesc = _fontDesc;
        }
        _measureText(ctx, fontDesc) {
          return str => safeMeasureText(ctx, str, fontDesc);
        }
        _calculateParagraphLength(paragraphedStrings, ctx, fontDesc) {
          const paragraphLength = [];
          for (const para of paragraphedStrings) {
            const width = safeMeasureText(ctx, para, fontDesc);
            paragraphLength.push(width);
          }
          return paragraphLength;
        }
        _updatePaddingRect(style, outputLayoutData) {
          let top = 0;
          let bottom = 0;
          let left = 0;
          let right = 0;
          let outlineWidth = 0;
          outputLayoutData.contentSizeExtend.width = outputLayoutData.contentSizeExtend.height = 0;
          if (style.isOutlined) {
            outlineWidth = style.outlineWidth;
            top = bottom = left = right = outlineWidth;
            outputLayoutData.contentSizeExtend.width = outputLayoutData.contentSizeExtend.height = outlineWidth * 2;
          }
          if (style.hasShadow) {
            const shadowWidth = style.shadowBlur + outlineWidth;
            const offsetX = style.shadowOffsetX;
            const offsetY = style.shadowOffsetY;
            left = Math.max(left, -offsetX + shadowWidth);
            right = Math.max(right, offsetX + shadowWidth);
            top = Math.max(top, offsetY + shadowWidth);
            bottom = Math.max(bottom, -offsetY + shadowWidth);
          }
          if (style.isItalic) {
            const offset = style.fontSize * Math.tan(12 * 0.0174532925);
            right += offset;
            outputLayoutData.contentSizeExtend.width += offset;
          }
          outputLayoutData.canvasPadding.x = left;
          outputLayoutData.canvasPadding.y = top;
          outputLayoutData.canvasPadding.width = left + right;
          outputLayoutData.canvasPadding.height = top + bottom;
        }
        _updateLabelDimensions(style, layout, outputLayoutData) {
          outputLayoutData.canvasSize.width = Math.min(outputLayoutData.canvasSize.width, MAX_SIZE);
          outputLayoutData.canvasSize.height = Math.min(outputLayoutData.canvasSize.height, MAX_SIZE);
          this._canvas.width = outputLayoutData.canvasSize.width;
          this._canvas.height = outputLayoutData.canvasSize.height;
          this._context.font = style.fontDesc;
          this._context.textAlign = Alignment[layout.horizontalAlign];
          this._context.textBaseline = 'alphabetic';
        }
        _calculateFillTextStartPosition(style, layout, outputLayoutData) {
          let labelX = 0;
          if (layout.horizontalAlign === HorizontalTextAlignment.RIGHT) {
            labelX = outputLayoutData.canvasSize.width - outputLayoutData.canvasPadding.width;
          } else if (layout.horizontalAlign === HorizontalTextAlignment.CENTER) {
            labelX = (outputLayoutData.canvasSize.width - outputLayoutData.canvasPadding.width) / 2;
          }
          const lineHeight = this._getLineHeight(layout.lineHeight, style.actualFontSize, style.fontSize);
          const drawStartY = lineHeight * (outputLayoutData.parsedString.length - 1);
          let firstLinelabelY = style.actualFontSize * (1 - BASELINE_RATIO / 2);
          if (layout.verticalAlign !== VerticalTextAlignment.TOP) {
            let blank = drawStartY + outputLayoutData.canvasPadding.height + style.actualFontSize - outputLayoutData.canvasSize.height;
            if (layout.verticalAlign === VerticalTextAlignment.BOTTOM) {
              blank += BASELINE_RATIO / 2 * style.actualFontSize;
              firstLinelabelY -= blank;
            } else {
              firstLinelabelY -= blank / 2;
            }
          }
          firstLinelabelY += _BASELINE_OFFSET * style.actualFontSize;
          outputLayoutData.startPosition.set(labelX + outputLayoutData.canvasPadding.x, firstLinelabelY + outputLayoutData.canvasPadding.y);
        }
        _updateTexture(style, layout, outputLayoutData, outputRenderData) {
          if (!this._context || !this._canvas) {
            return;
          }
          this._context.clearRect(0, 0, this._canvas.width, this._canvas.height);
          this._context.font = style.fontDesc;
          this._calculateFillTextStartPosition(style, layout, outputLayoutData);
          const lineHeight = this._getLineHeight(layout.lineHeight, style.actualFontSize, style.fontSize);
          this._context.lineJoin = 'round';
          if (style.isOutlined) {
            this._context.fillStyle = `rgba(${style.outlineColor.r}, ${style.outlineColor.g}, ${style.outlineColor.b}, ${_invisibleAlpha})`;
            this._context.fillRect(0, 0, this._canvas.width, this._canvas.height);
          } else {
            this._context.fillStyle = `rgba(${style.color.r}, ${style.color.g}, ${style.color.b}, ${_invisibleAlpha})`;
            this._context.fillRect(0, 0, this._canvas.width, this._canvas.height);
          }
          this._context.fillStyle = `rgb(${style.color.r}, ${style.color.g}, ${style.color.b})`;
          const tempPos = new Vec2(outputLayoutData.startPosition.x, outputLayoutData.startPosition.y);
          const drawTextPosX = tempPos.x;
          let drawTextPosY = 0;
          this._drawTextEffect(tempPos, lineHeight, style, layout, outputLayoutData);
          for (let i = 0; i < outputLayoutData.parsedString.length; ++i) {
            drawTextPosY = tempPos.y + i * lineHeight;
            if (style.isOutlined) {
              this._context.strokeText(outputLayoutData.parsedString[i], drawTextPosX, drawTextPosY);
            }
            this._context.fillText(outputLayoutData.parsedString[i], drawTextPosX, drawTextPosY);
          }
          if (style.hasShadow) {
            this._context.shadowColor = 'transparent';
          }
          this._uploadTexture(outputRenderData);
        }
        _uploadTexture(outputRenderData) {
          if (outputRenderData.texture && this._canvas) {
            let tex;
            if (outputRenderData.texture instanceof SpriteFrame) {
              tex = outputRenderData.texture.texture;
            } else {
              tex = outputRenderData.texture;
            }
            const uploadAgain = this._canvas.width !== 0 && this._canvas.height !== 0;
            if (uploadAgain) {
              tex.reset({
                width: this._canvas.width,
                height: this._canvas.height,
                mipmapLevel: 1
              });
              tex.uploadData(this._canvas);
              tex.setWrapMode(WrapMode.CLAMP_TO_EDGE, WrapMode.CLAMP_TO_EDGE);
              if (outputRenderData.texture instanceof SpriteFrame) {
                outputRenderData.texture.rect = new Rect$1(0, 0, this._canvas.width, this._canvas.height);
                outputRenderData.texture._calculateUV();
              }
              if (legacyCC.director.root && legacyCC.director.root.batcher2D) {
                {
                  legacyCC.director.root.batcher2D._releaseDescriptorSetCache(tex.getGFXTexture(), tex.getGFXSampler());
                }
              }
            }
          }
        }
        _drawTextEffect(startPosition, lineHeight, style, layout, outputLayoutData) {
          if (!style.hasShadow && !style.isOutlined && !style.isUnderline) return;
          const isMultiple = outputLayoutData.parsedString.length > 1 && style.hasShadow;
          const measureText = this._measureText(this._context, style.fontDesc);
          let drawTextPosX = 0;
          let drawTextPosY = 0;
          if (style.hasShadow) {
            this._setupShadow(style);
          }
          if (style.isOutlined) {
            this._setupOutline(style);
          }
          for (let i = 0; i < outputLayoutData.parsedString.length; ++i) {
            drawTextPosX = startPosition.x;
            drawTextPosY = startPosition.y + i * lineHeight;
            if (isMultiple) {
              if (style.isOutlined) {
                this._context.strokeText(outputLayoutData.parsedString[i], drawTextPosX, drawTextPosY);
              }
              this._context.fillText(outputLayoutData.parsedString[i], drawTextPosX, drawTextPosY);
            }
            if (style.isUnderline) {
              const _drawUnderlineWidth = measureText(outputLayoutData.parsedString[i]);
              const _drawUnderlinePos = new Vec2();
              if (layout.horizontalAlign === HorizontalTextAlignment.RIGHT) {
                _drawUnderlinePos.x = startPosition.x - _drawUnderlineWidth;
              } else if (layout.horizontalAlign === HorizontalTextAlignment.CENTER) {
                _drawUnderlinePos.x = startPosition.x - _drawUnderlineWidth / 2;
              } else {
                _drawUnderlinePos.x = startPosition.x;
              }
              _drawUnderlinePos.y = drawTextPosY + style.actualFontSize / 8;
              this._context.fillRect(_drawUnderlinePos.x, _drawUnderlinePos.y, _drawUnderlineWidth, style.underlineHeight * this._fontScale);
            }
          }
          if (isMultiple) {
            this._context.shadowColor = 'transparent';
          }
        }
        _setupOutline(style) {
          this._context.strokeStyle = `rgba(${style.outlineColor.r}, ${style.outlineColor.g}, ${style.outlineColor.b}, ${style.outlineColor.a / 255})`;
          this._context.lineWidth = style.outlineWidth * 2 * this._fontScale;
        }
        _setupShadow(style) {
          const fontScale = this._fontScale;
          this._context.shadowColor = `rgba(${style.shadowColor.r}, ${style.shadowColor.g}, ${style.shadowColor.b}, ${style.shadowColor.a / 255})`;
          this._context.shadowBlur = style.shadowBlur * fontScale;
          this._context.shadowOffsetX = style.shadowOffsetX * fontScale;
          this._context.shadowOffsetY = -style.shadowOffsetY * fontScale;
        }
        generateVertexData(isBmFont, style, layout, outputLayoutData, outputRenderData, inputString, callback) {
          if (!isBmFont) {
            this.updateQuatCount(outputRenderData);
            callback(style, outputLayoutData, outputRenderData);
          } else {
            this._updateQuads(style, layout, outputLayoutData, outputRenderData, inputString, callback);
          }
        }
        updateQuatCount(outputRenderData) {
          const data = outputRenderData.vertexBuffer;
          const count = outputRenderData.quadCount;
          if (data.length !== count) {
            for (let i = data.length; i < count; i++) {
              data.push({
                x: 0,
                y: 0,
                z: 0,
                u: 0,
                v: 0,
                color: Color$1.WHITE.clone()
              });
            }
            data.length = count;
          }
        }
        _setupBMFontOverflowMetrics(layout, outputLayoutData) {
          let newWidth = outputLayoutData.nodeContentSize.width;
          let newHeight = outputLayoutData.nodeContentSize.height;
          if (layout.overFlow === Overflow$1.RESIZE_HEIGHT) {
            newHeight = 0;
          }
          if (layout.overFlow === Overflow$1.NONE) {
            newWidth = 0;
            newHeight = 0;
          }
          layout.textWidthTemp = newWidth;
          layout.textHeightTemp = newHeight;
          layout.textDimensions.width = newWidth;
          layout.textDimensions.height = newHeight;
          layout.maxLineWidth = newWidth;
        }
        _updateFontScale(style) {
          style.bmfontScale = style.actualFontSize / (style.originFontSize * this._fontScale);
        }
        _computeHorizontalKerningForText(style, layout, inputString) {
          const string = inputString;
          const stringLen = string.length;
          if (!style.fntConfig) return;
          const kerningDict = style.fntConfig.kerningDict;
          const horizontalKerning = layout.horizontalKerning;
          if (!kerningDict || kerningDict.length === 0) {
            return;
          }
          let prev = -1;
          for (let i = 0; i < stringLen; ++i) {
            const key = string.charCodeAt(i);
            const kerningAmount = kerningDict[prev << 16 | key & 0xffff] || 0;
            if (i < stringLen - 1) {
              horizontalKerning[i] = kerningAmount;
            } else {
              horizontalKerning[i] = 0;
            }
            prev = key;
          }
        }
        _alignText(style, layout, outputLayoutData, inputString) {
          this._multilineTextWrap(style, layout, outputLayoutData, inputString, this._getFirstWordLen);
          if (layout.overFlow === Overflow$1.SHRINK) {
            if (style.fontSize > 0 && this._isVerticalClamp(style, layout, outputLayoutData, inputString, this)) {
              this._shrinkLabelToContentSize(style, layout, outputLayoutData, inputString, this._isVerticalClamp);
            }
            if (style.fontSize > 0 && this._isHorizontalNeedShrink(layout, outputLayoutData)) {
              this._shrinkLabelToContentSize(style, layout, outputLayoutData, inputString, this._isHorizontalClamp);
            }
          }
          this._parsedString(outputLayoutData, inputString);
        }
        _parsedString(outputLayoutData, inputString) {
          let _splitStrings = [];
          let textFragment = '';
          for (let i = 0, line = 0, l = inputString.length; i < l; ++i) {
            const letterInfo = this._lettersInfo[i];
            if (!letterInfo.valid) {
              continue;
            }
            if (line === letterInfo.line) {
              textFragment += letterInfo.char;
            } else {
              _splitStrings = _splitStrings.concat(textFragment);
              line = letterInfo.line;
              textFragment = '';
            }
          }
          _splitStrings = _splitStrings.concat(textFragment);
          outputLayoutData.parsedString = _splitStrings;
        }
        _multilineTextWrap(style, layout, outputLayoutData, inputString, nextTokenFunc) {
          layout.linesWidth.length = 0;
          const _string = inputString;
          const textLen = _string.length;
          let lineIndex = 0;
          let nextTokenX = 0;
          let nextTokenY = 0;
          let longestLine = 0;
          let letterRight = 0;
          let highestY = 0;
          let lowestY = 0;
          let letterDef = null;
          const _lineSpacing = 0;
          for (let index = 0; index < textLen;) {
            let character = _string.charAt(index);
            if (character === '\n') {
              layout.linesWidth.push(letterRight);
              letterRight = 0;
              lineIndex++;
              nextTokenX = 0;
              nextTokenY -= layout.lineHeight * this._getFontScale(style, layout) + _lineSpacing;
              this._recordPlaceholderInfo(index, character);
              index++;
              continue;
            }
            const tokenLen = nextTokenFunc(style, layout, _string, index, textLen);
            let tokenHighestY = highestY;
            let tokenLowestY = lowestY;
            let tokenRight = letterRight;
            let nextLetterX = nextTokenX;
            let newLine = false;
            const letterPosition = new Vec2();
            for (let tmp = 0; tmp < tokenLen; ++tmp) {
              const letterIndex = index + tmp;
              character = _string.charAt(letterIndex);
              if (character === '\r') {
                this._recordPlaceholderInfo(letterIndex, character);
                continue;
              }
              letterDef = shareLabelInfo.fontAtlas.getLetterDefinitionForChar(character, shareLabelInfo);
              if (!letterDef) {
                this._recordPlaceholderInfo(letterIndex, character);
                log(`Can't find letter definition in texture atlas ${style.fntConfig.atlasName} for letter:${character}`);
                continue;
              }
              const letterX = nextLetterX + letterDef.offsetX * style.bmfontScale - shareLabelInfo.margin;
              if (layout.wrapping && layout.maxLineWidth > 0 && nextTokenX > 0 && letterX + letterDef.w * style.bmfontScale > layout.maxLineWidth && !isUnicodeSpace(character)) {
                layout.linesWidth.push(letterRight);
                letterRight = 0;
                lineIndex++;
                nextTokenX = 0;
                nextTokenY -= layout.lineHeight * this._getFontScale(style, layout) + _lineSpacing;
                newLine = true;
                break;
              } else {
                letterPosition.x = letterX;
              }
              letterPosition.y = nextTokenY - letterDef.offsetY * style.bmfontScale;
              this._recordLetterInfo(letterPosition, character, letterIndex, lineIndex);
              if (letterIndex + 1 < layout.horizontalKerning.length && letterIndex < textLen - 1) {
                nextLetterX += layout.horizontalKerning[letterIndex + 1] * style.bmfontScale;
              }
              nextLetterX += letterDef.xAdvance * style.bmfontScale + layout.spacingX;
              tokenRight = letterPosition.x + letterDef.w * style.bmfontScale;
              if (tokenHighestY < letterPosition.y) {
                tokenHighestY = letterPosition.y;
              }
              if (tokenLowestY > letterPosition.y - letterDef.h * style.bmfontScale) {
                tokenLowestY = letterPosition.y - letterDef.h * style.bmfontScale;
              }
            }
            if (newLine) {
              continue;
            }
            nextTokenX = nextLetterX;
            letterRight = tokenRight;
            if (highestY < tokenHighestY) {
              highestY = tokenHighestY;
            }
            if (lowestY > tokenLowestY) {
              lowestY = tokenLowestY;
            }
            if (longestLine < letterRight) {
              longestLine = letterRight;
            }
            index += tokenLen;
          }
          layout.linesWidth.push(letterRight);
          layout.numberOfLines = lineIndex + 1;
          layout.textDesiredHeight = layout.numberOfLines * layout.lineHeight * this._getFontScale(style, layout);
          if (layout.numberOfLines > 1) {
            layout.textDesiredHeight += (layout.numberOfLines - 1) * _lineSpacing;
          }
          outputLayoutData.nodeContentSize.width = layout.textWidthTemp;
          outputLayoutData.nodeContentSize.height = layout.textHeightTemp;
          if (layout.textWidthTemp <= 0) {
            outputLayoutData.nodeContentSize.width = parseFloat(longestLine.toFixed(2)) + shareLabelInfo.margin * 2;
          }
          if (layout.textHeightTemp <= 0) {
            outputLayoutData.nodeContentSize.height = parseFloat(layout.textDesiredHeight.toFixed(2)) + shareLabelInfo.margin * 2;
          }
          layout.tailoredTopY = outputLayoutData.nodeContentSize.height;
          layout.tailoredBottomY = 0;
          if (highestY > 0) {
            layout.tailoredTopY = outputLayoutData.nodeContentSize.height + highestY;
          }
          if (lowestY < -layout.textDesiredHeight) {
            layout.tailoredBottomY = layout.textDesiredHeight + lowestY;
          }
          return true;
        }
        _recordPlaceholderInfo(letterIndex, char) {
          if (letterIndex >= this._lettersInfo.length) {
            const tmpInfo = new LetterInfo();
            this._lettersInfo.push(tmpInfo);
          }
          this._lettersInfo[letterIndex].char = char;
          this._lettersInfo[letterIndex].hash = `${char.charCodeAt(0)}${shareLabelInfo.hash}`;
          this._lettersInfo[letterIndex].valid = false;
        }
        _recordLetterInfo(letterPosition, character, letterIndex, lineIndex) {
          if (letterIndex >= this._lettersInfo.length) {
            const tmpInfo = new LetterInfo();
            this._lettersInfo.push(tmpInfo);
          }
          const char = character.charCodeAt(0);
          const key = `${char}${shareLabelInfo.hash}`;
          this._lettersInfo[letterIndex].line = lineIndex;
          this._lettersInfo[letterIndex].char = character;
          this._lettersInfo[letterIndex].hash = key;
          this._lettersInfo[letterIndex].valid = shareLabelInfo.fontAtlas.getLetter(key).valid;
          this._lettersInfo[letterIndex].x = letterPosition.x;
          this._lettersInfo[letterIndex].y = letterPosition.y;
        }
        _getFirstWordLen(style, layout, text, startIndex, textLen) {
          let character = text.charAt(startIndex);
          if (isUnicodeCJK(character) || character === '\n' || isUnicodeSpace(character)) {
            return 1;
          }
          let len = 1;
          let letterDef = shareLabelInfo.fontAtlas.getLetterDefinitionForChar(character, shareLabelInfo);
          if (!letterDef) {
            return len;
          }
          let nextLetterX = letterDef.xAdvance * style.bmfontScale + layout.spacingX;
          let letterX = 0;
          for (let index = startIndex + 1; index < textLen; ++index) {
            character = text.charAt(index);
            letterDef = shareLabelInfo.fontAtlas.getLetterDefinitionForChar(character, shareLabelInfo);
            if (!letterDef) {
              break;
            }
            letterX = nextLetterX + letterDef.offsetX * style.bmfontScale;
            if (letterX + letterDef.w * style.bmfontScale > layout.maxLineWidth && !isUnicodeSpace(character) && layout.maxLineWidth > 0) {
              return len;
            }
            nextLetterX += letterDef.xAdvance * style.bmfontScale + layout.spacingX;
            if (character === '\n' || isUnicodeSpace(character) || isUnicodeCJK(character)) {
              break;
            }
            len++;
          }
          return len;
        }
        _computeAlignmentOffset(style, layout, outputLayoutData) {
          layout.linesOffsetX.length = 0;
          layout.letterOffsetY = 0;
          switch (layout.horizontalAlign) {
            case HorizontalTextAlignment.LEFT:
              for (let i = 0; i < layout.numberOfLines; ++i) {
                layout.linesOffsetX.push(0);
              }
              break;
            case HorizontalTextAlignment.CENTER:
              for (let i = 0, l = layout.linesWidth.length; i < l; i++) {
                layout.linesOffsetX.push((outputLayoutData.nodeContentSize.width - layout.linesWidth[i]) / 2);
              }
              break;
            case HorizontalTextAlignment.RIGHT:
              for (let i = 0, l = layout.linesWidth.length; i < l; i++) {
                layout.linesOffsetX.push(outputLayoutData.nodeContentSize.width - layout.linesWidth[i]);
              }
              break;
          }
          layout.letterOffsetY = outputLayoutData.nodeContentSize.height;
          if (layout.verticalAlign !== VerticalTextAlignment.TOP) {
            const blank = outputLayoutData.nodeContentSize.height - layout.textDesiredHeight + layout.lineHeight * this._getFontScale(style, layout) - style.originFontSize * this._fontScale * style.bmfontScale;
            if (layout.verticalAlign === VerticalTextAlignment.BOTTOM) {
              layout.letterOffsetY -= blank;
            } else {
              layout.letterOffsetY -= blank / 2;
            }
          }
        }
        _getFontScale(style, layout) {
          return layout.overFlow === Overflow$1.SHRINK ? style.bmfontScale : 1;
        }
        _isVerticalClamp(style, layout, outputLayoutData, inputString, process) {
          if (layout.textDesiredHeight > outputLayoutData.nodeContentSize.height) {
            return true;
          } else {
            return false;
          }
        }
        _isHorizontalClamp(style, layout, outputLayoutData, inputString, process) {
          let letterClamp = false;
          const _string = inputString;
          for (let ctr = 0, l = _string.length; ctr < l; ++ctr) {
            const letterInfo = process._lettersInfo[ctr];
            if (letterInfo.valid) {
              const letterDef = shareLabelInfo.fontAtlas.getLetterDefinitionForChar(letterInfo.char, shareLabelInfo);
              if (!letterDef) {
                continue;
              }
              const px = letterInfo.x + letterDef.w * style.bmfontScale;
              const lineIndex = letterInfo.line;
              if (layout.textWidthTemp > 0) {
                if (!layout.wrapping) {
                  if (px > outputLayoutData.nodeContentSize.width) {
                    letterClamp = true;
                    break;
                  }
                } else {
                  const wordWidth = layout.linesWidth[lineIndex];
                  if (wordWidth > outputLayoutData.nodeContentSize.width && (px > outputLayoutData.nodeContentSize.width || px < 0)) {
                    letterClamp = true;
                    break;
                  }
                }
              }
            }
          }
          return letterClamp;
        }
        _isHorizontalNeedShrink(layout, outputLayoutData) {
          let wordWidth = 0;
          for (let ctr = 0, l = layout.linesWidth.length; ctr < l; ++ctr) {
            wordWidth = layout.linesWidth[ctr];
            if (wordWidth > outputLayoutData.nodeContentSize.width) return true;
          }
          return false;
        }
        _shrinkLabelToContentSize(style, layout, outputLayoutData, inputString, lambda) {
          const fontSize = style.actualFontSize;
          let left = 0;
          let right = fontSize | 0;
          let mid = 0;
          while (left < right) {
            mid = left + right + 1 >> 1;
            const newFontSize = mid;
            if (newFontSize <= 0) {
              break;
            }
            style.bmfontScale = newFontSize / (style.originFontSize * this._fontScale);
            this._multilineTextWrap(style, layout, outputLayoutData, inputString, this._getFirstWordLen);
            this._computeAlignmentOffset(style, layout, outputLayoutData);
            if (lambda(style, layout, outputLayoutData, inputString, this)) {
              right = mid - 1;
            } else {
              left = mid;
            }
          }
          if (left >= 0) {
            this._scaleFontSizeDown(style, layout, outputLayoutData, inputString, left);
          }
        }
        _scaleFontSizeDown(style, layout, outputLayoutData, inputString, fontSize) {
          let shouldUpdateContent = true;
          if (!fontSize) {
            fontSize = 0.1;
            shouldUpdateContent = false;
          }
          style.actualFontSize = fontSize;
          if (shouldUpdateContent) {
            this._updateFontScale(style);
            this._multilineTextWrap(style, layout, outputLayoutData, inputString, this._getFirstWordLen);
          }
        }
        _updateQuads(style, layout, outputLayoutData, outputRenderData, inputString, callback) {
          const texture = style.spriteFrame ? style.spriteFrame.texture : shareLabelInfo.fontAtlas.getTexture();
          const appX = outputRenderData.uiTransAnchorX * outputLayoutData.nodeContentSize.width;
          const appY = outputRenderData.uiTransAnchorY * outputLayoutData.nodeContentSize.height;
          const ret = true;
          for (let ctr = 0, l = inputString.length; ctr < l; ++ctr) {
            const letterInfo = this._lettersInfo[ctr];
            if (!letterInfo.valid) {
              continue;
            }
            const letterDef = shareLabelInfo.fontAtlas.getLetter(letterInfo.hash);
            if (!letterDef) {
              warn('Can\'t find letter in this bitmap-font');
              continue;
            }
            this._tmpRect.height = letterDef.h;
            this._tmpRect.width = letterDef.w;
            this._tmpRect.x = letterDef.u;
            this._tmpRect.y = letterDef.v;
            let py = letterInfo.y + layout.letterOffsetY;
            if (layout.textHeightTemp > 0) {
              if (py > layout.tailoredTopY) {
                const clipTop = py - layout.tailoredTopY;
                this._tmpRect.y += clipTop;
                this._tmpRect.height -= clipTop;
                py -= clipTop;
              }
              if (py - this._tmpRect.height * style.bmfontScale < layout.tailoredBottomY && layout.overFlow === Overflow$1.CLAMP) {
                this._tmpRect.height = py < layout.tailoredBottomY ? 0 : (py - layout.tailoredBottomY) / style.bmfontScale;
              }
            }
            const lineIndex = letterInfo.line;
            const px = letterInfo.x + letterDef.w / 2 * style.bmfontScale + layout.linesOffsetX[lineIndex];
            if (layout.textWidthTemp > 0) {
              if (this._isHorizontalClamped(layout, outputLayoutData, px, lineIndex)) {
                if (layout.overFlow === Overflow$1.CLAMP) {
                  this._tmpRect.width = 0;
                }
              }
            }
            if (this._tmpRect.height > 0 && this._tmpRect.width > 0) {
              const isRotated = this._determineRect(style);
              const letterPositionX = letterInfo.x + layout.linesOffsetX[letterInfo.line];
              const offset = outputRenderData.quadCount;
              outputRenderData.quadCount += 4;
              this.updateQuatCount(outputRenderData);
              callback(style, outputLayoutData, outputRenderData, offset, texture, this._tmpRect, isRotated, letterPositionX - appX, py - appY);
            }
          }
          return ret;
        }
        _isHorizontalClamped(layout, outputLayoutData, px, lineIndex) {
          const wordWidth = layout.linesWidth[lineIndex];
          const letterOverClamp = px > outputLayoutData.nodeContentSize.width || px < 0;
          if (!layout.wrapping) {
            return letterOverClamp;
          } else {
            return wordWidth > outputLayoutData.nodeContentSize.width && letterOverClamp;
          }
        }
        _determineRect(style) {
          const _spriteFrame = style.spriteFrame;
          if (!_spriteFrame) return false;
          const isRotated = _spriteFrame.isRotated();
          const originalSize = _spriteFrame.getOriginalSize();
          const rect = _spriteFrame.getRect();
          const offset = _spriteFrame.getOffset();
          const trimmedLeft = offset.x + (originalSize.width - rect.width) / 2;
          const trimmedTop = offset.y - (originalSize.height - rect.height) / 2;
          if (!isRotated) {
            this._tmpRect.x += rect.x - trimmedLeft;
            this._tmpRect.y += rect.y + trimmedTop;
          } else {
            const originalX = this._tmpRect.x;
            this._tmpRect.x = rect.x + rect.height - this._tmpRect.y - this._tmpRect.height - trimmedTop;
            this._tmpRect.y = originalX + rect.y - trimmedLeft;
            if (this._tmpRect.y < 0) {
              this._tmpRect.height += trimmedTop;
            }
          }
          return isRotated;
        }
      }
      TextProcessing.instance = void 0;
      TextProcessing.instance = new TextProcessing();

      const _defaultLetterAtlas = new LetterAtlas(64, 64);
      const _defaultFontAtlas = new FontAtlas(null);
      let _comp = null;
      let _uiTrans = null;
      let _fntConfig = null;
      let _spriteFrame = null;
      let QUAD_INDICES$6;
      const bmfontUtils = {
        updateProcessingData(style, layout, outputLayoutData, outputRenderData, comp, trans) {
          style.fontSize = comp.fontSize;
          style.actualFontSize = comp.fontSize;
          style.originFontSize = _fntConfig ? _fntConfig.fontSize : comp.fontSize;
          layout.horizontalAlign = comp.horizontalAlign;
          layout.verticalAlign = comp.verticalAlign;
          layout.spacingX = comp.spacingX;
          const overflow = comp.overflow;
          layout.overFlow = overflow;
          layout.lineHeight = comp.lineHeight;
          outputLayoutData.nodeContentSize.width = trans.width;
          outputLayoutData.nodeContentSize.height = trans.height;
          if (overflow === Overflow$1.NONE) {
            layout.wrapping = false;
            outputLayoutData.nodeContentSize.width += shareLabelInfo.margin * 2;
            outputLayoutData.nodeContentSize.height += shareLabelInfo.margin * 2;
          } else if (overflow === Overflow$1.RESIZE_HEIGHT) {
            layout.wrapping = true;
            outputLayoutData.nodeContentSize.height += shareLabelInfo.margin * 2;
          } else {
            layout.wrapping = comp.enableWrapText;
          }
          outputRenderData.uiTransAnchorX = trans.anchorX;
          outputRenderData.uiTransAnchorY = trans.anchorY;
          shareLabelInfo.lineHeight = comp.lineHeight;
          shareLabelInfo.fontSize = comp.fontSize;
          style.spriteFrame = _spriteFrame;
          style.fntConfig = _fntConfig;
          style.fontFamily = shareLabelInfo.fontFamily;
          style.color.set(comp.color);
        },
        updateRenderData(comp) {
          if (!comp.renderData) {
            return;
          }
          if (_comp === comp) {
            return;
          }
          if (comp.renderData.vertDirty) {
            _comp = comp;
            _uiTrans = _comp.node._uiProps.uiTransformComp;
            const renderData = comp.renderData;
            const processing = TextProcessing.instance;
            const style = comp.textStyle;
            const layout = comp.textLayout;
            const outputLayoutData = comp.textLayoutData;
            const outputRenderData = comp.textRenderData;
            style.fontScale = view.getScaleX();
            this._updateFontFamily(comp);
            this.updateProcessingData(style, layout, outputLayoutData, outputRenderData, comp, _uiTrans);
            this._updateLabelInfo(comp);
            style.fontDesc = shareLabelInfo.fontDesc;
            processing.processingString(true, style, layout, outputLayoutData, comp.string);
            this.resetRenderData(comp);
            outputRenderData.quadCount = 0;
            processing.generateRenderInfo(true, style, layout, outputLayoutData, outputRenderData, comp.string, this.generateVertexData);
            renderData.dataLength = outputRenderData.quadCount;
            renderData.resize(renderData.dataLength, renderData.dataLength / 2 * 3);
            const datalist = renderData.data;
            for (let i = 0, l = outputRenderData.quadCount; i < l; i++) {
              datalist[i] = outputRenderData.vertexBuffer[i];
            }
            const indexCount = renderData.indexCount;
            this.createQuadIndices(indexCount);
            renderData.chunk.setIndexBuffer(QUAD_INDICES$6);
            _comp.actualFontSize = style.actualFontSize;
            _uiTrans.setContentSize(outputLayoutData.nodeContentSize);
            this.updateUVs(comp);
            this.updateColor(comp);
            renderData.vertDirty = false;
            _comp = null;
            this._resetProperties();
          }
          if (comp.spriteFrame) {
            const renderData = comp.renderData;
            renderData.updateRenderData(comp, comp.spriteFrame);
          }
        },
        updateUVs(label) {
          const renderData = label.renderData;
          const vData = renderData.chunk.vb;
          const vertexCount = renderData.vertexCount;
          const dataList = renderData.data;
          let vertexOffset = 3;
          for (let i = 0; i < vertexCount; i++) {
            const vert = dataList[i];
            vData[vertexOffset] = vert.u;
            vData[vertexOffset + 1] = vert.v;
            vertexOffset += 9;
          }
        },
        updateColor(label) {
          {
            const renderData = label.renderData;
            const vertexCount = renderData.vertexCount;
            if (vertexCount === 0) return;
            const vData = renderData.chunk.vb;
            const stride = renderData.floatStride;
            let colorOffset = 5;
            const color = label.color;
            const colorR = color.r / 255;
            const colorG = color.g / 255;
            const colorB = color.b / 255;
            const colorA = color.a / 255;
            for (let i = 0; i < vertexCount; i++) {
              vData[colorOffset] = colorR;
              vData[colorOffset + 1] = colorG;
              vData[colorOffset + 2] = colorB;
              vData[colorOffset + 3] = colorA;
              colorOffset += stride;
            }
          }
        },
        resetRenderData(comp) {
          const renderData = comp.renderData;
          renderData.dataLength = 0;
          renderData.resize(0, 0);
        },
        generateVertexData(style, outputLayoutData, outputRenderData, offset, spriteFrame, rect, rotated, x, y) {
          const dataOffset = offset;
          const scale = style.bmfontScale;
          const dataList = outputRenderData.vertexBuffer;
          const texW = spriteFrame.width;
          const texH = spriteFrame.height;
          const rectWidth = rect.width;
          const rectHeight = rect.height;
          let l = 0;
          let b = 0;
          let t = 0;
          let r = 0;
          if (!rotated) {
            l = rect.x / texW;
            r = (rect.x + rectWidth) / texW;
            b = (rect.y + rectHeight) / texH;
            t = rect.y / texH;
            dataList[dataOffset].u = l;
            dataList[dataOffset].v = b;
            dataList[dataOffset + 1].u = r;
            dataList[dataOffset + 1].v = b;
            dataList[dataOffset + 2].u = l;
            dataList[dataOffset + 2].v = t;
            dataList[dataOffset + 3].u = r;
            dataList[dataOffset + 3].v = t;
          } else {
            l = rect.x / texW;
            r = (rect.x + rectHeight) / texW;
            b = (rect.y + rectWidth) / texH;
            t = rect.y / texH;
            dataList[dataOffset].u = l;
            dataList[dataOffset].v = t;
            dataList[dataOffset + 1].u = l;
            dataList[dataOffset + 1].v = b;
            dataList[dataOffset + 2].u = r;
            dataList[dataOffset + 2].v = t;
            dataList[dataOffset + 3].u = r;
            dataList[dataOffset + 3].v = b;
          }
          dataList[dataOffset].x = x;
          dataList[dataOffset].y = y - rectHeight * scale;
          dataList[dataOffset + 1].x = x + rectWidth * scale;
          dataList[dataOffset + 1].y = y - rectHeight * scale;
          dataList[dataOffset + 2].x = x;
          dataList[dataOffset + 2].y = y;
          dataList[dataOffset + 3].x = x + rectWidth * scale;
          dataList[dataOffset + 3].y = y;
        },
        _updateFontFamily(comp) {
          const fontAsset = comp.font;
          _spriteFrame = fontAsset.spriteFrame;
          _fntConfig = fontAsset.fntConfig;
          shareLabelInfo.fontAtlas = fontAsset.fontDefDictionary;
          if (!shareLabelInfo.fontAtlas) {
            if (comp.cacheMode === CacheMode.CHAR) {
              shareLabelInfo.fontAtlas = _defaultLetterAtlas;
            } else {
              shareLabelInfo.fontAtlas = _defaultFontAtlas;
            }
          }
          dynamicAtlasManager.packToDynamicAtlas(comp, _spriteFrame);
        },
        _updateLabelInfo(comp) {
          shareLabelInfo.hash = '';
          shareLabelInfo.margin = 0;
        },
        _resetProperties() {
          _fntConfig = null;
          _spriteFrame = null;
          shareLabelInfo.hash = '';
          shareLabelInfo.margin = 0;
        },
        createQuadIndices(indexCount) {
          if (indexCount % 6 !== 0) {
            console.error('illegal index count!');
            return;
          }
          const quadCount = indexCount / 6;
          QUAD_INDICES$6 = null;
          QUAD_INDICES$6 = new Uint16Array(indexCount);
          let offset = 0;
          for (let i = 0; i < quadCount; i++) {
            QUAD_INDICES$6[offset++] = 0 + i * 4;
            QUAD_INDICES$6[offset++] = 1 + i * 4;
            QUAD_INDICES$6[offset++] = 2 + i * 4;
            QUAD_INDICES$6[offset++] = 1 + i * 4;
            QUAD_INDICES$6[offset++] = 3 + i * 4;
            QUAD_INDICES$6[offset++] = 2 + i * 4;
          }
        }
      };

      const tempColor$1 = new Color$1(255, 255, 255, 255);
      const bmfont = {
        createData(comp) {
          const renderData = comp.requestRenderData();
          renderData.resize(0, 0);
          return renderData;
        },
        fillBuffers(comp, renderer) {
          const node = comp.node;
          tempColor$1.set(comp.color);
          tempColor$1.a = node._uiProps.opacity * 255;
          fillMeshVertices3D(node, renderer, comp.renderData, tempColor$1);
        },
        appendQuad(comp, spriteFrame, rect, rotated, x, y, scale) {
          const renderData = comp.renderData;
          if (!renderData) {
            return;
          }
          const dataOffset = renderData.dataLength;
          renderData.dataLength += 4;
          renderData.resize(renderData.dataLength, renderData.dataLength / 2 * 3);
          const dataList = renderData.data;
          const texW = spriteFrame.width;
          const texH = spriteFrame.height;
          const rectWidth = rect.width;
          const rectHeight = rect.height;
          let l = 0;
          let b = 0;
          let t = 0;
          let r = 0;
          if (!rotated) {
            l = rect.x / texW;
            r = (rect.x + rectWidth) / texW;
            b = (rect.y + rectHeight) / texH;
            t = rect.y / texH;
            dataList[dataOffset].u = l;
            dataList[dataOffset].v = b;
            dataList[dataOffset + 1].u = r;
            dataList[dataOffset + 1].v = b;
            dataList[dataOffset + 2].u = l;
            dataList[dataOffset + 2].v = t;
            dataList[dataOffset + 3].u = r;
            dataList[dataOffset + 3].v = t;
          } else {
            l = rect.x / texW;
            r = (rect.x + rectHeight) / texW;
            b = (rect.y + rectWidth) / texH;
            t = rect.y / texH;
            dataList[dataOffset].u = l;
            dataList[dataOffset].v = t;
            dataList[dataOffset + 1].u = l;
            dataList[dataOffset + 1].v = b;
            dataList[dataOffset + 2].u = r;
            dataList[dataOffset + 2].v = t;
            dataList[dataOffset + 3].u = r;
            dataList[dataOffset + 3].v = b;
          }
          dataList[dataOffset].x = x;
          dataList[dataOffset].y = y - rectHeight * scale;
          dataList[dataOffset + 1].x = x + rectWidth * scale;
          dataList[dataOffset + 1].y = y - rectHeight * scale;
          dataList[dataOffset + 2].x = x;
          dataList[dataOffset + 2].y = y;
          dataList[dataOffset + 3].x = x + rectWidth * scale;
          dataList[dataOffset + 3].y = y;
        }
      };
      addon(bmfont, bmfontUtils);

      const _atlasWidth = 1024;
      const _atlasHeight = 1024;
      let _shareAtlas = null;
      const letterFont = mixin(bmfontUtils, {
        getAssemblerData() {
          if (!_shareAtlas) {
            _shareAtlas = new LetterAtlas(_atlasWidth, _atlasHeight);
          }
          return _shareAtlas.getTexture();
        },
        _updateFontFamily(comp) {
          shareLabelInfo.fontAtlas = _shareAtlas;
          shareLabelInfo.fontFamily = this._getFontFamily(comp);
          const outline = comp.getComponent(LabelOutline);
          if (outline && outline.enabled) {
            shareLabelInfo.isOutlined = true;
            shareLabelInfo.margin = outline.width;
            shareLabelInfo.out = outline.color.clone();
            shareLabelInfo.out.a = outline.color.a * comp.color.a / 255.0;
          } else {
            shareLabelInfo.isOutlined = false;
            shareLabelInfo.margin = 0;
          }
        },
        _getFontFamily(comp) {
          let fontFamily = 'Arial';
          if (!comp.useSystemFont) {
            if (comp.font) {
              fontFamily = comp.font._nativeAsset || 'Arial';
            }
          } else {
            fontFamily = comp.fontFamily || 'Arial';
          }
          return fontFamily;
        },
        _updateLabelInfo(comp) {
          shareLabelInfo.fontDesc = this._getFontDesc();
          shareLabelInfo.color = comp.color;
          shareLabelInfo.hash = computeHash(shareLabelInfo);
        },
        _getFontDesc() {
          let fontDesc = `${shareLabelInfo.fontSize.toString()}px `;
          fontDesc += shareLabelInfo.fontFamily;
          return fontDesc;
        }
      });

      const tempColor = new Color$1(255, 255, 255, 255);
      const letter = {
        createData(comp) {
          const renderData = comp.requestRenderData();
          renderData.resize(0, 0);
          return renderData;
        },
        fillBuffers(comp, renderer) {
          if (!comp.renderData) {
            return;
          }
          const node = comp.node;
          tempColor.a = node._uiProps.opacity * 255;
          fillMeshVertices3D(node, renderer, comp.renderData, tempColor);
        },
        updateColor(label) {
          {
            const renderData = label.renderData;
            const vertexCount = renderData.vertexCount;
            if (vertexCount === 0) return;
            const vData = renderData.chunk.vb;
            const stride = renderData.floatStride;
            let colorOffset = 5;
            for (let i = 0; i < vertexCount; i++) {
              vData[colorOffset] = 1;
              vData[colorOffset + 1] = 1;
              vData[colorOffset + 2] = 1;
              vData[colorOffset + 3] = 1;
              colorOffset += stride;
            }
          }
        }
      };
      addon(letter, letterFont);

      const Overflow = Label.Overflow;
      const ttfUtils = {
        updateProcessingData(style, layout, outputLayoutData, outputRenderData, comp, trans) {
          style.isSystemFontUsed = comp.useSystemFont;
          style.fontSize = comp.fontSize;
          outputLayoutData.nodeContentSize.width = outputLayoutData.canvasSize.width = trans.width;
          outputLayoutData.nodeContentSize.height = outputLayoutData.canvasSize.height = trans.height;
          layout.lineHeight = comp.lineHeight;
          layout.overFlow = comp.overflow;
          if (comp.overflow === Overflow.NONE) {
            layout.wrapping = false;
          } else if (comp.overflow === Overflow.RESIZE_HEIGHT) {
            layout.wrapping = true;
          } else {
            layout.wrapping = comp.enableWrapText;
          }
          style.isBold = comp.isBold;
          style.isItalic = comp.isItalic;
          style.isUnderline = comp.isUnderline;
          style.underlineHeight = comp.underlineHeight;
          let outlineComp = LabelOutline && comp.getComponent(LabelOutline);
          outlineComp = outlineComp && outlineComp.enabled && outlineComp.width > 0 ? outlineComp : null;
          if (outlineComp) {
            style.isOutlined = true;
            style.outlineColor.set(outlineComp.color);
            style.outlineWidth = outlineComp.width;
          } else {
            style.isOutlined = false;
          }
          let shadowComp = LabelShadow && comp.getComponent(LabelShadow);
          shadowComp = shadowComp && shadowComp.enabled ? shadowComp : null;
          if (shadowComp) {
            style.hasShadow = true;
            style.shadowColor.set(shadowComp.color);
            style.shadowBlur = shadowComp.blur;
            style.shadowOffsetX = shadowComp.offset.x;
            style.shadowOffsetY = shadowComp.offset.y;
          } else {
            style.hasShadow = false;
          }
          style.color.set(comp.color);
          outputRenderData.texture = comp.spriteFrame;
          outputRenderData.uiTransAnchorX = trans.anchorX;
          outputRenderData.uiTransAnchorY = trans.anchorY;
          layout.horizontalAlign = comp.horizontalAlign;
          layout.verticalAlign = comp.verticalAlign;
        },
        getAssemblerData() {
          const sharedLabelData = Label._canvasPool.get();
          sharedLabelData.canvas.width = sharedLabelData.canvas.height = 1;
          return sharedLabelData;
        },
        resetAssemblerData(assemblerData) {
          if (assemblerData) {
            Label._canvasPool.put(assemblerData);
          }
        },
        updateRenderData(comp) {
          if (!comp.renderData) {
            return;
          }
          if (comp.renderData.vertDirty) {
            const trans = comp.node._uiProps.uiTransformComp;
            const processing = TextProcessing.instance;
            const style = comp.textStyle;
            const layout = comp.textLayout;
            const outputLayoutData = comp.textLayoutData;
            const outputRenderData = comp.textRenderData;
            style.fontScale = view.getScaleX();
            this.updateProcessingData(style, layout, outputLayoutData, outputRenderData, comp, trans);
            processing.setCanvasUsed(comp.assemblerData.canvas, comp.assemblerData.context);
            style.fontFamily = this._updateFontFamily(comp);
            this._resetDynamicAtlas(comp);
            processing.processingString(false, style, layout, outputLayoutData, comp.string);
            processing.generateRenderInfo(false, style, layout, outputLayoutData, outputRenderData, comp.string, this.generateVertexData);
            const renderData = comp.renderData;
            renderData.textureDirty = true;
            this._calDynamicAtlas(comp, outputLayoutData);
            comp.actualFontSize = style.actualFontSize;
            trans.setContentSize(outputLayoutData.nodeContentSize);
            const datalist = renderData.data;
            datalist[0] = outputRenderData.vertexBuffer[0];
            datalist[1] = outputRenderData.vertexBuffer[1];
            datalist[2] = outputRenderData.vertexBuffer[2];
            datalist[3] = outputRenderData.vertexBuffer[3];
            this.updateUVs(comp);
            comp.renderData.vertDirty = false;
            comp.contentWidth = outputLayoutData.nodeContentSize.width;
          }
          if (comp.spriteFrame) {
            const renderData = comp.renderData;
            renderData.updateRenderData(comp, comp.spriteFrame);
          }
        },
        generateVertexData(style, outputLayoutData, outputRenderData) {
          const data = outputRenderData.vertexBuffer;
          const width = outputLayoutData.nodeContentSize.width;
          const height = outputLayoutData.nodeContentSize.height;
          const appX = outputRenderData.uiTransAnchorX * width;
          const appY = outputRenderData.uiTransAnchorY * height;
          data[0].x = -appX;
          data[0].y = -appY;
          data[1].x = width - appX;
          data[1].y = -appY;
          data[2].x = -appX;
          data[2].y = height - appY;
          data[3].x = width - appX;
          data[3].y = height - appY;
        },
        updateVertexData(comp) {},
        updateUVs(comp) {},
        _updateFontFamily(comp) {
          let _fontFamily = '';
          if (!comp.useSystemFont) {
            if (comp.font) {
              _fontFamily = comp.font._nativeAsset || 'Arial';
            } else {
              _fontFamily = 'Arial';
            }
          } else {
            _fontFamily = comp.fontFamily || 'Arial';
          }
          return _fontFamily;
        },
        _calDynamicAtlas(comp, outputLayoutData) {
          if (comp.cacheMode !== Label.CacheMode.BITMAP || outputLayoutData.canvasSize.width <= 0 || outputLayoutData.canvasSize.height <= 0) return;
          const frame = comp.ttfSpriteFrame;
          dynamicAtlasManager.packToDynamicAtlas(comp, frame);
        },
        _resetDynamicAtlas(comp) {
          if (comp.cacheMode !== Label.CacheMode.BITMAP) return;
          const frame = comp.ttfSpriteFrame;
          dynamicAtlasManager.deleteAtlasSpriteFrame(frame);
          frame._resetDynamicAtlasFrame();
        }
      };

      const WHITE = Color$1.WHITE.clone();
      const QUAD_INDICES$5 = Uint16Array.from([0, 1, 2, 1, 3, 2]);
      const ttf = {
        createData(comp) {
          const renderData = comp.requestRenderData();
          renderData.dataLength = 4;
          renderData.resize(4, 6);
          comp.textRenderData.quadCount = 4;
          const vData = renderData.chunk.vb;
          vData[3] = vData[21] = vData[22] = vData[31] = 0;
          vData[4] = vData[12] = vData[13] = vData[30] = 1;
          let offset = 5;
          for (let i = 0; i < 4; i++) {
            Color$1.toArray(vData, WHITE, offset);
            offset += 9;
          }
          renderData.chunk.setIndexBuffer(QUAD_INDICES$5);
          return renderData;
        },
        fillBuffers(comp, renderer) {
          const renderData = comp.renderData;
          const chunk = renderData.chunk;
          const dataList = renderData.data;
          const node = comp.node;
          const vData = chunk.vb;
          const m = node.worldMatrix;
          const stride = renderData.floatStride;
          let offset = 0;
          const length = dataList.length;
          for (let i = 0; i < length; i++) {
            const curData = dataList[i];
            const x = curData.x;
            const y = curData.y;
            let rhw = m.m03 * x + m.m07 * y + m.m15;
            rhw = rhw ? 1 / rhw : 1;
            offset = i * stride;
            vData[offset + 0] = (m.m00 * x + m.m04 * y + m.m12) * rhw;
            vData[offset + 1] = (m.m01 * x + m.m05 * y + m.m13) * rhw;
            vData[offset + 2] = (m.m02 * x + m.m06 * y + m.m14) * rhw;
          }
          const vid = chunk.vertexOffset;
          const meshBuffer = chunk.meshBuffer;
          const ib = chunk.meshBuffer.iData;
          let indexOffset = meshBuffer.indexOffset;
          ib[indexOffset++] = vid;
          ib[indexOffset++] = vid + 1;
          ib[indexOffset++] = vid + 2;
          ib[indexOffset++] = vid + 2;
          ib[indexOffset++] = vid + 1;
          ib[indexOffset++] = vid + 3;
          meshBuffer.indexOffset += 6;
        },
        updateVertexData(comp) {
          const renderData = comp.renderData;
          if (!renderData) {
            return;
          }
          const uiTrans = comp.node._uiProps.uiTransformComp;
          const width = uiTrans.width;
          const height = uiTrans.height;
          const appX = uiTrans.anchorX * width;
          const appY = uiTrans.anchorY * height;
          const data = renderData.data;
          data[0].x = -appX;
          data[0].y = -appY;
          data[1].x = width - appX;
          data[1].y = -appY;
          data[2].x = -appX;
          data[2].y = height - appY;
          data[3].x = width - appX;
          data[3].y = height - appY;
        },
        updateUVs(comp) {
          const renderData = comp.renderData;
          if (!renderData || !comp.ttfSpriteFrame) {
            return;
          }
          const vData = renderData.chunk.vb;
          const uv = comp.ttfSpriteFrame.uv;
          vData[3] = uv[0];
          vData[4] = uv[1];
          vData[12] = uv[2];
          vData[13] = uv[3];
          vData[21] = uv[4];
          vData[22] = uv[5];
          vData[30] = uv[6];
          vData[31] = uv[7];
        },
        updateColor(comp) {}
      };
      addon(ttf, ttfUtils);

      const labelAssembler = exports('labelAssembler', {
        getAssembler(comp) {
          let assembler = ttf;
          if (comp.font instanceof BitmapFont) {
            assembler = bmfont;
          } else if (comp.cacheMode === Label.CacheMode.CHAR) {
            assembler = letter;
          }
          return assembler;
        }
      });
      Label.Assembler = labelAssembler;

      const FillType$1 = Sprite.FillType;
      const m$3 = new Mat4();
      const QUAD_INDICES$4 = Uint16Array.from([0, 1, 2, 1, 3, 2]);
      const barFilled = {
        updateRenderData(sprite) {
          const frame = sprite.spriteFrame;
          dynamicAtlasManager.packToDynamicAtlas(sprite, frame);
          const renderData = sprite.renderData;
          if (renderData && frame) {
            const vertDirty = renderData.vertDirty;
            if (!vertDirty) {
              return;
            }
            let fillStart = sprite.fillStart;
            let fillRange = sprite.fillRange;
            if (fillRange < 0) {
              fillStart += fillRange;
              fillRange = -fillRange;
            }
            fillRange = fillStart + fillRange;
            fillStart = fillStart > 1.0 ? 1.0 : fillStart;
            fillStart = fillStart < 0.0 ? 0.0 : fillStart;
            fillRange = fillRange > 1.0 ? 1.0 : fillRange;
            fillRange = fillRange < 0.0 ? 0.0 : fillRange;
            fillRange -= fillStart;
            fillRange = fillRange < 0 ? 0 : fillRange;
            let fillEnd = fillStart + fillRange;
            fillEnd = fillEnd > 1 ? 1 : fillEnd;
            this.updateUVs(sprite, fillStart, fillEnd);
            this.updateVertexData(sprite, fillStart, fillEnd);
            renderData.updateRenderData(sprite, frame);
          }
        },
        updateUVs(sprite, fillStart, fillEnd) {
          const spriteFrame = sprite.spriteFrame;
          const renderData = sprite.renderData;
          const vData = renderData.chunk.vb;
          const atlasWidth = spriteFrame.width;
          const atlasHeight = spriteFrame.height;
          const textureRect = spriteFrame.rect;
          let ul = 0;
          let vb = 0;
          let ur = 0;
          let vt = 0;
          let quadUV0 = 0;
          let quadUV1 = 0;
          let quadUV2 = 0;
          let quadUV3 = 0;
          let quadUV4 = 0;
          let quadUV5 = 0;
          let quadUV6 = 0;
          let quadUV7 = 0;
          if (spriteFrame.isRotated()) {
            ul = textureRect.x / atlasWidth;
            vb = (textureRect.y + textureRect.width) / atlasHeight;
            ur = (textureRect.x + textureRect.height) / atlasWidth;
            vt = textureRect.y / atlasHeight;
            quadUV0 = quadUV2 = ul;
            quadUV4 = quadUV6 = ur;
            quadUV3 = quadUV7 = vb;
            quadUV1 = quadUV5 = vt;
          } else {
            ul = textureRect.x / atlasWidth;
            vb = (textureRect.y + textureRect.height) / atlasHeight;
            ur = (textureRect.x + textureRect.width) / atlasWidth;
            vt = textureRect.y / atlasHeight;
            quadUV0 = quadUV4 = ul;
            quadUV2 = quadUV6 = ur;
            quadUV1 = quadUV3 = vb;
            quadUV5 = quadUV7 = vt;
          }
          switch (sprite.fillType) {
            case FillType$1.HORIZONTAL:
              vData[3] = quadUV0 + (quadUV2 - quadUV0) * fillStart;
              vData[4] = quadUV1 + (quadUV3 - quadUV1) * fillStart;
              vData[12] = quadUV0 + (quadUV2 - quadUV0) * fillEnd;
              vData[13] = quadUV1 + (quadUV3 - quadUV1) * fillEnd;
              vData[21] = quadUV4 + (quadUV6 - quadUV4) * fillStart;
              vData[22] = quadUV5 + (quadUV7 - quadUV5) * fillStart;
              vData[30] = quadUV4 + (quadUV6 - quadUV4) * fillEnd;
              vData[31] = quadUV5 + (quadUV7 - quadUV5) * fillEnd;
              break;
            case FillType$1.VERTICAL:
              vData[3] = quadUV0 + (quadUV4 - quadUV0) * fillStart;
              vData[4] = quadUV1 + (quadUV5 - quadUV1) * fillStart;
              vData[12] = quadUV2 + (quadUV6 - quadUV2) * fillStart;
              vData[13] = quadUV3 + (quadUV7 - quadUV3) * fillStart;
              vData[21] = quadUV0 + (quadUV4 - quadUV0) * fillEnd;
              vData[22] = quadUV1 + (quadUV5 - quadUV1) * fillEnd;
              vData[30] = quadUV2 + (quadUV6 - quadUV2) * fillEnd;
              vData[31] = quadUV3 + (quadUV7 - quadUV3) * fillEnd;
              break;
            default:
              errorID(2626);
              break;
          }
        },
        updateVertexData(sprite, fillStart, fillEnd) {
          const renderData = sprite.renderData;
          const dataList = renderData.data;
          const uiTrans = sprite.node._uiProps.uiTransformComp;
          const width = uiTrans.width;
          const height = uiTrans.height;
          const appX = uiTrans.anchorX * width;
          const appY = uiTrans.anchorY * height;
          let l = -appX;
          let b = -appY;
          let r = width - appX;
          let t = height - appY;
          let progressStart = 0;
          let progressEnd = 0;
          switch (sprite.fillType) {
            case FillType$1.HORIZONTAL:
              progressStart = l + (r - l) * fillStart;
              progressEnd = l + (r - l) * fillEnd;
              l = progressStart;
              r = progressEnd;
              break;
            case FillType$1.VERTICAL:
              progressStart = b + (t - b) * fillStart;
              progressEnd = b + (t - b) * fillEnd;
              b = progressStart;
              t = progressEnd;
              break;
            default:
              errorID(2626);
              break;
          }
          dataList[0].x = l;
          dataList[0].y = b;
          dataList[1].x = r;
          dataList[1].y = b;
          dataList[2].x = l;
          dataList[2].y = t;
          dataList[3].x = r;
          dataList[3].y = t;
        },
        createData(sprite) {
          const renderData = sprite.requestRenderData();
          renderData.dataLength = 4;
          renderData.resize(4, 6);
          renderData.chunk.setIndexBuffer(QUAD_INDICES$4);
          const dataList = renderData.data;
          for (const data of dataList) {
            data.z = 0;
          }
          return renderData;
        },
        updateWorldVertexData(sprite, chunk) {
          const node = sprite.node;
          node.getWorldMatrix(m$3);
          const renderData = sprite.renderData;
          const stride = renderData.floatStride;
          const dataList = sprite.renderData.data;
          const vData = chunk.vb;
          let offset = 0;
          for (let i = 0; i < 4; i++) {
            const local = dataList[i];
            const x = local.x;
            const y = local.y;
            let rhw = m$3.m03 * x + m$3.m07 * y + m$3.m15;
            rhw = rhw ? 1 / rhw : 1;
            offset = i * stride;
            vData[offset] = (m$3.m00 * x + m$3.m04 * y + m$3.m12) * rhw;
            vData[offset + 1] = (m$3.m01 * x + m$3.m05 * y + m$3.m13) * rhw;
            vData[offset + 2] = (m$3.m02 * x + m$3.m06 * y + m$3.m14) * rhw;
          }
        },
        fillBuffers(sprite, renderer) {
          const renderData = sprite.renderData;
          const chunk = renderData.chunk;
          if (sprite._flagChangedVersion !== sprite.node.flagChangedVersion || renderData.vertDirty) {
            this.updateWorldVertexData(sprite, chunk);
            renderData.vertDirty = false;
            sprite._flagChangedVersion = sprite.node.flagChangedVersion;
          }
          chunk.bufferId;
          const vid = chunk.vertexOffset;
          const meshBuffer = chunk.meshBuffer;
          const ib = chunk.meshBuffer.iData;
          let indexOffset = meshBuffer.indexOffset;
          ib[indexOffset++] = vid;
          ib[indexOffset++] = vid + 1;
          ib[indexOffset++] = vid + 2;
          ib[indexOffset++] = vid + 2;
          ib[indexOffset++] = vid + 1;
          ib[indexOffset++] = vid + 3;
          meshBuffer.indexOffset += 6;
        },
        updateColor(sprite) {
          const renderData = sprite.renderData;
          const vData = renderData.chunk.vb;
          const stride = renderData.floatStride;
          let colorOffset = 5;
          const color = sprite.color;
          const colorR = color.r / 255;
          const colorG = color.g / 255;
          const colorB = color.b / 255;
          const colorA = sprite.node._uiProps.opacity;
          for (let i = 0; i < 4; i++) {
            vData[colorOffset] = colorR;
            vData[colorOffset + 1] = colorG;
            vData[colorOffset + 2] = colorB;
            vData[colorOffset + 3] = colorA;
            colorOffset += stride;
          }
        }
      };

      const PI_2 = Math.PI * 2;
      const EPSILON$1 = 1e-6;
      const m$2 = new Mat4();
      const _vertPos = [new Vec2(), new Vec2(), new Vec2(), new Vec2()];
      const _vertices = new Array(4);
      const _uvs = new Array(8);
      const _intersectPoint_1 = [new Vec2(), new Vec2(), new Vec2(), new Vec2()];
      const _intersectPoint_2 = [new Vec2(), new Vec2(), new Vec2(), new Vec2()];
      const _center = new Vec2();
      const _triangles = [new Vec2(), new Vec2(), new Vec2(), new Vec2()];
      let QUAD_INDICES$3 = null;
      function _calcIntersectedPoints(left, right, bottom, top, center, angle, intersectPoints) {
        let sinAngle = Math.sin(angle);
        sinAngle = Math.abs(sinAngle) > EPSILON$1 ? sinAngle : 0;
        let cosAngle = Math.cos(angle);
        cosAngle = Math.abs(cosAngle) > EPSILON$1 ? cosAngle : 0;
        let tanAngle = 0;
        let cotAngle = 0;
        if (cosAngle !== 0) {
          tanAngle = sinAngle / cosAngle;
          if ((left - center.x) * cosAngle > 0) {
            const yLeft = center.y + tanAngle * (left - center.x);
            intersectPoints[0].x = left;
            intersectPoints[0].y = yLeft;
          }
          if ((right - center.x) * cosAngle > 0) {
            const yRight = center.y + tanAngle * (right - center.x);
            intersectPoints[2].x = right;
            intersectPoints[2].y = yRight;
          }
        }
        if (sinAngle !== 0) {
          cotAngle = cosAngle / sinAngle;
          if ((top - center.y) * sinAngle > 0) {
            const xTop = center.x + cotAngle * (top - center.y);
            intersectPoints[3].x = xTop;
            intersectPoints[3].y = top;
          }
          if ((bottom - center.y) * sinAngle > 0) {
            const xBottom = center.x + cotAngle * (bottom - center.y);
            intersectPoints[1].x = xBottom;
            intersectPoints[1].y = bottom;
          }
        }
      }
      function _calculateVertices(sprite) {
        const uiTrans = sprite.node._uiProps.uiTransformComp;
        const width = uiTrans.width;
        const height = uiTrans.height;
        const appX = uiTrans.anchorX * width;
        const appY = uiTrans.anchorY * height;
        const l = -appX;
        const b = -appY;
        const r = width - appX;
        const t = height - appY;
        const vertices = _vertices;
        vertices[0] = l;
        vertices[1] = b;
        vertices[2] = r;
        vertices[3] = t;
        const fillCenter = sprite.fillCenter;
        const cx = _center.x = Math.min(Math.max(0, fillCenter.x), 1) * (r - l) + l;
        const cy = _center.y = Math.min(Math.max(0, fillCenter.y), 1) * (t - b) + b;
        _vertPos[0].x = _vertPos[3].x = l;
        _vertPos[1].x = _vertPos[2].x = r;
        _vertPos[0].y = _vertPos[1].y = b;
        _vertPos[2].y = _vertPos[3].y = t;
        for (const num of _triangles) {
          Vec2.set(num, 0, 0);
        }
        if (cx !== vertices[0]) {
          Vec2.set(_triangles[0], 3, 0);
        }
        if (cx !== vertices[2]) {
          Vec2.set(_triangles[2], 1, 2);
        }
        if (cy !== vertices[1]) {
          Vec2.set(_triangles[1], 0, 1);
        }
        if (cy !== vertices[3]) {
          Vec2.set(_triangles[3], 2, 3);
        }
      }
      function _calculateUVs(spriteFrame) {
        const atlasWidth = spriteFrame.width;
        const atlasHeight = spriteFrame.height;
        const textureRect = spriteFrame.getRect();
        let u0 = 0;
        let u1 = 0;
        let v0 = 0;
        let v1 = 0;
        const uvs = _uvs;
        if (spriteFrame.isRotated()) {
          u0 = textureRect.x / atlasWidth;
          u1 = (textureRect.x + textureRect.height) / atlasWidth;
          v0 = textureRect.y / atlasHeight;
          v1 = (textureRect.y + textureRect.width) / atlasHeight;
          uvs[0] = uvs[2] = u0;
          uvs[4] = uvs[6] = u1;
          uvs[3] = uvs[7] = v1;
          uvs[1] = uvs[5] = v0;
        } else {
          u0 = textureRect.x / atlasWidth;
          u1 = (textureRect.x + textureRect.width) / atlasWidth;
          v0 = textureRect.y / atlasHeight;
          v1 = (textureRect.y + textureRect.height) / atlasHeight;
          uvs[0] = uvs[4] = u0;
          uvs[2] = uvs[6] = u1;
          uvs[1] = uvs[3] = v1;
          uvs[5] = uvs[7] = v0;
        }
      }
      function _getVertAngle(start, end) {
        const placementX = end.x - start.x;
        const placementY = end.y - start.y;
        if (placementX === 0 && placementY === 0) {
          return 0;
        } else if (placementX === 0) {
          if (placementY > 0) {
            return Math.PI * 0.5;
          } else {
            return Math.PI * 1.5;
          }
        } else {
          let angle = Math.atan(placementY / placementX);
          if (placementX < 0) {
            angle += Math.PI;
          }
          return angle;
        }
      }
      function _generateTriangle(dataList, offset, vert0, vert1, vert2) {
        const vertices = _vertices;
        const v0x = vertices[0];
        const v0y = vertices[1];
        const v1x = vertices[2];
        const v1y = vertices[3];
        dataList[offset].x = vert0.x;
        dataList[offset].y = vert0.y;
        dataList[offset + 1].x = vert1.x;
        dataList[offset + 1].y = vert1.y;
        dataList[offset + 2].x = vert2.x;
        dataList[offset + 2].y = vert2.y;
        let progressX = 0;
        let progressY = 0;
        progressX = (vert0.x - v0x) / (v1x - v0x);
        progressY = (vert0.y - v0y) / (v1y - v0y);
        _generateUV(progressX, progressY, dataList, offset);
        progressX = (vert1.x - v0x) / (v1x - v0x);
        progressY = (vert1.y - v0y) / (v1y - v0y);
        _generateUV(progressX, progressY, dataList, offset + 1);
        progressX = (vert2.x - v0x) / (v1x - v0x);
        progressY = (vert2.y - v0y) / (v1y - v0y);
        _generateUV(progressX, progressY, dataList, offset + 2);
      }
      function _generateUV(progressX, progressY, data, offset) {
        const uvs = _uvs;
        const px1 = uvs[0] + (uvs[2] - uvs[0]) * progressX;
        const px2 = uvs[4] + (uvs[6] - uvs[4]) * progressX;
        const py1 = uvs[1] + (uvs[3] - uvs[1]) * progressX;
        const py2 = uvs[5] + (uvs[7] - uvs[5]) * progressX;
        const uv = data[offset];
        uv.u = px1 + (px2 - px1) * progressY;
        uv.v = py1 + (py2 - py1) * progressY;
      }
      const radialFilled = {
        useModel: false,
        createData(sprite) {
          return sprite.requestRenderData();
        },
        updateRenderData(sprite) {
          const frame = sprite.spriteFrame;
          dynamicAtlasManager.packToDynamicAtlas(sprite, frame);
          this.updateUVs(sprite);
          const renderData = sprite.renderData;
          if (renderData && frame) {
            if (!renderData.vertDirty) {
              return;
            }
            const dataList = renderData.data;
            let fillStart = sprite.fillStart;
            let fillRange = sprite.fillRange;
            if (fillRange < 0) {
              fillStart += fillRange;
              fillRange = -fillRange;
            }
            while (fillStart >= 1.0) {
              fillStart -= 1.0;
            }
            while (fillStart < 0.0) {
              fillStart += 1.0;
            }
            fillStart *= PI_2;
            fillRange *= PI_2;
            const fillEnd = fillStart + fillRange;
            _calculateVertices(sprite);
            _calculateUVs(frame);
            _calcIntersectedPoints(_vertices[0], _vertices[2], _vertices[1], _vertices[3], _center, fillStart, _intersectPoint_1);
            _calcIntersectedPoints(_vertices[0], _vertices[2], _vertices[1], _vertices[3], _center, fillStart + fillRange, _intersectPoint_2);
            let offset = 0;
            for (let triangleIndex = 0; triangleIndex < 4; ++triangleIndex) {
              const triangle = _triangles[triangleIndex];
              if (!triangle) {
                continue;
              }
              if (fillRange >= PI_2) {
                renderData.dataLength = offset + 3;
                _generateTriangle(dataList, offset, _center, _vertPos[triangle.x], _vertPos[triangle.y]);
                offset += 3;
                continue;
              }
              let startAngle = _getVertAngle(_center, _vertPos[triangle.x]);
              let endAngle = _getVertAngle(_center, _vertPos[triangle.y]);
              if (endAngle < startAngle) {
                endAngle += PI_2;
              }
              startAngle -= PI_2;
              endAngle -= PI_2;
              for (let testIndex = 0; testIndex < 3; ++testIndex) {
                if (startAngle >= fillEnd) ; else if (startAngle >= fillStart) {
                  renderData.dataLength = offset + 3;
                  if (endAngle >= fillEnd) {
                    _generateTriangle(dataList, offset, _center, _vertPos[triangle.x], _intersectPoint_2[triangleIndex]);
                  } else {
                    _generateTriangle(dataList, offset, _center, _vertPos[triangle.x], _vertPos[triangle.y]);
                  }
                  offset += 3;
                } else if (endAngle > fillStart) {
                  if (endAngle <= fillEnd) {
                    renderData.dataLength = offset + 3;
                    _generateTriangle(dataList, offset, _center, _intersectPoint_1[triangleIndex], _vertPos[triangle.y]);
                    offset += 3;
                  } else {
                    renderData.dataLength = offset + 3;
                    _generateTriangle(dataList, offset, _center, _intersectPoint_1[triangleIndex], _intersectPoint_2[triangleIndex]);
                    offset += 3;
                  }
                }
                startAngle += PI_2;
                endAngle += PI_2;
              }
            }
            if (offset === 0) {
              renderData.dataLength = 0;
            }
            renderData.resize(offset, offset);
            {
              const indexCount = renderData.indexCount;
              this.createQuadIndices(indexCount);
              renderData.chunk.setIndexBuffer(QUAD_INDICES$3);
              this.updateWorldUVData(sprite);
              sprite.renderEntity.colorDirty = true;
            }
            renderData.updateRenderData(sprite, frame);
          }
        },
        createQuadIndices(indexCount) {
          QUAD_INDICES$3 = null;
          QUAD_INDICES$3 = new Uint16Array(indexCount);
          let offset = 0;
          for (let i = 0; i < indexCount; i++) {
            QUAD_INDICES$3[offset++] = i;
          }
        },
        fillBuffers(comp, renderer) {
          const node = comp.node;
          const renderData = comp.renderData;
          const chunk = renderData.chunk;
          if (comp._flagChangedVersion !== node.flagChangedVersion || renderData.vertDirty) {
            this.updateWorldVertexAndUVData(comp, chunk);
            renderData.vertDirty = false;
            comp._flagChangedVersion = node.flagChangedVersion;
          }
          this.updateColorLate(comp);
          chunk.bufferId;
          const vid = chunk.vertexOffset;
          const meshBuffer = chunk.meshBuffer;
          const ib = chunk.meshBuffer.iData;
          const indexOffset = meshBuffer.indexOffset;
          for (let i = 0; i < renderData.indexCount; i++) {
            ib[indexOffset + i] = vid + i;
          }
          meshBuffer.indexOffset += renderData.indexCount;
          meshBuffer.setDirty();
        },
        updateWorldUVData(sprite, chunk) {
          const renderData = sprite.renderData;
          const stride = renderData.floatStride;
          const dataList = renderData.data;
          const vData = renderData.chunk.vb;
          for (let i = 0; i < dataList.length; i++) {
            const offset = i * stride;
            vData[offset + 3] = dataList[i].u;
            vData[offset + 4] = dataList[i].v;
          }
        },
        updateWorldVertexAndUVData(sprite, chunk) {
          const node = sprite.node;
          node.getWorldMatrix(m$2);
          const renderData = sprite.renderData;
          const stride = renderData.floatStride;
          const dataList = sprite.renderData.data;
          const vData = chunk.vb;
          const vertexCount = renderData.vertexCount;
          let vertexOffset = 0;
          for (let i = 0; i < vertexCount; i++) {
            const vert = dataList[i];
            const x = vert.x;
            const y = vert.y;
            let rhw = m$2.m03 * x + m$2.m07 * y + m$2.m15;
            rhw = rhw ? 1 / rhw : 1;
            vData[vertexOffset + 0] = (m$2.m00 * x + m$2.m04 * y + m$2.m12) * rhw;
            vData[vertexOffset + 1] = (m$2.m01 * x + m$2.m05 * y + m$2.m13) * rhw;
            vData[vertexOffset + 2] = (m$2.m02 * x + m$2.m06 * y + m$2.m14) * rhw;
            vData[vertexOffset + 3] = vert.u;
            vData[vertexOffset + 4] = vert.v;
            vertexOffset += stride;
          }
        },
        updateUVs(sprite) {
          const renderData = sprite.renderData;
          renderData.vertDirty = true;
          sprite.markForUpdateRenderData();
        },
        updateColorLate(sprite) {
          const renderData = sprite.renderData;
          const vData = renderData.chunk.vb;
          const stride = renderData.floatStride;
          const vertexCount = renderData.vertexCount;
          let colorOffset = 5;
          const color = sprite.color;
          const colorR = color.r / 255;
          const colorG = color.g / 255;
          const colorB = color.b / 255;
          const colorA = sprite.node._uiProps.opacity;
          for (let i = 0; i < vertexCount; i++) {
            vData[colorOffset] = colorR;
            vData[colorOffset + 1] = colorG;
            vData[colorOffset + 2] = colorB;
            vData[colorOffset + 3] = colorA;
            colorOffset += stride;
          }
        },
        updateColor(sprite) {}
      };

      const QUAD_INDICES$2 = Uint16Array.from([0, 1, 2, 1, 3, 2]);
      const simple = {
        createData(sprite) {
          const renderData = sprite.requestRenderData();
          renderData.dataLength = 4;
          renderData.resize(4, 6);
          renderData.chunk.setIndexBuffer(QUAD_INDICES$2);
          return renderData;
        },
        updateRenderData(sprite) {
          const frame = sprite.spriteFrame;
          dynamicAtlasManager.packToDynamicAtlas(sprite, frame);
          this.updateUVs(sprite);
          const renderData = sprite.renderData;
          if (renderData && frame) {
            if (renderData.vertDirty) {
              this.updateVertexData(sprite);
            }
            renderData.updateRenderData(sprite, frame);
          }
        },
        updateWorldVerts(sprite, chunk) {
          const renderData = sprite.renderData;
          const vData = chunk.vb;
          const dataList = renderData.data;
          const node = sprite.node;
          const m = node.worldMatrix;
          const stride = renderData.floatStride;
          let offset = 0;
          const length = dataList.length;
          for (let i = 0; i < length; i++) {
            const curData = dataList[i];
            const x = curData.x;
            const y = curData.y;
            let rhw = m.m03 * x + m.m07 * y + m.m15;
            rhw = rhw ? 1 / rhw : 1;
            offset = i * stride;
            vData[offset + 0] = (m.m00 * x + m.m04 * y + m.m12) * rhw;
            vData[offset + 1] = (m.m01 * x + m.m05 * y + m.m13) * rhw;
            vData[offset + 2] = (m.m02 * x + m.m06 * y + m.m14) * rhw;
          }
        },
        fillBuffers(sprite, renderer) {
          if (sprite === null) {
            return;
          }
          const renderData = sprite.renderData;
          const chunk = renderData.chunk;
          if (sprite._flagChangedVersion !== sprite.node.flagChangedVersion || renderData.vertDirty) {
            this.updateWorldVerts(sprite, chunk);
            renderData.vertDirty = false;
            sprite._flagChangedVersion = sprite.node.flagChangedVersion;
          }
          const vidOrigin = chunk.vertexOffset;
          const meshBuffer = chunk.meshBuffer;
          const ib = chunk.meshBuffer.iData;
          let indexOffset = meshBuffer.indexOffset;
          const vid = vidOrigin;
          ib[indexOffset++] = vid;
          ib[indexOffset++] = vid + 1;
          ib[indexOffset++] = vid + 2;
          ib[indexOffset++] = vid + 1;
          ib[indexOffset++] = vid + 3;
          ib[indexOffset++] = vid + 2;
          meshBuffer.indexOffset += 6;
        },
        updateVertexData(sprite) {
          const renderData = sprite.renderData;
          if (!renderData) {
            return;
          }
          const uiTrans = sprite.node._uiProps.uiTransformComp;
          const dataList = renderData.data;
          const cw = uiTrans.width;
          const ch = uiTrans.height;
          const appX = uiTrans.anchorX * cw;
          const appY = uiTrans.anchorY * ch;
          let l = 0;
          let b = 0;
          let r = 0;
          let t = 0;
          if (sprite.trim) {
            l = -appX;
            b = -appY;
            r = cw - appX;
            t = ch - appY;
          } else {
            const frame = sprite.spriteFrame;
            const originSize = frame.originalSize;
            const ow = originSize.width;
            const oh = originSize.height;
            const scaleX = cw / ow;
            const scaleY = ch / oh;
            const trimmedBorder = frame.trimmedBorder;
            l = trimmedBorder.x * scaleX - appX;
            b = trimmedBorder.z * scaleY - appY;
            r = cw + trimmedBorder.y * scaleX - appX;
            t = ch + trimmedBorder.w * scaleY - appY;
          }
          dataList[0].x = l;
          dataList[0].y = b;
          dataList[1].x = r;
          dataList[1].y = b;
          dataList[2].x = l;
          dataList[2].y = t;
          dataList[3].x = r;
          dataList[3].y = t;
          renderData.vertDirty = true;
        },
        updateUVs(sprite) {
          if (!sprite.spriteFrame) return;
          const renderData = sprite.renderData;
          const vData = renderData.chunk.vb;
          const uv = sprite.spriteFrame.uv;
          vData[3] = uv[0];
          vData[4] = uv[1];
          vData[12] = uv[2];
          vData[13] = uv[3];
          vData[21] = uv[4];
          vData[22] = uv[5];
          vData[30] = uv[6];
          vData[31] = uv[7];
        },
        updateColor(sprite) {
          const renderData = sprite.renderData;
          const vData = renderData.chunk.vb;
          let colorOffset = 5;
          const color = sprite.color;
          const colorR = color.r / 255;
          const colorG = color.g / 255;
          const colorB = color.b / 255;
          const colorA = color.a / 255;
          for (let i = 0; i < 4; i++, colorOffset += renderData.floatStride) {
            vData[colorOffset] = colorR;
            vData[colorOffset + 1] = colorG;
            vData[colorOffset + 2] = colorB;
            vData[colorOffset + 3] = colorA;
          }
        }
      };

      const m$1 = new Mat4();
      const tempRenderData$1 = [];
      for (let i = 0; i < 4; i++) {
        tempRenderData$1.push({
          x: 0,
          y: 0,
          z: 0,
          u: 0,
          v: 0,
          color: new Color$1()
        });
      }
      const sliced = {
        createData(sprite) {
          const renderData = sprite.requestRenderData();
          renderData.dataLength = 16;
          renderData.resize(16, 54);
          this.QUAD_INDICES = new Uint16Array(54);
          this.createQuadIndices(4, 4);
          renderData.chunk.setIndexBuffer(this.QUAD_INDICES);
          return renderData;
        },
        createQuadIndices(vertexRow, vertexCol) {
          let offset = 0;
          for (let curRow = 0; curRow < vertexRow - 1; curRow++) {
            for (let curCol = 0; curCol < vertexCol - 1; curCol++) {
              const vid = curRow * vertexCol + curCol;
              this.QUAD_INDICES[offset++] = vid;
              this.QUAD_INDICES[offset++] = vid + 1;
              this.QUAD_INDICES[offset++] = vid + vertexCol;
              this.QUAD_INDICES[offset++] = vid + 1;
              this.QUAD_INDICES[offset++] = vid + 1 + vertexCol;
              this.QUAD_INDICES[offset++] = vid + vertexCol;
            }
          }
        },
        updateRenderData(sprite) {
          const frame = sprite.spriteFrame;
          dynamicAtlasManager.packToDynamicAtlas(sprite, frame);
          this.updateUVs(sprite);
          const renderData = sprite.renderData;
          if (renderData && frame) {
            const vertDirty = renderData.vertDirty;
            if (vertDirty) {
              this.updateVertexData(sprite);
            }
            renderData.updateRenderData(sprite, frame);
          }
        },
        updateVertexData(sprite) {
          const renderData = sprite.renderData;
          const dataList = renderData.data;
          const uiTrans = sprite.node._uiProps.uiTransformComp;
          const width = uiTrans.width;
          const height = uiTrans.height;
          const appX = uiTrans.anchorX * width;
          const appY = uiTrans.anchorY * height;
          const frame = sprite.spriteFrame;
          const leftWidth = frame.insetLeft;
          const rightWidth = frame.insetRight;
          const topHeight = frame.insetTop;
          const bottomHeight = frame.insetBottom;
          let sizableWidth = width - leftWidth - rightWidth;
          let sizableHeight = height - topHeight - bottomHeight;
          let xScale = width / (leftWidth + rightWidth);
          let yScale = height / (topHeight + bottomHeight);
          xScale = Number.isNaN(xScale) || xScale > 1 ? 1 : xScale;
          yScale = Number.isNaN(yScale) || yScale > 1 ? 1 : yScale;
          sizableWidth = sizableWidth < 0 ? 0 : sizableWidth;
          sizableHeight = sizableHeight < 0 ? 0 : sizableHeight;
          tempRenderData$1[0].x = -appX;
          tempRenderData$1[0].y = -appY;
          tempRenderData$1[1].x = leftWidth * xScale - appX;
          tempRenderData$1[1].y = bottomHeight * yScale - appY;
          tempRenderData$1[2].x = tempRenderData$1[1].x + sizableWidth;
          tempRenderData$1[2].y = tempRenderData$1[1].y + sizableHeight;
          tempRenderData$1[3].x = width - appX;
          tempRenderData$1[3].y = height - appY;
          for (let curRow = 0; curRow < 4; curRow++) {
            for (let curCol = 0; curCol < 4; curCol++) {
              const curIndex = curRow * 4 + curCol;
              if (curIndex < renderData.dataLength && curRow < tempRenderData$1.length && curCol < tempRenderData$1.length) {
                dataList[curIndex].x = tempRenderData$1[curCol].x;
                dataList[curIndex].y = tempRenderData$1[curRow].y;
              }
            }
          }
        },
        fillBuffers(sprite, renderer) {
          const renderData = sprite.renderData;
          const chunk = renderData.chunk;
          if (sprite._flagChangedVersion !== sprite.node.flagChangedVersion || renderData.vertDirty) {
            this.updateWorldVertexData(sprite, chunk);
            renderData.vertDirty = false;
            sprite._flagChangedVersion = sprite.node.flagChangedVersion;
          }
          chunk.bufferId;
          const vid = chunk.vertexOffset;
          const meshBuffer = chunk.meshBuffer;
          const ib = chunk.meshBuffer.iData;
          let indexOffset = meshBuffer.indexOffset;
          for (let r = 0; r < 3; ++r) {
            for (let c = 0; c < 3; ++c) {
              const start = vid + r * 4 + c;
              ib[indexOffset++] = start;
              ib[indexOffset++] = start + 1;
              ib[indexOffset++] = start + 4;
              ib[indexOffset++] = start + 1;
              ib[indexOffset++] = start + 5;
              ib[indexOffset++] = start + 4;
            }
          }
          meshBuffer.indexOffset = indexOffset;
        },
        updateWorldVertexData(sprite, chunk) {
          const node = sprite.node;
          node.getWorldMatrix(m$1);
          const renderData = sprite.renderData;
          const stride = renderData.floatStride;
          const dataList = renderData.data;
          const vData = chunk.vb;
          let offset = 0;
          for (let row = 0; row < 4; ++row) {
            const rowD = dataList[row * 4];
            for (let col = 0; col < 4; ++col) {
              const colD = dataList[col];
              const x = colD.x;
              const y = rowD.y;
              let rhw = m$1.m03 * x + m$1.m07 * y + m$1.m15;
              rhw = rhw ? 1 / rhw : 1;
              offset = (row * 4 + col) * stride;
              vData[offset + 0] = (m$1.m00 * x + m$1.m04 * y + m$1.m12) * rhw;
              vData[offset + 1] = (m$1.m01 * x + m$1.m05 * y + m$1.m13) * rhw;
              vData[offset + 2] = (m$1.m02 * x + m$1.m06 * y + m$1.m14) * rhw;
            }
          }
        },
        updateUVs(sprite) {
          if (!sprite.spriteFrame) return;
          const renderData = sprite.renderData;
          const vData = renderData.chunk.vb;
          const stride = renderData.floatStride;
          const uv = sprite.spriteFrame.uvSliced;
          let uvOffset = 3;
          for (let i = 0; i < 16; i++) {
            vData[uvOffset] = uv[i].u;
            vData[uvOffset + 1] = uv[i].v;
            uvOffset += stride;
          }
        },
        updateColor(sprite) {
          const renderData = sprite.renderData;
          const vData = renderData.chunk.vb;
          const stride = renderData.floatStride;
          let colorOffset = 5;
          const color = sprite.color;
          const colorR = color.r / 255;
          const colorG = color.g / 255;
          const colorB = color.b / 255;
          const colorA = sprite.node._uiProps.opacity;
          for (let i = 0; i < 16; i++) {
            vData[colorOffset] = colorR;
            vData[colorOffset + 1] = colorG;
            vData[colorOffset + 2] = colorB;
            vData[colorOffset + 3] = colorA;
            colorOffset += stride;
          }
        }
      };

      const m = new Mat4();
      let origin;
      let leftInner;
      let rightInner;
      let rightOuter;
      let bottomInner;
      let topInner;
      let topOuter;
      let tempRenderDataLength = 0;
      const tempRenderData = [];
      let QUAD_INDICES$1 = null;
      function has9SlicedOffsetVertexCount(spriteFrame) {
        if (spriteFrame) {
          if (spriteFrame.insetTop > 0 || spriteFrame.insetBottom > 0 || spriteFrame.insetLeft > 0 || spriteFrame.insetRight > 0) {
            return 2;
          }
        }
        return 0;
      }
      const tiled = {
        createData(sprite) {
          return sprite.requestRenderData();
        },
        updateRenderData(sprite) {
          const renderData = sprite.renderData;
          const frame = sprite.spriteFrame;
          if (!frame || !renderData) {
            return;
          }
          if (!renderData.vertDirty) {
            return;
          }
          const uiTrans = sprite.node._uiProps.uiTransformComp;
          const contentWidth = Math.abs(uiTrans.width);
          const contentHeight = Math.abs(uiTrans.height);
          const rect = frame.getRect();
          const leftWidth = frame.insetLeft;
          const rightWidth = frame.insetRight;
          const centerWidth = rect.width - leftWidth - rightWidth;
          const topHeight = frame.insetTop;
          const bottomHeight = frame.insetBottom;
          const centerHeight = rect.height - topHeight - bottomHeight;
          let sizableWidth = contentWidth - leftWidth - rightWidth;
          let sizableHeight = contentHeight - topHeight - bottomHeight;
          sizableWidth = sizableWidth > 0 ? sizableWidth : 0;
          sizableHeight = sizableHeight > 0 ? sizableHeight : 0;
          const hRepeat = centerWidth === 0 ? sizableWidth : sizableWidth / centerWidth;
          const vRepeat = centerHeight === 0 ? sizableHeight : sizableHeight / centerHeight;
          const offsetVertexCount = has9SlicedOffsetVertexCount(frame);
          const row = Math.ceil(vRepeat + offsetVertexCount);
          const col = Math.ceil(hRepeat + offsetVertexCount);
          renderData.dataLength = row * 2 * (col * 2);
          this.updateVerts(sprite, sizableWidth, sizableHeight, row, col);
          if (renderData.vertexCount !== row * col * 4) {
            sprite.renderEntity.colorDirty = true;
          }
          renderData.resize(row * col * 4, row * col * 6);
          {
            const indexCount = renderData.indexCount;
            this.createQuadIndices(indexCount);
            renderData.chunk.setIndexBuffer(QUAD_INDICES$1);
            this.updateWorldUVData(sprite);
          }
          renderData.updateRenderData(sprite, frame);
        },
        createQuadIndices(indexCount) {
          if (indexCount % 6 !== 0) {
            error('illegal index count!');
            return;
          }
          const quadCount = indexCount / 6;
          QUAD_INDICES$1 = null;
          QUAD_INDICES$1 = new Uint16Array(indexCount);
          let offset = 0;
          for (let i = 0; i < quadCount; i++) {
            QUAD_INDICES$1[offset++] = 0 + i * 4;
            QUAD_INDICES$1[offset++] = 1 + i * 4;
            QUAD_INDICES$1[offset++] = 2 + i * 4;
            QUAD_INDICES$1[offset++] = 1 + i * 4;
            QUAD_INDICES$1[offset++] = 3 + i * 4;
            QUAD_INDICES$1[offset++] = 2 + i * 4;
          }
        },
        updateUVs(sprite) {
          const renderData = sprite.renderData;
          renderData.vertDirty = true;
          sprite.markForUpdateRenderData();
        },
        fillBuffers(sprite, renderer) {
          const node = sprite.node;
          const renderData = sprite.renderData;
          const chunk = renderData.chunk;
          if (sprite._flagChangedVersion !== node.flagChangedVersion || renderData.vertDirty) {
            this.updateWorldVertexAndUVData(sprite, chunk);
            renderData.vertDirty = false;
            sprite._flagChangedVersion = node.flagChangedVersion;
          }
          this.updateColorLate(sprite);
          chunk.bufferId;
          let vid = chunk.vertexOffset;
          const meshBuffer = chunk.meshBuffer;
          const ib = chunk.meshBuffer.iData;
          let indexOffset = meshBuffer.indexOffset;
          for (let i = 0; i < renderData.indexCount; i += 6) {
            ib[indexOffset++] = vid;
            ib[indexOffset++] = vid + 1;
            ib[indexOffset++] = vid + 2;
            ib[indexOffset++] = vid + 1;
            ib[indexOffset++] = vid + 3;
            ib[indexOffset++] = vid + 2;
            vid += 4;
            meshBuffer.indexOffset += 6;
          }
          meshBuffer.setDirty();
        },
        updateWorldUVData(sprite) {
          const renderData = sprite.renderData;
          const stride = renderData.floatStride;
          const dataList = renderData.data;
          const vData = renderData.chunk.vb;
          for (let i = 0; i < dataList.length; i++) {
            const offset = i * stride;
            vData[offset + 3] = dataList[i].u;
            vData[offset + 4] = dataList[i].v;
          }
        },
        updateWorldVertexAndUVData(sprite, chunk) {
          const node = sprite.node;
          node.getWorldMatrix(m);
          const renderData = sprite.renderData;
          const stride = renderData.floatStride;
          const dataList = renderData.data;
          const vData = chunk.vb;
          const length = dataList.length;
          for (let i = 0; i < length; i++) {
            const x = dataList[i].x;
            const y = dataList[i].y;
            const z = dataList[i].z;
            let rhw = m.m03 * x + m.m07 * y + m.m11 * z + m.m15;
            rhw = rhw ? 1 / rhw : 1;
            const offset = i * stride;
            vData[offset] = (m.m00 * x + m.m04 * y + m.m08 * z + m.m12) * rhw;
            vData[offset + 1] = (m.m01 * x + m.m05 * y + m.m09 * z + m.m13) * rhw;
            vData[offset + 2] = (m.m02 * x + m.m06 * y + m.m10 * z + m.m14) * rhw;
          }
          this.updateWorldUVData(sprite);
        },
        updateVerts(sprite, sizableWidth, sizableHeight, row, col) {
          const uiTrans = sprite.node._uiProps.uiTransformComp;
          const renderData = sprite.renderData;
          const dataList = renderData.data;
          const frame = sprite.spriteFrame;
          const rect = frame.rect;
          const contentWidth = Math.abs(uiTrans.width);
          const contentHeight = Math.abs(uiTrans.height);
          const appx = uiTrans.anchorX * contentWidth;
          const appy = uiTrans.anchorY * contentHeight;
          const leftWidth = frame.insetLeft;
          const rightWidth = frame.insetRight;
          const centerWidth = rect.width - leftWidth - rightWidth;
          const topHeight = frame.insetTop;
          const bottomHeight = frame.insetBottom;
          const centerHeight = rect.height - topHeight - bottomHeight;
          const xScale = uiTrans.width / (leftWidth + rightWidth) > 1 ? 1 : uiTrans.width / (leftWidth + rightWidth);
          const yScale = uiTrans.height / (topHeight + bottomHeight) > 1 ? 1 : uiTrans.height / (topHeight + bottomHeight);
          let offsetWidth = 0;
          let offsetHeight = 0;
          if (centerWidth > 0) {
            offsetWidth = Math.floor(sizableWidth * 1000) / 1000 % centerWidth === 0 ? centerWidth : sizableWidth % centerWidth;
          } else {
            offsetWidth = sizableWidth;
          }
          if (centerHeight > 0) {
            offsetHeight = Math.floor(sizableHeight * 1000) / 1000 % centerHeight === 0 ? centerHeight : sizableHeight % centerHeight;
          } else {
            offsetHeight = sizableHeight;
          }
          tempRenderData.length = 0;
          tempRenderDataLength = Math.max(row + 1, col + 1);
          for (let i = 0; i < tempRenderDataLength; i++) {
            tempRenderData.push({
              x: 0,
              y: 0,
              z: 0,
              u: 0,
              v: 0,
              color: new Color$1()
            });
          }
          const offsetVertexCount = has9SlicedOffsetVertexCount(frame);
          if (offsetVertexCount === 0) {
            for (let i = 0; i < tempRenderDataLength; i++) {
              if (i >= col) {
                tempRenderData[i].x = contentWidth - appx;
              } else {
                tempRenderData[i].x = -appx + i * centerWidth;
              }
              if (i >= row) {
                tempRenderData[i].y = contentHeight - appy;
              } else {
                tempRenderData[i].y = -appy + i * centerHeight;
              }
            }
          } else {
            for (let i = 0; i < tempRenderDataLength; i++) {
              if (i === 0) {
                tempRenderData[i].x = -appx;
              } else if (i === 1) {
                tempRenderData[i].x = -appx + leftWidth * xScale;
              } else if (i > 1 && i < col - 1) {
                if (centerWidth > 0) {
                  tempRenderData[i].x = -appx + leftWidth * xScale + centerWidth * (i - 1);
                } else {
                  tempRenderData[i].x = leftWidth + sizableWidth - appx;
                }
              } else if (i === col - 1) {
                tempRenderData[i].x = -appx + leftWidth * xScale + offsetWidth + centerWidth * (i - 2);
              } else if (i >= col) {
                tempRenderData[i].x = Math.min(leftWidth + sizableWidth + rightWidth, contentWidth) - appx;
              }
              if (i === 0) {
                tempRenderData[i].y = -appy;
              } else if (i === 1) {
                tempRenderData[i].y = -appy + bottomHeight * yScale;
              } else if (i > 1 && i < row - 1) {
                if (centerHeight > 0) {
                  tempRenderData[i].y = -appy + bottomHeight * yScale + centerHeight * (i - 1);
                } else {
                  tempRenderData[i].y = bottomHeight + sizableHeight - appy;
                }
              } else if (i === row - 1) {
                tempRenderData[i].y = -appy + bottomHeight * yScale + offsetHeight + centerHeight * (i - 2);
              } else if (i >= row) {
                tempRenderData[i].y = Math.min(bottomHeight + sizableHeight + topHeight, contentHeight) - appy;
              }
            }
          }
          let x = 0;
          let x1 = 0;
          let y = 0;
          let y1 = 0;
          for (let yIndex = 0; yIndex < row; ++yIndex) {
            y = tempRenderData[yIndex].y;
            y1 = tempRenderData[yIndex + 1].y;
            for (let xIndex = 0; xIndex < col; ++xIndex) {
              x = tempRenderData[xIndex].x;
              x1 = tempRenderData[xIndex + 1].x;
              const curIndex = 4 * (yIndex * col + xIndex);
              dataList[curIndex].x = x;
              dataList[curIndex].y = y;
              dataList[curIndex + 1].x = x1;
              dataList[curIndex + 1].y = y;
              dataList[curIndex + 2].x = x;
              dataList[curIndex + 2].y = y1;
              dataList[curIndex + 3].x = x1;
              dataList[curIndex + 3].y = y1;
            }
          }
          const rotated = frame.rotated;
          frame.uv;
          const uvSliced = frame.uvSliced;
          origin = uvSliced[0];
          leftInner = uvSliced[1];
          rightInner = uvSliced[2];
          rightOuter = uvSliced[3];
          bottomInner = uvSliced[4];
          topInner = uvSliced[8];
          topOuter = uvSliced[12];
          let coefU = 0;
          let coefV = 0;
          const hRepeat = centerWidth === 0 ? sizableWidth : sizableWidth / centerWidth;
          const vRepeat = centerHeight === 0 ? sizableHeight : sizableHeight / centerHeight;
          const tempXVerts = [];
          const tempYVerts = [];
          for (let yIndexUV = 0; yIndexUV < row; ++yIndexUV) {
            if (sizableHeight > centerHeight) {
              const curYRectCount = offsetVertexCount > 0 ? yIndexUV : yIndexUV + 1;
              if (sizableHeight >= curYRectCount * centerHeight) {
                coefV = 1;
              } else {
                coefV = vRepeat % 1;
              }
            } else {
              coefV = vRepeat;
            }
            for (let xIndexUV = 0; xIndexUV < col; ++xIndexUV) {
              if (sizableWidth > centerWidth) {
                const curXRectCount = offsetVertexCount > 0 ? xIndexUV : xIndexUV + 1;
                if (sizableWidth >= curXRectCount * centerWidth) {
                  coefU = 1;
                } else {
                  coefU = hRepeat % 1;
                }
              } else {
                coefU = hRepeat;
              }
              if (rotated) {
                if (offsetVertexCount === 0) {
                  tempXVerts[0] = bottomInner.u;
                  tempXVerts[1] = bottomInner.u;
                  tempXVerts[2] = bottomInner.u + (topInner.u - bottomInner.u) * coefV;
                  tempYVerts[0] = leftInner.v;
                  tempYVerts[1] = leftInner.v + (rightInner.v - leftInner.v) * coefU;
                  tempYVerts[2] = leftInner.v;
                } else {
                  if (yIndexUV === 0) {
                    tempXVerts[0] = origin.u;
                    tempXVerts[1] = origin.u;
                    tempXVerts[2] = bottomInner.u;
                  } else if (yIndexUV < row - 1) {
                    tempXVerts[0] = bottomInner.u;
                    tempXVerts[1] = bottomInner.u;
                    tempXVerts[2] = bottomInner.u + (topInner.u - bottomInner.u) * coefV;
                  } else if (yIndexUV === row - 1) {
                    tempXVerts[0] = topInner.u;
                    tempXVerts[1] = topInner.u;
                    tempXVerts[2] = topOuter.u;
                  }
                  if (xIndexUV === 0) {
                    tempYVerts[0] = origin.v;
                    tempYVerts[1] = leftInner.v;
                    tempYVerts[2] = origin.v;
                  } else if (xIndexUV < col - 1) {
                    tempYVerts[0] = leftInner.v;
                    tempYVerts[1] = leftInner.v + (rightInner.v - leftInner.v) * coefU;
                    tempYVerts[2] = leftInner.v;
                  } else if (xIndexUV === col - 1) {
                    tempYVerts[0] = rightInner.v;
                    tempYVerts[1] = rightOuter.v;
                    tempYVerts[2] = rightInner.v;
                  }
                }
                tempXVerts[3] = tempXVerts[2];
                tempYVerts[3] = tempYVerts[1];
              } else {
                if (offsetVertexCount === 0) {
                  tempXVerts[0] = leftInner.u;
                  tempXVerts[1] = leftInner.u + (rightInner.u - leftInner.u) * coefU;
                  tempXVerts[2] = leftInner.u;
                  tempYVerts[0] = bottomInner.v;
                  tempYVerts[1] = bottomInner.v;
                  tempYVerts[2] = bottomInner.v + (topInner.v - bottomInner.v) * coefV;
                } else {
                  if (xIndexUV === 0) {
                    tempXVerts[0] = origin.u;
                    tempXVerts[1] = leftInner.u;
                    tempXVerts[2] = origin.u;
                  } else if (xIndexUV < col - 1) {
                    tempXVerts[0] = leftInner.u;
                    tempXVerts[1] = leftInner.u + (rightInner.u - leftInner.u) * coefU;
                    tempXVerts[2] = leftInner.u;
                  } else if (xIndexUV === col - 1) {
                    tempXVerts[0] = rightInner.u;
                    tempXVerts[1] = rightOuter.u;
                    tempXVerts[2] = rightInner.u;
                  }
                  if (yIndexUV === 0) {
                    tempYVerts[0] = origin.v;
                    tempYVerts[1] = origin.v;
                    tempYVerts[2] = bottomInner.v;
                  } else if (yIndexUV < row - 1) {
                    tempYVerts[0] = bottomInner.v;
                    tempYVerts[1] = bottomInner.v;
                    tempYVerts[2] = bottomInner.v + (topInner.v - bottomInner.v) * coefV;
                  } else if (yIndexUV === row - 1) {
                    tempYVerts[0] = topInner.v;
                    tempYVerts[1] = topInner.v;
                    tempYVerts[2] = topOuter.v;
                  }
                }
                tempXVerts[3] = tempXVerts[1];
                tempYVerts[3] = tempYVerts[2];
              }
              const curIndex = 4 * (yIndexUV * col + xIndexUV);
              dataList[curIndex].u = tempXVerts[0];
              dataList[curIndex].v = tempYVerts[0];
              dataList[curIndex + 1].u = tempXVerts[1];
              dataList[curIndex + 1].v = tempYVerts[1];
              dataList[curIndex + 2].u = tempXVerts[2];
              dataList[curIndex + 2].v = tempYVerts[2];
              dataList[curIndex + 3].u = tempXVerts[3];
              dataList[curIndex + 3].v = tempYVerts[3];
            }
          }
        },
        updateColorLate(sprite) {
          const renderData = sprite.renderData;
          const vData = renderData.chunk.vb;
          const stride = renderData.floatStride;
          const vertexCount = renderData.vertexCount;
          let colorOffset = 5;
          const color = sprite.color;
          const colorR = color.r / 255;
          const colorG = color.g / 255;
          const colorB = color.b / 255;
          const colorA = sprite.node._uiProps.opacity;
          for (let i = 0; i < vertexCount; i++) {
            vData[colorOffset] = colorR;
            vData[colorOffset + 1] = colorG;
            vData[colorOffset + 2] = colorB;
            vData[colorOffset + 3] = colorA;
            colorOffset += stride;
          }
        },
        updateColor(sprite) {}
      };

      const SpriteType = Sprite.Type;
      const FillType = Sprite.FillType;
      const spriteAssembler = exports('spriteAssembler', {
        getAssembler(spriteComp) {
          let util = simple;
          const comp = spriteComp;
          switch (comp.type) {
            case SpriteType.SLICED:
              util = sliced;
              break;
            case SpriteType.TILED:
              util = tiled;
              break;
            case SpriteType.FILLED:
              if (comp.fillType === FillType.RADIAL) {
                util = radialFilled;
              } else {
                util = barFilled;
              }
              break;
          }
          return util;
        }
      });
      Sprite.Assembler = spriteAssembler;

      const mouseEvents = [Input.EventType.MOUSE_DOWN, Input.EventType.MOUSE_MOVE, Input.EventType.MOUSE_UP, Input.EventType.MOUSE_WHEEL];
      const touchEvents = [Input.EventType.TOUCH_START, Input.EventType.TOUCH_MOVE, Input.EventType.TOUCH_END, Input.EventType.TOUCH_CANCEL];
      class PointerEventDispatcher {
        constructor() {
          this.priority = EventDispatcherPriority.UI;
          this._isListDirty = false;
          this._inDispatchCount = 0;
          this._pointerEventProcessorList = [];
          this._processorListToAdd = [];
          this._processorListToRemove = [];
          input._registerEventDispatcher(this);
          NodeEventProcessor.callbacksInvoker.on(DispatcherEventType.ADD_POINTER_EVENT_PROCESSOR, this.addPointerEventProcessor, this);
          NodeEventProcessor.callbacksInvoker.on(DispatcherEventType.REMOVE_POINTER_EVENT_PROCESSOR, this.removePointerEventProcessor, this);
          NodeEventProcessor.callbacksInvoker.on(DispatcherEventType.MARK_LIST_DIRTY, this._markListDirty, this);
        }
        dispatchEvent(event) {
          const eventType = event.type;
          if (touchEvents.includes(eventType)) {
            return this.dispatchEventTouch(event);
          } else if (mouseEvents.includes(eventType)) {
            return this.dispatchEventMouse(event);
          }
          return true;
        }
        addPointerEventProcessor(pointerEventProcessor) {
          if (this._inDispatchCount === 0) {
            if (!this._pointerEventProcessorList.includes(pointerEventProcessor)) {
              this._pointerEventProcessorList.push(pointerEventProcessor);
              this._isListDirty = true;
            }
          } else if (!this._processorListToAdd.includes(pointerEventProcessor)) {
            this._processorListToAdd.push(pointerEventProcessor);
          }
          remove(this._processorListToRemove, pointerEventProcessor);
        }
        removePointerEventProcessor(pointerEventProcessor) {
          if (this._inDispatchCount === 0) {
            remove(this._pointerEventProcessorList, pointerEventProcessor);
            this._isListDirty = true;
          } else if (!this._processorListToRemove.includes(pointerEventProcessor)) {
            this._processorListToRemove.push(pointerEventProcessor);
          }
          remove(this._processorListToAdd, pointerEventProcessor);
        }
        dispatchEventMouse(eventMouse) {
          this._inDispatchCount++;
          this._sortPointerEventProcessorList();
          const pointerEventProcessorList = this._pointerEventProcessorList;
          const length = pointerEventProcessorList.length;
          let dispatchToNextEventDispatcher = true;
          for (let i = 0; i < length; ++i) {
            const pointerEventProcessor = pointerEventProcessorList[i];
            if (pointerEventProcessor.isEnabled && pointerEventProcessor.shouldHandleEventMouse && pointerEventProcessor._handleEventMouse(eventMouse)) {
              dispatchToNextEventDispatcher = false;
              if (!eventMouse.preventSwallow) {
                break;
              } else {
                eventMouse.preventSwallow = false;
              }
            }
          }
          if (--this._inDispatchCount <= 0) {
            this._updatePointerEventProcessorList();
          }
          return dispatchToNextEventDispatcher;
        }
        dispatchEventTouch(eventTouch) {
          this._inDispatchCount++;
          this._sortPointerEventProcessorList();
          const pointerEventProcessorList = this._pointerEventProcessorList;
          const length = pointerEventProcessorList.length;
          const touch = eventTouch.touch;
          let dispatchToNextEventDispatcher = true;
          for (let i = 0; i < length; ++i) {
            const pointerEventProcessor = pointerEventProcessorList[i];
            if (pointerEventProcessor.isEnabled && pointerEventProcessor.shouldHandleEventTouch) {
              if (eventTouch.type === InputEventType.TOUCH_START) {
                if (pointerEventProcessor._handleEventTouch(eventTouch)) {
                  pointerEventProcessor.claimedTouchIdList.push(touch.getID());
                  dispatchToNextEventDispatcher = false;
                  if (!eventTouch.preventSwallow) {
                    break;
                  } else {
                    eventTouch.preventSwallow = false;
                  }
                }
              } else if (pointerEventProcessor.claimedTouchIdList.length > 0) {
                const index = pointerEventProcessor.claimedTouchIdList.indexOf(touch.getID());
                if (index !== -1) {
                  pointerEventProcessor._handleEventTouch(eventTouch);
                  if (eventTouch.type === InputEventType.TOUCH_END || eventTouch.type === InputEventType.TOUCH_CANCEL) {
                    removeAt(pointerEventProcessor.claimedTouchIdList, index);
                  }
                  dispatchToNextEventDispatcher = false;
                  if (!eventTouch.preventSwallow) {
                    break;
                  } else {
                    eventTouch.preventSwallow = false;
                  }
                }
              }
            }
          }
          if (--this._inDispatchCount <= 0) {
            this._updatePointerEventProcessorList();
          }
          return dispatchToNextEventDispatcher;
        }
        _updatePointerEventProcessorList() {
          const listToAdd = this._processorListToAdd;
          const addLength = listToAdd.length;
          for (let i = 0; i < addLength; ++i) {
            this.addPointerEventProcessor(listToAdd[i]);
          }
          listToAdd.length = 0;
          const listToRemove = this._processorListToRemove;
          const removeLength = listToRemove.length;
          for (let i = 0; i < removeLength; ++i) {
            this.removePointerEventProcessor(listToRemove[i]);
          }
          listToRemove.length = 0;
        }
        _sortPointerEventProcessorList() {
          if (!this._isListDirty) {
            return;
          }
          const pointerEventProcessorList = this._pointerEventProcessorList;
          const length = pointerEventProcessorList.length;
          for (let i = 0; i < length; ++i) {
            const pointerEventProcessor = pointerEventProcessorList[i];
            const node = pointerEventProcessor.node;
            if (node._uiProps) {
              const trans = node._uiProps.uiTransformComp;
              pointerEventProcessor.cachedCameraPriority = trans.cameraPriority;
            }
          }
          pointerEventProcessorList.sort(this._sortByPriority);
          this._isListDirty = false;
        }
        _sortByPriority(p1, p2) {
          const node1 = p1.node;
          const node2 = p2.node;
          if (!p2 || !node2 || !node2.activeInHierarchy || !node2._uiProps.uiTransformComp) {
            return -1;
          } else if (!p1 || !node1 || !node1.activeInHierarchy || !node1._uiProps.uiTransformComp) {
            return 1;
          }
          if (p1.cachedCameraPriority !== p2.cachedCameraPriority) {
            return p2.cachedCameraPriority - p1.cachedCameraPriority;
          }
          let n1 = node1;
          let n2 = node2;
          let ex = false;
          while (((_parent = n1.parent) === null || _parent === void 0 ? void 0 : _parent.uuid) !== ((_parent2 = n2.parent) === null || _parent2 === void 0 ? void 0 : _parent2.uuid)) {
            var _parent, _parent2, _n, _n$parent, _n2, _n2$parent;
            n1 = ((_n = n1) === null || _n === void 0 ? void 0 : (_n$parent = _n.parent) === null || _n$parent === void 0 ? void 0 : _n$parent.parent) === null ? (ex = true) && node2 : n1 && n1.parent;
            n2 = ((_n2 = n2) === null || _n2 === void 0 ? void 0 : (_n2$parent = _n2.parent) === null || _n2$parent === void 0 ? void 0 : _n2$parent.parent) === null ? (ex = true) && node1 : n2 && n2.parent;
          }
          if (n1.uuid === n2.uuid) {
            if (n1.uuid === node2.uuid) {
              return -1;
            }
            if (n1.uuid === node1.uuid) {
              return 1;
            }
          }
          const priority1 = n1 ? n1.getSiblingIndex() : 0;
          const priority2 = n2 ? n2.getSiblingIndex() : 0;
          return ex ? priority1 - priority2 : priority2 - priority1;
        }
        _markListDirty() {
          this._isListDirty = true;
        }
      }
      new PointerEventDispatcher();

      const _dsInfo = new DescriptorSetInfo(null);
      const m4_1 = new Mat4();
      class Batcher2D {
        get nativeObj() {
          return this._nativeObj;
        }
        get currBufferAccessor() {
          if (this._staticVBBuffer) return this._staticVBBuffer;
          this._staticVBBuffer = this.switchBufferAccessor();
          return this._staticVBBuffer;
        }
        get batches() {
          return this._batches;
        }
        set currStaticRoot(value) {
          this._currStaticRoot = value;
        }
        set currIsStatic(value) {
          this._currIsStatic = value;
        }
        constructor(_root) {
          this.device = void 0;
          this._screens = [];
          this._staticVBBuffer = null;
          this._bufferAccessors = new Map();
          this._drawBatchPool = void 0;
          this._batches = void 0;
          this._currBID = -1;
          this._indexStart = 0;
          this._emptyMaterial = new Material();
          this._currRenderData = null;
          this._currMaterial = this._emptyMaterial;
          this._currTexture = null;
          this._currSampler = null;
          this._currStaticRoot = null;
          this._currComponent = null;
          this._currTransform = null;
          this._currTextureHash = 0;
          this._currSamplerHash = 0;
          this._currLayer = 0;
          this._currDepthStencilStateStage = null;
          this._currIsStatic = false;
          this._currHash = 0;
          this._currIsMiddleware = false;
          this._middlewareEnableBatch = false;
          this._middlewareBuffer = null;
          this._middlewareIndexStart = 0;
          this._middlewareIndexCount = 0;
          this._pOpacity = 1;
          this._opacityDirty = 0;
          this._descriptorSetCache = new DescriptorSetCache();
          this._meshDataArray = [];
          this._maskClearModel = null;
          this._maskClearMtl = null;
          this._maskModelMesh = null;
          this._root = _root;
          this.device = _root.device;
          this._batches = new CachedArray(64);
          this._drawBatchPool = new Pool(() => new DrawBatch2D(), 128, obj => obj.destroy(this));
        }
        initialize() {
          return true;
        }
        destroy() {
          for (let i = 0; i < this._batches.length; i++) {
            if (this._batches.array[i]) {
              this._batches.array[i].destroy(this);
            }
          }
          this._batches.destroy();
          for (const accessor of this._bufferAccessors.values()) {
            accessor.destroy();
          }
          this._bufferAccessors.clear();
          if (this._drawBatchPool) {
            this._drawBatchPool.destroy();
          }
          this._descriptorSetCache.destroy();
          StencilManager.sharedManager.destroy();
          if (this._maskClearModel && this._maskModelMesh) {
            legacyCC.director.root.destroyModel(this._maskClearModel);
            this._maskModelMesh.destroy();
          }
          if (this._maskClearMtl) {
            this._maskClearMtl.destroy();
          }
        }
        syncRootNodesToNative() {
          {
            const rootNodes = [];
            for (const screen of this._screens) {
              rootNodes.push(screen.node);
            }
            this._nativeObj.syncRootNodesToNative(rootNodes);
          }
        }
        addScreen(comp) {
          this._screens.push(comp);
          this._screens.sort(this._screenSort);
          {
            this.syncRootNodesToNative();
          }
        }
        removeScreen(comp) {
          const idx = this._screens.indexOf(comp);
          if (idx === -1) {
            return;
          }
          this._screens.splice(idx, 1);
          {
            this.syncRootNodesToNative();
          }
        }
        sortScreens() {
          this._screens.sort(this._screenSort);
          {
            this.syncRootNodesToNative();
          }
        }
        getFirstRenderCamera(node) {
          if (node.scene && node.scene.renderScene) {
            const cameras = node.scene.renderScene.cameras;
            for (let i = 0; i < cameras.length; i++) {
              const camera = cameras[i];
              if (camera.visibility & node.layer) {
                return camera;
              }
            }
          }
          return null;
        }
        update() {
          {
            return;
          }
        }
        uploadBuffers() {
          {
            this._nativeObj.uploadBuffers();
          }
        }
        reset() {
          {
            this._nativeObj.reset();
          }
        }
        switchBufferAccessor(attributes = vfmtPosUvColor) {
          const strideBytes = attributes === vfmtPosUvColor ? 36 : getAttributeStride(attributes);
          if (!this._staticVBBuffer || this._staticVBBuffer.vertexFormatBytes !== strideBytes) {
            let accessor = this._bufferAccessors.get(strideBytes);
            if (!accessor) {
              accessor = new StaticVBAccessor(this.device, attributes);
              this._bufferAccessors.set(strideBytes, accessor);
            }
            this._staticVBBuffer = accessor;
            this._currBID = -1;
          }
          return this._staticVBBuffer;
        }
        registerBufferAccessor(key, accessor) {
          this._bufferAccessors.set(key, accessor);
        }
        updateBuffer(attributes, bid) {
          const accessor = this.switchBufferAccessor(attributes);
          if (this._currBID !== bid) {
            this._currBID = bid;
            this._indexStart = accessor.getMeshBuffer(bid).indexOffset;
          }
        }
        commitComp(comp, renderData, frame, assembler, transform) {
          let dataHash = 0;
          let mat;
          let bufferID = -1;
          if (renderData && renderData.chunk) {
            if (!renderData.isValid()) return;
            dataHash = renderData.dataHash;
            mat = renderData.material;
            bufferID = renderData.chunk.bufferId;
          }
          if (comp.stencilStage === Stage.ENTER_LEVEL || comp.stencilStage === Stage.ENTER_LEVEL_INVERTED) {
            this._insertMaskBatch(comp);
          } else {
            comp.stencilStage = StencilManager.sharedManager.stage;
          }
          const depthStencilStateStage = comp.stencilStage;
          if (this._currHash !== dataHash || dataHash === 0 || this._currMaterial !== mat || this._currDepthStencilStateStage !== depthStencilStateStage) {
            this.autoMergeBatches(this._currComponent);
            if (renderData && !renderData._isMeshBuffer) {
              this.updateBuffer(renderData.vertexFormat, bufferID);
            }
            this._currRenderData = renderData;
            this._currHash = renderData ? renderData.dataHash : 0;
            this._currComponent = comp;
            this._currTransform = transform;
            this._currMaterial = comp.getRenderMaterial(0);
            this._currDepthStencilStateStage = depthStencilStateStage;
            this._currLayer = comp.node.layer;
            if (frame) {
              {
                assert(frame.isValid, 'frame should not be invalid, it may have been released');
              }
              this._currTexture = frame.getGFXTexture();
              this._currSampler = frame.getGFXSampler();
              this._currTextureHash = frame.getHash();
              this._currSamplerHash = this._currSampler.hash;
            } else {
              this._currTexture = null;
              this._currSampler = null;
              this._currTextureHash = 0;
              this._currSamplerHash = 0;
            }
          }
          assembler.fillBuffers(comp, this);
        }
        commitIA(renderComp, ia, tex, mat, transform) {
          if (this._currMaterial !== this._emptyMaterial) {
            this.autoMergeBatches(this._currComponent);
            this.resetRenderStates();
          }
          let depthStencil;
          let dssHash = 0;
          if (renderComp) {
            renderComp.stencilStage = StencilManager.sharedManager.stage;
            if (renderComp.customMaterial !== null) {
              depthStencil = StencilManager.sharedManager.getStencilStage(renderComp.stencilStage, mat);
            } else {
              depthStencil = StencilManager.sharedManager.getStencilStage(renderComp.stencilStage);
            }
            dssHash = StencilManager.sharedManager.getStencilHash(renderComp.stencilStage);
          }
          const curDrawBatch = this._currStaticRoot ? this._currStaticRoot._requireDrawBatch() : this._drawBatchPool.alloc();
          curDrawBatch.visFlags = renderComp.node.layer;
          curDrawBatch.inputAssembler = ia;
          curDrawBatch.useLocalData = transform || null;
          if (tex) {
            curDrawBatch.texture = tex.getGFXTexture();
            curDrawBatch.sampler = tex.getGFXSampler();
            curDrawBatch.textureHash = tex.getHash();
            curDrawBatch.samplerHash = curDrawBatch.sampler.hash;
          }
          curDrawBatch.fillPasses(mat || null, depthStencil, dssHash, null);
          this._batches.push(curDrawBatch);
        }
        commitMiddleware(comp, meshBuffer, indexOffset, indexCount, tex, mat, enableBatch) {
          const texture = tex.getGFXTexture();
          if (enableBatch && this._middlewareEnableBatch && this._middlewareBuffer === meshBuffer && this._currTexture === texture && this._currMaterial.hash === mat.hash && this._middlewareIndexStart + this._middlewareIndexCount === indexOffset && this._currLayer === comp.node.layer) {
            this._middlewareIndexCount += indexCount;
          } else {
            this.autoMergeBatches(this._currComponent);
            this.resetRenderStates();
            this._currComponent = comp;
            this._currTexture = texture;
            this._currSampler = tex.getGFXSampler();
            this._currTextureHash = tex.getHash();
            this._currLayer = comp.node.layer;
            this._currSamplerHash = this._currSampler.hash;
            this._currHash = 0;
            this._currTransform = enableBatch ? null : comp.node;
            this._middlewareEnableBatch = enableBatch;
            this._middlewareBuffer = meshBuffer;
            this._currMaterial = mat;
            this._middlewareIndexStart = indexOffset;
            this._middlewareIndexCount = indexCount;
          }
          this._currIsMiddleware = true;
        }
        commitModel(comp, model, mat) {
          if (this._currMaterial !== this._emptyMaterial) {
            this.autoMergeBatches(this._currComponent);
            this.resetRenderStates();
          }
          let depthStencil;
          let dssHash = 0;
          if (mat) {
            if (comp.stencilStage === Stage.ENTER_LEVEL || comp.stencilStage === Stage.ENTER_LEVEL_INVERTED) {
              this._insertMaskBatch(comp);
            } else {
              comp.stencilStage = StencilManager.sharedManager.stage;
            }
            depthStencil = StencilManager.sharedManager.getStencilStage(comp.stencilStage, mat);
            dssHash = StencilManager.sharedManager.getStencilHash(comp.stencilStage);
          }
          const stamp = legacyCC.director.getTotalFrames();
          if (model) {
            model.updateTransform(stamp);
            model.updateUBOs(stamp);
          }
          for (let i = 0; i < model.subModels.length; i++) {
            const curDrawBatch = this._drawBatchPool.alloc();
            const subModel = model.subModels[i];
            curDrawBatch.visFlags = comp.node.layer;
            curDrawBatch.model = model;
            curDrawBatch.texture = null;
            curDrawBatch.sampler = null;
            curDrawBatch.useLocalData = null;
            if (!depthStencil) {
              depthStencil = null;
            }
            curDrawBatch.fillPasses(mat, depthStencil, dssHash, subModel.patches);
            curDrawBatch.inputAssembler = subModel.inputAssembler;
            curDrawBatch.model.visFlags = curDrawBatch.visFlags;
            curDrawBatch.descriptorSet = subModel.descriptorSet;
            this._batches.push(curDrawBatch);
          }
        }
        setupStaticBatch(staticComp, bufferAccessor) {
          this.finishMergeBatches();
          this._staticVBBuffer = bufferAccessor;
          this.currStaticRoot = staticComp;
        }
        endStaticBatch() {
          this.finishMergeBatches();
          this.currStaticRoot = null;
          this._staticVBBuffer = null;
          this.switchBufferAccessor();
        }
        commitStaticBatch(comp) {
          this._batches.concat(comp.drawBatchList);
          this.finishMergeBatches();
        }
        autoMergeBatches(renderComp) {
          if (this._currIsMiddleware) {
            this.mergeBatchesForMiddleware(renderComp);
            return;
          }
          const mat = this._currMaterial;
          if (!mat) {
            return;
          }
          let ia;
          const rd = this._currRenderData;
          const accessor = this._staticVBBuffer;
          if (rd && rd._isMeshBuffer) {
            ia = rd.requestIA(this.device);
            if (this._meshDataArray.indexOf(rd) === -1) {
              this._meshDataArray.push(rd);
            }
          } else if (accessor) {
            const bid = this._currBID;
            const buf = accessor.getMeshBuffer(bid);
            if (!buf) {
              return;
            }
            const indexCount = buf.indexOffset - this._indexStart;
            if (indexCount <= 0) return;
            assertIsTrue(this._indexStart < buf.indexOffset);
            buf.setDirty();
            ia = buf.requireFreeIA(this.device);
            ia.firstIndex = this._indexStart;
            ia.indexCount = indexCount;
            this._indexStart = buf.indexOffset;
          }
          this._currBID = -1;
          if (!ia) {
            return;
          }
          let depthStencil;
          let dssHash = 0;
          if (renderComp) {
            if (renderComp.customMaterial !== null) {
              depthStencil = StencilManager.sharedManager.getStencilStage(renderComp.stencilStage, mat);
            } else {
              depthStencil = StencilManager.sharedManager.getStencilStage(renderComp.stencilStage);
            }
            dssHash = StencilManager.sharedManager.getStencilHash(renderComp.stencilStage);
          }
          const curDrawBatch = this._currStaticRoot ? this._currStaticRoot._requireDrawBatch() : this._drawBatchPool.alloc();
          curDrawBatch.visFlags = this._currLayer;
          curDrawBatch.texture = this._currTexture;
          curDrawBatch.sampler = this._currSampler;
          curDrawBatch.inputAssembler = ia;
          curDrawBatch.useLocalData = this._currTransform;
          curDrawBatch.textureHash = this._currTextureHash;
          curDrawBatch.samplerHash = this._currSamplerHash;
          curDrawBatch.fillPasses(mat, depthStencil, dssHash, null);
          this._batches.push(curDrawBatch);
        }
        mergeBatchesForMiddleware(renderComp) {
          let depthStencil;
          let dssHash = 0;
          renderComp.stencilStage = StencilManager.sharedManager.stage;
          if (renderComp.customMaterial !== null) {
            depthStencil = StencilManager.sharedManager.getStencilStage(renderComp.stencilStage, this._currMaterial);
          } else {
            depthStencil = StencilManager.sharedManager.getStencilStage(renderComp.stencilStage);
          }
          dssHash = StencilManager.sharedManager.getStencilHash(renderComp.stencilStage);
          const curDrawBatch = this._currStaticRoot ? this._currStaticRoot._requireDrawBatch() : this._drawBatchPool.alloc();
          curDrawBatch.visFlags = renderComp.node.layer;
          const ia = this._middlewareBuffer.requireFreeIA(this.device);
          ia.firstIndex = this._middlewareIndexStart;
          ia.indexCount = this._middlewareIndexCount;
          curDrawBatch.inputAssembler = ia;
          curDrawBatch.useLocalData = this._currTransform;
          curDrawBatch.texture = this._currTexture;
          curDrawBatch.sampler = this._currSampler;
          curDrawBatch.textureHash = this._currTextureHash;
          curDrawBatch.samplerHash = this._currSamplerHash;
          curDrawBatch.fillPasses(this._currMaterial || null, depthStencil, dssHash, null);
          this._batches.push(curDrawBatch);
          this._currIsMiddleware = false;
          this._middlewareBuffer = null;
        }
        forceMergeBatches(material, frame, renderComp) {
          this._currMaterial = material;
          if (frame) {
            this._currTexture = frame.getGFXTexture();
            this._currSampler = frame.getGFXSampler();
            this._currTextureHash = frame.getHash();
            this._currSamplerHash = this._currSampler.hash;
          } else {
            this._currTexture = this._currSampler = null;
            this._currTextureHash = this._currSamplerHash = 0;
          }
          this._currLayer = renderComp.node.layer;
          this.autoMergeBatches(renderComp);
        }
        resetRenderStates() {
          this._currMaterial = this._emptyMaterial;
          this._currRenderData = null;
          this._currTexture = null;
          this._currComponent = null;
          this._currTransform = null;
          this._currTextureHash = 0;
          this._currSamplerHash = 0;
          this._currLayer = 0;
        }
        finishMergeBatches() {
          this.autoMergeBatches();
          this.resetRenderStates();
        }
        flushMaterial(mat) {
          this._currMaterial = mat;
        }
        walk(node, level = 0) {
          if (!node.activeInHierarchy) {
            return;
          }
          const children = node.children;
          const uiProps = node._uiProps;
          const render = uiProps.uiComp;
          const parentOpacity = this._pOpacity;
          let opacity = parentOpacity;
          const selfOpacity = render && render.color ? render.color.a / 255 : 1;
          this._pOpacity = opacity *= selfOpacity * uiProps.localOpacity;
          uiProps.setOpacity(opacity);
          if (!approx(opacity, 0, EPSILON$2)) {
            if (uiProps.colorDirty) {
              this._opacityDirty++;
            }
            if (render && render.enabledInHierarchy) {
              render.fillBuffers(this);
            }
            if (this._opacityDirty && render && !render.useVertexOpacity && render.renderData && render.renderData.vertexCount > 0) {
              updateOpacity(render.renderData, opacity);
              const buffer = render.renderData.getMeshBuffer();
              if (buffer) {
                buffer.setDirty();
              }
            }
            if (children.length > 0 && !node._static) {
              for (let i = 0; i < children.length; ++i) {
                const child = children[i];
                this.walk(child, level);
              }
            }
            if (uiProps.colorDirty) {
              this._opacityDirty--;
              uiProps.colorDirty = false;
            }
          }
          this._pOpacity = parentOpacity;
          if (render && render.enabledInHierarchy) {
            render.postUpdateAssembler(this);
            if ((render.stencilStage === Stage.ENTER_LEVEL || render.stencilStage === Stage.ENTER_LEVEL_INVERTED) && StencilManager.sharedManager.getMaskStackSize() > 0) {
              this.autoMergeBatches(this._currComponent);
              this.resetRenderStates();
              StencilManager.sharedManager.exitMask();
            }
          }
          level += 1;
        }
        _screenSort(a, b) {
          return a.node.getSiblingIndex() - b.node.getSiblingIndex();
        }
        _releaseDescriptorSetCache(textureHash, sampler = null) {
          {
            this._nativeObj.releaseDescriptorSetCache(textureHash, sampler);
          }
        }
        _createClearModel() {
          if (!this._maskClearModel) {
            this._maskClearMtl = builtinResMgr.get('default-clear-stencil');
            this._maskClearModel = legacyCC.director.root.createModel(Model);
            const stride = getAttributeStride(vfmt);
            const gfxDevice = deviceManager.gfxDevice;
            const vertexBuffer = gfxDevice.createBuffer(new BufferInfo(BufferUsageBit.VERTEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, 4 * stride, stride));
            const vb = new Float32Array([-1, -1, 0, 1, -1, 0, -1, 1, 0, 1, 1, 0]);
            vertexBuffer.update(vb);
            const indexBuffer = gfxDevice.createBuffer(new BufferInfo(BufferUsageBit.INDEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, 6 * Uint16Array.BYTES_PER_ELEMENT, Uint16Array.BYTES_PER_ELEMENT));
            const ib = new Uint16Array([0, 1, 2, 2, 1, 3]);
            indexBuffer.update(ib);
            this._maskModelMesh = new RenderingSubMesh([vertexBuffer], vfmt, PrimitiveMode.TRIANGLE_LIST, indexBuffer);
            this._maskModelMesh.subMeshIdx = 0;
            this._maskClearModel.initSubModel(0, this._maskModelMesh, this._maskClearMtl);
          }
        }
        _insertMaskBatch(comp) {
          this.autoMergeBatches(this._currComponent);
          this.resetRenderStates();
          this._createClearModel();
          this._maskClearModel.node = this._maskClearModel.transform = comp.node;
          const _stencilManager = StencilManager.sharedManager;
          _stencilManager.pushMask(1);
          const stage = _stencilManager.clear(comp);
          let depthStencil;
          let dssHash = 0;
          const mat = this._maskClearMtl;
          if (mat) {
            depthStencil = _stencilManager.getStencilStage(stage, mat);
            dssHash = _stencilManager.getStencilHash(stage);
          }
          const model = this._maskClearModel;
          const stamp = legacyCC.director.getTotalFrames();
          if (model) {
            model.updateTransform(stamp);
            model.updateUBOs(stamp);
          }
          for (let i = 0; i < model.subModels.length; i++) {
            const curDrawBatch = this._drawBatchPool.alloc();
            const subModel = model.subModels[i];
            curDrawBatch.visFlags = comp.node.layer;
            curDrawBatch.model = model;
            curDrawBatch.texture = null;
            curDrawBatch.sampler = null;
            curDrawBatch.useLocalData = null;
            if (!depthStencil) {
              depthStencil = null;
            }
            curDrawBatch.fillPasses(mat, depthStencil, dssHash, subModel.patches);
            curDrawBatch.inputAssembler = subModel.inputAssembler;
            curDrawBatch.model.visFlags = curDrawBatch.visFlags;
            curDrawBatch.descriptorSet = subModel.descriptorSet;
            this._batches.push(curDrawBatch);
          }
          _stencilManager.enableMask();
        }
        syncMeshBuffersToNative(accId, buffers) {
          {
            const nativeBuffers = buffers.map(buf => buf.nativeObj);
            this._nativeObj.syncMeshBuffersToNative(accId, nativeBuffers);
          }
        }
      } exports('UI', Batcher2D);
      class LocalDescriptorSet {
        get descriptorSet() {
          return this._descriptorSet;
        }
        constructor() {
          this._descriptorSet = null;
          this._transform = null;
          this._textureHash = 0;
          this._samplerHash = 0;
          this._localBuffer = null;
          this._transformUpdate = true;
          const device = deviceManager.gfxDevice;
          this._localData = new Float32Array(UBOLocal.COUNT);
          this._localBuffer = device.createBuffer(new BufferInfo(BufferUsageBit.UNIFORM | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, UBOLocal.SIZE, UBOLocal.SIZE));
        }
        initialize(batch) {
          const device = deviceManager.gfxDevice;
          this._transform = batch.useLocalData;
          this._textureHash = batch.textureHash;
          this._samplerHash = batch.samplerHash;
          _dsInfo.layout = batch.passes[0].localSetLayout;
          this._descriptorSet = device.createDescriptorSet(_dsInfo);
          this._descriptorSet.bindBuffer(UBOLocal.BINDING, this._localBuffer);
          const binding = ModelLocalBindings.SAMPLER_SPRITE;
          this._descriptorSet.bindTexture(binding, batch.texture);
          this._descriptorSet.bindSampler(binding, batch.sampler);
          this._descriptorSet.update();
          this._transformUpdate = true;
        }
        updateTransform(transform) {
          if (transform === this._transform) return;
          this._transform = transform;
          this._transformUpdate = true;
          this.uploadLocalData();
        }
        equals(transform, textureHash, samplerHash) {
          return this._transform === transform && this._textureHash === textureHash && this._samplerHash === samplerHash;
        }
        reset() {
          this._transform = null;
          this._textureHash = 0;
          this._samplerHash = 0;
        }
        destroy() {
          if (this._localBuffer) {
            this._localBuffer.destroy();
            this._localBuffer = null;
          }
          if (this._descriptorSet) {
            this._descriptorSet.destroy();
            this._descriptorSet = null;
          }
          this._localData = null;
        }
        isValid() {
          return this._transform && this._transform.isValid;
        }
        uploadLocalData() {
          const node = this._transform;
          if (node.hasChangedFlags || node.isTransformDirty()) {
            node.updateWorldTransform();
            this._transformUpdate = true;
          }
          if (this._transformUpdate) {
            const worldMatrix = node.worldMatrix;
            Mat4.toArray(this._localData, worldMatrix, UBOLocal.MAT_WORLD_OFFSET);
            Mat4.invert(m4_1, worldMatrix);
            Mat4.transpose(m4_1, m4_1);
            Mat4.toArray(this._localData, m4_1, UBOLocal.MAT_WORLD_IT_OFFSET);
            this._localBuffer.update(this._localData);
            this._transformUpdate = false;
          }
        }
      }
      class DescriptorSetCache {
        constructor() {
          this._descriptorSetCache = new Map();
          this._dsCacheHashByTexture = new Map();
          this._localDescriptorSetCache = [];
          this._localCachePool = void 0;
          this._localCachePool = new Pool(() => new LocalDescriptorSet(), 16, obj => obj.destroy());
        }
        getDescriptorSet(batch) {
          legacyCC.director.root;
          let hash;
          if (batch.useLocalData) {
            const caches = this._localDescriptorSetCache;
            for (let i = 0, len = caches.length; i < len; i++) {
              const cache = caches[i];
              if (cache.equals(batch.useLocalData, batch.textureHash, batch.samplerHash)) {
                return cache.descriptorSet;
              }
            }
            const localDs = this._localCachePool.alloc();
            localDs.initialize(batch);
            this._localDescriptorSetCache.push(localDs);
            return localDs.descriptorSet;
          } else {
            hash = batch.textureHash ^ batch.samplerHash;
            if (this._descriptorSetCache.has(hash)) {
              return this._descriptorSetCache.get(hash);
            } else {
              _dsInfo.layout = batch.passes[0].localSetLayout;
              const descriptorSet = deviceManager.gfxDevice.createDescriptorSet(_dsInfo);
              const binding = ModelLocalBindings.SAMPLER_SPRITE;
              descriptorSet.bindTexture(binding, batch.texture);
              descriptorSet.bindSampler(binding, batch.sampler);
              descriptorSet.update();
              this._descriptorSetCache.set(hash, descriptorSet);
              this._dsCacheHashByTexture.set(batch.textureHash, hash);
              return descriptorSet;
            }
          }
        }
        update() {
          const caches = this._localDescriptorSetCache;
          const length = caches.length;
          if (length === 0) {
            return;
          }
          const uselessArray = [];
          for (let i = 0; i < length; i++) {
            const value = caches[i];
            if (value.isValid()) {
              value.uploadLocalData();
            } else {
              value.reset();
              const pos = caches.indexOf(value);
              uselessArray.push(pos);
            }
          }
          for (let i = uselessArray.length - 1; i >= 0; i--) {
            const index = uselessArray[i];
            const localDs = caches[index];
            caches.splice(index, 1);
            this._localCachePool.free(localDs);
          }
        }
        reset() {
          const caches = this._localDescriptorSetCache;
          const length = caches.length;
          for (let i = 0; i < length; i++) {
            const value = caches[i];
            this._localCachePool.free(value);
          }
          this._localDescriptorSetCache.length = 0;
        }
        releaseDescriptorSetCache(textureHash) {
          const key = this._dsCacheHashByTexture.get(textureHash);
          if (key && this._descriptorSetCache.has(key)) {
            this._descriptorSetCache.get(key).destroy();
            this._descriptorSetCache.delete(key);
            this._dsCacheHashByTexture.delete(textureHash);
          }
        }
        destroy() {
          for (const value of this._descriptorSetCache.values()) {
            value.destroy();
          }
          this._descriptorSetCache.clear();
          this._dsCacheHashByTexture.clear();
          this._localDescriptorSetCache.length = 0;
          this._localCachePool.destroy();
        }
      }
      legacyCC.internal.Batcher2D = Batcher2D;

      class UIDrawBatch extends DrawBatch2D {} exports('UIDrawBatch', UIDrawBatch);
      markAsWarning(MeshBuffer.prototype, 'MeshBuffer', ['byteStart', 'vertexStart', 'indicesStart', 'request'].map(item => ({
        name: item,
        suggest: `please use meshBuffer.accessor.${item} instead`
      })));
      replaceProperty(MeshBuffer.prototype, 'MeshBuffer', [{
        name: 'indicesOffset',
        newName: 'indexOffset'
      }]);
      removeProperty(MeshBuffer.prototype, 'MeshBuffer', [{
        name: 'vertexBuffers'
      }, {
        name: 'indexBuffer'
      }]);
      replaceProperty(Batcher2D.prototype, 'Batcher2D', [{
        name: 'currBufferBatch',
        newName: 'currBufferAccessor'
      }, {
        name: 'acquireBufferBatch',
        newName: 'switchBufferAccessor'
      }]);
      removeProperty(MeshRenderData.prototype, 'MeshRenderData', [{
        name: 'formatByte'
      }, {
        name: 'byteStart'
      }, {
        name: 'byteCount'
      }]);
      replaceProperty(MeshRenderData.prototype, 'MeshRenderData', [{
        name: 'indicesStart',
        newName: 'indexStart'
      }]);
      class QuadRenderData extends MeshRenderData {
        constructor(vertexFormat) {
          super(vertexFormat);
          warnID(9006);
        }
      } exports('QuadRenderData', QuadRenderData);

      const ccdocument$1 = ccwindow$1.document;
      let _canvasContext = null;
      let _intervalId = -1;
      const _testString = 'BES bswy:->@123\u4E01\u3041\u1101';
      const _fontFaces = Object.create(null);
      const _loadingFonts = [];
      const _timeout = 3000;
      const useNativeCheck = (() => {
        let nativeCheck;
        return () => {
          if (nativeCheck === undefined) {
            if ('FontFace' in ccwindow$1) {
              const match = /Gecko.*Firefox\/(\d+)/.exec(ccwindow$1.navigator.userAgent);
              const safari10Match = /OS X.*Version\/10\..*Safari/.exec(ccwindow$1.navigator.userAgent) && /Apple/.exec(ccwindow$1.navigator.vendor);
              if (match) {
                nativeCheck = parseInt(match[1], 10) > 42;
              } else if (safari10Match) {
                nativeCheck = false;
              } else {
                nativeCheck = true;
              }
            } else {
              nativeCheck = false;
            }
          }
          return nativeCheck;
        };
      })();
      function checkFontLoaded() {
        let allFontsLoaded = true;
        const now = Date.now();
        for (let i = _loadingFonts.length - 1; i >= 0; i--) {
          const fontLoadHandle = _loadingFonts[i];
          const fontFamily = fontLoadHandle.fontFamilyName;
          if (now - fontLoadHandle.startTime > _timeout) {
            warnID(4933, fontFamily);
            fontLoadHandle.onComplete(null, fontFamily);
            _loadingFonts.splice(i, 1);
            continue;
          }
          const oldWidth = fontLoadHandle.refWidth;
          const fontDesc = `40px ${fontFamily}`;
          _canvasContext.font = fontDesc;
          const newWidth = safeMeasureText(_canvasContext, _testString, fontDesc);
          if (oldWidth !== newWidth) {
            _loadingFonts.splice(i, 1);
            fontLoadHandle.onComplete(null, fontFamily);
          } else {
            allFontsLoaded = false;
          }
        }
        if (allFontsLoaded) {
          clearInterval(_intervalId);
          _intervalId = -1;
        }
      }
      function nativeCheckFontLoaded(start, font, callback) {
        const loader = new Promise((resolve, reject) => {
          const check = () => {
            const now = Date.now();
            if (now - start >= _timeout) {
              reject();
            } else {
              ccdocument$1.fonts.load(`40px ${font}`).then(fonts => {
                if (fonts.length >= 1) {
                  resolve();
                } else {
                  setTimeout(check, 100);
                }
              }, () => {
                reject();
              });
            }
          };
          check();
        });
        let timeoutId = null;
        const timer = new Promise((resolve, reject) => {
          timeoutId = setTimeout(reject, _timeout);
        });
        Promise.race([timer, loader]).then(() => {
          if (timeoutId) {
            clearTimeout(timeoutId);
            timeoutId = null;
          }
          callback(null, font);
        }, () => {
          warnID(4933, font);
          callback(null, font);
        });
      }
      function loadFont(url, options, onComplete) {
        const fontFamilyName = getFontFamily(url);
        if (_fontFaces[fontFamilyName]) {
          onComplete(null, fontFamilyName);
          return;
        }
        if (!_canvasContext) {
          const labelCanvas = ccdocument$1.createElement('canvas');
          labelCanvas.width = 100;
          labelCanvas.height = 100;
          _canvasContext = labelCanvas.getContext('2d');
        }
        const fontDesc = `40px ${fontFamilyName}`;
        const fontStyle = ccdocument$1.createElement('style');
        fontStyle.type = 'text/css';
        let fontStr = '';
        if (Number.isNaN(fontFamilyName)) {
          fontStr += `@font-face { font-family:${fontFamilyName}; src:`;
        } else {
          fontStr += `@font-face { font-family:"${fontFamilyName}"; src:`;
        }
        fontStr += `url("${url}");`;
        fontStyle.textContent = `${fontStr}}`;
        ccdocument$1.body.appendChild(fontStyle);
        const preloadDiv = ccdocument$1.createElement('div');
        const divStyle = preloadDiv.style;
        divStyle.fontFamily = fontFamilyName;
        preloadDiv.innerHTML = '.';
        divStyle.position = 'absolute';
        divStyle.left = '-100px';
        divStyle.top = '-100px';
        ccdocument$1.body.appendChild(preloadDiv);
        if (useNativeCheck()) {
          nativeCheckFontLoaded(Date.now(), fontFamilyName, onComplete);
        } else {
          const refWidth = safeMeasureText(_canvasContext, _testString, fontDesc);
          const fontLoadHandle = {
            fontFamilyName,
            refWidth,
            onComplete,
            startTime: Date.now()
          };
          _loadingFonts.push(fontLoadHandle);
          if (_intervalId === -1) {
            _intervalId = setInterval(checkFontLoaded, 100);
          }
        }
        _fontFaces[fontFamilyName] = fontStyle;
      }
      function getFontFamily(fontHandle) {
        const ttfIndex = fontHandle.lastIndexOf('.ttf');
        if (ttfIndex === -1) {
          return fontHandle;
        }
        const slashPos = fontHandle.lastIndexOf('/');
        let fontFamilyName;
        if (slashPos === -1) {
          fontFamilyName = `${fontHandle.substring(0, ttfIndex)}_LABEL`;
        } else {
          fontFamilyName = `${fontHandle.substring(slashPos + 1, ttfIndex)}_LABEL`;
        }
        if (fontFamilyName.indexOf(' ') !== -1) {
          fontFamilyName = `"${fontFamilyName}"`;
        }
        return fontFamilyName;
      }
      function createFont(id, data, options, onComplete) {
        const out = new TTFFont();
        out._nativeUrl = id;
        out._nativeAsset = data;
        onComplete(null, out);
      }
      downloader$1.register({
        '.font': loadFont,
        '.eot': loadFont,
        '.ttf': loadFont,
        '.woff': loadFont,
        '.svg': loadFont,
        '.ttc': loadFont
      });
      factory.register({
        '.font': createFont,
        '.eot': createFont,
        '.ttf': createFont,
        '.woff': createFont,
        '.svg': createFont,
        '.ttc': createFont
      });

      legacyCC.UI = {
        MeshBuffer,
        spriteAssembler,
        graphicsAssembler: graphicsAssemblerManager,
        labelAssembler,
        RenderData,
        MeshRenderData
      };

      const SortingLayer = {
        default: 0
      };
      game.on(Game.EVENT_POST_SUBSYSTEM_INIT, () => {
        SortingLayers.init();
      });
      class SortingLayers {
        static getSortingPriority(layer = 0, order = 0) {
          return (layer + (1 << 15) << 16 | order + (1 << 15)) >>> 0;
        }
        static getLayerIndex(layer = 0) {
          let index = 0;
          if (this.indexMap.has(layer)) {
            index = this.indexMap.get(layer);
          } else {
            errorID(2105);
          }
          return index;
        }
        static getLayerIndexByName(name) {
          const id = this.getLayerByName(name);
          return this.getLayerIndex(id);
        }
        static getLayerName(layer = 0) {
          let name = '';
          if (this.nameMap.has(layer)) {
            name = this.nameMap.get(layer);
          } else {
            errorID(2105);
          }
          return name;
        }
        static getLayerByName(name) {
          const count = this.nameMap.size;
          const keyIterator = this.nameMap.keys();
          let key = 0;
          for (let i = 0; i < count; i++) {
            key = keyIterator.next().value;
            if (this.nameMap.get(key) === name) return key;
          }
          errorID(2106);
          return 0;
        }
        static isLayerValid(id) {
          if (this.indexMap.has(id)) {
            return true;
          } else {
            errorID(2105);
            return false;
          }
        }
        static getBuiltinLayers() {
          return [{
            id: 0,
            name: 'default',
            value: 0
          }];
        }
        static init() {
          let sortingLayers = settings.querySettings(Settings.Category.ENGINE, 'sortingLayers');
          if (!sortingLayers || sortingLayers.length === 0) {
            sortingLayers = this.getBuiltinLayers();
          }
          SortingLayers.resetState();
          for (let i = 0; i < sortingLayers.length; i++) {
            const layer = sortingLayers[i];
            SortingLayers.setLayer(layer.id, layer.name, layer.value);
            SortingLayers.Enum[layer.name] = layer.id;
          }
          Enum.update(SortingLayers.Enum);
          Enum.sortList(SortingLayers.Enum, (a, b) => SortingLayers.getLayerIndex(a.value) - SortingLayers.getLayerIndex(b.value));
        }
        static setLayer(layer, layerName, layerIndex) {
          this.nameMap.set(layer, layerName);
          this.indexMap.set(layer, layerIndex);
        }
        static resetState() {
          const oldItem = Object.keys(SortingLayers.Enum);
          for (let i = 0; i < oldItem.length; i++) {
            delete SortingLayers.Enum[SortingLayers.Enum[oldItem[i]]];
            delete SortingLayers.Enum[oldItem[i]];
          }
          SortingLayers.indexMap.clear();
          SortingLayers.nameMap.clear();
        }
      } exports('SortingLayers', SortingLayers);
      SortingLayers.nameMap = new Map();
      SortingLayers.indexMap = new Map();
      SortingLayers.Enum = Enum(SortingLayer);

      var _dec$n, _dec2$j, _class$m, _class2$l, _initializer$j, _initializer2$h;
      const MAX_INT16 = (1 << 15) - 1;
      const MIN_INT16 = -1 << 15;
      let Sorting = exports('Sorting', (_dec$n = ccclass$3('cc.Sorting'), _dec2$j = type$2(SortingLayers.Enum), _dec$n(_class$m = disallowMultiple$1(_class$m = (_class2$l = class Sorting extends Component {
        constructor(...args) {
          super(...args);
          this._sortingLayer = _initializer$j && _initializer$j();
          this._sortingOrder = _initializer2$h && _initializer2$h();
          this._modelRenderer = null;
        }
        get sortingLayer() {
          return this._sortingLayer;
        }
        set sortingLayer(val) {
          if (val === this._sortingLayer || !SortingLayers.isLayerValid(val)) return;
          this._sortingLayer = val;
          this._updateSortingPriority();
        }
        get sortingOrder() {
          return this._sortingOrder;
        }
        set sortingOrder(val) {
          if (val === this._sortingOrder) return;
          this._sortingOrder = clamp$1(val, MIN_INT16, MAX_INT16);
          this._updateSortingPriority();
        }
        __preload() {
          this._modelRenderer = this.getComponent('cc.ModelRenderer');
          if (!this._modelRenderer) {
            warnID(16301, this.node.name);
          }
          this._updateSortingPriority();
        }
        _updateSortingPriority() {
          const sortingLayerValue = SortingLayers.getLayerIndex(this._sortingLayer);
          const sortingPriority = SortingLayers.getSortingPriority(sortingLayerValue, this._sortingOrder);
          if (this._modelRenderer && this._modelRenderer.isValid) {
            this._modelRenderer.priority = sortingPriority;
          }
        }
      }, (_applyDecoratedDescriptor(_class2$l.prototype, "sortingLayer", [_dec2$j], Object.getOwnPropertyDescriptor(_class2$l.prototype, "sortingLayer"), _class2$l.prototype), _initializer$j = applyDecoratedInitializer(_class2$l.prototype, "_sortingLayer", [serializable$3], function () {
        return SortingLayers.Enum.default;
      }), _initializer2$h = applyDecoratedInitializer(_class2$l.prototype, "_sortingOrder", [serializable$3], function () {
        return 0;
      })), _class2$l)) || _class$m) || _class$m));

      let AudioEvent;
      (function (AudioEvent) {
        AudioEvent["PLAYED"] = "play";
        AudioEvent["PAUSED"] = "pause";
        AudioEvent["STOPPED"] = "stop";
        AudioEvent["SEEKED"] = "seeked";
        AudioEvent["ENDED"] = "ended";
        AudioEvent["INTERRUPTION_BEGIN"] = "interruptionBegin";
        AudioEvent["INTERRUPTION_END"] = "interruptionEnd";
        AudioEvent["USER_GESTURE"] = "on_gesture";
      })(AudioEvent || (AudioEvent = {}));
      let AudioType;
      (function (AudioType) {
        AudioType[AudioType["DOM_AUDIO"] = 0] = "DOM_AUDIO";
        AudioType[AudioType["WEB_AUDIO"] = 1] = "WEB_AUDIO";
        AudioType[AudioType["MINIGAME_AUDIO"] = 2] = "MINIGAME_AUDIO";
        AudioType[AudioType["NATIVE_AUDIO"] = 3] = "NATIVE_AUDIO";
        AudioType[AudioType["UNKNOWN_AUDIO"] = 4] = "UNKNOWN_AUDIO";
      })(AudioType || (AudioType = {}));
      let AudioState;
      (function (AudioState) {
        AudioState[AudioState["INIT"] = 0] = "INIT";
        AudioState[AudioState["PLAYING"] = 1] = "PLAYING";
        AudioState[AudioState["PAUSED"] = 2] = "PAUSED";
        AudioState[AudioState["STOPPED"] = 3] = "STOPPED";
        AudioState[AudioState["INTERRUPTED"] = 4] = "INTERRUPTED";
      })(AudioState || (AudioState = {}));
      class AudioPCMDataView {
        constructor(...args) {
          this._bufferView = void 0;
          this._normalizeFactor = 1;
          if (args.length === 2) {
            this._bufferView = args[0];
            this._normalizeFactor = args[1];
          } else {
            const arrayBuffer = args[0];
            const Ctor = args[1];
            const normalizeFactor = args[2];
            this._bufferView = new Ctor(arrayBuffer);
            this._normalizeFactor = normalizeFactor;
          }
        }
        get length() {
          return this._bufferView.length;
        }
        getData(offset) {
          return this._bufferView[offset] * this._normalizeFactor;
        }
      } exports('AudioPCMDataView', AudioPCMDataView);

      function removeUnneededCalls(instance) {
        const size = instance._operationQueue.length;
        const tmpQueue = instance._operationQueue.slice();
        const reserveOps = [];
        let seekSearched = false;
        for (let i = size - 1; i >= 0; i--) {
          const opInfo = tmpQueue[i];
          if (opInfo.op === 'stop') {
            reserveOps.push(opInfo);
            break;
          } else if (opInfo.op === 'seek') {
            if (!seekSearched) {
              reserveOps.push(opInfo);
              seekSearched = true;
            }
          } else if (seekSearched) {
            reserveOps.push(opInfo);
            break;
          } else if (reserveOps.length === 0) {
            reserveOps.push(opInfo);
          }
        }
        instance._operationQueue = reserveOps.reverse();
      }
      let operationId = 0;
      function _tryCallingRecursively(target, opInfo) {
        if (opInfo.invoking) {
          return;
        }
        opInfo.invoking = true;
        opInfo.func.call(target, ...opInfo.args).then(() => {
          opInfo.invoking = false;
          target._operationQueue.shift();
          target._eventTarget.emit(opInfo.id.toString());
          removeUnneededCalls(target);
          const nextOpInfo = target._operationQueue[0];
          if (nextOpInfo) {
            _tryCallingRecursively(target, nextOpInfo);
          }
        }).catch(e => {});
      }
      function enqueueOperation(target, propertyKey, descriptor) {
        const originalOperation = descriptor.value;
        descriptor.value = function (...args) {
          return new Promise(resolve => {
            const id = operationId++;
            const instance = this;
            instance._operationQueue.push({
              op: propertyKey,
              id,
              func: originalOperation,
              args,
              invoking: false
            });
            instance._eventTarget.once(id.toString(), resolve);
            const opInfo = instance._operationQueue[0];
            _tryCallingRecursively(instance, opInfo);
          });
        };
      }

      var _class2$k, _class3$f;
      const urlCount = {};
      const audioEngine = jsb.AudioEngine;
      const INVALID_AUDIO_ID = -1;
      var AudioBufferFormat;
      (function (AudioBufferFormat) {
        AudioBufferFormat[AudioBufferFormat["UNKNOWN"] = 0] = "UNKNOWN";
        AudioBufferFormat[AudioBufferFormat["SIGNED_8"] = 1] = "SIGNED_8";
        AudioBufferFormat[AudioBufferFormat["UNSIGNED_8"] = 2] = "UNSIGNED_8";
        AudioBufferFormat[AudioBufferFormat["SIGNED_16"] = 3] = "SIGNED_16";
        AudioBufferFormat[AudioBufferFormat["UNSIGNED_16"] = 4] = "UNSIGNED_16";
        AudioBufferFormat[AudioBufferFormat["SIGNED_32"] = 5] = "SIGNED_32";
        AudioBufferFormat[AudioBufferFormat["UNSIGNED_32"] = 6] = "UNSIGNED_32";
        AudioBufferFormat[AudioBufferFormat["FLOAT_32"] = 7] = "FLOAT_32";
        AudioBufferFormat[AudioBufferFormat["FLOAT_64"] = 8] = "FLOAT_64";
      })(AudioBufferFormat || (AudioBufferFormat = {}));
      const bufferConstructorMap = {
        [AudioBufferFormat.UNKNOWN]: undefined,
        [AudioBufferFormat.SIGNED_8]: {
          ctor: Int8Array,
          maxValue: 127
        },
        [AudioBufferFormat.UNSIGNED_8]: {
          ctor: Uint8Array,
          maxValue: 255
        },
        [AudioBufferFormat.SIGNED_16]: {
          ctor: Int16Array,
          maxValue: 32767
        },
        [AudioBufferFormat.UNSIGNED_16]: {
          ctor: Uint16Array,
          maxValue: 65535
        },
        [AudioBufferFormat.SIGNED_32]: {
          ctor: Int32Array,
          maxValue: 2147483647
        },
        [AudioBufferFormat.UNSIGNED_32]: {
          ctor: Uint32Array,
          maxValue: 4294967295
        },
        [AudioBufferFormat.FLOAT_32]: {
          ctor: Float32Array,
          maxValue: 1
        },
        [AudioBufferFormat.FLOAT_64]: {
          ctor: Float64Array,
          maxValue: 1
        }
      };
      class OneShotAudio {
        get onPlay() {
          return this._onPlayCb;
        }
        set onPlay(cb) {
          this._onPlayCb = cb;
        }
        get onEnd() {
          return this._onEndCb;
        }
        set onEnd(cb) {
          this._onEndCb = cb;
        }
        constructor(url, volume) {
          this._id = INVALID_AUDIO_ID;
          this._url = void 0;
          this._volume = void 0;
          this._onPlayCb = void 0;
          this._onEndCb = void 0;
          this._url = url;
          this._volume = volume;
        }
        play() {
          var _this$onPlay;
          this._id = jsb.AudioEngine.play2d(this._url, false, this._volume);
          jsb.AudioEngine.setFinishCallback(this._id, () => {
            var _this$onEnd;
            (_this$onEnd = this.onEnd) === null || _this$onEnd === void 0 ? void 0 : _this$onEnd.call(this);
          });
          (_this$onPlay = this.onPlay) === null || _this$onPlay === void 0 ? void 0 : _this$onPlay.call(this);
        }
        stop() {
          if (this._id === INVALID_AUDIO_ID) {
            return;
          }
          jsb.AudioEngine.stop(this._id);
        }
      }
      let AudioPlayer = (_class2$k = (_class3$f = class AudioPlayer {
        constructor(url) {
          this._url = void 0;
          this._id = INVALID_AUDIO_ID;
          this._state = AudioState.INIT;
          this._pcmHeader = void 0;
          this._eventTarget = new EventTarget();
          this._operationQueue = [];
          this._cachedState = {
            duration: 1,
            loop: false,
            currentTime: 0,
            volume: 1
          };
          this._url = url;
          this._pcmHeader = null;
          game.on(Game.EVENT_PAUSE, this._onInterruptedBegin, this);
          game.on(Game.EVENT_RESUME, this._onInterruptedEnd, this);
        }
        destroy() {
          game.off(Game.EVENT_PAUSE, this._onInterruptedBegin, this);
          game.off(Game.EVENT_RESUME, this._onInterruptedEnd, this);
          if (--urlCount[this._url] <= 0) {
            audioEngine.uncache(this._url);
          }
        }
        _onInterruptedBegin() {
          if (this._state === AudioState.PLAYING) {
            this.pause().then(() => {
              this._state = AudioState.INTERRUPTED;
              this._eventTarget.emit(AudioEvent.INTERRUPTION_BEGIN);
            }).catch(e => {});
          }
        }
        _onInterruptedEnd() {
          if (this._state === AudioState.INTERRUPTED) {
            this.play().then(() => {
              this._eventTarget.emit(AudioEvent.INTERRUPTION_END);
            }).catch(e => {});
          }
        }
        static load(url, opts) {
          return new Promise((resolve, reject) => {
            AudioPlayer.loadNative(url, opts).then(url => {
              resolve(new AudioPlayer(url));
            }).catch(err => reject(err));
          });
        }
        static loadNative(url, opts) {
          return new Promise((resolve, reject) => {
            if (systemInfo.platform === Platform.WIN32) {
              audioEngine.preload(url, isSuccess => {
                console.debug('somehow preload success on windows');
              });
              resolve(url);
            } else {
              audioEngine.preload(url, isSuccess => {
                if (isSuccess) {
                  resolve(url);
                } else {
                  reject(new Error('load audio failed'));
                }
              });
            }
          });
        }
        static loadOneShotAudio(url, volume, opts) {
          return new Promise((resolve, reject) => {
            AudioPlayer.loadNative(url, opts).then(url => {
              resolve(new OneShotAudio(url, volume));
            }).catch(reject);
          });
        }
        get _isValid() {
          return this._id !== INVALID_AUDIO_ID;
        }
        get src() {
          return this._url;
        }
        get type() {
          return AudioType.NATIVE_AUDIO;
        }
        get state() {
          return this._state;
        }
        get loop() {
          if (!this._isValid) {
            return this._cachedState.loop;
          }
          return audioEngine.isLoop(this._id);
        }
        set loop(val) {
          if (this._isValid) {
            audioEngine.setLoop(this._id, val);
          }
          this._cachedState.loop = val;
        }
        get volume() {
          if (!this._isValid) {
            return this._cachedState.volume;
          }
          return audioEngine.getVolume(this._id);
        }
        set volume(val) {
          val = clamp01(val);
          if (this._isValid) {
            audioEngine.setVolume(this._id, val);
          }
          this._cachedState.volume = val;
        }
        get duration() {
          if (!this._isValid) {
            return this._cachedState.duration;
          }
          return audioEngine.getDuration(this._id);
        }
        get currentTime() {
          if (!this._isValid) {
            return this._cachedState.currentTime;
          }
          return audioEngine.getCurrentTime(this._id);
        }
        get sampleRate() {
          if (this._pcmHeader === null) {
            this._pcmHeader = jsb.AudioEngine.getPCMHeader(this._url);
          }
          return this._pcmHeader.sampleRate;
        }
        getPCMData(channelIndex) {
          const arrayBuffer = audioEngine.getOriginalPCMBuffer(this._url, channelIndex);
          if (this._pcmHeader === null) {
            this._pcmHeader = jsb.AudioEngine.getPCMHeader(this._url);
          }
          const audioBufferInfo = bufferConstructorMap[this._pcmHeader.audioFormat];
          if (!arrayBuffer || !audioBufferInfo) {
            return undefined;
          }
          return new AudioPCMDataView(arrayBuffer, audioBufferInfo.ctor, 1 / audioBufferInfo.maxValue);
        }
        seek(time) {
          return new Promise(resolve => {
            if (this._isValid) {
              audioEngine.setCurrentTime(this._id, time);
            }
            this._cachedState.currentTime = time;
            return resolve();
          });
        }
        play() {
          return new Promise(resolve => {
            if (this._isValid) {
              if (this._state === AudioState.PAUSED || this._state === AudioState.INTERRUPTED) {
                audioEngine.resume(this._id);
              } else if (this._state === AudioState.PLAYING) {
                audioEngine.pause(this._id);
                audioEngine.setCurrentTime(this._id, 0);
                audioEngine.resume(this._id);
              }
            } else {
              this._id = audioEngine.play2d(this._url, this._cachedState.loop, this._cachedState.volume);
              if (this._isValid) {
                if (this._cachedState.currentTime !== 0) {
                  audioEngine.setCurrentTime(this._id, this._cachedState.currentTime);
                  this._cachedState.currentTime = 0;
                }
                audioEngine.setFinishCallback(this._id, () => {
                  this._cachedState.currentTime = 0;
                  this._id = INVALID_AUDIO_ID;
                  this._state = AudioState.INIT;
                  this._eventTarget.emit(AudioEvent.ENDED);
                });
              }
            }
            this._state = AudioState.PLAYING;
            resolve();
          });
        }
        pause() {
          return new Promise(resolve => {
            if (this._isValid) {
              audioEngine.pause(this._id);
            }
            this._state = AudioState.PAUSED;
            resolve();
          });
        }
        stop() {
          return new Promise(resolve => {
            if (this._isValid) {
              audioEngine.stop(this._id);
            }
            this._state = AudioState.STOPPED;
            this._id = INVALID_AUDIO_ID;
            this._cachedState.currentTime = 0;
            resolve();
          });
        }
        onInterruptionBegin(cb) {
          this._eventTarget.on(AudioEvent.INTERRUPTION_BEGIN, cb);
        }
        offInterruptionBegin(cb) {
          this._eventTarget.off(AudioEvent.INTERRUPTION_BEGIN, cb);
        }
        onInterruptionEnd(cb) {
          this._eventTarget.on(AudioEvent.INTERRUPTION_END, cb);
        }
        offInterruptionEnd(cb) {
          this._eventTarget.off(AudioEvent.INTERRUPTION_END, cb);
        }
        onEnded(cb) {
          this._eventTarget.on(AudioEvent.ENDED, cb);
        }
        offEnded(cb) {
          this._eventTarget.off(AudioEvent.ENDED, cb);
        }
      }, _class3$f.maxAudioChannel = audioEngine.getMaxAudioInstance(), _class3$f), (_applyDecoratedDescriptor(_class2$k.prototype, "seek", [enqueueOperation], Object.getOwnPropertyDescriptor(_class2$k.prototype, "seek"), _class2$k.prototype), _applyDecoratedDescriptor(_class2$k.prototype, "play", [enqueueOperation], Object.getOwnPropertyDescriptor(_class2$k.prototype, "play"), _class2$k.prototype), _applyDecoratedDescriptor(_class2$k.prototype, "pause", [enqueueOperation], Object.getOwnPropertyDescriptor(_class2$k.prototype, "pause"), _class2$k.prototype), _applyDecoratedDescriptor(_class2$k.prototype, "stop", [enqueueOperation], Object.getOwnPropertyDescriptor(_class2$k.prototype, "stop"), _class2$k.prototype)), _class2$k);
      legacyCC.AudioPlayer = AudioPlayer;

      var _dec$m, _class$l, _class2$j, _initializer$i, _class3$e;
      let AudioClip = exports('AudioClip', (_dec$m = ccclass$3('cc.AudioClip'), _dec$m(_class$l = (_class2$j = (_class3$e = class AudioClip extends Asset {
        constructor(...args) {
          super(...args);
          this._duration = _initializer$i && _initializer$i();
          this._loadMode = AudioType.UNKNOWN_AUDIO;
          this._meta = null;
          this._player = null;
        }
        set duration(v) {
          this._duration = v;
        }
        destroy() {
          var _this$_player;
          const destroyResult = super.destroy();
          (_this$_player = this._player) === null || _this$_player === void 0 ? void 0 : _this$_player.destroy();
          this._player = null;
          if (this._meta) {
            this._meta.player = null;
          }
          return destroyResult;
        }
        set _nativeAsset(meta) {
          this._meta = meta;
          if (meta) {
            this._loadMode = meta.type;
            this._player = meta.player;
          } else {
            this._meta = null;
            this._loadMode = AudioType.UNKNOWN_AUDIO;
            this._duration = 0;
          }
        }
        get _nativeAsset() {
          return this._meta;
        }
        get _nativeDep() {
          return {
            uuid: this._uuid,
            audioLoadMode: this.loadMode,
            ext: this._native,
            __isNative__: true
          };
        }
        get loadMode() {
          return this._loadMode;
        }
        validate() {
          return !!this._meta;
        }
        getDuration() {
          if (this._duration) {
            return this._duration;
          }
          return this._meta ? this._meta.duration : 0;
        }
        get state() {
          return this._player ? this._player.state : AudioState.INIT;
        }
        getCurrentTime() {
          return this._player ? this._player.currentTime : 0;
        }
        getVolume() {
          return this._player ? this._player.volume : 0;
        }
        getLoop() {
          return this._player ? this._player.loop : false;
        }
        setCurrentTime(time) {
          var _this$_player2;
          (_this$_player2 = this._player) === null || _this$_player2 === void 0 ? void 0 : _this$_player2.seek(time).catch(e => {});
        }
        setVolume(volume) {
          if (this._player) {
            this._player.volume = volume;
          }
        }
        setLoop(loop) {
          if (this._player) {
            this._player.loop = loop;
          }
        }
        play() {
          var _this$_player3;
          (_this$_player3 = this._player) === null || _this$_player3 === void 0 ? void 0 : _this$_player3.play().catch(e => {});
        }
        pause() {
          var _this$_player4;
          (_this$_player4 = this._player) === null || _this$_player4 === void 0 ? void 0 : _this$_player4.pause().catch(e => {});
        }
        stop() {
          var _this$_player5;
          (_this$_player5 = this._player) === null || _this$_player5 === void 0 ? void 0 : _this$_player5.stop().catch(e => {});
        }
        playOneShot(volume = 1) {
          if (this._nativeAsset) {
            AudioPlayer.loadOneShotAudio(this._nativeAsset.url, volume).then(oneShotAudio => {
              oneShotAudio.play();
            }).catch(e => {});
          }
        }
      }, _class3$e.AudioType = AudioType, _class3$e), (_initializer$i = applyDecoratedInitializer(_class2$j.prototype, "_duration", [serializable$3], function () {
        return 0;
      }), _applyDecoratedDescriptor(_class2$j.prototype, "_nativeDep", [override], Object.getOwnPropertyDescriptor(_class2$j.prototype, "_nativeDep"), _class2$j.prototype)), _class2$j)) || _class$l));
      legacyCC.AudioClip = AudioClip;

      function loadAudioPlayer(url, options, onComplete) {
        AudioPlayer.load(url, {
          audioLoadMode: options.audioLoadMode
        }).then(player => {
          const audioMeta = {
            player,
            url,
            duration: player.duration,
            type: player.type
          };
          onComplete(null, audioMeta);
        }).catch(err => {
          onComplete(err);
        });
      }
      function createAudioClip(id, data, options, onComplete) {
        const out = new AudioClip();
        out._nativeUrl = id;
        out._nativeAsset = data;
        out.duration = data.duration;
        onComplete(null, out);
      }
      downloader$1.register({
        '.mp3': loadAudioPlayer,
        '.ogg': loadAudioPlayer,
        '.wav': loadAudioPlayer,
        '.m4a': loadAudioPlayer
      });
      factory.register({
        '.mp3': createAudioClip,
        '.ogg': createAudioClip,
        '.wav': createAudioClip,
        '.m4a': createAudioClip
      });

      class AudioManager {
        constructor() {
          this._oneShotAudioInfoList = [];
          this._audioPlayerInfoList = [];
        }
        _findIndex(audioInfoList, audio) {
          return audioInfoList.findIndex(item => item.audio === audio);
        }
        _tryAddPlaying(audioInfoList, audio) {
          const idx = this._findIndex(audioInfoList, audio);
          if (idx > -1) {
            audioInfoList[idx].playTime = performance.now();
            return false;
          }
          audioInfoList.push({
            audio,
            playTime: performance.now()
          });
          return true;
        }
        addPlaying(audio) {
          if (audio instanceof AudioPlayer) {
            this._tryAddPlaying(this._audioPlayerInfoList, audio);
          } else {
            this._tryAddPlaying(this._oneShotAudioInfoList, audio);
          }
        }
        _tryRemovePlaying(audioInfoList, audio) {
          const idx = this._findIndex(audioInfoList, audio);
          if (idx === -1) {
            return false;
          }
          fastRemoveAt$2(audioInfoList, idx);
          return true;
        }
        removePlaying(audio) {
          if (audio instanceof AudioPlayer) {
            this._tryRemovePlaying(this._audioPlayerInfoList, audio);
          } else {
            this._tryRemovePlaying(this._oneShotAudioInfoList, audio);
          }
        }
        discardOnePlayingIfNeeded() {
          if (this._audioPlayerInfoList.length + this._oneShotAudioInfoList.length < AudioPlayer.maxAudioChannel) {
            return;
          }
          let audioInfoToDiscard;
          if (this._oneShotAudioInfoList.length > 0) {
            this._oneShotAudioInfoList.forEach(audioInfo => {
              if (!audioInfoToDiscard || audioInfo.playTime < audioInfoToDiscard.playTime) {
                audioInfoToDiscard = audioInfo;
              }
            });
          } else {
            this._audioPlayerInfoList.forEach(audioInfo => {
              if (!audioInfoToDiscard || audioInfo.playTime < audioInfoToDiscard.playTime) {
                audioInfoToDiscard = audioInfo;
              }
            });
          }
          if (audioInfoToDiscard) {
            audioInfoToDiscard.audio.stop();
            this.removePlaying(audioInfoToDiscard.audio);
          }
        }
        pause() {
          this._oneShotAudioInfoList.forEach(info => {
            info.audio.stop();
          });
          this._audioPlayerInfoList.forEach(info => {
            info.audio.pause().catch(e => {});
          });
        }
        resume() {
          this._audioPlayerInfoList.forEach(info => {
            info.audio.play().catch(e => {});
          });
        }
      }
      const audioManager = new AudioManager();

      var _dec$l, _dec2$i, _dec3$g, _class$k, _class2$i, _initializer$h, _initializer2$g, _initializer3$e, _initializer4$d, _class3$d;
      const _LOADED_EVENT = 'audiosource-loaded';
      var AudioSourceEventType;
      (function (AudioSourceEventType) {
        AudioSourceEventType["STARTED"] = "started";
        AudioSourceEventType["ENDED"] = "ended";
      })(AudioSourceEventType || (AudioSourceEventType = {}));
      var AudioOperationType;
      (function (AudioOperationType) {
        AudioOperationType["PLAY"] = "play";
        AudioOperationType["STOP"] = "stop";
        AudioOperationType["PAUSE"] = "pause";
        AudioOperationType["SEEK"] = "seek";
      })(AudioOperationType || (AudioOperationType = {}));
      let AudioSource = (_dec$l = ccclass$3('cc.AudioSource'), _dec2$i = type$2(AudioClip), _dec3$g = type$2(AudioClip), _dec$l(_class$k = (_class2$i = (_class3$d = class AudioSource extends Component {
        constructor(...args) {
          super(...args);
          this._clip = _initializer$h && _initializer$h();
          this._player = null;
          this._hasRegisterListener = false;
          this._loop = _initializer2$g && _initializer2$g();
          this._playOnAwake = _initializer3$e && _initializer3$e();
          this._volume = _initializer4$d && _initializer4$d();
          this._cachedCurrentTime = -1;
          this._operationsBeforeLoading = [];
          this._isLoaded = false;
          this._lastSetClip = null;
        }
        static get maxAudioChannel() {
          return AudioPlayer.maxAudioChannel;
        }
        _resetPlayer() {
          if (this._player) {
            audioManager.removePlaying(this._player);
            this._unregisterListener();
            this._player.destroy();
            this._player = null;
          }
        }
        set clip(val) {
          if (val === this._clip) {
            return;
          }
          this._clip = val;
          this._syncPlayer();
        }
        get clip() {
          return this._clip;
        }
        _syncPlayer() {
          const clip = this._clip;
          if (this._lastSetClip === clip) {
            return;
          }
          if (!clip) {
            this._lastSetClip = null;
            this._resetPlayer();
            return;
          }
          if (!clip._nativeAsset) {
            console.error('Invalid audio clip');
            return;
          }
          this._isLoaded = false;
          this._lastSetClip = clip;
          this._operationsBeforeLoading.length = 0;
          AudioPlayer.load(clip._nativeAsset.url, {
            audioLoadMode: clip.loadMode
          }).then(player => {
            var _this$node;
            if (this._lastSetClip !== clip) {
              player.destroy();
              return;
            }
            this._isLoaded = true;
            this._resetPlayer();
            this._player = player;
            this._syncStates();
            (_this$node = this.node) === null || _this$node === void 0 ? void 0 : _this$node.emit(_LOADED_EVENT);
          }).catch(e => {});
        }
        _registerListener() {
          if (!this._hasRegisterListener && this._player) {
            const player = this._player;
            player.onEnded(() => {
              var _this$node2;
              audioManager.removePlaying(player);
              (_this$node2 = this.node) === null || _this$node2 === void 0 ? void 0 : _this$node2.emit(AudioSourceEventType.ENDED, this);
            });
            player.onInterruptionBegin(() => {
              audioManager.removePlaying(player);
            });
            player.onInterruptionEnd(() => {
              if (this._player === player) {
                audioManager.addPlaying(player);
              }
            });
            this._hasRegisterListener = true;
          }
        }
        _unregisterListener() {
          if (this._player && this._hasRegisterListener) {
            this._player.offEnded();
            this._player.offInterruptionBegin();
            this._player.offInterruptionEnd();
            this._hasRegisterListener = false;
          }
        }
        set loop(val) {
          this._loop = val;
          if (this._player) {
            this._player.loop = val;
          }
        }
        get loop() {
          return this._loop;
        }
        set playOnAwake(val) {
          this._playOnAwake = val;
        }
        get playOnAwake() {
          return this._playOnAwake;
        }
        set volume(val) {
          if (Number.isNaN(val)) {
            console.warn('illegal audio volume!');
            return;
          }
          val = clamp$1(val, 0, 1);
          if (this._player) {
            this._player.volume = val;
            this._volume = this._player.volume;
          } else {
            this._volume = val;
          }
        }
        get volume() {
          return this._volume;
        }
        onLoad() {
          this._syncPlayer();
        }
        onEnable() {
          if (this._playOnAwake && !this.playing) {
            this.play();
          }
        }
        onDisable() {
          const rootNode = this._getRootNode();
          if (rootNode !== null && rootNode !== void 0 && rootNode._persistNode) {
            return;
          }
          this.pause();
        }
        onDestroy() {
          this.stop();
          this.clip = null;
        }
        getPCMData(channelIndex) {
          return new Promise(resolve => {
            if (channelIndex !== 0 && channelIndex !== 1) {
              console.warn('Only support channel index 0 or 1 to get buffer');
              resolve(undefined);
              return;
            }
            if (this._player) {
              resolve(this._player.getPCMData(channelIndex));
            } else {
              var _this$node3;
              (_this$node3 = this.node) === null || _this$node3 === void 0 ? void 0 : _this$node3.once(_LOADED_EVENT, () => {
                var _this$_player;
                resolve((_this$_player = this._player) === null || _this$_player === void 0 ? void 0 : _this$_player.getPCMData(channelIndex));
              });
            }
          });
        }
        getSampleRate() {
          return new Promise(resolve => {
            if (this._player) {
              resolve(this._player.sampleRate);
            } else {
              var _this$node4;
              (_this$node4 = this.node) === null || _this$node4 === void 0 ? void 0 : _this$node4.once(_LOADED_EVENT, () => {
                resolve(this._player.sampleRate);
              });
            }
          });
        }
        _getRootNode() {
          var _currentNode, _currentNode$parent;
          let currentNode = this.node;
          let currentGrandparentNode = (_currentNode = currentNode) === null || _currentNode === void 0 ? void 0 : (_currentNode$parent = _currentNode.parent) === null || _currentNode$parent === void 0 ? void 0 : _currentNode$parent.parent;
          while (currentGrandparentNode) {
            var _currentNode2, _currentNode3, _currentNode3$parent;
            currentNode = (_currentNode2 = currentNode) === null || _currentNode2 === void 0 ? void 0 : _currentNode2.parent;
            currentGrandparentNode = (_currentNode3 = currentNode) === null || _currentNode3 === void 0 ? void 0 : (_currentNode3$parent = _currentNode3.parent) === null || _currentNode3$parent === void 0 ? void 0 : _currentNode3$parent.parent;
          }
          return currentNode;
        }
        play() {
          if (!this._isLoaded && this.clip) {
            this._operationsBeforeLoading.push({
              op: AudioOperationType.PLAY,
              params: null
            });
            return;
          }
          this._registerListener();
          audioManager.discardOnePlayingIfNeeded();
          if (this.state === AudioState.PLAYING) {
            var _this$_player2;
            (_this$_player2 = this._player) === null || _this$_player2 === void 0 ? void 0 : _this$_player2.stop().catch(e => {});
          }
          const player = this._player;
          if (player) {
            player.play().then(() => {
              var _this$node5;
              (_this$node5 = this.node) === null || _this$node5 === void 0 ? void 0 : _this$node5.emit(AudioSourceEventType.STARTED, this);
            }).catch(e => {
              audioManager.removePlaying(player);
            });
            audioManager.addPlaying(player);
          }
        }
        pause() {
          var _this$_player3;
          if (!this._isLoaded && this.clip) {
            this._operationsBeforeLoading.push({
              op: AudioOperationType.PAUSE,
              params: null
            });
            return;
          }
          (_this$_player3 = this._player) === null || _this$_player3 === void 0 ? void 0 : _this$_player3.pause().catch(e => {});
        }
        stop() {
          if (!this._isLoaded && this.clip) {
            this._operationsBeforeLoading.push({
              op: AudioOperationType.STOP,
              params: null
            });
            return;
          }
          if (this._player) {
            this._player.stop().catch(e => {});
            audioManager.removePlaying(this._player);
          }
        }
        playOneShot(clip, volumeScale = 1) {
          if (!clip._nativeAsset) {
            console.error('Invalid audio clip');
            return;
          }
          let player;
          AudioPlayer.loadOneShotAudio(clip._nativeAsset.url, this._volume * volumeScale, {
            audioLoadMode: clip.loadMode
          }).then(oneShotAudio => {
            player = oneShotAudio;
            audioManager.discardOnePlayingIfNeeded();
            oneShotAudio.onEnd = () => {
              audioManager.removePlaying(oneShotAudio);
            };
            oneShotAudio.play();
            audioManager.addPlaying(oneShotAudio);
          }).catch(e => {
            if (player) {
              audioManager.removePlaying(player);
            }
          });
        }
        _syncStates() {
          if (this._player) {
            this._player.loop = this._loop;
            this._player.volume = this._volume;
            this._operationsBeforeLoading.forEach(opInfo => {
              if (opInfo.op === AudioOperationType.SEEK) {
                this._cachedCurrentTime = opInfo.params && opInfo.params[0];
                if (this._player) {
                  this._player.seek(this._cachedCurrentTime).catch(e => {});
                }
              } else {
                var _this$opInfo$op;
                (_this$opInfo$op = this[opInfo.op]) === null || _this$opInfo$op === void 0 ? void 0 : _this$opInfo$op.call(this);
              }
            });
            this._operationsBeforeLoading.length = 0;
          }
        }
        set currentTime(num) {
          var _this$_player4;
          if (Number.isNaN(num)) {
            console.warn('illegal audio time!');
            return;
          }
          num = clamp$1(num, 0, this.duration);
          if (!this._isLoaded && this.clip) {
            this._operationsBeforeLoading.push({
              op: AudioOperationType.SEEK,
              params: [num]
            });
            return;
          }
          this._cachedCurrentTime = num;
          (_this$_player4 = this._player) === null || _this$_player4 === void 0 ? void 0 : _this$_player4.seek(this._cachedCurrentTime).catch(e => {});
        }
        get currentTime() {
          return this._player ? this._player.currentTime : this._cachedCurrentTime < 0 ? 0 : this._cachedCurrentTime;
        }
        get duration() {
          var _this$_clip$getDurati, _this$_clip;
          return (_this$_clip$getDurati = (_this$_clip = this._clip) === null || _this$_clip === void 0 ? void 0 : _this$_clip.getDuration()) !== null && _this$_clip$getDurati !== void 0 ? _this$_clip$getDurati : this._player ? this._player.duration : 0;
        }
        get state() {
          return this._player ? this._player.state : AudioState.INIT;
        }
        get playing() {
          return this.state === AudioSource.AudioState.PLAYING;
        }
      }, _class3$d.AudioState = AudioState, _class3$d.EventType = AudioSourceEventType, _class3$d), (_initializer$h = applyDecoratedInitializer(_class2$i.prototype, "_clip", [_dec2$i], function () {
        return null;
      }), _initializer2$g = applyDecoratedInitializer(_class2$i.prototype, "_loop", [serializable$3], function () {
        return false;
      }), _initializer3$e = applyDecoratedInitializer(_class2$i.prototype, "_playOnAwake", [serializable$3], function () {
        return true;
      }), _initializer4$d = applyDecoratedInitializer(_class2$i.prototype, "_volume", [serializable$3], function () {
        return 1;
      }), _applyDecoratedDescriptor(_class2$i.prototype, "clip", [_dec3$g], Object.getOwnPropertyDescriptor(_class2$i.prototype, "clip"), _class2$i.prototype)), _class2$i)) || _class$k); exports({ AudioSource: AudioSource, AudioSourceComponent: AudioSource });

      replaceProperty(AudioClip, 'AudioClip', [{
        name: 'PlayingState',
        newName: 'AudioState',
        target: AudioSource,
        targetName: 'AudioSource'
      }]);
      markAsWarning(AudioClip.prototype, 'AudioClip.prototype', ['state', 'play', 'pause', 'stop', 'playOneShot', 'setCurrentTime', 'setVolume', 'setLoop', 'getCurrentTime', 'getVolume', 'getLoop'].map(item => ({
        name: item,
        suggest: `please use AudioSource.prototype.${item} instead`
      })));

      legacyCC.AudioSourceComponent = AudioSource;
      setClassAlias(AudioSource, 'cc.AudioSourceComponent');

      legacyCC.log = log;
      legacyCC.warn = warn;
      legacyCC.error = error;
      legacyCC.assert = assert;
      legacyCC._throw = _throw;
      legacyCC.logID = logID;
      legacyCC.warnID = warnID;
      legacyCC.errorID = errorID;
      legacyCC.assertID = assertID;
      legacyCC.debug = debug$1;
      legacyCC.path = {
        join,
        extname,
        mainFileName,
        basename,
        dirname,
        changeExtname,
        changeBasename,
        _normalize,
        stripSep,
        get sep() {
          return getSeperator();
        }
      };

      let LightType;
      (function (LightType) {
        LightType[LightType["DIRECTIONAL"] = 0] = "DIRECTIONAL";
        LightType[LightType["SPHERE"] = 1] = "SPHERE";
        LightType[LightType["SPOT"] = 2] = "SPOT";
        LightType[LightType["POINT"] = 3] = "POINT";
        LightType[LightType["RANGED_DIRECTIONAL"] = 4] = "RANGED_DIRECTIONAL";
        LightType[LightType["UNKNOWN"] = 5] = "UNKNOWN";
      })(LightType || (LightType = {}));

      let UpdateFrequency;
      (function (UpdateFrequency) {
        UpdateFrequency[UpdateFrequency["PER_INSTANCE"] = 0] = "PER_INSTANCE";
        UpdateFrequency[UpdateFrequency["PER_BATCH"] = 1] = "PER_BATCH";
        UpdateFrequency[UpdateFrequency["PER_PHASE"] = 2] = "PER_PHASE";
        UpdateFrequency[UpdateFrequency["PER_PASS"] = 3] = "PER_PASS";
        UpdateFrequency[UpdateFrequency["COUNT"] = 4] = "COUNT";
      })(UpdateFrequency || (UpdateFrequency = {}));
      let ParameterType;
      (function (ParameterType) {
        ParameterType[ParameterType["CONSTANTS"] = 0] = "CONSTANTS";
        ParameterType[ParameterType["CBV"] = 1] = "CBV";
        ParameterType[ParameterType["UAV"] = 2] = "UAV";
        ParameterType[ParameterType["SRV"] = 3] = "SRV";
        ParameterType[ParameterType["TABLE"] = 4] = "TABLE";
        ParameterType[ParameterType["SSV"] = 5] = "SSV";
      })(ParameterType || (ParameterType = {}));
      let ResourceResidency;
      (function (ResourceResidency) {
        ResourceResidency[ResourceResidency["MANAGED"] = 0] = "MANAGED";
        ResourceResidency[ResourceResidency["MEMORYLESS"] = 1] = "MEMORYLESS";
        ResourceResidency[ResourceResidency["PERSISTENT"] = 2] = "PERSISTENT";
        ResourceResidency[ResourceResidency["EXTERNAL"] = 3] = "EXTERNAL";
        ResourceResidency[ResourceResidency["BACKBUFFER"] = 4] = "BACKBUFFER";
      })(ResourceResidency || (ResourceResidency = {}));
      let QueueHint;
      (function (QueueHint) {
        QueueHint[QueueHint["NONE"] = 0] = "NONE";
        QueueHint[QueueHint["OPAQUE"] = 1] = "OPAQUE";
        QueueHint[QueueHint["MASK"] = 2] = "MASK";
        QueueHint[QueueHint["BLEND"] = 3] = "BLEND";
        QueueHint[QueueHint["RENDER_OPAQUE"] = 1] = "RENDER_OPAQUE";
        QueueHint[QueueHint["RENDER_CUTOUT"] = 2] = "RENDER_CUTOUT";
        QueueHint[QueueHint["RENDER_TRANSPARENT"] = 3] = "RENDER_TRANSPARENT";
      })(QueueHint || (QueueHint = {}));
      let ResourceDimension;
      (function (ResourceDimension) {
        ResourceDimension[ResourceDimension["BUFFER"] = 0] = "BUFFER";
        ResourceDimension[ResourceDimension["TEXTURE1D"] = 1] = "TEXTURE1D";
        ResourceDimension[ResourceDimension["TEXTURE2D"] = 2] = "TEXTURE2D";
        ResourceDimension[ResourceDimension["TEXTURE3D"] = 3] = "TEXTURE3D";
      })(ResourceDimension || (ResourceDimension = {}));
      let ResourceFlags;
      (function (ResourceFlags) {
        ResourceFlags[ResourceFlags["NONE"] = 0] = "NONE";
        ResourceFlags[ResourceFlags["UNIFORM"] = 1] = "UNIFORM";
        ResourceFlags[ResourceFlags["INDIRECT"] = 2] = "INDIRECT";
        ResourceFlags[ResourceFlags["STORAGE"] = 4] = "STORAGE";
        ResourceFlags[ResourceFlags["SAMPLED"] = 8] = "SAMPLED";
        ResourceFlags[ResourceFlags["COLOR_ATTACHMENT"] = 16] = "COLOR_ATTACHMENT";
        ResourceFlags[ResourceFlags["DEPTH_STENCIL_ATTACHMENT"] = 32] = "DEPTH_STENCIL_ATTACHMENT";
        ResourceFlags[ResourceFlags["INPUT_ATTACHMENT"] = 64] = "INPUT_ATTACHMENT";
        ResourceFlags[ResourceFlags["SHADING_RATE"] = 128] = "SHADING_RATE";
        ResourceFlags[ResourceFlags["TRANSFER_SRC"] = 256] = "TRANSFER_SRC";
        ResourceFlags[ResourceFlags["TRANSFER_DST"] = 512] = "TRANSFER_DST";
      })(ResourceFlags || (ResourceFlags = {}));
      let TaskType;
      (function (TaskType) {
        TaskType[TaskType["SYNC"] = 0] = "SYNC";
        TaskType[TaskType["ASYNC"] = 1] = "ASYNC";
      })(TaskType || (TaskType = {}));
      let SceneFlags;
      (function (SceneFlags) {
        SceneFlags[SceneFlags["NONE"] = 0] = "NONE";
        SceneFlags[SceneFlags["OPAQUE"] = 1] = "OPAQUE";
        SceneFlags[SceneFlags["MASK"] = 2] = "MASK";
        SceneFlags[SceneFlags["BLEND"] = 4] = "BLEND";
        SceneFlags[SceneFlags["OPAQUE_OBJECT"] = 1] = "OPAQUE_OBJECT";
        SceneFlags[SceneFlags["CUTOUT_OBJECT"] = 2] = "CUTOUT_OBJECT";
        SceneFlags[SceneFlags["TRANSPARENT_OBJECT"] = 4] = "TRANSPARENT_OBJECT";
        SceneFlags[SceneFlags["SHADOW_CASTER"] = 8] = "SHADOW_CASTER";
        SceneFlags[SceneFlags["UI"] = 16] = "UI";
        SceneFlags[SceneFlags["DEFAULT_LIGHTING"] = 32] = "DEFAULT_LIGHTING";
        SceneFlags[SceneFlags["VOLUMETRIC_LIGHTING"] = 64] = "VOLUMETRIC_LIGHTING";
        SceneFlags[SceneFlags["CLUSTERED_LIGHTING"] = 128] = "CLUSTERED_LIGHTING";
        SceneFlags[SceneFlags["PLANAR_SHADOW"] = 256] = "PLANAR_SHADOW";
        SceneFlags[SceneFlags["GEOMETRY"] = 512] = "GEOMETRY";
        SceneFlags[SceneFlags["PROFILER"] = 1024] = "PROFILER";
        SceneFlags[SceneFlags["DRAW_INSTANCING"] = 2048] = "DRAW_INSTANCING";
        SceneFlags[SceneFlags["DRAW_NON_INSTANCING"] = 4096] = "DRAW_NON_INSTANCING";
        SceneFlags[SceneFlags["REFLECTION_PROBE"] = 8192] = "REFLECTION_PROBE";
        SceneFlags[SceneFlags["GPU_DRIVEN"] = 16384] = "GPU_DRIVEN";
        SceneFlags[SceneFlags["ALL"] = 4294967295] = "ALL";
      })(SceneFlags || (SceneFlags = {}));
      let LightingMode;
      (function (LightingMode) {
        LightingMode[LightingMode["NONE"] = 0] = "NONE";
        LightingMode[LightingMode["DEFAULT"] = 1] = "DEFAULT";
        LightingMode[LightingMode["CLUSTERED"] = 2] = "CLUSTERED";
      })(LightingMode || (LightingMode = {}));
      let AttachmentType;
      (function (AttachmentType) {
        AttachmentType[AttachmentType["RENDER_TARGET"] = 0] = "RENDER_TARGET";
        AttachmentType[AttachmentType["DEPTH_STENCIL"] = 1] = "DEPTH_STENCIL";
        AttachmentType[AttachmentType["SHADING_RATE"] = 2] = "SHADING_RATE";
      })(AttachmentType || (AttachmentType = {}));
      let AccessType;
      (function (AccessType) {
        AccessType[AccessType["READ"] = 0] = "READ";
        AccessType[AccessType["READ_WRITE"] = 1] = "READ_WRITE";
        AccessType[AccessType["WRITE"] = 2] = "WRITE";
      })(AccessType || (AccessType = {}));
      let ClearValueType;
      (function (ClearValueType) {
        ClearValueType[ClearValueType["NONE"] = 0] = "NONE";
        ClearValueType[ClearValueType["FLOAT_TYPE"] = 1] = "FLOAT_TYPE";
        ClearValueType[ClearValueType["INT_TYPE"] = 2] = "INT_TYPE";
      })(ClearValueType || (ClearValueType = {}));
      class LightInfo {
        constructor(light = null, level = 0, culledByLight = false) {
          this.light = void 0;
          this.level = void 0;
          this.culledByLight = void 0;
          this.light = light;
          this.level = level;
          this.culledByLight = culledByLight;
        }
      }
      let DescriptorTypeOrder;
      (function (DescriptorTypeOrder) {
        DescriptorTypeOrder[DescriptorTypeOrder["UNIFORM_BUFFER"] = 0] = "UNIFORM_BUFFER";
        DescriptorTypeOrder[DescriptorTypeOrder["DYNAMIC_UNIFORM_BUFFER"] = 1] = "DYNAMIC_UNIFORM_BUFFER";
        DescriptorTypeOrder[DescriptorTypeOrder["SAMPLER_TEXTURE"] = 2] = "SAMPLER_TEXTURE";
        DescriptorTypeOrder[DescriptorTypeOrder["SAMPLER"] = 3] = "SAMPLER";
        DescriptorTypeOrder[DescriptorTypeOrder["TEXTURE"] = 4] = "TEXTURE";
        DescriptorTypeOrder[DescriptorTypeOrder["STORAGE_BUFFER"] = 5] = "STORAGE_BUFFER";
        DescriptorTypeOrder[DescriptorTypeOrder["DYNAMIC_STORAGE_BUFFER"] = 6] = "DYNAMIC_STORAGE_BUFFER";
        DescriptorTypeOrder[DescriptorTypeOrder["STORAGE_IMAGE"] = 7] = "STORAGE_IMAGE";
        DescriptorTypeOrder[DescriptorTypeOrder["INPUT_ATTACHMENT"] = 8] = "INPUT_ATTACHMENT";
      })(DescriptorTypeOrder || (DescriptorTypeOrder = {}));
      let ResolveFlags;
      (function (ResolveFlags) {
        ResolveFlags[ResolveFlags["NONE"] = 0] = "NONE";
        ResolveFlags[ResolveFlags["COLOR"] = 1] = "COLOR";
        ResolveFlags[ResolveFlags["DEPTH"] = 2] = "DEPTH";
        ResolveFlags[ResolveFlags["STENCIL"] = 4] = "STENCIL";
      })(ResolveFlags || (ResolveFlags = {}));
      class UploadPair {
        constructor(source = new Uint8Array(0), target = '', mipLevels = 0xFFFFFFFF, numSlices = 0xFFFFFFFF, targetMostDetailedMip = 0, targetFirstSlice = 0, targetPlaneSlice = 0) {
          this.source = void 0;
          this.target = void 0;
          this.mipLevels = void 0;
          this.numSlices = void 0;
          this.targetMostDetailedMip = void 0;
          this.targetFirstSlice = void 0;
          this.targetPlaneSlice = void 0;
          this.source = source;
          this.target = target;
          this.mipLevels = mipLevels;
          this.numSlices = numSlices;
          this.targetMostDetailedMip = targetMostDetailedMip;
          this.targetFirstSlice = targetFirstSlice;
          this.targetPlaneSlice = targetPlaneSlice;
        }
      }

      new Viewport();
      new Rect();
      function SRGBToLinear(out, gamma) {
        out.x = gamma.x * gamma.x;
        out.y = gamma.y * gamma.y;
        out.z = gamma.z * gamma.z;
      }
      let profilerCamera = null;
      function getProfilerCamera() {
        return profilerCamera;
      }

      const _rangedDirLightBoundingBox = new AABB(0.0, 0.0, 0.0, 0.5, 0.5, 0.5);
      const _tmpBoundingBox = new AABB();
      let AntiAliasing;
      (function (AntiAliasing) {
        AntiAliasing[AntiAliasing["NONE"] = 0] = "NONE";
        AntiAliasing[AntiAliasing["FXAA"] = 1] = "FXAA";
        AntiAliasing[AntiAliasing["FXAAHQ"] = 2] = "FXAAHQ";
      })(AntiAliasing || (AntiAliasing = {}));
      function getRTFormatBeforeToneMapping(ppl) {
        const useFloatOutput = ppl.getMacroBool('CC_USE_FLOAT_OUTPUT');
        return ppl.pipelineSceneData.isHDR && useFloatOutput && supportsRGBA16HalfFloatTexture(ppl.device) ? Format.RGBA16F : Format.RGBA8;
      }
      function validPunctualLightsCulling(pipeline, camera) {
        const sceneData = pipeline.pipelineSceneData;
        const validPunctualLights = sceneData.validPunctualLights;
        validPunctualLights.length = 0;
        const _sphere = Sphere.create(0, 0, 0, 1);
        const {
          spotLights
        } = camera.scene;
        for (let i = 0; i < spotLights.length; i++) {
          const light = spotLights[i];
          if (light.baked && !camera.node.scene.globals.disableLightmap) {
            continue;
          }
          Sphere.set(_sphere, light.position.x, light.position.y, light.position.z, light.range);
          if (intersect.sphereFrustum(_sphere, camera.frustum)) {
            validPunctualLights.push(light);
          }
        }
        const {
          sphereLights
        } = camera.scene;
        for (let i = 0; i < sphereLights.length; i++) {
          const light = sphereLights[i];
          if (light.baked && !camera.node.scene.globals.disableLightmap) {
            continue;
          }
          Sphere.set(_sphere, light.position.x, light.position.y, light.position.z, light.range);
          if (intersect.sphereFrustum(_sphere, camera.frustum)) {
            validPunctualLights.push(light);
          }
        }
        const {
          pointLights
        } = camera.scene;
        for (let i = 0; i < pointLights.length; i++) {
          const light = pointLights[i];
          if (light.baked) {
            continue;
          }
          Sphere.set(_sphere, light.position.x, light.position.y, light.position.z, light.range);
          if (intersect.sphereFrustum(_sphere, camera.frustum)) {
            validPunctualLights.push(light);
          }
        }
        const {
          rangedDirLights
        } = camera.scene;
        for (let i = 0; i < rangedDirLights.length; i++) {
          const light = rangedDirLights[i];
          AABB.transform(_tmpBoundingBox, _rangedDirLightBoundingBox, light.node.getWorldMatrix());
          if (intersect.aabbFrustum(_tmpBoundingBox, camera.frustum)) {
            validPunctualLights.push(light);
          }
        }
        sceneData.validPunctualLights = validPunctualLights;
      }
      const _cameras = [];
      function getCameraUniqueID(camera) {
        if (!_cameras.includes(camera)) {
          _cameras.push(camera);
        }
        return _cameras.indexOf(camera);
      }
      function getLoadOpOfClearFlag(clearFlag, attachment) {
        let loadOp = LoadOp.CLEAR;
        if (!(clearFlag & ClearFlagBit.COLOR) && attachment === AttachmentType.RENDER_TARGET) {
          if (clearFlag & SKYBOX_FLAG) {
            loadOp = LoadOp.CLEAR;
          } else {
            loadOp = LoadOp.LOAD;
          }
        }
        if ((clearFlag & ClearFlagBit.DEPTH_STENCIL) !== ClearFlagBit.DEPTH_STENCIL && attachment === AttachmentType.DEPTH_STENCIL) {
          if (!(clearFlag & ClearFlagBit.DEPTH)) loadOp = LoadOp.LOAD;
          if (!(clearFlag & ClearFlagBit.STENCIL)) loadOp = LoadOp.LOAD;
        }
        return loadOp;
      }
      function getRenderArea(camera, width, height, light = null, level = 0, out = undefined) {
        out = out || new Rect();
        const vp = camera ? camera.viewport : new Rect(0, 0, 1, 1);
        const w = width;
        const h = height;
        out.x = vp.x * w;
        out.y = vp.y * h;
        out.width = vp.width * w;
        out.height = vp.height * h;
        if (light) {
          switch (light.type) {
            case LightType.DIRECTIONAL:
              {
                const mainLight = light;
                if (mainLight.shadowFixedArea || mainLight.csmLevel === CSMLevel.LEVEL_1) {
                  out.x = 0;
                  out.y = 0;
                  out.width = w;
                  out.height = h;
                } else {
                  const screenSpaceSignY = legacyCC.director.root.device.capabilities.screenSpaceSignY;
                  out.x = level % 2 * 0.5 * w;
                  if (screenSpaceSignY > 0) {
                    out.y = (1 - Math.floor(level / 2)) * 0.5 * h;
                  } else {
                    out.y = Math.floor(level / 2) * 0.5 * h;
                  }
                  out.width = 0.5 * w;
                  out.height = 0.5 * h;
                }
                break;
              }
            case LightType.SPOT:
              {
                out.x = 0;
                out.y = 0;
                out.width = w;
                out.height = h;
                break;
              }
          }
        }
        return out;
      }
      class PostInfo {
        _init() {
          this.postMaterial = new Material();
          this.postMaterial.name = 'builtin-post-process-material';
          this.postMaterial.initialize({
            effectName: 'pipeline/post-process',
            defines: {
              ANTIALIAS_TYPE: this.antiAliasing
            }
          });
          for (let i = 0; i < this.postMaterial.passes.length; ++i) {
            this.postMaterial.passes[i].tryCompile();
          }
        }
        constructor(antiAliasing = AntiAliasing.NONE) {
          this.antiAliasing = AntiAliasing.NONE;
          this.antiAliasing = antiAliasing;
          this._init();
        }
      }
      class ShadowInfo {
        constructor() {
          this.shadowEnabled = false;
          this.mainLightShadowNames = new Array();
          this.spotLightShadowNames = new Array();
          this.validLights = [];
        }
        reset() {
          this.shadowEnabled = false;
          this.mainLightShadowNames.length = 0;
          this.spotLightShadowNames.length = 0;
          this.validLights.length = 0;
        }
      }
      new ShadowInfo();
      class GBufferInfo {
        constructor() {
          this.color = void 0;
          this.normal = void 0;
          this.emissive = void 0;
          this.ds = void 0;
        }
      }
      class LightingInfo {
        _init() {
          this.deferredLightingMaterial = new Material();
          this.deferredLightingMaterial.name = 'builtin-deferred-material';
          this.deferredLightingMaterial.initialize({
            effectName: 'pipeline/deferred-lighting',
            defines: {
              CC_ENABLE_CLUSTERED_LIGHT_CULLING: this.enableCluster,
              CC_RECEIVE_SHADOW: 1
            }
          });
          for (let i = 0; i < this.deferredLightingMaterial.passes.length; ++i) {
            this.deferredLightingMaterial.passes[i].tryCompile();
          }
        }
        constructor(clusterEn) {
          this.enableCluster = void 0;
          this.enableCluster = clusterEn ? 1 : 0;
          this._init();
        }
      }
      new Vec3();
      new Vec3();
      new Vec4();
      new Vec4();
      new Vec2();
      const MAX_LIGHTS_PER_CLUSTER = 100;
      const CLUSTERS_X = 16;
      const CLUSTERS_Y = 8;
      const CLUSTERS_Z = 24;
      const CLUSTER_COUNT = CLUSTERS_X * CLUSTERS_Y * CLUSTERS_Z;
      class ClusterLightData {
        _initMaterial(id, effect) {
          const mat = new Material();
          mat.name = id;
          mat.initialize({
            effectName: effect
          });
          for (let i = 0; i < mat.passes.length; ++i) {
            mat.passes[i].tryCompile();
          }
          return mat;
        }
        _init() {
          this.clusterBuildCS = this._initMaterial('builtin-cluster-build-cs-material', 'pipeline/cluster-build');
          this.clusterLightCullingCS = this._initMaterial('builtin-cluster-culling-cs-material', 'pipeline/cluster-culling');
          this.dispatchX = CLUSTERS_X / this.clusters_x_threads;
          this.dispatchY = CLUSTERS_Y / this.clusters_y_threads;
          this.dispatchZ = CLUSTERS_Z / this.clusters_z_threads;
        }
        constructor() {
          this.clusters_x_threads = 16;
          this.clusters_y_threads = 8;
          this.clusters_z_threads = 1;
          this.dispatchX = 1;
          this.dispatchY = 1;
          this.dispatchZ = 1;
          this._init();
        }
      }
      let _clusterLightData = null;
      function buildLightClusterBuildPass(camera, clusterData, ppl) {
        const cameraID = getCameraUniqueID(camera);
        const clusterBufferName = `clusterBuffer${cameraID}`;
        const clusterBufferSize = CLUSTER_COUNT * 2 * 4 * 4;
        if (!ppl.containsResource(clusterBufferName)) {
          ppl.addStorageBuffer(clusterBufferName, Format.UNKNOWN, clusterBufferSize, ResourceResidency.MANAGED);
        }
        ppl.updateStorageBuffer(clusterBufferName, clusterBufferSize);
        const clusterPass = ppl.addComputePass('cluster-build-cs');
        clusterPass.addStorageBuffer(clusterBufferName, AccessType.WRITE, 'b_clustersBuffer');
        clusterPass.addQueue().addDispatch(clusterData.dispatchX, clusterData.dispatchY, clusterData.dispatchZ, clusterData.clusterBuildCS, 0);
        const width = camera.width * ppl.pipelineSceneData.shadingScale;
        const height = camera.height * ppl.pipelineSceneData.shadingScale;
        clusterPass.setVec4('cc_nearFar', new Vec4(camera.nearClip, camera.farClip, camera.getClipSpaceMinz(), 0));
        clusterPass.setVec4('cc_viewPort', new Vec4(0, 0, width, height));
        clusterPass.setVec4('cc_workGroup', new Vec4(CLUSTERS_X, CLUSTERS_Y, CLUSTERS_Z, 0));
        clusterPass.setMat4('cc_matView', camera.matView);
        clusterPass.setMat4('cc_matProjInv', camera.matProjInv);
      }
      function buildLightClusterCullingPass(camera, clusterData, ppl) {
        const cameraID = getCameraUniqueID(camera);
        const clusterBufferName = `clusterBuffer${cameraID}`;
        const clusterLightBufferName = `clusterLightBuffer${cameraID}`;
        const clusterGlobalIndexBufferName = `globalIndexBuffer${cameraID}`;
        const clusterLightIndicesBufferName = `clusterLightIndicesBuffer${cameraID}`;
        const clusterLightGridBufferName = `clusterLightGridBuffer${cameraID}`;
        const lightIndexBufferSize = MAX_LIGHTS_PER_CLUSTER * CLUSTER_COUNT * 4;
        const lightGridBufferSize = CLUSTER_COUNT * 4 * 4;
        if (!ppl.containsResource(clusterLightIndicesBufferName)) {
          ppl.addStorageBuffer(clusterLightIndicesBufferName, Format.UNKNOWN, lightIndexBufferSize, ResourceResidency.MANAGED);
        }
        if (!ppl.containsResource(clusterLightGridBufferName)) {
          ppl.addStorageBuffer(clusterLightGridBufferName, Format.UNKNOWN, lightGridBufferSize, ResourceResidency.MANAGED);
        }
        const clusterPass = ppl.addComputePass('cluster-culling-cs');
        clusterPass.addStorageBuffer(clusterLightBufferName, AccessType.READ, 'b_ccLightsBuffer');
        clusterPass.addStorageBuffer(clusterBufferName, AccessType.READ, 'b_clustersBuffer');
        clusterPass.addStorageBuffer(clusterLightIndicesBufferName, AccessType.WRITE, 'b_clusterLightIndicesBuffer');
        clusterPass.addStorageBuffer(clusterLightGridBufferName, AccessType.WRITE, 'b_clusterLightGridBuffer');
        clusterPass.addStorageBuffer(clusterGlobalIndexBufferName, AccessType.WRITE, 'b_globalIndexBuffer');
        clusterPass.addQueue().addDispatch(clusterData.dispatchX, clusterData.dispatchY, clusterData.dispatchZ, clusterData.clusterLightCullingCS, 0);
        const width = camera.width * ppl.pipelineSceneData.shadingScale;
        const height = camera.height * ppl.pipelineSceneData.shadingScale;
        clusterPass.setVec4('cc_nearFar', new Vec4(camera.nearClip, camera.farClip, camera.getClipSpaceMinz(), 0));
        clusterPass.setVec4('cc_viewPort', new Vec4(width, height, width, height));
        clusterPass.setVec4('cc_workGroup', new Vec4(CLUSTERS_X, CLUSTERS_Y, CLUSTERS_Z, 0));
        clusterPass.setMat4('cc_matView', camera.matView);
        clusterPass.setMat4('cc_matProjInv', camera.matProjInv);
      }
      function buildLightBuffer(size, floatPerLight, camera, pipeline) {
        const buffer = new ArrayBuffer(size);
        const view = new Float32Array(buffer);
        const data = pipeline.pipelineSceneData;
        const lightMeterScale = 10000.0;
        const exposure = camera.exposure;
        let index = 0;
        for (const light of data.validPunctualLights) {
          const offset = index * floatPerLight;
          const positionOffset = offset + 0;
          const colorOffset = offset + 4;
          const sizeRangeAngleOffset = offset + 8;
          const directionOffset = offset + 12;
          const boundSizeOffset = offset + 16;
          let luminanceHDR = 0;
          let luminanceLDR = 0;
          let position;
          if (light.type === LightType.POINT) {
            const point = light;
            position = point.position;
            luminanceLDR = point.luminanceLDR;
            luminanceHDR = point.luminanceHDR;
            view[sizeRangeAngleOffset] = 0;
            view[sizeRangeAngleOffset + 1] = point.range;
            view[sizeRangeAngleOffset + 2] = 0;
            view[sizeRangeAngleOffset + 3] = 0;
          } else if (light.type === LightType.SPHERE) {
            const sphere = light;
            position = sphere.position;
            luminanceLDR = sphere.luminanceLDR;
            luminanceHDR = sphere.luminanceHDR;
            view[sizeRangeAngleOffset] = sphere.size;
            view[sizeRangeAngleOffset + 1] = sphere.range;
            view[sizeRangeAngleOffset + 2] = 0;
            view[sizeRangeAngleOffset + 3] = 0;
          } else if (light.type === LightType.SPOT) {
            const spot = light;
            position = spot.position;
            luminanceLDR = spot.luminanceLDR;
            luminanceHDR = spot.luminanceHDR;
            view[sizeRangeAngleOffset] = spot.size;
            view[sizeRangeAngleOffset + 1] = spot.range;
            view[sizeRangeAngleOffset + 2] = spot.spotAngle;
            view[sizeRangeAngleOffset + 3] = 0;
            const dir = spot.direction;
            view[directionOffset] = dir.x;
            view[directionOffset + 1] = dir.y;
            view[directionOffset + 2] = dir.z;
            view[directionOffset + 3] = 0;
          } else if (light.type === LightType.RANGED_DIRECTIONAL) {
            const directional = light;
            position = directional.position;
            luminanceLDR = directional.illuminanceLDR;
            luminanceHDR = directional.illuminanceHDR;
            const right = directional.right;
            view[sizeRangeAngleOffset] = right.x;
            view[sizeRangeAngleOffset + 1] = right.y;
            view[sizeRangeAngleOffset + 2] = right.z;
            view[sizeRangeAngleOffset + 3] = 0;
            const dir = directional.direction;
            view[directionOffset] = dir.x;
            view[directionOffset + 1] = dir.y;
            view[directionOffset + 2] = dir.z;
            view[directionOffset + 3] = 0;
            const scale = directional.scale;
            view[boundSizeOffset] = scale.x * 0.5;
            view[boundSizeOffset + 1] = scale.y * 0.5;
            view[boundSizeOffset + 2] = scale.z * 0.5;
            view[boundSizeOffset + 3] = 0;
          }
          view[positionOffset] = position.x;
          view[positionOffset + 1] = position.y;
          view[positionOffset + 2] = position.z;
          view[positionOffset + 3] = light.type;
          const color = light.color;
          if (light.useColorTemperature) {
            const tempRGB = light.colorTemperatureRGB;
            view[colorOffset] = color.x * tempRGB.x;
            view[colorOffset + 1] = color.y * tempRGB.y;
            view[colorOffset + 2] = color.z * tempRGB.z;
          } else {
            view[colorOffset] = color.x;
            view[colorOffset + 1] = color.y;
            view[colorOffset + 2] = color.z;
          }
          view[colorOffset + 3] = data.isHDR ? luminanceHDR * exposure * lightMeterScale : luminanceLDR;
          index++;
        }
        view[3 * 4 + 3] = data.validPunctualLights.length;
        return buffer;
      }
      function buildClusterLightData(camera, pipeline) {
        validPunctualLightsCulling(pipeline, camera);
        const data = pipeline.pipelineSceneData;
        const validLightCountForBuffer = nextPow2(Math.max(data.validPunctualLights.length, 1));
        const lightBufferFloatNum = 20;
        const clusterLightBufferSize = validLightCountForBuffer * 4 * lightBufferFloatNum;
        const cameraID = getCameraUniqueID(camera);
        const clusterLightBufferName = `clusterLightBuffer${cameraID}`;
        const clusterGlobalIndexBufferName = `globalIndexBuffer${cameraID}`;
        const ppl = pipeline;
        if (!ppl.containsResource(clusterGlobalIndexBufferName)) {
          ppl.addStorageBuffer(clusterGlobalIndexBufferName, Format.UNKNOWN, 4, ResourceResidency.PERSISTENT);
        }
        if (!ppl.containsResource(clusterLightBufferName)) {
          ppl.addStorageBuffer(clusterLightBufferName, Format.UNKNOWN, clusterLightBufferSize, ResourceResidency.PERSISTENT);
        }
        ppl.updateStorageBuffer(clusterLightBufferName, clusterLightBufferSize);
        const buffer = buildLightBuffer(clusterLightBufferSize, lightBufferFloatNum, camera, pipeline);
        const globalIndexBuffer = new ArrayBuffer(4);
        const globalIndexBufferView = new Uint32Array(globalIndexBuffer);
        globalIndexBufferView[0] = 0;
        const uploadPair1 = new UploadPair(new Uint8Array(buffer), clusterLightBufferName);
        const uploadPair2 = new UploadPair(new Uint8Array(globalIndexBuffer), clusterGlobalIndexBufferName);
        ppl.addUploadPass([uploadPair1, uploadPair2]);
      }
      function buildClusterPasses(camera, pipeline) {
        buildClusterLightData(camera, pipeline);
        const ppl = pipeline;
        if (!_clusterLightData) _clusterLightData = new ClusterLightData();
        buildLightClusterBuildPass(camera, _clusterLightData, ppl);
        buildLightClusterCullingPass(camera, _clusterLightData, ppl);
      }

      function isUICamera(camera) {
        const scene = camera.scene;
        const batches = scene.batches;
        for (let i = 0; batches && i < batches.length; i++) {
          const batch = batches[i];
          if (camera.visibility & batch.visFlags) {
            return true;
          }
        }
        return false;
      }

      class CameraInfo {
        constructor(camera, id, windowID, width, height) {
          this.camera = void 0;
          this.id = 0xFFFFFFFF;
          this.windowID = 0xFFFFFFFF;
          this.width = 0;
          this.height = 0;
          this.camera = camera;
          this.id = id;
          this.windowID = windowID;
          this.width = width;
          this.height = height;
        }
      }
      const cameraInfos = new Map();
      const windowInfos = new Map();
      function prepareRenderWindow(camera) {
        let windowID = windowInfos.get(camera.window);
        if (windowID === undefined) {
          windowID = windowInfos.size;
          windowInfos.set(camera.window, windowID);
        }
        return windowID;
      }
      function prepareResource(ppl, camera, initResourceFunc, updateResourceFunc) {
        let info = cameraInfos.get(camera);
        if (info !== undefined) {
          camera.window.width;
          camera.window.height;
          prepareRenderWindow(camera);
          updateResourceFunc(ppl, info);
          return info;
        }
        const windowID = prepareRenderWindow(camera);
        info = new CameraInfo(camera, cameraInfos.size, windowID, camera.window.width ? camera.window.width : 1, camera.window.height ? camera.window.height : 1);
        initResourceFunc(ppl, info);
        cameraInfos.set(camera, info);
        return info;
      }
      function buildShadowRes(ppl, name, width, height) {
        const fboW = width;
        const fboH = height;
        const shadowMapName = name;
        const device = ppl.device;
        if (!ppl.containsResource(shadowMapName)) {
          const format = supportsR32FloatTexture(device) ? Format.R32F : Format.RGBA8;
          ppl.addRenderTarget(shadowMapName, format, fboW, fboH, ResourceResidency.MANAGED);
          ppl.addDepthStencil(`${shadowMapName}Depth`, Format.DEPTH_STENCIL, fboW, fboH, ResourceResidency.MANAGED);
        }
        ppl.updateRenderTarget(shadowMapName, fboW, fboH);
        ppl.updateDepthStencil(`${shadowMapName}Depth`, fboW, fboH);
      }
      const shadowInfo = new ShadowInfo();
      function setupShadowRes(ppl, cameraInfo) {
        const camera = cameraInfo.camera;
        validPunctualLightsCulling(ppl, camera);
        const pipeline = ppl;
        const shadow = pipeline.pipelineSceneData.shadows;
        const validPunctualLights = ppl.pipelineSceneData.validPunctualLights;
        const shadows = ppl.pipelineSceneData.shadows;
        shadowInfo.reset();
        if (!shadow.enabled || shadow.type !== ShadowType$2.ShadowMap) {
          return shadowInfo;
        }
        shadowInfo.shadowEnabled = true;
        const _validLights = shadowInfo.validLights;
        let n = 0;
        let m = 0;
        for (; n < shadow.maxReceived && m < validPunctualLights.length;) {
          const light = validPunctualLights[m];
          if (light.type === LightType$1.SPOT) {
            const spotLight = light;
            if (spotLight.shadowEnabled) {
              _validLights.push(light);
              n++;
            }
          }
          m++;
        }
        const {
          mainLight
        } = camera.scene;
        const mapWidth = shadows.size.x;
        const mapHeight = shadows.size.y;
        if (mainLight && mainLight.shadowEnabled) {
          shadowInfo.mainLightShadowNames[0] = `MainLightShadow${cameraInfo.id}`;
          if (mainLight.shadowFixedArea) {
            buildShadowRes(ppl, shadowInfo.mainLightShadowNames[0], mapWidth, mapHeight);
          } else {
            const csmLevel = pipeline.pipelineSceneData.csmSupported ? mainLight.csmLevel : 1;
            shadowInfo.mainLightShadowNames[0] = `MainLightShadow${cameraInfo.id}`;
            for (let i = 0; i < csmLevel; i++) {
              buildShadowRes(ppl, shadowInfo.mainLightShadowNames[0], mapWidth, mapHeight);
            }
          }
        }
        for (let l = 0; l < _validLights.length; l++) {
          _validLights[l];
          const passName = `SpotLightShadow${l.toString()}${cameraInfo.id}`;
          shadowInfo.spotLightShadowNames[l] = passName;
          buildShadowRes(ppl, shadowInfo.spotLightShadowNames[l], mapWidth, mapHeight);
        }
        return shadowInfo;
      }
      const updateShadowRes = setupShadowRes;
      let shadowPass;
      function buildShadowPass(passName, ppl, camera, light, level, width, height) {
        const fboW = width;
        const fboH = height;
        const area = getRenderArea(camera, width, height, light, level);
        width = area.width;
        height = area.height;
        const shadowMapName = passName;
        if (!level) {
          shadowPass = ppl.addRenderPass(width, height, 'default');
          shadowPass.name = passName;
          shadowPass.setViewport(new Viewport(0, 0, fboW, fboH));
          shadowPass.addRenderTarget(shadowMapName, LoadOp.CLEAR, StoreOp.STORE, new Color(1, 1, 1, camera.clearColor.w));
          shadowPass.addDepthStencil(`${shadowMapName}Depth`, LoadOp.CLEAR, StoreOp.DISCARD, camera.clearDepth, camera.clearStencil, ClearFlagBit.DEPTH_STENCIL);
        }
        const queue = shadowPass.addQueue(QueueHint.RENDER_OPAQUE, 'shadow-caster');
        queue.addSceneOfCamera(camera, new LightInfo(light, level), SceneFlags.SHADOW_CASTER);
        queue.setViewport(new Viewport(area.x, area.y, area.width, area.height));
      }
      function setupShadowPass(ppl, cameraInfo) {
        if (!shadowInfo.shadowEnabled) return;
        const camera = cameraInfo.camera;
        const shadows = ppl.pipelineSceneData.shadows;
        const mapWidth = shadows.size.x;
        const mapHeight = shadows.size.y;
        const {
          mainLight
        } = camera.scene;
        if (mainLight && mainLight.shadowEnabled) {
          shadowInfo.mainLightShadowNames[0] = `MainLightShadow${cameraInfo.id}`;
          if (mainLight.shadowFixedArea) {
            buildShadowPass(shadowInfo.mainLightShadowNames[0], ppl, camera, mainLight, 0, mapWidth, mapHeight);
          } else {
            const csmLevel = ppl.pipelineSceneData.csmSupported ? mainLight.csmLevel : 1;
            shadowInfo.mainLightShadowNames[0] = `MainLightShadow${cameraInfo.id}`;
            for (let i = 0; i < csmLevel; i++) {
              buildShadowPass(shadowInfo.mainLightShadowNames[0], ppl, camera, mainLight, i, mapWidth, mapHeight);
            }
          }
        }
        for (let l = 0; l < shadowInfo.validLights.length; l++) {
          const light = shadowInfo.validLights[l];
          const passName = `SpotLightShadow${l.toString()}${cameraInfo.id}`;
          shadowInfo.spotLightShadowNames[l] = passName;
          buildShadowPass(passName, ppl, camera, light, 0, mapWidth, mapHeight);
        }
      }
      function setupForwardRes(ppl, cameraInfo, isOffScreen = false) {
        const camera = cameraInfo.camera;
        const area = getRenderArea(camera, camera.window.width, camera.window.height);
        const width = area.width;
        const height = area.height;
        setupShadowRes(ppl, cameraInfo);
        if (!isOffScreen) {
          ppl.addRenderWindow(`ForwardColor${cameraInfo.id}`, Format.BGRA8, width, height, cameraInfo.camera.window);
        } else {
          ppl.addRenderTarget(`ForwardColor${cameraInfo.id}`, getRTFormatBeforeToneMapping(ppl), width, height, ResourceResidency.PERSISTENT);
        }
        ppl.addDepthStencil(`ForwardDepthStencil${cameraInfo.id}`, Format.DEPTH_STENCIL, width, height);
      }
      function updateForwardRes(ppl, cameraInfo, isOffScreen = false) {
        const camera = cameraInfo.camera;
        const area = getRenderArea(camera, camera.window.width, camera.window.height);
        const width = area.width;
        const height = area.height;
        updateShadowRes(ppl, cameraInfo);
        if (!isOffScreen) {
          ppl.updateRenderWindow(`ForwardColor${cameraInfo.id}`, cameraInfo.camera.window);
        } else {
          ppl.updateRenderTarget(`ForwardColor${cameraInfo.id}`, width, height);
        }
        ppl.updateDepthStencil(`ForwardDepthStencil${cameraInfo.id}`, width, height);
      }
      function setupDeferredForward(ppl, cameraInfo, inputColor) {
        const area = getRenderArea(cameraInfo.camera, cameraInfo.camera.window.width, cameraInfo.camera.window.height);
        const width = area.width;
        const height = area.height;
        const forwardPass = ppl.addRenderPass(width, height, 'default');
        const camera = cameraInfo.camera;
        forwardPass.addRenderTarget(inputColor, LoadOp.LOAD, StoreOp.STORE);
        forwardPass.addDepthStencil(gBufferInfo.ds, LoadOp.LOAD, StoreOp.DISCARD);
        for (const dirShadowName of shadowInfo.mainLightShadowNames) {
          if (ppl.containsResource(dirShadowName)) {
            forwardPass.addTexture(dirShadowName, 'cc_shadowMap');
          }
        }
        for (const spotShadowName of shadowInfo.spotLightShadowNames) {
          if (ppl.containsResource(spotShadowName)) {
            forwardPass.addTexture(spotShadowName, 'cc_spotShadowMap');
          }
        }
        forwardPass.addQueue(QueueHint.RENDER_OPAQUE, 'deferred-forward').addSceneOfCamera(camera, new LightInfo(), SceneFlags.OPAQUE_OBJECT | SceneFlags.PLANAR_SHADOW | SceneFlags.CUTOUT_OBJECT | SceneFlags.DEFAULT_LIGHTING | SceneFlags.DRAW_INSTANCING);
        forwardPass.addQueue(QueueHint.RENDER_TRANSPARENT, 'deferred-forward').addSceneOfCamera(camera, new LightInfo(), SceneFlags.TRANSPARENT_OBJECT | SceneFlags.GEOMETRY);
      }
      function setupForwardPass(ppl, cameraInfo, isOffScreen = false, enabledAlpha = true) {
        setupShadowPass(ppl, cameraInfo);
        const cameraID = cameraInfo.id;
        const area = getRenderArea(cameraInfo.camera, cameraInfo.camera.window.width, cameraInfo.camera.window.height);
        const width = area.width;
        const height = area.height;
        const forwardPass = ppl.addRenderPass(width, height, 'default');
        forwardPass.name = `ForwardPass${cameraID}`;
        forwardPass.setViewport(new Viewport(area.x, area.y, width, height));
        for (const dirShadowName of shadowInfo.mainLightShadowNames) {
          if (ppl.containsResource(dirShadowName)) {
            forwardPass.addTexture(dirShadowName, 'cc_shadowMap');
          }
        }
        for (const spotShadowName of shadowInfo.spotLightShadowNames) {
          if (ppl.containsResource(spotShadowName)) {
            forwardPass.addTexture(spotShadowName, 'cc_spotShadowMap');
          }
        }
        const camera = cameraInfo.camera;
        forwardPass.addRenderTarget(`ForwardColor${cameraInfo.id}`, isOffScreen ? LoadOp.CLEAR : getLoadOpOfClearFlag(camera.clearFlag, AttachmentType.RENDER_TARGET), StoreOp.STORE, new Color(camera.clearColor.x, camera.clearColor.y, camera.clearColor.z, camera.clearColor.w));
        forwardPass.addDepthStencil(`ForwardDepthStencil${cameraInfo.id}`, isOffScreen ? LoadOp.CLEAR : getLoadOpOfClearFlag(camera.clearFlag, AttachmentType.DEPTH_STENCIL), isOffScreen ? StoreOp.DISCARD : StoreOp.STORE, camera.clearDepth, camera.clearStencil, camera.clearFlag);
        forwardPass.addQueue(QueueHint.RENDER_OPAQUE).addSceneOfCamera(camera, new LightInfo(), SceneFlags.OPAQUE_OBJECT | SceneFlags.PLANAR_SHADOW | SceneFlags.CUTOUT_OBJECT | SceneFlags.DEFAULT_LIGHTING | SceneFlags.DRAW_INSTANCING);
        let sceneFlags = SceneFlags.TRANSPARENT_OBJECT | SceneFlags.GEOMETRY;
        if (!isOffScreen) {
          sceneFlags |= SceneFlags.UI;
          forwardPass.showStatistics = true;
        }
        if (enabledAlpha) {
          forwardPass.addQueue(QueueHint.RENDER_TRANSPARENT).addSceneOfCamera(camera, new LightInfo(), sceneFlags);
        }
        return {
          rtName: `ForwardColor${cameraInfo.id}`,
          dsName: `ForwardDepthStencil${cameraInfo.id}`
        };
      }
      const gBufferInfo = new GBufferInfo();
      function setupGBufferRes(ppl, info) {
        const camera = info.camera;
        const area = getRenderArea(camera, camera.window.width, camera.window.height);
        const width = area.width;
        const height = area.height;
        const gBufferPassRTName = `gBufferPassColorCamera${info.id}`;
        const gBufferPassNormal = `gBufferPassNormal${info.id}`;
        const gBufferPassEmissive = `gBufferPassEmissive${info.id}`;
        const gBufferPassDSName = `gBufferPassDSCamera${info.id}`;
        const colFormat = Format.RGBA16F;
        ppl.addRenderTarget(gBufferPassRTName, colFormat, width, height, ResourceResidency.MANAGED);
        ppl.addRenderTarget(gBufferPassEmissive, colFormat, width, height, ResourceResidency.MANAGED);
        ppl.addRenderTarget(gBufferPassNormal, colFormat, width, height, ResourceResidency.MANAGED);
        ppl.addDepthStencil(gBufferPassDSName, Format.DEPTH_STENCIL, width, height, ResourceResidency.MANAGED);
        gBufferInfo.color = gBufferPassRTName;
        gBufferInfo.normal = gBufferPassNormal;
        gBufferInfo.emissive = gBufferPassEmissive;
        gBufferInfo.ds = gBufferPassDSName;
      }
      function updateGBufferRes(ppl, info) {
        const camera = info.camera;
        const area = getRenderArea(camera, camera.window.width, camera.window.height);
        const width = area.width;
        const height = area.height;
        const gBufferPassRTName = `gBufferPassColorCamera${info.id}`;
        const gBufferPassNormal = `gBufferPassNormal${info.id}`;
        const gBufferPassEmissive = `gBufferPassEmissive${info.id}`;
        const gBufferPassDSName = `gBufferPassDSCamera${info.id}`;
        ppl.updateRenderTarget(gBufferPassRTName, width, height);
        ppl.updateRenderTarget(gBufferPassEmissive, width, height);
        ppl.updateRenderTarget(gBufferPassNormal, width, height);
        ppl.updateDepthStencil(gBufferPassDSName, width, height);
      }
      new Color(0, 0, 0, 0);
      function setupGBufferPass(ppl, info) {
        const camera = info.camera;
        const area = getRenderArea(camera, camera.window.width, camera.window.height);
        const width = area.width;
        const height = area.height;
        const gBufferPassRTName = gBufferInfo.color;
        const gBufferPassNormal = gBufferInfo.normal;
        const gBufferPassEmissive = gBufferInfo.emissive;
        const gBufferPassDSName = gBufferInfo.ds;
        const gBufferPass = ppl.addRenderPass(width, height, 'gbuffer');
        gBufferPass.name = `CameraGBufferPass${info.id}`;
        gBufferPass.setViewport(new Viewport(area.x, area.y, width, height));
        const rtColor = new Color(0, 0, 0, 0);
        if (camera.clearFlag & ClearFlagBit.COLOR) {
          if (ppl.pipelineSceneData.isHDR) {
            SRGBToLinear(rtColor, camera.clearColor);
          } else {
            rtColor.x = camera.clearColor.x;
            rtColor.y = camera.clearColor.y;
            rtColor.z = camera.clearColor.z;
          }
        }
        gBufferPass.addRenderTarget(gBufferPassRTName, LoadOp.CLEAR, StoreOp.STORE, rtColor);
        gBufferPass.addRenderTarget(gBufferPassEmissive, LoadOp.CLEAR, StoreOp.STORE, new Color(0, 0, 0, 0));
        gBufferPass.addRenderTarget(gBufferPassNormal, LoadOp.CLEAR, StoreOp.STORE, new Color(0, 0, 0, 0));
        gBufferPass.addDepthStencil(gBufferPassDSName, LoadOp.CLEAR, StoreOp.STORE, camera.clearDepth, camera.clearStencil, camera.clearFlag);
        gBufferPass.addQueue(QueueHint.RENDER_OPAQUE, 'gbuffer').addSceneOfCamera(camera, new LightInfo(), SceneFlags.OPAQUE_OBJECT | SceneFlags.CUTOUT_OBJECT);
        return gBufferPass;
      }
      function setupLightingRes(ppl, info) {
        setupShadowRes(ppl, info);
        const camera = info.camera;
        const area = getRenderArea(camera, camera.window.width, camera.window.height);
        const width = area.width;
        const height = area.height;
        const deferredLightingPassRTName = `deferredLightingPassRTName${info.id}`;
        ppl.addRenderTarget(deferredLightingPassRTName, Format.RGBA8, width, height, ResourceResidency.MANAGED);
      }
      function updateLightingRes(ppl, info) {
        updateShadowRes(ppl, info);
        const camera = info.camera;
        const area = getRenderArea(camera, camera.window.width, camera.window.height);
        const width = area.width;
        const height = area.height;
        const deferredLightingPassRTName = `deferredLightingPassRTName${info.id}`;
        ppl.updateRenderTarget(deferredLightingPassRTName, width, height);
      }
      let lightingInfo;
      function setupLightingPass(pipeline, info, useCluster) {
        setupShadowPass(pipeline, info);
        if (!lightingInfo) {
          lightingInfo = new LightingInfo(useCluster);
        }
        const ppl = pipeline;
        const camera = info.camera;
        const area = getRenderArea(camera, camera.window.width, camera.window.height);
        const width = area.width;
        const height = area.height;
        const cameraID = getCameraUniqueID(camera);
        const deferredLightingPassRTName = `deferredLightingPassRTName${info.id}`;
        const lightingPass = ppl.addRenderPass(width, height, 'deferred-lighting');
        lightingPass.name = `CameraLightingPass${info.id}`;
        lightingPass.setViewport(new Viewport(area.x, area.y, width, height));
        for (const dirShadowName of shadowInfo.mainLightShadowNames) {
          if (ppl.containsResource(dirShadowName)) {
            lightingPass.addTexture(dirShadowName, 'cc_shadowMap');
          }
        }
        for (const spotShadowName of shadowInfo.spotLightShadowNames) {
          if (ppl.containsResource(spotShadowName)) {
            lightingPass.addTexture(spotShadowName, 'cc_spotShadowMap');
          }
        }
        if (ppl.containsResource(gBufferInfo.color)) {
          lightingPass.addTexture(gBufferInfo.color, 'albedoMap');
          lightingPass.addTexture(gBufferInfo.normal, 'normalMap');
          lightingPass.addTexture(gBufferInfo.emissive, 'emissiveMap');
          lightingPass.addTexture(gBufferInfo.ds, 'depthStencil');
        }
        const clusterLightBufferName = `clusterLightBuffer${cameraID}`;
        const clusterLightIndicesBufferName = `clusterLightIndicesBuffer${cameraID}`;
        const clusterLightGridBufferName = `clusterLightGridBuffer${cameraID}`;
        if (ppl.containsResource(clusterLightBufferName)) {
          lightingPass.addStorageBuffer(clusterLightBufferName, AccessType.READ, 'b_ccLightsBuffer');
          lightingPass.addStorageBuffer(clusterLightIndicesBufferName, AccessType.READ, 'b_clusterLightIndicesBuffer');
          lightingPass.addStorageBuffer(clusterLightGridBufferName, AccessType.READ, 'b_clusterLightGridBuffer');
        }
        const lightingClearColor = new Color(0, 0, 0, 0);
        if (camera.clearFlag & ClearFlagBit.COLOR) {
          lightingClearColor.x = camera.clearColor.x;
          lightingClearColor.y = camera.clearColor.y;
          lightingClearColor.z = camera.clearColor.z;
        }
        lightingClearColor.w = 0;
        lightingPass.addRenderTarget(deferredLightingPassRTName, LoadOp.CLEAR, StoreOp.STORE, lightingClearColor);
        lightingPass.addQueue(QueueHint.RENDER_TRANSPARENT).addCameraQuad(camera, lightingInfo.deferredLightingMaterial, 0, SceneFlags.VOLUMETRIC_LIGHTING);
        return {
          rtName: deferredLightingPassRTName
        };
      }
      function setupPostprocessRes(ppl, info) {
        const cameraID = info.id;
        const camera = info.camera;
        const area = getRenderArea(camera, camera.window.width, camera.window.height);
        const width = area.width;
        const height = area.height;
        const postprocessPassRTName = `postprocessPassRTName${cameraID}`;
        const postprocessPassDS = `postprocessPassDS${cameraID}`;
        ppl.addRenderWindow(postprocessPassRTName, Format.BGRA8, width, height, camera.window);
        ppl.addDepthStencil(postprocessPassDS, Format.DEPTH_STENCIL, width, height, ResourceResidency.MANAGED);
      }
      function updatePostprocessRes(ppl, info) {
        const cameraID = info.id;
        const camera = info.camera;
        const area = getRenderArea(camera, camera.window.width, camera.window.height);
        const width = area.width;
        const height = area.height;
        const postprocessPassRTName = `postprocessPassRTName${cameraID}`;
        const postprocessPassDS = `postprocessPassDS${cameraID}`;
        ppl.updateRenderWindow(postprocessPassRTName, camera.window);
        ppl.updateDepthStencil(postprocessPassDS, width, height);
      }
      let postInfo;
      function setupPostprocessPass(ppl, info, inputTex) {
        if (!postInfo) {
          postInfo = new PostInfo();
        }
        const cameraID = info.id;
        const camera = info.camera;
        const area = getRenderArea(camera, camera.window.width, camera.window.height);
        const width = area.width;
        const height = area.height;
        const postprocessPassRTName = `postprocessPassRTName${cameraID}`;
        const postprocessPassDS = `postprocessPassDS${cameraID}`;
        const postprocessPass = ppl.addRenderPass(width, height, 'post-process');
        postprocessPass.name = `CameraPostprocessPass${cameraID}`;
        postprocessPass.setViewport(new Viewport(area.x, area.y, area.width, area.height));
        if (ppl.containsResource(inputTex)) {
          postprocessPass.addTexture(inputTex, 'outputResultMap');
        }
        const postClearColor = new Color(0, 0, 0, camera.clearColor.w);
        if (camera.clearFlag & ClearFlagBit.COLOR) {
          postClearColor.x = camera.clearColor.x;
          postClearColor.y = camera.clearColor.y;
          postClearColor.z = camera.clearColor.z;
        }
        postprocessPass.addRenderTarget(postprocessPassRTName, getLoadOpOfClearFlag(camera.clearFlag, AttachmentType.RENDER_TARGET), StoreOp.STORE, postClearColor);
        postprocessPass.addDepthStencil(postprocessPassDS, getLoadOpOfClearFlag(camera.clearFlag, AttachmentType.DEPTH_STENCIL), StoreOp.STORE, camera.clearDepth, camera.clearStencil, camera.clearFlag);
        postprocessPass.addQueue(QueueHint.NONE).addCameraQuad(camera, postInfo.postMaterial, 0, SceneFlags.NONE);
        if (getProfilerCamera() === camera) {
          postprocessPass.showStatistics = true;
        }
        return {
          rtName: postprocessPassRTName,
          dsName: postprocessPassDS
        };
      }
      function setupUIRes(ppl, info) {
        const camera = info.camera;
        const area = getRenderArea(camera, camera.window.width, camera.window.height);
        const width = area.width;
        const height = area.height;
        const dsUIAndProfilerPassRTName = `dsUIAndProfilerPassColor${info.id}`;
        const dsUIAndProfilerPassDSName = `dsUIAndProfilerPassDS${info.id}`;
        ppl.addRenderWindow(dsUIAndProfilerPassRTName, Format.BGRA8, width, height, camera.window);
        ppl.addDepthStencil(dsUIAndProfilerPassDSName, Format.DEPTH_STENCIL, width, height, ResourceResidency.MANAGED);
      }
      function updateUIRes(ppl, info) {
        const camera = info.camera;
        const area = getRenderArea(camera, camera.window.width, camera.window.height);
        const width = area.width;
        const height = area.height;
        const dsUIAndProfilerPassRTName = `dsUIAndProfilerPassColor${info.id}`;
        const dsUIAndProfilerPassDSName = `dsUIAndProfilerPassDS${info.id}`;
        ppl.updateRenderWindow(dsUIAndProfilerPassRTName, camera.window);
        ppl.updateDepthStencil(dsUIAndProfilerPassDSName, width, height);
      }
      function setupUIPass(ppl, info) {
        const camera = info.camera;
        const area = getRenderArea(camera, camera.window.width, camera.window.height);
        const width = area.width;
        const height = area.height;
        const dsUIAndProfilerPassRTName = `dsUIAndProfilerPassColor${info.id}`;
        const dsUIAndProfilerPassDSName = `dsUIAndProfilerPassDS${info.id}`;
        const uiAndProfilerPass = ppl.addRenderPass(width, height, 'default');
        uiAndProfilerPass.name = `CameraUIAndProfilerPass${info.id}`;
        uiAndProfilerPass.setViewport(new Viewport(area.x, area.y, width, height));
        uiAndProfilerPass.addRenderTarget(dsUIAndProfilerPassRTName, getLoadOpOfClearFlag(camera.clearFlag, AttachmentType.RENDER_TARGET), StoreOp.STORE, new Color(camera.clearColor.x, camera.clearColor.y, camera.clearColor.z, camera.clearColor.w));
        uiAndProfilerPass.addDepthStencil(dsUIAndProfilerPassDSName, getLoadOpOfClearFlag(camera.clearFlag, AttachmentType.DEPTH_STENCIL), StoreOp.STORE, camera.clearDepth, camera.clearStencil, camera.clearFlag);
        const sceneFlags = SceneFlags.UI;
        uiAndProfilerPass.addQueue(QueueHint.RENDER_TRANSPARENT).addSceneOfCamera(camera, new LightInfo(), sceneFlags);
        if (getProfilerCamera() === camera) {
          uiAndProfilerPass.showStatistics = true;
        }
      }

      class ForwardPipelineBuilder {
        setup(cameras, ppl) {
          for (let i = 0; i < cameras.length; i++) {
            const camera = cameras[i];
            if (camera.scene === null) {
              continue;
            }
            ppl.update(camera);
            const info = prepareResource(ppl, camera, this.initResource, this.updateResource);
            setupForwardPass(ppl, info);
          }
        }
        initResource(ppl, cameraInfo) {
          setupForwardRes(ppl, cameraInfo);
        }
        updateResource(ppl, cameraInfo) {
          updateForwardRes(ppl, cameraInfo);
        }
      } exports('ForwardPipelineBuilder', ForwardPipelineBuilder);
      class DeferredPipelineBuilder {
        setup(cameras, ppl) {
          for (let i = 0; i < cameras.length; ++i) {
            const camera = cameras[i];
            if (!camera.scene) {
              continue;
            }
            ppl.update(camera);
            const useCluster = ppl.device.hasFeature(Feature.COMPUTE_SHADER);
            const isGameView = camera.cameraUsage === CameraUsage.GAME || camera.cameraUsage === CameraUsage.GAME_VIEW;
            const info = prepareResource(ppl, camera, this.initResource, this.updateResource);
            if (!isGameView) {
              setupForwardPass(ppl, info);
              continue;
            }
            if (!isUICamera(camera)) {
              if (useCluster) {
                buildClusterPasses(camera, ppl);
              }
              setupGBufferPass(ppl, info);
              const lightInfo = setupLightingPass(ppl, info, useCluster);
              setupDeferredForward(ppl, info, lightInfo.rtName);
              setupPostprocessPass(ppl, info, lightInfo.rtName);
              continue;
            }
            setupUIPass(ppl, info);
          }
        }
        initResource(ppl, cameraInfo) {
          if (!isUICamera(cameraInfo.camera)) {
            setupGBufferRes(ppl, cameraInfo);
            setupLightingRes(ppl, cameraInfo);
            setupPostprocessRes(ppl, cameraInfo);
          } else {
            setupUIRes(ppl, cameraInfo);
          }
        }
        updateResource(ppl, cameraInfo) {
          if (!isUICamera(cameraInfo.camera)) {
            updateGBufferRes(ppl, cameraInfo);
            updateLightingRes(ppl, cameraInfo);
            updatePostprocessRes(ppl, cameraInfo);
          } else {
            updateUIRes(ppl, cameraInfo);
          }
        }
      } exports('DeferredPipelineBuilder', DeferredPipelineBuilder);

      const Destroyed = CCObject.Flags.Destroyed;
      const PersistentMask = CCObject.Flags.PersistentMask;
      const objsToClearTmpVar = [];
      function hasImplementedInstantiate(original) {
        return typeof original._instantiate === 'function';
      }
      function instantiate(original, internalForce) {
        let clone;
        if (isCCObject(original)) {
          if (hasImplementedInstantiate(original)) {
            legacyCC.game._isCloning = true;
            clone = original._instantiate(null, true);
            legacyCC.game._isCloning = false;
            {
              updateChildrenForDeserialize(clone);
            }
            return clone;
          } else if (original instanceof legacyCC.Asset) {
            throw new TypeError(getError(6903));
          }
        }
        legacyCC.game._isCloning = true;
        clone = doInstantiate(original);
        legacyCC.game._isCloning = false;
        {
          updateChildrenForDeserialize(clone);
        }
        return clone;
      }
      function doInstantiate(obj, parent) {
        let clone;
        if (obj._iN$t) {
          clone = obj._iN$t;
        } else if (obj.constructor) {
          const Klass = obj.constructor;
          clone = new Klass();
        } else {
          clone = Object.create(null);
        }
        enumerateObject(obj, clone, parent);
        for (let i = 0, len = objsToClearTmpVar.length; i < len; ++i) {
          objsToClearTmpVar[i]._iN$t = null;
        }
        objsToClearTmpVar.length = 0;
        return clone;
      }
      function enumerateCCClass(klass, obj, clone, parent) {
        const props = klass.__values__;
        for (let p = 0; p < props.length; p++) {
          const key = props[p];
          const value = obj[key];
          if (typeof value === 'object' && value) {
            const initValue = clone[key];
            if (initValue instanceof ValueType && initValue.constructor === value.constructor) {
              initValue.set(value);
            } else {
              clone[key] = value._iN$t || instantiateObj(value, parent);
            }
          } else {
            clone[key] = value;
          }
        }
      }
      function enumerateObject(obj, clone, parent) {
        value(obj, '_iN$t', clone, true);
        objsToClearTmpVar.push(obj);
        const klass = obj.constructor;
        if (isCCClassOrFastDefined(klass)) {
          enumerateCCClass(klass, obj, clone, parent);
        } else {
          for (const key in obj) {
            if (!obj.hasOwnProperty(key) || key.charCodeAt(0) === 95 && key.charCodeAt(1) === 95 && key !== '__type__' && key !== '__prefab') {
              continue;
            }
            const value = obj[key];
            if (typeof value === 'object' && value) {
              if (value === clone) {
                continue;
              }
              clone[key] = value._iN$t || instantiateObj(value, parent);
            } else {
              clone[key] = value;
            }
          }
        }
        if (isCCObject(obj)) {
          clone._objFlags &= PersistentMask;
        }
      }
      function instantiateObj(obj, parent) {
        if (obj instanceof ValueType) {
          return obj.clone();
        }
        if (obj instanceof legacyCC.Asset) {
          return obj;
        }
        let clone;
        if (ArrayBuffer.isView(obj)) {
          const len = obj.length;
          clone = new obj.constructor(len);
          obj._iN$t = clone;
          objsToClearTmpVar.push(obj);
          for (let i = 0; i < len; ++i) {
            clone[i] = obj[i];
          }
          return clone;
        }
        if (Array.isArray(obj)) {
          const len = obj.length;
          clone = new Array(len);
          obj._iN$t = clone;
          objsToClearTmpVar.push(obj);
          for (let i = 0; i < len; ++i) {
            const value = obj[i];
            if (typeof value === 'object' && value) {
              clone[i] = value._iN$t || instantiateObj(value, parent);
            } else {
              clone[i] = value;
            }
          }
          return clone;
        } else if (obj._objFlags & Destroyed) {
          return null;
        }
        const ctor = obj.constructor;
        if (isCCClassOrFastDefined(ctor)) {
          if (parent) {
            if (parent instanceof Component) {
              if (obj instanceof Node$1 || obj instanceof Component) {
                return obj;
              }
            } else if (parent instanceof Node$1) {
              if (obj instanceof Node$1) {
                if (!obj.isChildOf(parent)) {
                  return obj;
                }
              } else if (obj instanceof Component) {
                if (obj.node && !obj.node.isChildOf(parent)) {
                  return obj;
                }
              }
            }
          }
          clone = new ctor();
        } else if (ctor === Object) {
          clone = {};
        } else if (!ctor) {
          clone = Object.create(null);
        } else {
          return obj;
        }
        enumerateObject(obj, clone, parent);
        return clone;
      }
      instantiate._clone = doInstantiate;
      legacyCC.instantiate = instantiate;

      class NodePool {
        constructor(poolHandlerComp) {
          this.poolHandlerComp = void 0;
          this._pool = void 0;
          this.poolHandlerComp = poolHandlerComp;
          this._pool = [];
        }
        size() {
          return this._pool.length;
        }
        clear() {
          const count = this._pool.length;
          for (let i = 0; i < count; ++i) {
            this._pool[i].destroy();
          }
          this._pool.length = 0;
        }
        put(obj) {
          if (obj && this._pool.indexOf(obj) === -1) {
            obj.removeFromParent();
            const handler = this.poolHandlerComp ? obj.getComponent(this.poolHandlerComp) : null;
            if (handler && handler.unuse) {
              handler.unuse();
            }
            this._pool.push(obj);
          }
        }
        get(...args) {
          const last = this._pool.length - 1;
          if (last < 0) {
            return null;
          } else {
            const obj = this._pool[last];
            this._pool.length = last;
            const handler = this.poolHandlerComp ? obj.getComponent(this.poolHandlerComp) : null;
            if (handler && handler.reuse) {
              handler.reuse(arguments);
            }
            return obj;
          }
        }
      } exports('NodePool', NodePool);
      legacyCC.NodePool = NodePool;

      var _globalThis$jsb, _globalJsb$copyTextTo;
      const globalJsb = (_globalThis$jsb = globalThis.jsb) !== null && _globalThis$jsb !== void 0 ? _globalThis$jsb : {};
      {
        Object.defineProperty(globalJsb, 'reflection', {
          get() {
            if (globalJsb.__bridge !== undefined) return globalJsb.__bridge;
            if (globalThis.JavascriptJavaBridge && (sys.os === sys.OS.ANDROID || sys.os === sys.OS.OHOS)) {
              globalJsb.__bridge = new globalThis.JavascriptJavaBridge();
            } else if (globalThis.JavaScriptObjCBridge && (sys.os === sys.OS.IOS || sys.os === sys.OS.OSX)) {
              globalJsb.__bridge = new globalThis.JavaScriptObjCBridge();
            } else {
              globalJsb.__bridge = null;
            }
            return globalJsb.__bridge;
          },
          enumerable: true,
          configurable: true,
          set(value) {
            globalJsb.__bridge = value;
          }
        });
        Object.defineProperty(globalJsb, 'bridge', {
          get() {
            if (globalJsb.__ccbridge !== undefined) return globalJsb.__ccbridge;
            if (globalThis.ScriptNativeBridge && sys.os === sys.OS.ANDROID || sys.os === sys.OS.IOS || sys.os === sys.OS.OSX || sys.os === sys.OS.OHOS) {
              globalJsb.__ccbridge = new ScriptNativeBridge();
            } else {
              globalJsb.__ccbridge = null;
            }
            return globalJsb.__ccbridge;
          },
          enumerable: true,
          configurable: true,
          set(value) {
            globalJsb.__ccbridge = value;
          }
        });
        const JsbBridgeWrapper = {
          eventMap: new Map(),
          addNativeEventListener(eventName, listener) {
            if (!this.eventMap.get(eventName)) {
              this.eventMap.set(eventName, []);
            }
            const arr = this.eventMap.get(eventName);
            if (!arr.find(listener)) {
              arr.push(listener);
            }
          },
          dispatchEventToNative(eventName, arg) {
            globalJsb.bridge.sendToNative(eventName, arg);
          },
          removeAllListenersForEvent(eventName) {
            return this.eventMap.delete(eventName);
          },
          removeNativeEventListener(eventName, listener) {
            const arr = this.eventMap.get(eventName);
            if (!arr) {
              return false;
            }
            for (let i = 0, l = arr.length; i < l; i++) {
              if (arr[i] === listener) {
                arr.splice(i, 1);
                return true;
              }
            }
            return true;
          },
          removeAllListeners() {
            this.eventMap.clear();
          },
          triggerEvent(eventName, arg) {
            const arr = this.eventMap.get(eventName);
            if (!arr) {
              console.error(`${eventName} does not exist`);
              return;
            }
            arr.map(listener => listener.call(null, arg));
          }
        };
        Object.defineProperty(globalJsb, 'jsbBridgeWrapper', {
          get() {
            if (globalJsb.__JsbBridgeWrapper !== undefined) return globalJsb.__JsbBridgeWrapper;
            if (globalThis.ScriptNativeBridge && sys.os === sys.OS.ANDROID || sys.os === sys.OS.IOS || sys.os === sys.OS.OSX || sys.os === sys.OS.OHOS) {
              globalJsb.__JsbBridgeWrapper = JsbBridgeWrapper;
              globalJsb.bridge.onNative = (methodName, arg1) => {
                globalJsb.__JsbBridgeWrapper.triggerEvent(methodName, arg1);
              };
            } else {
              globalJsb.__JsbBridgeWrapper = null;
            }
            return globalJsb.__JsbBridgeWrapper;
          },
          enumerable: true,
          configurable: true,
          set(value) {
            globalJsb.__JsbBridgeWrapper = value;
          }
        });
        const originSaveImageData = globalJsb.saveImageData;
        globalJsb.saveImageData = (data, width, height, filePath) => {
          return new Promise((resolve, reject) => {
            originSaveImageData(data, width, height, filePath, isSuccess => {
              if (isSuccess) {
                resolve();
              } else {
                reject();
              }
            });
          });
        };
      }
      const native = exports('native', {
        DownloaderHints: globalJsb.DownloaderHints,
        Downloader: globalJsb.Downloader,
        zipUtils: globalJsb.zipUtils,
        fileUtils: globalJsb.fileUtils,
        DebugRenderer: globalJsb.DebugRenderer,
        copyTextToClipboard: (_globalJsb$copyTextTo = globalJsb.copyTextToClipboard) === null || _globalJsb$copyTextTo === void 0 ? void 0 : _globalJsb$copyTextTo.bind(globalJsb),
        garbageCollect: globalJsb.garbageCollect,
        reflection: globalJsb.reflection,
        bridge: globalJsb.bridge,
        jsbBridgeWrapper: globalJsb.jsbBridgeWrapper,
        AssetsManager: globalJsb.AssetsManager,
        EventAssetsManager: globalJsb.EventAssetsManager,
        Manifest: globalJsb.Manifest,
        saveImageData: globalJsb.saveImageData,
        process: globalJsb.process
      });

      legacyCC.renderer = renderer;

      class WebGLDescriptorSet extends DescriptorSet {
        constructor(...args) {
          super(...args);
          this._gpuDescriptorSet = null;
        }
        get gpuDescriptorSet() {
          return this._gpuDescriptorSet;
        }
        initialize(info) {
          this._layout = info.layout;
          const {
            bindings,
            descriptorIndices,
            descriptorCount
          } = info.layout.gpuDescriptorSetLayout;
          this._buffers = Array(descriptorCount).fill(null);
          this._textures = Array(descriptorCount).fill(null);
          this._samplers = Array(descriptorCount).fill(null);
          const gpuDescriptors = [];
          this._gpuDescriptorSet = {
            gpuDescriptors,
            descriptorIndices
          };
          for (let i = 0; i < bindings.length; ++i) {
            const binding = bindings[i];
            for (let j = 0; j < binding.count; j++) {
              gpuDescriptors.push({
                type: binding.descriptorType,
                gpuBuffer: null,
                gpuTexture: null,
                gpuSampler: null
              });
            }
          }
        }
        destroy() {
          this._layout = null;
          this._gpuDescriptorSet = null;
        }
        update() {
          if (this._isDirty && this._gpuDescriptorSet) {
            const descriptors = this._gpuDescriptorSet.gpuDescriptors;
            for (let i = 0; i < descriptors.length; ++i) {
              if (descriptors[i].type & DESCRIPTOR_BUFFER_TYPE) {
                const buffer = this._buffers[i];
                if (buffer) {
                  descriptors[i].gpuBuffer = buffer.gpuBuffer || buffer.gpuBufferView;
                }
              } else if (descriptors[i].type & DESCRIPTOR_SAMPLER_TYPE) {
                if (this._textures[i]) {
                  descriptors[i].gpuTexture = this._textures[i].gpuTexture;
                }
                if (this._samplers[i]) {
                  descriptors[i].gpuSampler = this._samplers[i].gpuSampler;
                }
              }
            }
            this._isDirty = false;
          }
        }
      }

      let WebGLEXT;
      (function (WebGLEXT) {
        WebGLEXT[WebGLEXT["RGBA16F_EXT"] = 34842] = "RGBA16F_EXT";
        WebGLEXT[WebGLEXT["RGB16F_EXT"] = 34843] = "RGB16F_EXT";
        WebGLEXT[WebGLEXT["RGBA32F_EXT"] = 34836] = "RGBA32F_EXT";
        WebGLEXT[WebGLEXT["FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT"] = 33297] = "FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT";
        WebGLEXT[WebGLEXT["UNSIGNED_NORMALIZED_EXT"] = 35863] = "UNSIGNED_NORMALIZED_EXT";
        WebGLEXT[WebGLEXT["UNSIGNED_INT_24_8_WEBGL"] = 34042] = "UNSIGNED_INT_24_8_WEBGL";
        WebGLEXT[WebGLEXT["HALF_FLOAT_OES"] = 36193] = "HALF_FLOAT_OES";
        WebGLEXT[WebGLEXT["SRGB_EXT"] = 35904] = "SRGB_EXT";
        WebGLEXT[WebGLEXT["SRGB_ALPHA_EXT"] = 35906] = "SRGB_ALPHA_EXT";
        WebGLEXT[WebGLEXT["SRGB8_ALPHA8_EXT"] = 35907] = "SRGB8_ALPHA8_EXT";
        WebGLEXT[WebGLEXT["COMPRESSED_RGB_S3TC_DXT1_EXT"] = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT";
        WebGLEXT[WebGLEXT["COMPRESSED_RGBA_S3TC_DXT1_EXT"] = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT";
        WebGLEXT[WebGLEXT["COMPRESSED_RGBA_S3TC_DXT3_EXT"] = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT";
        WebGLEXT[WebGLEXT["COMPRESSED_RGBA_S3TC_DXT5_EXT"] = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT";
        WebGLEXT[WebGLEXT["COMPRESSED_SRGB_S3TC_DXT1_EXT"] = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT";
        WebGLEXT[WebGLEXT["COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT"] = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT";
        WebGLEXT[WebGLEXT["COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT"] = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT";
        WebGLEXT[WebGLEXT["COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT"] = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT";
        WebGLEXT[WebGLEXT["COMPRESSED_RGB_PVRTC_4BPPV1_IMG"] = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG";
        WebGLEXT[WebGLEXT["COMPRESSED_RGB_PVRTC_2BPPV1_IMG"] = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG";
        WebGLEXT[WebGLEXT["COMPRESSED_RGBA_PVRTC_4BPPV1_IMG"] = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG";
        WebGLEXT[WebGLEXT["COMPRESSED_RGBA_PVRTC_2BPPV1_IMG"] = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG";
        WebGLEXT[WebGLEXT["COMPRESSED_RGB_ETC1_WEBGL"] = 36196] = "COMPRESSED_RGB_ETC1_WEBGL";
        WebGLEXT[WebGLEXT["COMPRESSED_R11_EAC"] = 37488] = "COMPRESSED_R11_EAC";
        WebGLEXT[WebGLEXT["COMPRESSED_SIGNED_R11_EAC"] = 37489] = "COMPRESSED_SIGNED_R11_EAC";
        WebGLEXT[WebGLEXT["COMPRESSED_RG11_EAC"] = 37490] = "COMPRESSED_RG11_EAC";
        WebGLEXT[WebGLEXT["COMPRESSED_SIGNED_RG11_EAC"] = 37491] = "COMPRESSED_SIGNED_RG11_EAC";
        WebGLEXT[WebGLEXT["COMPRESSED_RGB8_ETC2"] = 37492] = "COMPRESSED_RGB8_ETC2";
        WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ETC2"] = 37493] = "COMPRESSED_SRGB8_ETC2";
        WebGLEXT[WebGLEXT["COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37494] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2";
        WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37495] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2";
        WebGLEXT[WebGLEXT["COMPRESSED_RGBA8_ETC2_EAC"] = 37496] = "COMPRESSED_RGBA8_ETC2_EAC";
        WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ETC2_EAC"] = 37497] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC";
        WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_4x4_KHR"] = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_5x4_KHR"] = 37809] = "COMPRESSED_RGBA_ASTC_5x4_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_5x5_KHR"] = 37810] = "COMPRESSED_RGBA_ASTC_5x5_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_6x5_KHR"] = 37811] = "COMPRESSED_RGBA_ASTC_6x5_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_6x6_KHR"] = 37812] = "COMPRESSED_RGBA_ASTC_6x6_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_8x5_KHR"] = 37813] = "COMPRESSED_RGBA_ASTC_8x5_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_8x6_KHR"] = 37814] = "COMPRESSED_RGBA_ASTC_8x6_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_8x8_KHR"] = 37815] = "COMPRESSED_RGBA_ASTC_8x8_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_10x5_KHR"] = 37816] = "COMPRESSED_RGBA_ASTC_10x5_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_10x6_KHR"] = 37817] = "COMPRESSED_RGBA_ASTC_10x6_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_10x8_KHR"] = 37818] = "COMPRESSED_RGBA_ASTC_10x8_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_10x10_KHR"] = 37819] = "COMPRESSED_RGBA_ASTC_10x10_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_12x10_KHR"] = 37820] = "COMPRESSED_RGBA_ASTC_12x10_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_12x12_KHR"] = 37821] = "COMPRESSED_RGBA_ASTC_12x12_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR"] = 37840] = "COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR"] = 37841] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR"] = 37842] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR"] = 37843] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR"] = 37844] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR"] = 37845] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR"] = 37846] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR"] = 37847] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR"] = 37848] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR"] = 37849] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR"] = 37850] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR"] = 37851] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR"] = 37852] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR"] = 37853] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR";
      })(WebGLEXT || (WebGLEXT = {}));
      class WebGLDeviceManager {
        static get instance() {
          return WebGLDeviceManager._instance;
        }
        static setInstance(instance) {
          WebGLDeviceManager._instance = instance;
        }
      }
      WebGLDeviceManager._instance = null;

      function GFXFormatToWebGLType$1(format, gl) {
        switch (format) {
          case Format.R8:
            return gl.UNSIGNED_BYTE;
          case Format.R8SN:
            return gl.BYTE;
          case Format.R8UI:
            return gl.UNSIGNED_BYTE;
          case Format.R8I:
            return gl.BYTE;
          case Format.R16F:
            return WebGLEXT.HALF_FLOAT_OES;
          case Format.R16UI:
            return gl.UNSIGNED_SHORT;
          case Format.R16I:
            return gl.SHORT;
          case Format.R32F:
            return gl.FLOAT;
          case Format.R32UI:
            return gl.UNSIGNED_INT;
          case Format.R32I:
            return gl.INT;
          case Format.RG8:
            return gl.UNSIGNED_BYTE;
          case Format.RG8SN:
            return gl.BYTE;
          case Format.RG8UI:
            return gl.UNSIGNED_BYTE;
          case Format.RG8I:
            return gl.BYTE;
          case Format.RG16F:
            return WebGLEXT.HALF_FLOAT_OES;
          case Format.RG16UI:
            return gl.UNSIGNED_SHORT;
          case Format.RG16I:
            return gl.SHORT;
          case Format.RG32F:
            return gl.FLOAT;
          case Format.RG32UI:
            return gl.UNSIGNED_INT;
          case Format.RG32I:
            return gl.INT;
          case Format.RGB8:
            return gl.UNSIGNED_BYTE;
          case Format.SRGB8:
            return gl.UNSIGNED_BYTE;
          case Format.RGB8SN:
            return gl.BYTE;
          case Format.RGB8UI:
            return gl.UNSIGNED_BYTE;
          case Format.RGB8I:
            return gl.BYTE;
          case Format.RGB16F:
            return WebGLEXT.HALF_FLOAT_OES;
          case Format.RGB16UI:
            return gl.UNSIGNED_SHORT;
          case Format.RGB16I:
            return gl.SHORT;
          case Format.RGB32F:
            return gl.FLOAT;
          case Format.RGB32UI:
            return gl.UNSIGNED_INT;
          case Format.RGB32I:
            return gl.INT;
          case Format.BGRA8:
            return gl.UNSIGNED_BYTE;
          case Format.RGBA8:
            return gl.UNSIGNED_BYTE;
          case Format.SRGB8_A8:
            return gl.UNSIGNED_BYTE;
          case Format.RGBA8SN:
            return gl.BYTE;
          case Format.RGBA8UI:
            return gl.UNSIGNED_BYTE;
          case Format.RGBA8I:
            return gl.BYTE;
          case Format.RGBA16F:
            return WebGLEXT.HALF_FLOAT_OES;
          case Format.RGBA16UI:
            return gl.UNSIGNED_SHORT;
          case Format.RGBA16I:
            return gl.SHORT;
          case Format.RGBA32F:
            return gl.FLOAT;
          case Format.RGBA32UI:
            return gl.UNSIGNED_INT;
          case Format.RGBA32I:
            return gl.INT;
          case Format.R5G6B5:
            return gl.UNSIGNED_SHORT_5_6_5;
          case Format.R11G11B10F:
            return gl.FLOAT;
          case Format.RGB5A1:
            return gl.UNSIGNED_SHORT_5_5_5_1;
          case Format.RGBA4:
            return gl.UNSIGNED_SHORT_4_4_4_4;
          case Format.RGB10A2:
            return gl.UNSIGNED_BYTE;
          case Format.RGB10A2UI:
            return gl.UNSIGNED_INT;
          case Format.RGB9E5:
            return gl.UNSIGNED_BYTE;
          case Format.DEPTH:
            return gl.UNSIGNED_INT;
          case Format.DEPTH_STENCIL:
            return WebGLEXT.UNSIGNED_INT_24_8_WEBGL;
          case Format.BC1:
            return gl.UNSIGNED_BYTE;
          case Format.BC1_SRGB:
            return gl.UNSIGNED_BYTE;
          case Format.BC2:
            return gl.UNSIGNED_BYTE;
          case Format.BC2_SRGB:
            return gl.UNSIGNED_BYTE;
          case Format.BC3:
            return gl.UNSIGNED_BYTE;
          case Format.BC3_SRGB:
            return gl.UNSIGNED_BYTE;
          case Format.BC4:
            return gl.UNSIGNED_BYTE;
          case Format.BC4_SNORM:
            return gl.BYTE;
          case Format.BC5:
            return gl.UNSIGNED_BYTE;
          case Format.BC5_SNORM:
            return gl.BYTE;
          case Format.BC6H_SF16:
            return gl.FLOAT;
          case Format.BC6H_UF16:
            return gl.FLOAT;
          case Format.BC7:
            return gl.UNSIGNED_BYTE;
          case Format.BC7_SRGB:
            return gl.UNSIGNED_BYTE;
          case Format.ETC_RGB8:
            return gl.UNSIGNED_BYTE;
          case Format.ETC2_RGB8:
            return gl.UNSIGNED_BYTE;
          case Format.ETC2_SRGB8:
            return gl.UNSIGNED_BYTE;
          case Format.ETC2_RGB8_A1:
            return gl.UNSIGNED_BYTE;
          case Format.ETC2_SRGB8_A1:
            return gl.UNSIGNED_BYTE;
          case Format.EAC_R11:
            return gl.UNSIGNED_BYTE;
          case Format.EAC_R11SN:
            return gl.BYTE;
          case Format.EAC_RG11:
            return gl.UNSIGNED_BYTE;
          case Format.EAC_RG11SN:
            return gl.BYTE;
          case Format.PVRTC_RGB2:
            return gl.UNSIGNED_BYTE;
          case Format.PVRTC_RGBA2:
            return gl.UNSIGNED_BYTE;
          case Format.PVRTC_RGB4:
            return gl.UNSIGNED_BYTE;
          case Format.PVRTC_RGBA4:
            return gl.UNSIGNED_BYTE;
          case Format.PVRTC2_2BPP:
            return gl.UNSIGNED_BYTE;
          case Format.PVRTC2_4BPP:
            return gl.UNSIGNED_BYTE;
          case Format.ASTC_RGBA_4X4:
          case Format.ASTC_RGBA_5X4:
          case Format.ASTC_RGBA_5X5:
          case Format.ASTC_RGBA_6X5:
          case Format.ASTC_RGBA_6X6:
          case Format.ASTC_RGBA_8X5:
          case Format.ASTC_RGBA_8X6:
          case Format.ASTC_RGBA_8X8:
          case Format.ASTC_RGBA_10X5:
          case Format.ASTC_RGBA_10X6:
          case Format.ASTC_RGBA_10X8:
          case Format.ASTC_RGBA_10X10:
          case Format.ASTC_RGBA_12X10:
          case Format.ASTC_RGBA_12X12:
          case Format.ASTC_SRGBA_4X4:
          case Format.ASTC_SRGBA_5X4:
          case Format.ASTC_SRGBA_5X5:
          case Format.ASTC_SRGBA_6X5:
          case Format.ASTC_SRGBA_6X6:
          case Format.ASTC_SRGBA_8X5:
          case Format.ASTC_SRGBA_8X6:
          case Format.ASTC_SRGBA_8X8:
          case Format.ASTC_SRGBA_10X5:
          case Format.ASTC_SRGBA_10X6:
          case Format.ASTC_SRGBA_10X8:
          case Format.ASTC_SRGBA_10X10:
          case Format.ASTC_SRGBA_12X10:
          case Format.ASTC_SRGBA_12X12:
            return gl.UNSIGNED_BYTE;
          default:
            {
              return gl.UNSIGNED_BYTE;
            }
        }
      }
      function GFXFormatToWebGLInternalFormat$1(format, gl) {
        switch (format) {
          case Format.R5G6B5:
            return gl.RGB565;
          case Format.RGB5A1:
            return gl.RGB5_A1;
          case Format.RGBA4:
            return gl.RGBA4;
          case Format.RGBA16F:
            return WebGLEXT.RGBA16F_EXT;
          case Format.RGBA32F:
            return WebGLEXT.RGBA32F_EXT;
          case Format.SRGB8_A8:
            return WebGLEXT.SRGB8_ALPHA8_EXT;
          case Format.DEPTH:
            return gl.DEPTH_COMPONENT16;
          case Format.DEPTH_STENCIL:
            return gl.DEPTH_STENCIL;
          default:
            {
              error('Unsupported Format, convert to WebGL internal format failed.');
              return gl.RGBA;
            }
        }
      }
      function GFXFormatToWebGLFormat$1(format, gl) {
        switch (format) {
          case Format.A8:
            return gl.ALPHA;
          case Format.L8:
            return gl.LUMINANCE;
          case Format.LA8:
            return gl.LUMINANCE_ALPHA;
          case Format.RGB8:
            return gl.RGB;
          case Format.RGB16F:
            return gl.RGB;
          case Format.RGB32F:
            return gl.RGB;
          case Format.BGRA8:
            return gl.RGBA;
          case Format.RGBA8:
            return gl.RGBA;
          case Format.SRGB8_A8:
            return gl.RGBA;
          case Format.RGBA16F:
            return gl.RGBA;
          case Format.RGBA32F:
            return gl.RGBA;
          case Format.R5G6B5:
            return gl.RGB;
          case Format.RGB5A1:
            return gl.RGBA;
          case Format.RGBA4:
            return gl.RGBA;
          case Format.DEPTH:
            return gl.DEPTH_COMPONENT;
          case Format.DEPTH_STENCIL:
            return gl.DEPTH_STENCIL;
          case Format.BC1:
            return WebGLEXT.COMPRESSED_RGB_S3TC_DXT1_EXT;
          case Format.BC1_ALPHA:
            return WebGLEXT.COMPRESSED_RGBA_S3TC_DXT1_EXT;
          case Format.BC1_SRGB:
            return WebGLEXT.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          case Format.BC1_SRGB_ALPHA:
            return WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          case Format.BC2:
            return WebGLEXT.COMPRESSED_RGBA_S3TC_DXT3_EXT;
          case Format.BC2_SRGB:
            return WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          case Format.BC3:
            return WebGLEXT.COMPRESSED_RGBA_S3TC_DXT5_EXT;
          case Format.BC3_SRGB:
            return WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
          case Format.ETC_RGB8:
            return WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL;
          case Format.ETC2_RGB8:
            return WebGLEXT.COMPRESSED_RGB8_ETC2;
          case Format.ETC2_SRGB8:
            return WebGLEXT.COMPRESSED_SRGB8_ETC2;
          case Format.ETC2_RGB8_A1:
            return WebGLEXT.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2;
          case Format.ETC2_SRGB8_A1:
            return WebGLEXT.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2;
          case Format.ETC2_RGBA8:
            return WebGLEXT.COMPRESSED_RGBA8_ETC2_EAC;
          case Format.ETC2_SRGB8_A8:
            return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC;
          case Format.EAC_R11:
            return WebGLEXT.COMPRESSED_R11_EAC;
          case Format.EAC_R11SN:
            return WebGLEXT.COMPRESSED_SIGNED_R11_EAC;
          case Format.EAC_RG11:
            return WebGLEXT.COMPRESSED_RG11_EAC;
          case Format.EAC_RG11SN:
            return WebGLEXT.COMPRESSED_SIGNED_RG11_EAC;
          case Format.PVRTC_RGB2:
            return WebGLEXT.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
          case Format.PVRTC_RGBA2:
            return WebGLEXT.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
          case Format.PVRTC_RGB4:
            return WebGLEXT.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
          case Format.PVRTC_RGBA4:
            return WebGLEXT.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
          case Format.ASTC_RGBA_4X4:
            return WebGLEXT.COMPRESSED_RGBA_ASTC_4x4_KHR;
          case Format.ASTC_RGBA_5X4:
            return WebGLEXT.COMPRESSED_RGBA_ASTC_5x4_KHR;
          case Format.ASTC_RGBA_5X5:
            return WebGLEXT.COMPRESSED_RGBA_ASTC_5x5_KHR;
          case Format.ASTC_RGBA_6X5:
            return WebGLEXT.COMPRESSED_RGBA_ASTC_6x5_KHR;
          case Format.ASTC_RGBA_6X6:
            return WebGLEXT.COMPRESSED_RGBA_ASTC_6x6_KHR;
          case Format.ASTC_RGBA_8X5:
            return WebGLEXT.COMPRESSED_RGBA_ASTC_8x5_KHR;
          case Format.ASTC_RGBA_8X6:
            return WebGLEXT.COMPRESSED_RGBA_ASTC_8x6_KHR;
          case Format.ASTC_RGBA_8X8:
            return WebGLEXT.COMPRESSED_RGBA_ASTC_8x8_KHR;
          case Format.ASTC_RGBA_10X5:
            return WebGLEXT.COMPRESSED_RGBA_ASTC_10x5_KHR;
          case Format.ASTC_RGBA_10X6:
            return WebGLEXT.COMPRESSED_RGBA_ASTC_10x6_KHR;
          case Format.ASTC_RGBA_10X8:
            return WebGLEXT.COMPRESSED_RGBA_ASTC_10x8_KHR;
          case Format.ASTC_RGBA_10X10:
            return WebGLEXT.COMPRESSED_RGBA_ASTC_10x10_KHR;
          case Format.ASTC_RGBA_12X10:
            return WebGLEXT.COMPRESSED_RGBA_ASTC_12x10_KHR;
          case Format.ASTC_RGBA_12X12:
            return WebGLEXT.COMPRESSED_RGBA_ASTC_12x12_KHR;
          case Format.ASTC_SRGBA_4X4:
            return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR;
          case Format.ASTC_SRGBA_5X4:
            return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR;
          case Format.ASTC_SRGBA_5X5:
            return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR;
          case Format.ASTC_SRGBA_6X5:
            return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR;
          case Format.ASTC_SRGBA_6X6:
            return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR;
          case Format.ASTC_SRGBA_8X5:
            return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR;
          case Format.ASTC_SRGBA_8X6:
            return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR;
          case Format.ASTC_SRGBA_8X8:
            return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR;
          case Format.ASTC_SRGBA_10X5:
            return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR;
          case Format.ASTC_SRGBA_10X6:
            return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR;
          case Format.ASTC_SRGBA_10X8:
            return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR;
          case Format.ASTC_SRGBA_10X10:
            return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR;
          case Format.ASTC_SRGBA_12X10:
            return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR;
          case Format.ASTC_SRGBA_12X12:
            return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR;
          default:
            {
              error('Unsupported Format, convert to WebGL format failed.');
              return gl.RGBA;
            }
        }
      }
      function GFXTypeToWebGLType$1(type, gl) {
        switch (type) {
          case Type$1.BOOL:
            return gl.BOOL;
          case Type$1.BOOL2:
            return gl.BOOL_VEC2;
          case Type$1.BOOL3:
            return gl.BOOL_VEC3;
          case Type$1.BOOL4:
            return gl.BOOL_VEC4;
          case Type$1.INT:
            return gl.INT;
          case Type$1.INT2:
            return gl.INT_VEC2;
          case Type$1.INT3:
            return gl.INT_VEC3;
          case Type$1.INT4:
            return gl.INT_VEC4;
          case Type$1.UINT:
            return gl.UNSIGNED_INT;
          case Type$1.FLOAT:
            return gl.FLOAT;
          case Type$1.FLOAT2:
            return gl.FLOAT_VEC2;
          case Type$1.FLOAT3:
            return gl.FLOAT_VEC3;
          case Type$1.FLOAT4:
            return gl.FLOAT_VEC4;
          case Type$1.MAT2:
            return gl.FLOAT_MAT2;
          case Type$1.MAT3:
            return gl.FLOAT_MAT3;
          case Type$1.MAT4:
            return gl.FLOAT_MAT4;
          case Type$1.SAMPLER2D:
            return gl.SAMPLER_2D;
          case Type$1.SAMPLER_CUBE:
            return gl.SAMPLER_CUBE;
          default:
            {
              error('Unsupported GLType, convert to GL type failed.');
              return Type$1.UNKNOWN;
            }
        }
      }
      function GFXTypeToTypedArrayCtor(type) {
        switch (type) {
          case Type$1.BOOL:
          case Type$1.BOOL2:
          case Type$1.BOOL3:
          case Type$1.BOOL4:
          case Type$1.INT:
          case Type$1.INT2:
          case Type$1.INT3:
          case Type$1.INT4:
          case Type$1.UINT:
            return Int32Array;
          case Type$1.FLOAT:
          case Type$1.FLOAT2:
          case Type$1.FLOAT3:
          case Type$1.FLOAT4:
          case Type$1.MAT2:
          case Type$1.MAT3:
          case Type$1.MAT4:
            return Float32Array;
          default:
            {
              error('Unsupported GLType, convert to TypedArrayConstructor failed.');
              return Float32Array;
            }
        }
      }
      function WebGLTypeToGFXType$1(glType, gl) {
        switch (glType) {
          case gl.BOOL:
            return Type$1.BOOL;
          case gl.BOOL_VEC2:
            return Type$1.BOOL2;
          case gl.BOOL_VEC3:
            return Type$1.BOOL3;
          case gl.BOOL_VEC4:
            return Type$1.BOOL4;
          case gl.INT:
            return Type$1.INT;
          case gl.INT_VEC2:
            return Type$1.INT2;
          case gl.INT_VEC3:
            return Type$1.INT3;
          case gl.INT_VEC4:
            return Type$1.INT4;
          case gl.UNSIGNED_INT:
            return Type$1.UINT;
          case gl.FLOAT:
            return Type$1.FLOAT;
          case gl.FLOAT_VEC2:
            return Type$1.FLOAT2;
          case gl.FLOAT_VEC3:
            return Type$1.FLOAT3;
          case gl.FLOAT_VEC4:
            return Type$1.FLOAT4;
          case gl.FLOAT_MAT2:
            return Type$1.MAT2;
          case gl.FLOAT_MAT3:
            return Type$1.MAT3;
          case gl.FLOAT_MAT4:
            return Type$1.MAT4;
          case gl.SAMPLER_2D:
            return Type$1.SAMPLER2D;
          case gl.SAMPLER_CUBE:
            return Type$1.SAMPLER_CUBE;
          default:
            {
              error('Unsupported GLType, convert to Type failed.');
              return Type$1.UNKNOWN;
            }
        }
      }
      function WebGLGetTypeSize$1(glType, gl) {
        switch (glType) {
          case gl.BOOL:
            return 4;
          case gl.BOOL_VEC2:
            return 8;
          case gl.BOOL_VEC3:
            return 12;
          case gl.BOOL_VEC4:
            return 16;
          case gl.INT:
            return 4;
          case gl.INT_VEC2:
            return 8;
          case gl.INT_VEC3:
            return 12;
          case gl.INT_VEC4:
            return 16;
          case gl.UNSIGNED_INT:
            return 4;
          case gl.FLOAT:
            return 4;
          case gl.FLOAT_VEC2:
            return 8;
          case gl.FLOAT_VEC3:
            return 12;
          case gl.FLOAT_VEC4:
            return 16;
          case gl.FLOAT_MAT2:
            return 16;
          case gl.FLOAT_MAT3:
            return 36;
          case gl.FLOAT_MAT4:
            return 64;
          case gl.SAMPLER_2D:
            return 4;
          case gl.SAMPLER_CUBE:
            return 4;
          default:
            {
              error('Unsupported GLType, get type failed.');
              return 0;
            }
        }
      }
      function WebGLGetComponentCount$1(glType, gl) {
        switch (glType) {
          case gl.FLOAT_MAT2:
            return 2;
          case gl.FLOAT_MAT3:
            return 3;
          case gl.FLOAT_MAT4:
            return 4;
          default:
            {
              return 1;
            }
        }
      }
      const WebGLCmpFuncs$1 = [0x0200, 0x0201, 0x0202, 0x0203, 0x0204, 0x0205, 0x0206, 0x0207];
      const WebGLStencilOps$1 = [0x0000, 0x1E00, 0x1E01, 0x1E02, 0x1E03, 0x150A, 0x8507, 0x8508];
      const WebGLBlendOps$1 = [0x8006, 0x800A, 0x800B, 0x8007, 0x8008];
      const WebGLBlendFactors$1 = [0x0000, 0x0001, 0x0302, 0x0304, 0x0303, 0x0305, 0x0300, 0x0306, 0x0301, 0x0307, 0x0308, 0x8001, 0x8002, 0x8003, 0x8004];
      let WebGLCmd;
      (function (WebGLCmd) {
        WebGLCmd[WebGLCmd["BEGIN_RENDER_PASS"] = 0] = "BEGIN_RENDER_PASS";
        WebGLCmd[WebGLCmd["END_RENDER_PASS"] = 1] = "END_RENDER_PASS";
        WebGLCmd[WebGLCmd["BIND_STATES"] = 2] = "BIND_STATES";
        WebGLCmd[WebGLCmd["DRAW"] = 3] = "DRAW";
        WebGLCmd[WebGLCmd["UPDATE_BUFFER"] = 4] = "UPDATE_BUFFER";
        WebGLCmd[WebGLCmd["COPY_BUFFER_TO_TEXTURE"] = 5] = "COPY_BUFFER_TO_TEXTURE";
        WebGLCmd[WebGLCmd["BLIT_TEXTURE"] = 6] = "BLIT_TEXTURE";
        WebGLCmd[WebGLCmd["COUNT"] = 7] = "COUNT";
      })(WebGLCmd || (WebGLCmd = {}));
      class WebGLCmdObject {
        constructor(type) {
          this.cmdType = void 0;
          this.refCount = 0;
          this.cmdType = type;
        }
      }
      class WebGLCmdBeginRenderPass extends WebGLCmdObject {
        constructor() {
          super(WebGLCmd.BEGIN_RENDER_PASS);
          this.gpuRenderPass = null;
          this.gpuFramebuffer = null;
          this.renderArea = new Rect();
          this.clearFlag = ClearFlagBit.NONE;
          this.clearColors = [];
          this.clearDepth = 1.0;
          this.clearStencil = 0;
        }
        clear() {
          this.gpuFramebuffer = null;
          this.clearColors.length = 0;
        }
      }
      class WebGLCmdBindStates extends WebGLCmdObject {
        constructor() {
          super(WebGLCmd.BIND_STATES);
          this.gpuPipelineState = null;
          this.gpuInputAssembler = null;
          this.gpuDescriptorSets = [];
          this.dynamicOffsets = [];
          this.dynamicStates = new DynamicStates();
        }
        clear() {
          this.gpuPipelineState = null;
          this.gpuDescriptorSets.length = 0;
          this.gpuInputAssembler = null;
          this.dynamicOffsets.length = 0;
        }
      }
      class WebGLCmdDraw extends WebGLCmdObject {
        constructor() {
          super(WebGLCmd.DRAW);
          this.drawInfo = new DrawInfo();
        }
        clear() {}
      }
      class WebGLCmdUpdateBuffer extends WebGLCmdObject {
        constructor() {
          super(WebGLCmd.UPDATE_BUFFER);
          this.gpuBuffer = null;
          this.buffer = null;
          this.offset = 0;
          this.size = 0;
        }
        clear() {
          this.gpuBuffer = null;
          this.buffer = null;
        }
      }
      class WebGLCmdCopyBufferToTexture extends WebGLCmdObject {
        constructor() {
          super(WebGLCmd.COPY_BUFFER_TO_TEXTURE);
          this.gpuTexture = null;
          this.buffers = [];
          this.regions = [];
        }
        clear() {
          this.gpuTexture = null;
          this.buffers.length = 0;
          this.regions.length = 0;
        }
      }
      class WebGLCmdBlitTexture extends WebGLCmdObject {
        constructor() {
          super(WebGLCmd.BLIT_TEXTURE);
          this.srcTexture = null;
          this.dstTexture = null;
          this.regions = [];
          this.filter = Filter$1.LINEAR;
        }
        clear() {
          this.srcTexture = null;
          this.dstTexture = null;
          this.regions.length = 0;
        }
      }
      class WebGLCmdPackage {
        constructor() {
          this.cmds = new CachedArray(1);
          this.beginRenderPassCmds = new CachedArray(1);
          this.bindStatesCmds = new CachedArray(1);
          this.drawCmds = new CachedArray(1);
          this.updateBufferCmds = new CachedArray(1);
          this.copyBufferToTextureCmds = new CachedArray(1);
          this.blitTextureCmds = new CachedArray(1);
        }
        clearCmds(allocator) {
          if (this.beginRenderPassCmds.length) {
            allocator.beginRenderPassCmdPool.freeCmds(this.beginRenderPassCmds);
            this.beginRenderPassCmds.clear();
          }
          if (this.bindStatesCmds.length) {
            allocator.bindStatesCmdPool.freeCmds(this.bindStatesCmds);
            this.bindStatesCmds.clear();
          }
          if (this.drawCmds.length) {
            allocator.drawCmdPool.freeCmds(this.drawCmds);
            this.drawCmds.clear();
          }
          if (this.updateBufferCmds.length) {
            allocator.updateBufferCmdPool.freeCmds(this.updateBufferCmds);
            this.updateBufferCmds.clear();
          }
          if (this.copyBufferToTextureCmds.length) {
            allocator.copyBufferToTextureCmdPool.freeCmds(this.copyBufferToTextureCmds);
            this.copyBufferToTextureCmds.clear();
          }
          if (this.blitTextureCmds.length) {
            allocator.blitTextureCmdPool.freeCmds(this.blitTextureCmds);
            this.blitTextureCmds.clear();
          }
          this.cmds.clear();
        }
      }
      function WebGLCmdFuncCreateBuffer(device, gpuBuffer) {
        const {
          gl
        } = device;
        const cache = device.stateCache;
        const glUsage = gpuBuffer.memUsage & MemoryUsageBit.HOST ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;
        if (gpuBuffer.usage & BufferUsageBit.VERTEX) {
          gpuBuffer.glTarget = gl.ARRAY_BUFFER;
          const glBuffer = gl.createBuffer();
          if (glBuffer) {
            gpuBuffer.glBuffer = glBuffer;
            if (gpuBuffer.size > 0) {
              if (device.extensions.useVAO) {
                if (cache.glVAO) {
                  device.extensions.OES_vertex_array_object.bindVertexArrayOES(null);
                  cache.glVAO = null;
                }
              }
              gfxStateCache$1.gpuInputAssembler = null;
              if (device.stateCache.glArrayBuffer !== gpuBuffer.glBuffer) {
                gl.bindBuffer(gl.ARRAY_BUFFER, gpuBuffer.glBuffer);
                device.stateCache.glArrayBuffer = gpuBuffer.glBuffer;
              }
              gl.bufferData(gl.ARRAY_BUFFER, gpuBuffer.size, glUsage);
              gl.bindBuffer(gl.ARRAY_BUFFER, null);
              device.stateCache.glArrayBuffer = null;
            }
          }
        } else if (gpuBuffer.usage & BufferUsageBit.INDEX) {
          gpuBuffer.glTarget = gl.ELEMENT_ARRAY_BUFFER;
          const glBuffer = gl.createBuffer();
          if (glBuffer) {
            gpuBuffer.glBuffer = glBuffer;
            if (gpuBuffer.size > 0) {
              if (device.extensions.useVAO) {
                if (cache.glVAO) {
                  device.extensions.OES_vertex_array_object.bindVertexArrayOES(null);
                  cache.glVAO = null;
                }
              }
              gfxStateCache$1.gpuInputAssembler = null;
              if (device.stateCache.glElementArrayBuffer !== gpuBuffer.glBuffer) {
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.glBuffer);
                device.stateCache.glElementArrayBuffer = gpuBuffer.glBuffer;
              }
              gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.size, glUsage);
              gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
              device.stateCache.glElementArrayBuffer = null;
            }
          }
        } else if (gpuBuffer.usage & BufferUsageBit.UNIFORM) {
          gpuBuffer.glTarget = gl.NONE;
          if (gpuBuffer.buffer) {
            gpuBuffer.vf32 = new Float32Array(gpuBuffer.buffer.buffer);
          }
        } else if (gpuBuffer.usage & BufferUsageBit.INDIRECT) {
          gpuBuffer.glTarget = gl.NONE;
        } else if (gpuBuffer.usage & BufferUsageBit.TRANSFER_DST) {
          gpuBuffer.glTarget = gl.NONE;
        } else if (gpuBuffer.usage & BufferUsageBit.TRANSFER_SRC) {
          gpuBuffer.glTarget = gl.NONE;
        } else {
          error('Unsupported BufferType, create buffer failed.');
          gpuBuffer.glTarget = gl.NONE;
        }
      }
      function WebGLCmdFuncDestroyBuffer(device, gpuBuffer) {
        const {
          gl
        } = device;
        const cache = device.stateCache;
        if (gpuBuffer.glBuffer) {
          switch (gpuBuffer.glTarget) {
            case gl.ARRAY_BUFFER:
              if (device.extensions.useVAO) {
                if (cache.glVAO) {
                  device.extensions.OES_vertex_array_object.bindVertexArrayOES(null);
                  device.stateCache.glVAO = null;
                }
              }
              gfxStateCache$1.gpuInputAssembler = null;
              gl.bindBuffer(gl.ARRAY_BUFFER, null);
              device.stateCache.glArrayBuffer = null;
              break;
            case gl.ELEMENT_ARRAY_BUFFER:
              if (device.extensions.useVAO) {
                if (cache.glVAO) {
                  device.extensions.OES_vertex_array_object.bindVertexArrayOES(null);
                  device.stateCache.glVAO = null;
                }
              }
              gfxStateCache$1.gpuInputAssembler = null;
              gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
              device.stateCache.glElementArrayBuffer = null;
              break;
          }
          gl.deleteBuffer(gpuBuffer.glBuffer);
          gpuBuffer.glBuffer = null;
        }
      }
      function WebGLCmdFuncResizeBuffer(device, gpuBuffer) {
        const {
          gl
        } = device;
        const cache = device.stateCache;
        const glUsage = gpuBuffer.memUsage & MemoryUsageBit.HOST ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;
        if (gpuBuffer.usage & BufferUsageBit.VERTEX) {
          if (device.extensions.useVAO) {
            if (cache.glVAO) {
              device.extensions.OES_vertex_array_object.bindVertexArrayOES(null);
              cache.glVAO = null;
            }
          }
          gfxStateCache$1.gpuInputAssembler = null;
          if (device.stateCache.glArrayBuffer !== gpuBuffer.glBuffer) {
            gl.bindBuffer(gl.ARRAY_BUFFER, gpuBuffer.glBuffer);
          }
          if (gpuBuffer.buffer) {
            gl.bufferData(gl.ARRAY_BUFFER, gpuBuffer.buffer, glUsage);
          } else {
            gl.bufferData(gl.ARRAY_BUFFER, gpuBuffer.size, glUsage);
          }
          gl.bindBuffer(gl.ARRAY_BUFFER, null);
          device.stateCache.glArrayBuffer = null;
        } else if (gpuBuffer.usage & BufferUsageBit.INDEX) {
          if (device.extensions.useVAO) {
            if (cache.glVAO) {
              device.extensions.OES_vertex_array_object.bindVertexArrayOES(null);
              cache.glVAO = null;
            }
          }
          gfxStateCache$1.gpuInputAssembler = null;
          if (device.stateCache.glElementArrayBuffer !== gpuBuffer.glBuffer) {
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.glBuffer);
          }
          if (gpuBuffer.buffer) {
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.buffer, glUsage);
          } else {
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.size, glUsage);
          }
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
          device.stateCache.glElementArrayBuffer = null;
        } else if (gpuBuffer.usage & BufferUsageBit.UNIFORM) {
          if (gpuBuffer.buffer) {
            gpuBuffer.vf32 = new Float32Array(gpuBuffer.buffer.buffer);
          }
        } else if (gpuBuffer.usage & BufferUsageBit.INDIRECT || gpuBuffer.usage & BufferUsageBit.TRANSFER_DST || gpuBuffer.usage & BufferUsageBit.TRANSFER_SRC) {
          gpuBuffer.glTarget = gl.NONE;
        } else {
          error('Unsupported BufferType, create buffer failed.');
          gpuBuffer.glTarget = gl.NONE;
        }
      }
      function WebGLCmdFuncUpdateBuffer(device, gpuBuffer, buffer, offset, size) {
        if (gpuBuffer.usage & BufferUsageBit.UNIFORM) {
          if (ArrayBuffer.isView(buffer)) {
            gpuBuffer.vf32.set(buffer, offset / Float32Array.BYTES_PER_ELEMENT);
          } else {
            gpuBuffer.vf32.set(new Float32Array(buffer), offset / Float32Array.BYTES_PER_ELEMENT);
          }
        } else if (gpuBuffer.usage & BufferUsageBit.INDIRECT) {
          gpuBuffer.indirects.clearDraws();
          const drawInfos = buffer.drawInfos;
          for (let i = 0; i < drawInfos.length; ++i) {
            gpuBuffer.indirects.setDrawInfo(offset + i, drawInfos[i]);
          }
        } else {
          const buff = buffer;
          const {
            gl
          } = device;
          const cache = device.stateCache;
          switch (gpuBuffer.glTarget) {
            case gl.ARRAY_BUFFER:
              {
                if (device.extensions.useVAO) {
                  if (cache.glVAO) {
                    device.extensions.OES_vertex_array_object.bindVertexArrayOES(null);
                    cache.glVAO = null;
                  }
                }
                gfxStateCache$1.gpuInputAssembler = null;
                if (device.stateCache.glArrayBuffer !== gpuBuffer.glBuffer) {
                  gl.bindBuffer(gl.ARRAY_BUFFER, gpuBuffer.glBuffer);
                  device.stateCache.glArrayBuffer = gpuBuffer.glBuffer;
                }
                break;
              }
            case gl.ELEMENT_ARRAY_BUFFER:
              {
                if (device.extensions.useVAO) {
                  if (cache.glVAO) {
                    device.extensions.OES_vertex_array_object.bindVertexArrayOES(null);
                    cache.glVAO = null;
                  }
                }
                gfxStateCache$1.gpuInputAssembler = null;
                if (device.stateCache.glElementArrayBuffer !== gpuBuffer.glBuffer) {
                  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.glBuffer);
                  device.stateCache.glElementArrayBuffer = gpuBuffer.glBuffer;
                }
                break;
              }
            default:
              {
                error('Unsupported BufferType, update buffer failed.');
                return;
              }
          }
          if (size === buff.byteLength) {
            gl.bufferSubData(gpuBuffer.glTarget, offset, buff);
          } else {
            gl.bufferSubData(gpuBuffer.glTarget, offset, buff.slice(0, size));
          }
        }
      }
      function WebGLCmdFuncCreateTexture(device, gpuTexture) {
        const {
          gl
        } = device;
        gpuTexture.glFormat = gpuTexture.glInternalFmt = GFXFormatToWebGLFormat$1(gpuTexture.format, gl);
        gpuTexture.glType = GFXFormatToWebGLType$1(gpuTexture.format, gl);
        let w = gpuTexture.width;
        let h = gpuTexture.height;
        switch (gpuTexture.type) {
          case TextureType.TEX2D:
            {
              gpuTexture.glTarget = gl.TEXTURE_2D;
              const maxSize = Math.max(w, h);
              if (maxSize > device.capabilities.maxTextureSize) {
                errorID(9100, maxSize, device.capabilities.maxTextureSize);
              }
              if (!device.textureExclusive[gpuTexture.format] && !device.extensions.WEBGL_depth_texture && FormatInfos[gpuTexture.format].hasDepth) {
                gpuTexture.glInternalFmt = GFXFormatToWebGLInternalFormat$1(gpuTexture.format, gl);
                gpuTexture.glRenderbuffer = gl.createRenderbuffer();
                if (gpuTexture.size > 0) {
                  if (device.stateCache.glRenderbuffer !== gpuTexture.glRenderbuffer) {
                    gl.bindRenderbuffer(gl.RENDERBUFFER, gpuTexture.glRenderbuffer);
                    device.stateCache.glRenderbuffer = gpuTexture.glRenderbuffer;
                  }
                  gl.renderbufferStorage(gl.RENDERBUFFER, gpuTexture.glInternalFmt, w, h);
                }
              } else {
                gpuTexture.glTexture = gl.createTexture();
                if (gpuTexture.size > 0) {
                  const glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];
                  if (glTexUnit.glTexture !== gpuTexture.glTexture) {
                    gl.bindTexture(gl.TEXTURE_2D, gpuTexture.glTexture);
                    glTexUnit.glTexture = gpuTexture.glTexture;
                  }
                  if (FormatInfos[gpuTexture.format].isCompressed) {
                    for (let i = 0; i < gpuTexture.mipLevel; ++i) {
                      const imgSize = FormatSize(gpuTexture.format, w, h, 1);
                      const view = new Uint8Array(imgSize);
                      gl.compressedTexImage2D(gl.TEXTURE_2D, i, gpuTexture.glInternalFmt, w, h, 0, view);
                      w = Math.max(1, w >> 1);
                      h = Math.max(1, h >> 1);
                    }
                  } else {
                    for (let i = 0; i < gpuTexture.mipLevel; ++i) {
                      gl.texImage2D(gl.TEXTURE_2D, i, gpuTexture.glInternalFmt, w, h, 0, gpuTexture.glFormat, gpuTexture.glType, null);
                      w = Math.max(1, w >> 1);
                      h = Math.max(1, h >> 1);
                    }
                  }
                  if (gpuTexture.isPowerOf2) {
                    gpuTexture.glWrapS = gl.REPEAT;
                    gpuTexture.glWrapT = gl.REPEAT;
                  } else {
                    gpuTexture.glWrapS = gl.CLAMP_TO_EDGE;
                    gpuTexture.glWrapT = gl.CLAMP_TO_EDGE;
                  }
                  gpuTexture.glMinFilter = gl.LINEAR;
                  gpuTexture.glMagFilter = gl.LINEAR;
                  gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_WRAP_S, gpuTexture.glWrapS);
                  gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_WRAP_T, gpuTexture.glWrapT);
                  gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_MIN_FILTER, gpuTexture.glMinFilter);
                  gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_MAG_FILTER, gpuTexture.glMagFilter);
                }
              }
              break;
            }
          case TextureType.CUBE:
            {
              gpuTexture.glTarget = gl.TEXTURE_CUBE_MAP;
              const maxSize = Math.max(w, h);
              if (maxSize > device.capabilities.maxCubeMapTextureSize) {
                errorID(9100, maxSize, device.capabilities.maxTextureSize);
              }
              gpuTexture.glTexture = gl.createTexture();
              if (gpuTexture.size > 0) {
                const glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];
                if (glTexUnit.glTexture !== gpuTexture.glTexture) {
                  gl.bindTexture(gl.TEXTURE_CUBE_MAP, gpuTexture.glTexture);
                  glTexUnit.glTexture = gpuTexture.glTexture;
                }
                if (FormatInfos[gpuTexture.format].isCompressed) {
                  for (let f = 0; f < 6; ++f) {
                    w = gpuTexture.width;
                    h = gpuTexture.height;
                    for (let i = 0; i < gpuTexture.mipLevel; ++i) {
                      const imgSize = FormatSize(gpuTexture.format, w, h, 1);
                      const view = new Uint8Array(imgSize);
                      gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, i, gpuTexture.glInternalFmt, w, h, 0, view);
                      w = Math.max(1, w >> 1);
                      h = Math.max(1, h >> 1);
                    }
                  }
                } else {
                  for (let f = 0; f < 6; ++f) {
                    w = gpuTexture.width;
                    h = gpuTexture.height;
                    for (let i = 0; i < gpuTexture.mipLevel; ++i) {
                      gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, i, gpuTexture.glInternalFmt, w, h, 0, gpuTexture.glFormat, gpuTexture.glType, null);
                      w = Math.max(1, w >> 1);
                      h = Math.max(1, h >> 1);
                    }
                  }
                }
                if (gpuTexture.isPowerOf2) {
                  gpuTexture.glWrapS = gl.REPEAT;
                  gpuTexture.glWrapT = gl.REPEAT;
                } else {
                  gpuTexture.glWrapS = gl.CLAMP_TO_EDGE;
                  gpuTexture.glWrapT = gl.CLAMP_TO_EDGE;
                }
                gpuTexture.glMinFilter = gl.LINEAR;
                gpuTexture.glMagFilter = gl.LINEAR;
                gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_WRAP_S, gpuTexture.glWrapS);
                gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_WRAP_T, gpuTexture.glWrapT);
                gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_MIN_FILTER, gpuTexture.glMinFilter);
                gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_MAG_FILTER, gpuTexture.glMagFilter);
              }
              break;
            }
          default:
            {
              error('Unsupported TextureType, create texture failed.');
              gpuTexture.type = TextureType.TEX2D;
              gpuTexture.glTarget = gl.TEXTURE_2D;
            }
        }
      }
      function WebGLCmdFuncDestroyTexture(device, gpuTexture) {
        const {
          gl
        } = device;
        if (gpuTexture.glTexture) {
          const glTexUnits = device.stateCache.glTexUnits;
          let texUnit = device.stateCache.texUnit;
          gl.deleteTexture(gpuTexture.glTexture);
          for (let i = 0; i < glTexUnits.length; i++) {
            if (glTexUnits[i].glTexture === gpuTexture.glTexture) {
              gl.activeTexture(gl.TEXTURE0 + i);
              texUnit = i;
              gl.bindTexture(gpuTexture.glTarget, null);
              glTexUnits[i].glTexture = null;
            }
          }
          device.stateCache.texUnit = texUnit;
          gpuTexture.glTexture = null;
        }
        if (gpuTexture.glRenderbuffer) {
          let glRenderbuffer = device.stateCache.glRenderbuffer;
          gl.deleteRenderbuffer(gpuTexture.glRenderbuffer);
          if (glRenderbuffer === gpuTexture.glRenderbuffer) {
            gl.bindRenderbuffer(gl.RENDERBUFFER, null);
            glRenderbuffer = null;
          }
          gpuTexture.glRenderbuffer = null;
        }
      }
      function WebGLCmdFuncResizeTexture(device, gpuTexture) {
        if (!gpuTexture.size) return;
        const {
          gl
        } = device;
        let w = gpuTexture.width;
        let h = gpuTexture.height;
        switch (gpuTexture.type) {
          case TextureType.TEX2D:
            {
              gpuTexture.glTarget = gl.TEXTURE_2D;
              const maxSize = Math.max(w, h);
              if (maxSize > device.capabilities.maxTextureSize) {
                errorID(9100, maxSize, device.capabilities.maxTextureSize);
              }
              if (gpuTexture.glRenderbuffer) {
                if (device.stateCache.glRenderbuffer !== gpuTexture.glRenderbuffer) {
                  gl.bindRenderbuffer(gl.RENDERBUFFER, gpuTexture.glRenderbuffer);
                  device.stateCache.glRenderbuffer = gpuTexture.glRenderbuffer;
                }
                gl.renderbufferStorage(gl.RENDERBUFFER, gpuTexture.glInternalFmt, w, h);
              } else if (gpuTexture.glTexture) {
                const glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];
                if (glTexUnit.glTexture !== gpuTexture.glTexture) {
                  gl.bindTexture(gl.TEXTURE_2D, gpuTexture.glTexture);
                  glTexUnit.glTexture = gpuTexture.glTexture;
                }
                if (FormatInfos[gpuTexture.format].isCompressed) {
                  for (let i = 0; i < gpuTexture.mipLevel; ++i) {
                    const imgSize = FormatSize(gpuTexture.format, w, h, 1);
                    const view = new Uint8Array(imgSize);
                    gl.compressedTexImage2D(gl.TEXTURE_2D, i, gpuTexture.glInternalFmt, w, h, 0, view);
                    w = Math.max(1, w >> 1);
                    h = Math.max(1, h >> 1);
                  }
                } else {
                  for (let i = 0; i < gpuTexture.mipLevel; ++i) {
                    gl.texImage2D(gl.TEXTURE_2D, i, gpuTexture.glInternalFmt, w, h, 0, gpuTexture.glFormat, gpuTexture.glType, null);
                    w = Math.max(1, w >> 1);
                    h = Math.max(1, h >> 1);
                  }
                }
              }
              break;
            }
          case TextureType.CUBE:
            {
              gpuTexture.glTarget = gl.TEXTURE_CUBE_MAP;
              const maxSize = Math.max(w, h);
              if (maxSize > device.capabilities.maxCubeMapTextureSize) {
                errorID(9100, maxSize, device.capabilities.maxTextureSize);
              }
              const glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];
              if (glTexUnit.glTexture !== gpuTexture.glTexture) {
                gl.bindTexture(gl.TEXTURE_CUBE_MAP, gpuTexture.glTexture);
                glTexUnit.glTexture = gpuTexture.glTexture;
              }
              if (FormatInfos[gpuTexture.format].isCompressed) {
                for (let f = 0; f < 6; ++f) {
                  w = gpuTexture.width;
                  h = gpuTexture.height;
                  for (let i = 0; i < gpuTexture.mipLevel; ++i) {
                    const imgSize = FormatSize(gpuTexture.format, w, h, 1);
                    const view = new Uint8Array(imgSize);
                    gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, i, gpuTexture.glInternalFmt, w, h, 0, view);
                    w = Math.max(1, w >> 1);
                    h = Math.max(1, h >> 1);
                  }
                }
              } else {
                for (let f = 0; f < 6; ++f) {
                  w = gpuTexture.width;
                  h = gpuTexture.height;
                  for (let i = 0; i < gpuTexture.mipLevel; ++i) {
                    gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, i, gpuTexture.glInternalFmt, w, h, 0, gpuTexture.glFormat, gpuTexture.glType, null);
                    w = Math.max(1, w >> 1);
                    h = Math.max(1, h >> 1);
                  }
                }
              }
              break;
            }
          default:
            {
              error('Unsupported TextureType, create texture failed.');
              gpuTexture.type = TextureType.TEX2D;
              gpuTexture.glTarget = gl.TEXTURE_2D;
            }
        }
      }
      function WebGLCmdFuncCreateFramebuffer(device, gpuFramebuffer) {
        for (let i = 0; i < gpuFramebuffer.gpuColorTextures.length; ++i) {
          const tex = gpuFramebuffer.gpuColorTextures[i];
          if (tex.isSwapchainTexture) {
            gpuFramebuffer.isOffscreen = false;
            return;
          }
        }
        const {
          gl
        } = device;
        const attachments = [];
        const glFramebuffer = gl.createFramebuffer();
        if (glFramebuffer) {
          gpuFramebuffer.glFramebuffer = glFramebuffer;
          if (device.stateCache.glFramebuffer !== gpuFramebuffer.glFramebuffer) {
            gl.bindFramebuffer(gl.FRAMEBUFFER, gpuFramebuffer.glFramebuffer);
          }
          for (let i = 0; i < gpuFramebuffer.gpuColorTextures.length; ++i) {
            const gpuTexture = gpuFramebuffer.gpuColorTextures[i];
            if (gpuTexture) {
              if (gpuTexture.glTexture) {
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gpuTexture.glTarget, gpuTexture.glTexture, 0);
              } else {
                gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.RENDERBUFFER, gpuTexture.glRenderbuffer);
              }
              attachments.push(gl.COLOR_ATTACHMENT0 + i);
              gpuFramebuffer.width = Math.min(gpuFramebuffer.width, gpuTexture.width);
              gpuFramebuffer.height = Math.min(gpuFramebuffer.height, gpuTexture.height);
            }
          }
          const dst = gpuFramebuffer.gpuDepthStencilTexture;
          if (dst) {
            const glAttachment = FormatInfos[dst.format].hasStencil ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;
            if (dst.glTexture) {
              gl.framebufferTexture2D(gl.FRAMEBUFFER, glAttachment, dst.glTarget, dst.glTexture, 0);
            } else {
              gl.framebufferRenderbuffer(gl.FRAMEBUFFER, glAttachment, gl.RENDERBUFFER, dst.glRenderbuffer);
            }
            gpuFramebuffer.width = Math.min(gpuFramebuffer.width, dst.width);
            gpuFramebuffer.height = Math.min(gpuFramebuffer.height, dst.height);
          }
          if (device.extensions.WEBGL_draw_buffers) {
            device.extensions.WEBGL_draw_buffers.drawBuffersWEBGL(attachments);
          }
          const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
          if (status !== gl.FRAMEBUFFER_COMPLETE) {
            switch (status) {
              case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                {
                  error('glCheckFramebufferStatus() - FRAMEBUFFER_INCOMPLETE_ATTACHMENT');
                  break;
                }
              case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                {
                  error('glCheckFramebufferStatus() - FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT');
                  break;
                }
              case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                {
                  error('glCheckFramebufferStatus() - FRAMEBUFFER_INCOMPLETE_DIMENSIONS');
                  break;
                }
              case gl.FRAMEBUFFER_UNSUPPORTED:
                {
                  error('glCheckFramebufferStatus() - FRAMEBUFFER_UNSUPPORTED');
                  break;
                }
            }
          }
          if (device.stateCache.glFramebuffer !== gpuFramebuffer.glFramebuffer) {
            gl.bindFramebuffer(gl.FRAMEBUFFER, device.stateCache.glFramebuffer);
          }
        }
      }
      function WebGLCmdFuncDestroyFramebuffer(device, gpuFramebuffer) {
        if (gpuFramebuffer.glFramebuffer) {
          device.gl.deleteFramebuffer(gpuFramebuffer.glFramebuffer);
          if (device.stateCache.glFramebuffer === gpuFramebuffer.glFramebuffer) {
            device.gl.bindFramebuffer(device.gl.FRAMEBUFFER, null);
            device.stateCache.glFramebuffer = null;
          }
          gpuFramebuffer.glFramebuffer = null;
        }
      }
      function WebGLCmdFuncCreateShader(device, gpuShader) {
        const {
          gl
        } = device;
        for (let k = 0; k < gpuShader.gpuStages.length; k++) {
          const gpuStage = gpuShader.gpuStages[k];
          let glShaderType = 0;
          let shaderTypeStr = '';
          let lineNumber = 1;
          switch (gpuStage.type) {
            case ShaderStageFlagBit.VERTEX:
              {
                shaderTypeStr = 'VertexShader';
                glShaderType = gl.VERTEX_SHADER;
                break;
              }
            case ShaderStageFlagBit.FRAGMENT:
              {
                shaderTypeStr = 'FragmentShader';
                glShaderType = gl.FRAGMENT_SHADER;
                break;
              }
            default:
              {
                error('Unsupported ShaderType.');
                return;
              }
          }
          const glShader = gl.createShader(glShaderType);
          if (glShader) {
            gpuStage.glShader = glShader;
            gl.shaderSource(gpuStage.glShader, gpuStage.source);
            gl.compileShader(gpuStage.glShader);
            if (!gl.getShaderParameter(gpuStage.glShader, gl.COMPILE_STATUS)) {
              error(`${shaderTypeStr} in '${gpuShader.name}' compilation failed.`);
              error('Shader source dump:', gpuStage.source.replace(/^|\n/g, () => `\n${lineNumber++} `));
              error(gl.getShaderInfoLog(gpuStage.glShader));
              for (let l = 0; l < gpuShader.gpuStages.length; l++) {
                const stage = gpuShader.gpuStages[k];
                if (stage.glShader) {
                  gl.deleteShader(stage.glShader);
                  stage.glShader = null;
                }
              }
              return;
            }
          }
        }
        const glProgram = gl.createProgram();
        if (!glProgram) {
          return;
        }
        gpuShader.glProgram = glProgram;
        for (let k = 0; k < gpuShader.gpuStages.length; k++) {
          const gpuStage = gpuShader.gpuStages[k];
          gl.attachShader(gpuShader.glProgram, gpuStage.glShader);
        }
        gl.linkProgram(gpuShader.glProgram);
        if (device.extensions.destroyShadersImmediately) {
          for (let k = 0; k < gpuShader.gpuStages.length; k++) {
            const gpuStage = gpuShader.gpuStages[k];
            if (gpuStage.glShader) {
              gl.detachShader(gpuShader.glProgram, gpuStage.glShader);
              gl.deleteShader(gpuStage.glShader);
              gpuStage.glShader = null;
            }
          }
        }
        if (gl.getProgramParameter(gpuShader.glProgram, gl.LINK_STATUS)) {
          debug(`Shader '${gpuShader.name}' compilation succeeded.`);
        } else {
          error(`Failed to link shader '${gpuShader.name}'.`);
          error(gl.getProgramInfoLog(gpuShader.glProgram));
          return;
        }
        const activeAttribCount = gl.getProgramParameter(gpuShader.glProgram, gl.ACTIVE_ATTRIBUTES);
        gpuShader.glInputs = new Array(activeAttribCount);
        for (let i = 0; i < activeAttribCount; ++i) {
          const attribInfo = gl.getActiveAttrib(gpuShader.glProgram, i);
          if (attribInfo) {
            let varName;
            const nameOffset = attribInfo.name.indexOf('[');
            if (nameOffset !== -1) {
              varName = attribInfo.name.substr(0, nameOffset);
            } else {
              varName = attribInfo.name;
            }
            const glLoc = gl.getAttribLocation(gpuShader.glProgram, varName);
            const type = WebGLTypeToGFXType$1(attribInfo.type, gl);
            const stride = WebGLGetTypeSize$1(attribInfo.type, gl);
            gpuShader.glInputs[i] = {
              binding: glLoc,
              name: varName,
              type,
              stride,
              count: attribInfo.size,
              size: stride * attribInfo.size,
              glType: attribInfo.type,
              glLoc
            };
          }
        }
        if (gpuShader.blocks.length > 0) {
          gpuShader.glBlocks = new Array(gpuShader.blocks.length);
          for (let i = 0; i < gpuShader.blocks.length; ++i) {
            const block = gpuShader.blocks[i];
            const glBlock = {
              set: block.set,
              binding: block.binding,
              name: block.name,
              size: 0,
              glUniforms: new Array(block.members.length),
              glActiveUniforms: []
            };
            gpuShader.glBlocks[i] = glBlock;
            for (let u = 0; u < block.members.length; ++u) {
              const uniform = block.members[u];
              const glType = GFXTypeToWebGLType$1(uniform.type, gl);
              const stride = WebGLGetTypeSize$1(glType, gl);
              const size = stride * uniform.count;
              glBlock.glUniforms[u] = {
                binding: -1,
                name: uniform.name,
                type: uniform.type,
                stride,
                count: uniform.count,
                size,
                offset: 0,
                glType,
                glLoc: null,
                array: null
              };
            }
          }
        }
        for (let i = 0; i < gpuShader.subpassInputs.length; ++i) {
          const subpassInput = gpuShader.subpassInputs[i];
          gpuShader.samplerTextures.push(new UniformSamplerTexture(subpassInput.set, subpassInput.binding, subpassInput.name, Type$1.SAMPLER2D, subpassInput.count));
        }
        if (gpuShader.samplerTextures.length > 0) {
          gpuShader.glSamplerTextures = new Array(gpuShader.samplerTextures.length);
          for (let i = 0; i < gpuShader.samplerTextures.length; ++i) {
            const sampler = gpuShader.samplerTextures[i];
            gpuShader.glSamplerTextures[i] = {
              set: sampler.set,
              binding: sampler.binding,
              name: sampler.name,
              type: sampler.type,
              count: sampler.count,
              units: [],
              glUnits: null,
              glType: GFXTypeToWebGLType$1(sampler.type, gl),
              glLoc: null
            };
          }
        }
        const activeUniformCount = gl.getProgramParameter(gpuShader.glProgram, gl.ACTIVE_UNIFORMS);
        for (let i = 0; i < activeUniformCount; ++i) {
          const uniformInfo = gl.getActiveUniform(gpuShader.glProgram, i);
          if (uniformInfo) {
            const isSampler = uniformInfo.type === gl.SAMPLER_2D || uniformInfo.type === gl.SAMPLER_CUBE;
            if (!isSampler) {
              const glLoc = gl.getUniformLocation(gpuShader.glProgram, uniformInfo.name);
              if (device.extensions.isLocationActive(glLoc)) {
                let varName;
                const nameOffset = uniformInfo.name.indexOf('[');
                if (nameOffset !== -1) {
                  varName = uniformInfo.name.substr(0, nameOffset);
                } else {
                  varName = uniformInfo.name;
                }
                for (let j = 0; j < gpuShader.glBlocks.length; j++) {
                  const glBlock = gpuShader.glBlocks[j];
                  for (let k = 0; k < glBlock.glUniforms.length; k++) {
                    const glUniform = glBlock.glUniforms[k];
                    if (glUniform.name === varName) {
                      glUniform.glLoc = glLoc;
                      glUniform.count = uniformInfo.size;
                      glUniform.size = glUniform.stride * glUniform.count;
                      glUniform.array = new (GFXTypeToTypedArrayCtor(glUniform.type))(glUniform.size / 4);
                      glBlock.glActiveUniforms.push(glUniform);
                      break;
                    }
                  }
                }
              }
            }
          }
        }
        for (let j = 0; j < gpuShader.glBlocks.length; j++) {
          const glBlock = gpuShader.glBlocks[j];
          for (let k = 0; k < glBlock.glUniforms.length; k++) {
            const glUniform = glBlock.glUniforms[k];
            glUniform.offset = glBlock.size / 4;
            glBlock.size += glUniform.size;
          }
        }
        const glActiveSamplers = [];
        const glActiveSamplerLocations = [];
        const {
          bindingMappings
        } = device;
        const {
          texUnitCacheMap
        } = device.stateCache;
        if (!(legacyCC.rendering && legacyCC.rendering.enableEffectImport)) {
          let flexibleSetBaseOffset = 0;
          for (let i = 0; i < gpuShader.blocks.length; ++i) {
            if (gpuShader.blocks[i].set === bindingMappings.flexibleSet) {
              flexibleSetBaseOffset++;
            }
          }
          let arrayOffset = 0;
          for (let i = 0; i < gpuShader.samplerTextures.length; ++i) {
            const sampler = gpuShader.samplerTextures[i];
            const glLoc = gl.getUniformLocation(gpuShader.glProgram, sampler.name);
            if (device.extensions.isLocationActive(glLoc)) {
              glActiveSamplers.push(gpuShader.glSamplerTextures[i]);
              glActiveSamplerLocations.push(glLoc);
            }
            if (texUnitCacheMap[sampler.name] === undefined) {
              let binding = sampler.binding + bindingMappings.samplerTextureOffsets[sampler.set] + arrayOffset;
              if (sampler.set === bindingMappings.flexibleSet) {
                binding -= flexibleSetBaseOffset;
              }
              texUnitCacheMap[sampler.name] = binding % device.capabilities.maxTextureUnits;
              arrayOffset += sampler.count - 1;
            }
          }
        } else {
          for (let i = 0; i < gpuShader.samplerTextures.length; ++i) {
            const sampler = gpuShader.samplerTextures[i];
            const glLoc = gl.getUniformLocation(gpuShader.glProgram, sampler.name);
            if (device.extensions.isLocationActive(glLoc)) {
              glActiveSamplers.push(gpuShader.glSamplerTextures[i]);
              glActiveSamplerLocations.push(glLoc);
            }
            if (texUnitCacheMap[sampler.name] === undefined) {
              texUnitCacheMap[sampler.name] = sampler.flattened % device.capabilities.maxTextureUnits;
            }
          }
        }
        if (glActiveSamplers.length) {
          const usedTexUnits = [];
          for (let i = 0; i < glActiveSamplers.length; ++i) {
            const glSampler = glActiveSamplers[i];
            let cachedUnit = texUnitCacheMap[glSampler.name];
            if (cachedUnit !== undefined) {
              glSampler.glLoc = glActiveSamplerLocations[i];
              for (let t = 0; t < glSampler.count; ++t) {
                while (usedTexUnits[cachedUnit]) {
                  cachedUnit = (cachedUnit + 1) % device.capabilities.maxTextureUnits;
                }
                glSampler.units.push(cachedUnit);
                usedTexUnits[cachedUnit] = true;
              }
            }
          }
          let unitIdx = 0;
          for (let i = 0; i < glActiveSamplers.length; ++i) {
            const glSampler = glActiveSamplers[i];
            if (!device.extensions.isLocationActive(glSampler.glLoc)) {
              glSampler.glLoc = glActiveSamplerLocations[i];
              for (let t = 0; t < glSampler.count; ++t) {
                while (usedTexUnits[unitIdx]) {
                  unitIdx = (unitIdx + 1) % device.capabilities.maxTextureUnits;
                }
                if (texUnitCacheMap[glSampler.name] === undefined) {
                  texUnitCacheMap[glSampler.name] = unitIdx;
                }
                glSampler.units.push(unitIdx);
                usedTexUnits[unitIdx] = true;
              }
            }
          }
          if (device.stateCache.glProgram !== gpuShader.glProgram) {
            gl.useProgram(gpuShader.glProgram);
          }
          for (let i = 0; i < glActiveSamplers.length; i++) {
            const glSampler = glActiveSamplers[i];
            glSampler.glUnits = new Int32Array(glSampler.units);
            gl.uniform1iv(glSampler.glLoc, glSampler.glUnits);
          }
          if (device.stateCache.glProgram !== gpuShader.glProgram) {
            gl.useProgram(device.stateCache.glProgram);
          }
        }
        for (let i = 0; i < gpuShader.glBlocks.length;) {
          if (gpuShader.glBlocks[i].glActiveUniforms.length) {
            i++;
          } else {
            gpuShader.glBlocks[i] = gpuShader.glBlocks[gpuShader.glBlocks.length - 1];
            gpuShader.glBlocks.length--;
          }
        }
        gpuShader.glSamplerTextures = glActiveSamplers;
      }
      function WebGLCmdFuncDestroyShader(device, gpuShader) {
        if (gpuShader.glProgram) {
          const {
            gl
          } = device;
          if (!device.extensions.destroyShadersImmediately) {
            for (let k = 0; k < gpuShader.gpuStages.length; k++) {
              const gpuStage = gpuShader.gpuStages[k];
              if (gpuStage.glShader) {
                gl.detachShader(gpuShader.glProgram, gpuStage.glShader);
                gl.deleteShader(gpuStage.glShader);
                gpuStage.glShader = null;
              }
            }
          }
          gl.deleteProgram(gpuShader.glProgram);
          if (device.stateCache.glProgram === gpuShader.glProgram) {
            device.gl.useProgram(null);
            device.stateCache.glProgram = null;
          }
          gpuShader.glProgram = null;
        }
      }
      function WebGLCmdFuncCreateInputAssember(device, gpuInputAssembler) {
        const {
          gl
        } = device;
        gpuInputAssembler.glAttribs = new Array(gpuInputAssembler.attributes.length);
        const offsets = [0, 0, 0, 0, 0, 0, 0, 0];
        for (let i = 0; i < gpuInputAssembler.attributes.length; ++i) {
          const attrib = gpuInputAssembler.attributes[i];
          const stream = attrib.stream !== undefined ? attrib.stream : 0;
          const gpuBuffer = gpuInputAssembler.gpuVertexBuffers[stream];
          const glType = GFXFormatToWebGLType$1(attrib.format, gl);
          const {
            size
          } = FormatInfos[attrib.format];
          gpuInputAssembler.glAttribs[i] = {
            name: attrib.name,
            glBuffer: gpuBuffer.glBuffer,
            glType,
            size,
            count: FormatInfos[attrib.format].count,
            stride: gpuBuffer.stride,
            componentCount: WebGLGetComponentCount$1(glType, gl),
            isNormalized: attrib.isNormalized !== undefined ? attrib.isNormalized : false,
            isInstanced: attrib.isInstanced !== undefined ? attrib.isInstanced : false,
            offset: offsets[stream]
          };
          offsets[stream] += size;
        }
      }
      function WebGLCmdFuncDestroyInputAssembler(device, gpuInputAssembler) {
        const it = gpuInputAssembler.glVAOs.values();
        let res = it.next();
        const OES_vertex_array_object = device.extensions.OES_vertex_array_object;
        let glVAO = device.stateCache.glVAO;
        while (!res.done) {
          OES_vertex_array_object.deleteVertexArrayOES(res.value);
          if (glVAO === res.value) {
            OES_vertex_array_object.bindVertexArrayOES(null);
            glVAO = null;
          }
          res = it.next();
        }
        device.stateCache.glVAO = glVAO;
        gpuInputAssembler.glVAOs.clear();
      }
      const gfxStateCache$1 = {
        gpuPipelineState: null,
        gpuInputAssembler: null,
        glPrimitive: 0
      };
      const realRenderArea = new Rect();
      function WebGLCmdFuncBeginRenderPass(device, gpuRenderPass, gpuFramebuffer, renderArea, clearColors, clearDepth, clearStencil) {
        const {
          gl
        } = device;
        const cache = device.stateCache;
        let clears = 0;
        if (gpuFramebuffer) {
          realRenderArea.x = renderArea.x << gpuFramebuffer.lodLevel;
          realRenderArea.y = renderArea.y << gpuFramebuffer.lodLevel;
          realRenderArea.width = renderArea.width << gpuFramebuffer.lodLevel;
          realRenderArea.height = renderArea.height << gpuFramebuffer.lodLevel;
        }
        if (gpuFramebuffer && gpuRenderPass) {
          if (cache.glFramebuffer !== gpuFramebuffer.glFramebuffer) {
            gl.bindFramebuffer(gl.FRAMEBUFFER, gpuFramebuffer.glFramebuffer);
            cache.glFramebuffer = gpuFramebuffer.glFramebuffer;
          }
          if (cache.viewport.left !== realRenderArea.x || cache.viewport.top !== realRenderArea.y || cache.viewport.width !== realRenderArea.width || cache.viewport.height !== realRenderArea.height) {
            gl.viewport(realRenderArea.x, realRenderArea.y, realRenderArea.width, realRenderArea.height);
            cache.viewport.left = realRenderArea.x;
            cache.viewport.top = realRenderArea.y;
            cache.viewport.width = realRenderArea.width;
            cache.viewport.height = realRenderArea.height;
          }
          if (cache.scissorRect.x !== realRenderArea.x || cache.scissorRect.y !== realRenderArea.y || cache.scissorRect.width !== realRenderArea.width || cache.scissorRect.height !== realRenderArea.height) {
            gl.scissor(realRenderArea.x, realRenderArea.y, realRenderArea.width, realRenderArea.height);
            cache.scissorRect.x = realRenderArea.x;
            cache.scissorRect.y = realRenderArea.y;
            cache.scissorRect.width = realRenderArea.width;
            cache.scissorRect.height = realRenderArea.height;
          }
          let clearCount = clearColors.length;
          if (!device.extensions.WEBGL_draw_buffers) {
            clearCount = 1;
          }
          for (let j = 0; j < clearCount; ++j) {
            const colorAttachment = gpuRenderPass.colorAttachments[j];
            if (colorAttachment.format !== Format.UNKNOWN) {
              switch (colorAttachment.loadOp) {
                case LoadOp.LOAD:
                  break;
                case LoadOp.CLEAR:
                  {
                    if (cache.bs.targets[0].blendColorMask !== ColorMask.ALL) {
                      gl.colorMask(true, true, true, true);
                    }
                    const clearColor = clearColors[0];
                    gl.clearColor(clearColor.x, clearColor.y, clearColor.z, clearColor.w);
                    clears |= gl.COLOR_BUFFER_BIT;
                    break;
                  }
                case LoadOp.DISCARD:
                  {
                    break;
                  }
              }
            }
          }
          if (gpuRenderPass.depthStencilAttachment) {
            if (gpuRenderPass.depthStencilAttachment.format !== Format.UNKNOWN) {
              switch (gpuRenderPass.depthStencilAttachment.depthLoadOp) {
                case LoadOp.LOAD:
                  break;
                case LoadOp.CLEAR:
                  {
                    if (!cache.dss.depthWrite) {
                      gl.depthMask(true);
                    }
                    gl.clearDepth(clearDepth);
                    clears |= gl.DEPTH_BUFFER_BIT;
                    break;
                  }
                case LoadOp.DISCARD:
                  {
                    break;
                  }
              }
              if (FormatInfos[gpuRenderPass.depthStencilAttachment.format].hasStencil) {
                switch (gpuRenderPass.depthStencilAttachment.stencilLoadOp) {
                  case LoadOp.LOAD:
                    break;
                  case LoadOp.CLEAR:
                    {
                      if (!cache.dss.stencilWriteMaskFront) {
                        gl.stencilMaskSeparate(gl.FRONT, 0xffff);
                      }
                      if (!cache.dss.stencilWriteMaskBack) {
                        gl.stencilMaskSeparate(gl.BACK, 0xffff);
                      }
                      gl.clearStencil(clearStencil);
                      clears |= gl.STENCIL_BUFFER_BIT;
                      break;
                    }
                  case LoadOp.DISCARD:
                    {
                      break;
                    }
                }
              }
            }
          }
          if (clears) {
            gl.clear(clears);
          }
          if (clears & gl.COLOR_BUFFER_BIT) {
            const colorMask = cache.bs.targets[0].blendColorMask;
            if (colorMask !== ColorMask.ALL) {
              const r = (colorMask & ColorMask.R) !== ColorMask.NONE;
              const g = (colorMask & ColorMask.G) !== ColorMask.NONE;
              const b = (colorMask & ColorMask.B) !== ColorMask.NONE;
              const a = (colorMask & ColorMask.A) !== ColorMask.NONE;
              gl.colorMask(r, g, b, a);
            }
          }
          if (clears & gl.DEPTH_BUFFER_BIT && !cache.dss.depthWrite) {
            gl.depthMask(false);
          }
          if (clears & gl.STENCIL_BUFFER_BIT) {
            if (!cache.dss.stencilWriteMaskFront) {
              gl.stencilMaskSeparate(gl.FRONT, 0);
            }
            if (!cache.dss.stencilWriteMaskBack) {
              gl.stencilMaskSeparate(gl.BACK, 0);
            }
          }
        }
      }
      function WebGLCmdFuncBindStates(device, gpuPipelineState, gpuInputAssembler, gpuDescriptorSets, dynamicOffsets, dynamicStates) {
        const {
          gl
        } = device;
        const cache = device.stateCache;
        const gpuShader = gpuPipelineState && gpuPipelineState.gpuShader;
        let isShaderChanged = false;
        let glWrapS;
        let glWrapT;
        let glMinFilter;
        if (gpuPipelineState && gfxStateCache$1.gpuPipelineState !== gpuPipelineState) {
          gfxStateCache$1.gpuPipelineState = gpuPipelineState;
          gfxStateCache$1.glPrimitive = gpuPipelineState.glPrimitive;
          if (gpuPipelineState.gpuShader) {
            const {
              glProgram
            } = gpuPipelineState.gpuShader;
            if (cache.glProgram !== glProgram) {
              gl.useProgram(glProgram);
              cache.glProgram = glProgram;
              isShaderChanged = true;
            }
          }
          const {
            rs
          } = gpuPipelineState;
          if (rs) {
            if (cache.rs.cullMode !== rs.cullMode) {
              switch (rs.cullMode) {
                case CullMode.NONE:
                  {
                    gl.disable(gl.CULL_FACE);
                    break;
                  }
                case CullMode.FRONT:
                  {
                    gl.enable(gl.CULL_FACE);
                    gl.cullFace(gl.FRONT);
                    break;
                  }
                case CullMode.BACK:
                  {
                    gl.enable(gl.CULL_FACE);
                    gl.cullFace(gl.BACK);
                    break;
                  }
              }
              cache.rs.cullMode = rs.cullMode;
            }
            const isFrontFaceCCW = rs.isFrontFaceCCW;
            if (cache.rs.isFrontFaceCCW !== isFrontFaceCCW) {
              gl.frontFace(isFrontFaceCCW ? gl.CCW : gl.CW);
              cache.rs.isFrontFaceCCW = isFrontFaceCCW;
            }
            if (cache.rs.depthBias !== rs.depthBias || cache.rs.depthBiasSlop !== rs.depthBiasSlop) {
              gl.polygonOffset(rs.depthBias, rs.depthBiasSlop);
              cache.rs.depthBias = rs.depthBias;
              cache.rs.depthBiasSlop = rs.depthBiasSlop;
            }
            if (cache.rs.lineWidth !== rs.lineWidth) {
              gl.lineWidth(rs.lineWidth);
              cache.rs.lineWidth = rs.lineWidth;
            }
          }
          const {
            dss
          } = gpuPipelineState;
          if (dss) {
            if (cache.dss.depthTest !== dss.depthTest) {
              if (dss.depthTest) {
                gl.enable(gl.DEPTH_TEST);
              } else {
                gl.disable(gl.DEPTH_TEST);
              }
              cache.dss.depthTest = dss.depthTest;
            }
            if (cache.dss.depthWrite !== dss.depthWrite) {
              gl.depthMask(dss.depthWrite);
              cache.dss.depthWrite = dss.depthWrite;
            }
            if (cache.dss.depthFunc !== dss.depthFunc) {
              gl.depthFunc(WebGLCmpFuncs$1[dss.depthFunc]);
              cache.dss.depthFunc = dss.depthFunc;
            }
            if (cache.dss.stencilTestFront !== dss.stencilTestFront || cache.dss.stencilTestBack !== dss.stencilTestBack) {
              if (dss.stencilTestFront || dss.stencilTestBack) {
                gl.enable(gl.STENCIL_TEST);
              } else {
                gl.disable(gl.STENCIL_TEST);
              }
              cache.dss.stencilTestFront = dss.stencilTestFront;
              cache.dss.stencilTestBack = dss.stencilTestBack;
            }
            if (cache.dss.stencilFuncFront !== dss.stencilFuncFront || cache.dss.stencilRefFront !== dss.stencilRefFront || cache.dss.stencilReadMaskFront !== dss.stencilReadMaskFront) {
              gl.stencilFuncSeparate(gl.FRONT, WebGLCmpFuncs$1[dss.stencilFuncFront], dss.stencilRefFront, dss.stencilReadMaskFront);
              cache.dss.stencilFuncFront = dss.stencilFuncFront;
              cache.dss.stencilRefFront = dss.stencilRefFront;
              cache.dss.stencilReadMaskFront = dss.stencilReadMaskFront;
            }
            if (cache.dss.stencilFailOpFront !== dss.stencilFailOpFront || cache.dss.stencilZFailOpFront !== dss.stencilZFailOpFront || cache.dss.stencilPassOpFront !== dss.stencilPassOpFront) {
              gl.stencilOpSeparate(gl.FRONT, WebGLStencilOps$1[dss.stencilFailOpFront], WebGLStencilOps$1[dss.stencilZFailOpFront], WebGLStencilOps$1[dss.stencilPassOpFront]);
              cache.dss.stencilFailOpFront = dss.stencilFailOpFront;
              cache.dss.stencilZFailOpFront = dss.stencilZFailOpFront;
              cache.dss.stencilPassOpFront = dss.stencilPassOpFront;
            }
            if (cache.dss.stencilWriteMaskFront !== dss.stencilWriteMaskFront) {
              gl.stencilMaskSeparate(gl.FRONT, dss.stencilWriteMaskFront);
              cache.dss.stencilWriteMaskFront = dss.stencilWriteMaskFront;
            }
            if (cache.dss.stencilFuncBack !== dss.stencilFuncBack || cache.dss.stencilRefBack !== dss.stencilRefBack || cache.dss.stencilReadMaskBack !== dss.stencilReadMaskBack) {
              gl.stencilFuncSeparate(gl.BACK, WebGLCmpFuncs$1[dss.stencilFuncBack], dss.stencilRefBack, dss.stencilReadMaskBack);
              cache.dss.stencilFuncBack = dss.stencilFuncBack;
              cache.dss.stencilRefBack = dss.stencilRefBack;
              cache.dss.stencilReadMaskBack = dss.stencilReadMaskBack;
            }
            if (cache.dss.stencilFailOpBack !== dss.stencilFailOpBack || cache.dss.stencilZFailOpBack !== dss.stencilZFailOpBack || cache.dss.stencilPassOpBack !== dss.stencilPassOpBack) {
              gl.stencilOpSeparate(gl.BACK, WebGLStencilOps$1[dss.stencilFailOpBack], WebGLStencilOps$1[dss.stencilZFailOpBack], WebGLStencilOps$1[dss.stencilPassOpBack]);
              cache.dss.stencilFailOpBack = dss.stencilFailOpBack;
              cache.dss.stencilZFailOpBack = dss.stencilZFailOpBack;
              cache.dss.stencilPassOpBack = dss.stencilPassOpBack;
            }
            if (cache.dss.stencilWriteMaskBack !== dss.stencilWriteMaskBack) {
              gl.stencilMaskSeparate(gl.BACK, dss.stencilWriteMaskBack);
              cache.dss.stencilWriteMaskBack = dss.stencilWriteMaskBack;
            }
          }
          const {
            bs
          } = gpuPipelineState;
          if (bs) {
            if (cache.bs.isA2C !== bs.isA2C) {
              if (bs.isA2C) {
                gl.enable(gl.SAMPLE_ALPHA_TO_COVERAGE);
              } else {
                gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
              }
              cache.bs.isA2C = bs.isA2C;
            }
            if (cache.bs.blendColor.x !== bs.blendColor.x || cache.bs.blendColor.y !== bs.blendColor.y || cache.bs.blendColor.z !== bs.blendColor.z || cache.bs.blendColor.w !== bs.blendColor.w) {
              gl.blendColor(bs.blendColor.x, bs.blendColor.y, bs.blendColor.z, bs.blendColor.w);
              cache.bs.blendColor.x = bs.blendColor.x;
              cache.bs.blendColor.y = bs.blendColor.y;
              cache.bs.blendColor.z = bs.blendColor.z;
              cache.bs.blendColor.w = bs.blendColor.w;
            }
            const target0 = bs.targets[0];
            const target0Cache = cache.bs.targets[0];
            if (target0Cache.blend !== target0.blend) {
              if (target0.blend) {
                gl.enable(gl.BLEND);
              } else {
                gl.disable(gl.BLEND);
              }
              target0Cache.blend = target0.blend;
            }
            if (target0Cache.blendEq !== target0.blendEq || target0Cache.blendAlphaEq !== target0.blendAlphaEq) {
              gl.blendEquationSeparate(WebGLBlendOps$1[target0.blendEq], WebGLBlendOps$1[target0.blendAlphaEq]);
              target0Cache.blendEq = target0.blendEq;
              target0Cache.blendAlphaEq = target0.blendAlphaEq;
            }
            if (target0Cache.blendSrc !== target0.blendSrc || target0Cache.blendDst !== target0.blendDst || target0Cache.blendSrcAlpha !== target0.blendSrcAlpha || target0Cache.blendDstAlpha !== target0.blendDstAlpha) {
              gl.blendFuncSeparate(WebGLBlendFactors$1[target0.blendSrc], WebGLBlendFactors$1[target0.blendDst], WebGLBlendFactors$1[target0.blendSrcAlpha], WebGLBlendFactors$1[target0.blendDstAlpha]);
              target0Cache.blendSrc = target0.blendSrc;
              target0Cache.blendDst = target0.blendDst;
              target0Cache.blendSrcAlpha = target0.blendSrcAlpha;
              target0Cache.blendDstAlpha = target0.blendDstAlpha;
            }
            if (target0Cache.blendColorMask !== target0.blendColorMask) {
              gl.colorMask((target0.blendColorMask & ColorMask.R) !== ColorMask.NONE, (target0.blendColorMask & ColorMask.G) !== ColorMask.NONE, (target0.blendColorMask & ColorMask.B) !== ColorMask.NONE, (target0.blendColorMask & ColorMask.A) !== ColorMask.NONE);
              target0Cache.blendColorMask = target0.blendColorMask;
            }
          }
        }
        if (gpuPipelineState && gpuPipelineState.gpuPipelineLayout && gpuShader) {
          const blockLen = gpuShader.glBlocks.length;
          const {
            dynamicOffsetIndices
          } = gpuPipelineState.gpuPipelineLayout;
          for (let j = 0; j < blockLen; j++) {
            const glBlock = gpuShader.glBlocks[j];
            const gpuDescriptorSet = gpuDescriptorSets[glBlock.set];
            const descriptorIdx = gpuDescriptorSet && gpuDescriptorSet.descriptorIndices[glBlock.binding];
            const gpuDescriptor = descriptorIdx >= 0 && gpuDescriptorSet.gpuDescriptors[descriptorIdx];
            let vf32 = null;
            let offset = 0;
            if (gpuDescriptor && gpuDescriptor.gpuBuffer) {
              const {
                gpuBuffer
              } = gpuDescriptor;
              const dynamicOffsetIndexSet = dynamicOffsetIndices[glBlock.set];
              const dynamicOffsetIndex = dynamicOffsetIndexSet && dynamicOffsetIndexSet[glBlock.binding];
              if (dynamicOffsetIndex >= 0) {
                offset = dynamicOffsets[dynamicOffsetIndex];
              }
              if ('vf32' in gpuBuffer) {
                vf32 = gpuBuffer.vf32;
              } else {
                offset += gpuBuffer.offset;
                vf32 = gpuBuffer.gpuBuffer.vf32;
              }
              offset >>= 2;
            }
            if (!vf32) {
              continue;
            }
            const uniformLen = glBlock.glActiveUniforms.length;
            for (let l = 0; l < uniformLen; l++) {
              const glUniform = glBlock.glActiveUniforms[l];
              switch (glUniform.glType) {
                case gl.BOOL:
                case gl.INT:
                  {
                    for (let u = 0; u < glUniform.array.length; ++u) {
                      const idx = glUniform.offset + offset + u;
                      if (vf32[idx] !== glUniform.array[u]) {
                        for (let n = u, m = idx; n < glUniform.array.length; ++n, ++m) {
                          glUniform.array[n] = vf32[m];
                        }
                        gl.uniform1iv(glUniform.glLoc, glUniform.array);
                        break;
                      }
                    }
                    break;
                  }
                case gl.BOOL_VEC2:
                case gl.INT_VEC2:
                  {
                    for (let u = 0; u < glUniform.array.length; ++u) {
                      const idx = glUniform.offset + offset + u;
                      if (vf32[idx] !== glUniform.array[u]) {
                        for (let n = u, m = idx; n < glUniform.array.length; ++n, ++m) {
                          glUniform.array[n] = vf32[m];
                        }
                        gl.uniform2iv(glUniform.glLoc, glUniform.array);
                        break;
                      }
                    }
                    break;
                  }
                case gl.BOOL_VEC3:
                case gl.INT_VEC3:
                  {
                    for (let u = 0; u < glUniform.array.length; ++u) {
                      const idx = glUniform.offset + offset + u;
                      if (vf32[idx] !== glUniform.array[u]) {
                        for (let n = u, m = idx; n < glUniform.array.length; ++n, ++m) {
                          glUniform.array[n] = vf32[m];
                        }
                        gl.uniform3iv(glUniform.glLoc, glUniform.array);
                        break;
                      }
                    }
                    break;
                  }
                case gl.BOOL_VEC4:
                case gl.INT_VEC4:
                  {
                    for (let u = 0; u < glUniform.array.length; ++u) {
                      const idx = glUniform.offset + offset + u;
                      if (vf32[idx] !== glUniform.array[u]) {
                        for (let n = u, m = idx; n < glUniform.array.length; ++n, ++m) {
                          glUniform.array[n] = vf32[m];
                        }
                        gl.uniform4iv(glUniform.glLoc, glUniform.array);
                        break;
                      }
                    }
                    break;
                  }
                case gl.FLOAT:
                  {
                    for (let u = 0; u < glUniform.array.length; ++u) {
                      const idx = glUniform.offset + offset + u;
                      if (vf32[idx] !== glUniform.array[u]) {
                        for (let n = u, m = idx; n < glUniform.array.length; ++n, ++m) {
                          glUniform.array[n] = vf32[m];
                        }
                        gl.uniform1fv(glUniform.glLoc, glUniform.array);
                        break;
                      }
                    }
                    break;
                  }
                case gl.FLOAT_VEC2:
                  {
                    for (let u = 0; u < glUniform.array.length; ++u) {
                      const idx = glUniform.offset + offset + u;
                      if (vf32[idx] !== glUniform.array[u]) {
                        for (let n = u, m = idx; n < glUniform.array.length; ++n, ++m) {
                          glUniform.array[n] = vf32[m];
                        }
                        gl.uniform2fv(glUniform.glLoc, glUniform.array);
                        break;
                      }
                    }
                    break;
                  }
                case gl.FLOAT_VEC3:
                  {
                    for (let u = 0; u < glUniform.array.length; ++u) {
                      const idx = glUniform.offset + offset + u;
                      if (vf32[idx] !== glUniform.array[u]) {
                        for (let n = u, m = idx; n < glUniform.array.length; ++n, ++m) {
                          glUniform.array[n] = vf32[m];
                        }
                        gl.uniform3fv(glUniform.glLoc, glUniform.array);
                        break;
                      }
                    }
                    break;
                  }
                case gl.FLOAT_VEC4:
                  {
                    for (let u = 0; u < glUniform.array.length; ++u) {
                      const idx = glUniform.offset + offset + u;
                      if (vf32[idx] !== glUniform.array[u]) {
                        for (let n = u, m = idx; n < glUniform.array.length; ++n, ++m) {
                          glUniform.array[n] = vf32[m];
                        }
                        gl.uniform4fv(glUniform.glLoc, glUniform.array);
                        break;
                      }
                    }
                    break;
                  }
                case gl.FLOAT_MAT2:
                  {
                    for (let u = 0; u < glUniform.array.length; ++u) {
                      const idx = glUniform.offset + offset + u;
                      if (vf32[idx] !== glUniform.array[u]) {
                        for (let n = u, m = idx; n < glUniform.array.length; ++n, ++m) {
                          glUniform.array[n] = vf32[m];
                        }
                        gl.uniformMatrix2fv(glUniform.glLoc, false, glUniform.array);
                        break;
                      }
                    }
                    break;
                  }
                case gl.FLOAT_MAT3:
                  {
                    for (let u = 0; u < glUniform.array.length; ++u) {
                      const idx = glUniform.offset + offset + u;
                      if (vf32[idx] !== glUniform.array[u]) {
                        for (let n = u, m = idx; n < glUniform.array.length; ++n, ++m) {
                          glUniform.array[n] = vf32[m];
                        }
                        gl.uniformMatrix3fv(glUniform.glLoc, false, glUniform.array);
                        break;
                      }
                    }
                    break;
                  }
                case gl.FLOAT_MAT4:
                  {
                    for (let u = 0; u < glUniform.array.length; ++u) {
                      const idx = glUniform.offset + offset + u;
                      if (vf32[idx] !== glUniform.array[u]) {
                        for (let n = u, m = idx; n < glUniform.array.length; ++n, ++m) {
                          glUniform.array[n] = vf32[m];
                        }
                        gl.uniformMatrix4fv(glUniform.glLoc, false, glUniform.array);
                        break;
                      }
                    }
                    break;
                  }
              }
            }
            continue;
          }
          const samplerLen = gpuShader.glSamplerTextures.length;
          for (let i = 0; i < samplerLen; i++) {
            const glSampler = gpuShader.glSamplerTextures[i];
            const gpuDescriptorSet = gpuDescriptorSets[glSampler.set];
            let descriptorIndex = gpuDescriptorSet && gpuDescriptorSet.descriptorIndices[glSampler.binding];
            let gpuDescriptor = descriptorIndex >= 0 && gpuDescriptorSet.gpuDescriptors[descriptorIndex];
            const texUnitLen = glSampler.units.length;
            for (let l = 0; l < texUnitLen; l++) {
              const texUnit = glSampler.units[l];
              if (!gpuDescriptor || !gpuDescriptor.gpuSampler) {
                continue;
              }
              if (gpuDescriptor.gpuTexture && gpuDescriptor.gpuTexture.size > 0) {
                const {
                  gpuTexture
                } = gpuDescriptor;
                const glTexUnit = cache.glTexUnits[texUnit];
                if (glTexUnit.glTexture !== gpuTexture.glTexture) {
                  if (cache.texUnit !== texUnit) {
                    gl.activeTexture(gl.TEXTURE0 + texUnit);
                    cache.texUnit = texUnit;
                  }
                  if (gpuTexture.glTexture) {
                    gl.bindTexture(gpuTexture.glTarget, gpuTexture.glTexture);
                  } else {
                    gl.bindTexture(gpuTexture.glTarget, device.nullTex2D.gpuTexture.glTexture);
                  }
                  glTexUnit.glTexture = gpuTexture.glTexture;
                }
                const {
                  gpuSampler
                } = gpuDescriptor;
                if (gpuTexture.isPowerOf2) {
                  glWrapS = gpuSampler.glWrapS;
                  glWrapT = gpuSampler.glWrapT;
                } else {
                  glWrapS = gl.CLAMP_TO_EDGE;
                  glWrapT = gl.CLAMP_TO_EDGE;
                }
                if (gpuTexture.isPowerOf2) {
                  if (gpuTexture.mipLevel <= 1 && (gpuSampler.glMinFilter === gl.LINEAR_MIPMAP_NEAREST || gpuSampler.glMinFilter === gl.LINEAR_MIPMAP_LINEAR)) {
                    glMinFilter = gl.LINEAR;
                  } else {
                    glMinFilter = gpuSampler.glMinFilter;
                  }
                } else if (gpuSampler.glMinFilter === gl.LINEAR || gpuSampler.glMinFilter === gl.LINEAR_MIPMAP_NEAREST || gpuSampler.glMinFilter === gl.LINEAR_MIPMAP_LINEAR) {
                  glMinFilter = gl.LINEAR;
                } else {
                  glMinFilter = gl.NEAREST;
                }
                if (gpuTexture.glWrapS !== glWrapS) {
                  if (cache.texUnit !== texUnit) {
                    gl.activeTexture(gl.TEXTURE0 + texUnit);
                    cache.texUnit = texUnit;
                  }
                  gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_WRAP_S, glWrapS);
                  gpuTexture.glWrapS = glWrapS;
                }
                if (gpuTexture.glWrapT !== glWrapT) {
                  if (cache.texUnit !== texUnit) {
                    gl.activeTexture(gl.TEXTURE0 + texUnit);
                    cache.texUnit = texUnit;
                  }
                  gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_WRAP_T, glWrapT);
                  gpuTexture.glWrapT = glWrapT;
                }
                if (gpuTexture.glMinFilter !== glMinFilter) {
                  if (cache.texUnit !== texUnit) {
                    gl.activeTexture(gl.TEXTURE0 + texUnit);
                    cache.texUnit = texUnit;
                  }
                  gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_MIN_FILTER, glMinFilter);
                  gpuTexture.glMinFilter = glMinFilter;
                }
                if (gpuTexture.glMagFilter !== gpuSampler.glMagFilter) {
                  if (cache.texUnit !== texUnit) {
                    gl.activeTexture(gl.TEXTURE0 + texUnit);
                    cache.texUnit = texUnit;
                  }
                  gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_MAG_FILTER, gpuSampler.glMagFilter);
                  gpuTexture.glMagFilter = gpuSampler.glMagFilter;
                }
              }
              gpuDescriptor = gpuDescriptorSet.gpuDescriptors[++descriptorIndex];
            }
          }
        }
        if (gpuInputAssembler && gpuShader && (isShaderChanged || gfxStateCache$1.gpuInputAssembler !== gpuInputAssembler)) {
          gfxStateCache$1.gpuInputAssembler = gpuInputAssembler;
          const ia = device.extensions.ANGLE_instanced_arrays;
          if (device.extensions.useVAO) {
            const vao = device.extensions.OES_vertex_array_object;
            let glVAO = gpuInputAssembler.glVAOs.get(gpuShader.glProgram);
            if (!glVAO) {
              glVAO = vao.createVertexArrayOES();
              gpuInputAssembler.glVAOs.set(gpuShader.glProgram, glVAO);
              vao.bindVertexArrayOES(glVAO);
              gl.bindBuffer(gl.ARRAY_BUFFER, null);
              gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
              cache.glArrayBuffer = null;
              cache.glElementArrayBuffer = null;
              let glAttrib;
              const inputLen = gpuShader.glInputs.length;
              for (let j = 0; j < inputLen; j++) {
                const glInput = gpuShader.glInputs[j];
                glAttrib = null;
                const attribLen = gpuInputAssembler.glAttribs.length;
                for (let k = 0; k < attribLen; k++) {
                  const attrib = gpuInputAssembler.glAttribs[k];
                  if (attrib.name === glInput.name) {
                    glAttrib = attrib;
                    break;
                  }
                }
                if (glAttrib) {
                  if (cache.glArrayBuffer !== glAttrib.glBuffer) {
                    gl.bindBuffer(gl.ARRAY_BUFFER, glAttrib.glBuffer);
                    cache.glArrayBuffer = glAttrib.glBuffer;
                  }
                  for (let c = 0; c < glAttrib.componentCount; ++c) {
                    const glLoc = glInput.glLoc + c;
                    const attribOffset = glAttrib.offset + glAttrib.size * c;
                    gl.enableVertexAttribArray(glLoc);
                    cache.glCurrentAttribLocs[glLoc] = true;
                    gl.vertexAttribPointer(glLoc, glAttrib.count, glAttrib.glType, glAttrib.isNormalized, glAttrib.stride, attribOffset);
                    if (ia) {
                      ia.vertexAttribDivisorANGLE(glLoc, glAttrib.isInstanced ? 1 : 0);
                    }
                  }
                }
              }
              const gpuBuffer = gpuInputAssembler.gpuIndexBuffer;
              if (gpuBuffer) {
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.glBuffer);
              }
              vao.bindVertexArrayOES(null);
              gl.bindBuffer(gl.ARRAY_BUFFER, null);
              gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
              cache.glArrayBuffer = null;
              cache.glElementArrayBuffer = null;
            }
            if (cache.glVAO !== glVAO) {
              vao.bindVertexArrayOES(glVAO);
              cache.glVAO = glVAO;
            }
          } else {
            for (let a = 0; a < device.capabilities.maxVertexAttributes; ++a) {
              cache.glCurrentAttribLocs[a] = false;
            }
            const inputLen = gpuShader.glInputs.length;
            for (let j = 0; j < inputLen; j++) {
              const glInput = gpuShader.glInputs[j];
              let glAttrib = null;
              const attribLen = gpuInputAssembler.glAttribs.length;
              for (let k = 0; k < attribLen; k++) {
                const attrib = gpuInputAssembler.glAttribs[k];
                if (attrib.name === glInput.name) {
                  glAttrib = attrib;
                  break;
                }
              }
              if (glAttrib) {
                if (cache.glArrayBuffer !== glAttrib.glBuffer) {
                  gl.bindBuffer(gl.ARRAY_BUFFER, glAttrib.glBuffer);
                  cache.glArrayBuffer = glAttrib.glBuffer;
                }
                for (let c = 0; c < glAttrib.componentCount; ++c) {
                  const glLoc = glInput.glLoc + c;
                  const attribOffset = glAttrib.offset + glAttrib.size * c;
                  if (!cache.glEnabledAttribLocs[glLoc] && glLoc >= 0) {
                    gl.enableVertexAttribArray(glLoc);
                    cache.glEnabledAttribLocs[glLoc] = true;
                  }
                  cache.glCurrentAttribLocs[glLoc] = true;
                  gl.vertexAttribPointer(glLoc, glAttrib.count, glAttrib.glType, glAttrib.isNormalized, glAttrib.stride, attribOffset);
                  if (ia) {
                    ia.vertexAttribDivisorANGLE(glLoc, glAttrib.isInstanced ? 1 : 0);
                  }
                }
              }
            }
            const gpuBuffer = gpuInputAssembler.gpuIndexBuffer;
            if (gpuBuffer) {
              if (cache.glElementArrayBuffer !== gpuBuffer.glBuffer) {
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.glBuffer);
                cache.glElementArrayBuffer = gpuBuffer.glBuffer;
              }
            }
            for (let a = 0; a < device.capabilities.maxVertexAttributes; ++a) {
              if (cache.glEnabledAttribLocs[a] !== cache.glCurrentAttribLocs[a]) {
                gl.disableVertexAttribArray(a);
                cache.glEnabledAttribLocs[a] = false;
              }
            }
          }
        }
        if (gpuPipelineState && gpuPipelineState.dynamicStates.length) {
          const dsLen = gpuPipelineState.dynamicStates.length;
          for (let j = 0; j < dsLen; j++) {
            const dynamicState = gpuPipelineState.dynamicStates[j];
            switch (dynamicState) {
              case DynamicStateFlagBit.LINE_WIDTH:
                {
                  if (cache.rs.lineWidth !== dynamicStates.lineWidth) {
                    gl.lineWidth(dynamicStates.lineWidth);
                    cache.rs.lineWidth = dynamicStates.lineWidth;
                  }
                  break;
                }
              case DynamicStateFlagBit.DEPTH_BIAS:
                {
                  if (cache.rs.depthBias !== dynamicStates.depthBiasConstant || cache.rs.depthBiasSlop !== dynamicStates.depthBiasSlope) {
                    gl.polygonOffset(dynamicStates.depthBiasConstant, dynamicStates.depthBiasSlope);
                    cache.rs.depthBias = dynamicStates.depthBiasConstant;
                    cache.rs.depthBiasSlop = dynamicStates.depthBiasSlope;
                  }
                  break;
                }
              case DynamicStateFlagBit.BLEND_CONSTANTS:
                {
                  const blendConstant = dynamicStates.blendConstant;
                  if (cache.bs.blendColor.x !== blendConstant.x || cache.bs.blendColor.y !== blendConstant.y || cache.bs.blendColor.z !== blendConstant.z || cache.bs.blendColor.w !== blendConstant.w) {
                    gl.blendColor(blendConstant.x, blendConstant.y, blendConstant.z, blendConstant.w);
                    cache.bs.blendColor.copy(blendConstant);
                  }
                  break;
                }
              case DynamicStateFlagBit.STENCIL_WRITE_MASK:
                {
                  const front = dynamicStates.stencilStatesFront;
                  const back = dynamicStates.stencilStatesBack;
                  if (cache.dss.stencilWriteMaskFront !== front.writeMask) {
                    gl.stencilMaskSeparate(gl.FRONT, front.writeMask);
                    cache.dss.stencilWriteMaskFront = front.writeMask;
                  }
                  if (cache.dss.stencilWriteMaskBack !== back.writeMask) {
                    gl.stencilMaskSeparate(gl.BACK, back.writeMask);
                    cache.dss.stencilWriteMaskBack = back.writeMask;
                  }
                  break;
                }
              case DynamicStateFlagBit.STENCIL_COMPARE_MASK:
                {
                  const front = dynamicStates.stencilStatesFront;
                  const back = dynamicStates.stencilStatesBack;
                  if (cache.dss.stencilRefFront !== front.reference || cache.dss.stencilReadMaskFront !== front.compareMask) {
                    gl.stencilFuncSeparate(gl.FRONT, WebGLCmpFuncs$1[cache.dss.stencilFuncFront], front.reference, front.compareMask);
                    cache.dss.stencilRefFront = front.reference;
                    cache.dss.stencilReadMaskFront = front.compareMask;
                  }
                  if (cache.dss.stencilRefBack !== back.reference || cache.dss.stencilReadMaskBack !== back.compareMask) {
                    gl.stencilFuncSeparate(gl.BACK, WebGLCmpFuncs$1[cache.dss.stencilFuncBack], back.reference, back.compareMask);
                    cache.dss.stencilRefBack = back.reference;
                    cache.dss.stencilReadMaskBack = back.compareMask;
                  }
                  break;
                }
            }
          }
        }
      }
      function WebGLCmdFuncDraw(device, drawInfo) {
        const {
          gl
        } = device;
        const {
          ANGLE_instanced_arrays: ia,
          WEBGL_multi_draw: md
        } = device.extensions;
        const {
          gpuInputAssembler,
          glPrimitive
        } = gfxStateCache$1;
        if (gpuInputAssembler) {
          const indexBuffer = gpuInputAssembler.gpuIndexBuffer;
          if (gpuInputAssembler.gpuIndirectBuffer) {
            const indirects = gpuInputAssembler.gpuIndirectBuffer.indirects;
            if (indirects.drawByIndex) {
              for (let j = 0; j < indirects.drawCount; j++) {
                indirects.byteOffsets[j] = indirects.offsets[j] * indexBuffer.stride;
              }
              if (md) {
                if (indirects.instancedDraw) {
                  md.multiDrawElementsInstancedWEBGL(glPrimitive, indirects.counts, 0, gpuInputAssembler.glIndexType, indirects.byteOffsets, 0, indirects.instances, 0, indirects.drawCount);
                } else {
                  md.multiDrawElementsWEBGL(glPrimitive, indirects.counts, 0, gpuInputAssembler.glIndexType, indirects.byteOffsets, 0, indirects.drawCount);
                }
              } else {
                for (let j = 0; j < indirects.drawCount; j++) {
                  if (indirects.instances[j] && ia) {
                    ia.drawElementsInstancedANGLE(glPrimitive, indirects.counts[j], gpuInputAssembler.glIndexType, indirects.byteOffsets[j], indirects.instances[j]);
                  } else {
                    gl.drawElements(glPrimitive, indirects.counts[j], gpuInputAssembler.glIndexType, indirects.byteOffsets[j]);
                  }
                }
              }
            } else if (md) {
              if (indirects.instancedDraw) {
                md.multiDrawArraysInstancedWEBGL(glPrimitive, indirects.offsets, 0, indirects.counts, 0, indirects.instances, 0, indirects.drawCount);
              } else {
                md.multiDrawArraysWEBGL(glPrimitive, indirects.offsets, 0, indirects.counts, 0, indirects.drawCount);
              }
            } else {
              for (let j = 0; j < indirects.drawCount; j++) {
                if (indirects.instances[j] && ia) {
                  ia.drawArraysInstancedANGLE(glPrimitive, indirects.offsets[j], indirects.counts[j], indirects.instances[j]);
                } else {
                  gl.drawArrays(glPrimitive, indirects.offsets[j], indirects.counts[j]);
                }
              }
            }
          } else if (drawInfo.instanceCount && ia) {
            if (indexBuffer) {
              if (drawInfo.indexCount > 0) {
                const offset = drawInfo.firstIndex * indexBuffer.stride;
                ia.drawElementsInstancedANGLE(glPrimitive, drawInfo.indexCount, gpuInputAssembler.glIndexType, offset, drawInfo.instanceCount);
              }
            } else if (drawInfo.vertexCount > 0) {
              ia.drawArraysInstancedANGLE(glPrimitive, drawInfo.firstVertex, drawInfo.vertexCount, drawInfo.instanceCount);
            }
          } else if (indexBuffer) {
            if (drawInfo.indexCount > 0) {
              const offset = drawInfo.firstIndex * indexBuffer.stride;
              gl.drawElements(glPrimitive, drawInfo.indexCount, gpuInputAssembler.glIndexType, offset);
            }
          } else if (drawInfo.vertexCount > 0) {
            gl.drawArrays(glPrimitive, drawInfo.firstVertex, drawInfo.vertexCount);
          }
        }
      }
      const cmdIds$1 = new Array(WebGLCmd.COUNT);
      function WebGLCmdFuncExecuteCmds(device, cmdPackage) {
        cmdIds$1.fill(0);
        for (let i = 0; i < cmdPackage.cmds.length; ++i) {
          const cmd = cmdPackage.cmds.array[i];
          const cmdId = cmdIds$1[cmd]++;
          switch (cmd) {
            case WebGLCmd.BEGIN_RENDER_PASS:
              {
                const cmd0 = cmdPackage.beginRenderPassCmds.array[cmdId];
                WebGLCmdFuncBeginRenderPass(device, cmd0.gpuRenderPass, cmd0.gpuFramebuffer, cmd0.renderArea, cmd0.clearColors, cmd0.clearDepth, cmd0.clearStencil);
                break;
              }
            case WebGLCmd.BIND_STATES:
              {
                const cmd2 = cmdPackage.bindStatesCmds.array[cmdId];
                WebGLCmdFuncBindStates(device, cmd2.gpuPipelineState, cmd2.gpuInputAssembler, cmd2.gpuDescriptorSets, cmd2.dynamicOffsets, cmd2.dynamicStates);
                break;
              }
            case WebGLCmd.DRAW:
              {
                const cmd3 = cmdPackage.drawCmds.array[cmdId];
                WebGLCmdFuncDraw(device, cmd3.drawInfo);
                break;
              }
            case WebGLCmd.UPDATE_BUFFER:
              {
                const cmd4 = cmdPackage.updateBufferCmds.array[cmdId];
                WebGLCmdFuncUpdateBuffer(device, cmd4.gpuBuffer, cmd4.buffer, cmd4.offset, cmd4.size);
                break;
              }
            case WebGLCmd.COPY_BUFFER_TO_TEXTURE:
              {
                const cmd5 = cmdPackage.copyBufferToTextureCmds.array[cmdId];
                WebGLCmdFuncCopyBuffersToTexture(device, cmd5.buffers, cmd5.gpuTexture, cmd5.regions);
                break;
              }
            case WebGLCmd.BLIT_TEXTURE:
              {
                const cmd6 = cmdPackage.blitTextureCmds.array[cmdId];
                WebGLCmdFuncBlitTexture(device, cmd6.srcTexture, cmd6.dstTexture, cmd6.regions, cmd6.filter);
                break;
              }
          }
        }
      }
      function WebGLCmdFuncCopyTexImagesToTexture(device, texImages, gpuTexture, regions) {
        const {
          gl
        } = device;
        const glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];
        if (glTexUnit.glTexture !== gpuTexture.glTexture) {
          gl.bindTexture(gpuTexture.glTarget, gpuTexture.glTexture);
          glTexUnit.glTexture = gpuTexture.glTexture;
        }
        let n = 0;
        let f = 0;
        switch (gpuTexture.glTarget) {
          case gl.TEXTURE_2D:
            {
              for (let i = 0; i < regions.length; i++) {
                const region = regions[i];
                gl.texSubImage2D(gl.TEXTURE_2D, region.texSubres.mipLevel, region.texOffset.x, region.texOffset.y, gpuTexture.glFormat, gpuTexture.glType, texImages[n++]);
              }
              break;
            }
          case gl.TEXTURE_CUBE_MAP:
            {
              for (let i = 0; i < regions.length; i++) {
                const region = regions[i];
                const fcount = region.texSubres.baseArrayLayer + region.texSubres.layerCount;
                for (f = region.texSubres.baseArrayLayer; f < fcount; ++f) {
                  gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, region.texSubres.mipLevel, region.texOffset.x, region.texOffset.y, gpuTexture.glFormat, gpuTexture.glType, texImages[n++]);
                }
              }
              break;
            }
          default:
            {
              error('Unsupported GL texture type, copy buffer to texture failed.');
            }
        }
        if (gpuTexture.flags & TextureFlagBit.GEN_MIPMAP && gpuTexture.isPowerOf2) {
          gl.generateMipmap(gpuTexture.glTarget);
        }
      }
      let stagingBuffer$1 = new Uint8Array(1);
      function pixelBufferPick$1(buffer, format, offset, stride, extent) {
        const blockHeight = formatAlignment(format).height;
        const bufferSize = FormatSize(format, extent.width, extent.height, extent.depth);
        const rowStride = FormatSize(format, stride.width, 1, 1);
        const sliceStride = FormatSize(format, stride.width, stride.height, 1);
        const chunkSize = FormatSize(format, extent.width, 1, 1);
        const ArrayBufferCtor = getTypedArrayConstructor(FormatInfos[format]);
        if (stagingBuffer$1.byteLength < bufferSize) {
          stagingBuffer$1 = new Uint8Array(bufferSize);
        }
        let destOffset = 0;
        let bufferOffset = offset;
        for (let i = 0; i < extent.depth; i++) {
          bufferOffset = offset + sliceStride * i;
          for (let j = 0; j < extent.height; j += blockHeight) {
            stagingBuffer$1.subarray(destOffset, destOffset + chunkSize).set(new Uint8Array(buffer.buffer, buffer.byteOffset + bufferOffset, chunkSize));
            destOffset += chunkSize;
            bufferOffset += rowStride;
          }
        }
        const length = bufferSize / ArrayBufferCtor.BYTES_PER_ELEMENT;
        assertID(Number.isInteger(length), 9101);
        return new ArrayBufferCtor(stagingBuffer$1.buffer, 0, length);
      }
      function WebGLCmdFuncCopyBuffersToTexture(device, buffers, gpuTexture, regions) {
        const {
          gl
        } = device;
        const glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];
        if (glTexUnit.glTexture !== gpuTexture.glTexture) {
          gl.bindTexture(gpuTexture.glTarget, gpuTexture.glTexture);
          glTexUnit.glTexture = gpuTexture.glTexture;
        }
        let n = 0;
        let f = 0;
        const fmtInfo = FormatInfos[gpuTexture.format];
        const ArrayBufferCtor = getTypedArrayConstructor(fmtInfo);
        const {
          isCompressed
        } = fmtInfo;
        const blockSize = formatAlignment(gpuTexture.format);
        const extent = new Extent();
        const offset = new Offset();
        const stride = new Extent();
        switch (gpuTexture.glTarget) {
          case gl.TEXTURE_2D:
            {
              for (let i = 0; i < regions.length; i++) {
                const region = regions[i];
                const mipLevel = region.texSubres.mipLevel;
                offset.x = region.texOffset.x === 0 ? 0 : alignTo(region.texOffset.x, blockSize.width);
                offset.y = region.texOffset.y === 0 ? 0 : alignTo(region.texOffset.y, blockSize.height);
                extent.width = region.texExtent.width < blockSize.width ? region.texExtent.width : alignTo(region.texExtent.width, blockSize.width);
                extent.height = region.texExtent.height < blockSize.height ? region.texExtent.width : alignTo(region.texExtent.height, blockSize.height);
                stride.width = region.buffStride > 0 ? region.buffStride : extent.width;
                stride.height = region.buffTexHeight > 0 ? region.buffTexHeight : extent.height;
                const destWidth = region.texExtent.width + offset.x === gpuTexture.width >> mipLevel ? region.texExtent.width : extent.width;
                const destHeight = region.texExtent.height + offset.y === gpuTexture.height >> mipLevel ? region.texExtent.height : extent.height;
                let pixels;
                const buffer = buffers[n++];
                if (stride.width === extent.width && stride.height === extent.height) {
                  const length = FormatSize(gpuTexture.format, destWidth, destHeight, 1) / ArrayBufferCtor.BYTES_PER_ELEMENT;
                  assertID(Number.isInteger(length), 9101);
                  pixels = new ArrayBufferCtor(buffer.buffer, buffer.byteOffset + region.buffOffset, length);
                } else {
                  pixels = pixelBufferPick$1(buffer, gpuTexture.format, region.buffOffset, stride, extent);
                }
                if (!isCompressed) {
                  gl.texSubImage2D(gl.TEXTURE_2D, mipLevel, offset.x, offset.y, destWidth, destHeight, gpuTexture.glFormat, gpuTexture.glType, pixels);
                } else if (gpuTexture.glInternalFmt !== WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL && !device.extensions.noCompressedTexSubImage2D) {
                  gl.compressedTexSubImage2D(gl.TEXTURE_2D, mipLevel, offset.x, offset.y, destWidth, destHeight, gpuTexture.glFormat, pixels);
                } else {
                  gl.compressedTexImage2D(gl.TEXTURE_2D, mipLevel, gpuTexture.glInternalFmt, destWidth, destHeight, 0, pixels);
                }
              }
              break;
            }
          case gl.TEXTURE_CUBE_MAP:
            {
              for (let i = 0; i < regions.length; i++) {
                const region = regions[i];
                const mipLevel = region.texSubres.mipLevel;
                offset.x = region.texOffset.x === 0 ? 0 : alignTo(region.texOffset.x, blockSize.width);
                offset.y = region.texOffset.y === 0 ? 0 : alignTo(region.texOffset.y, blockSize.height);
                extent.width = region.texExtent.width < blockSize.width ? region.texExtent.width : alignTo(region.texExtent.width, blockSize.width);
                extent.height = region.texExtent.height < blockSize.height ? region.texExtent.width : alignTo(region.texExtent.height, blockSize.height);
                stride.width = region.buffStride > 0 ? region.buffStride : extent.width;
                stride.height = region.buffTexHeight > 0 ? region.buffTexHeight : extent.height;
                const destWidth = region.texExtent.width + offset.x === gpuTexture.width >> mipLevel ? region.texExtent.width : extent.width;
                const destHeight = region.texExtent.height + offset.y === gpuTexture.height >> mipLevel ? region.texExtent.height : extent.height;
                const fcount = region.texSubres.baseArrayLayer + region.texSubres.layerCount;
                for (f = region.texSubres.baseArrayLayer; f < fcount; ++f) {
                  let pixels;
                  const buffer = buffers[n++];
                  if (stride.width === extent.width && stride.height === extent.height) {
                    const length = FormatSize(gpuTexture.format, destWidth, destHeight, 1) / ArrayBufferCtor.BYTES_PER_ELEMENT;
                    assertID(Number.isInteger(length), 9101);
                    pixels = new ArrayBufferCtor(buffer.buffer, buffer.byteOffset + region.buffOffset, length);
                  } else {
                    pixels = pixelBufferPick$1(buffer, gpuTexture.format, region.buffOffset, stride, extent);
                  }
                  if (!isCompressed) {
                    gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, mipLevel, offset.x, offset.y, destWidth, destHeight, gpuTexture.glFormat, gpuTexture.glType, pixels);
                  } else if (gpuTexture.glInternalFmt !== WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL && !device.extensions.noCompressedTexSubImage2D) {
                    gl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, mipLevel, offset.x, offset.y, destWidth, destHeight, gpuTexture.glFormat, pixels);
                  } else {
                    gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, mipLevel, gpuTexture.glInternalFmt, destWidth, destHeight, 0, pixels);
                  }
                }
              }
              break;
            }
          default:
            {
              error('Unsupported GL texture type, copy buffer to texture failed.');
            }
        }
        if (gpuTexture.flags & TextureFlagBit.GEN_MIPMAP) {
          gl.generateMipmap(gpuTexture.glTarget);
        }
      }
      function WebGLCmdFuncCopyTextureToBuffers(device, gpuTexture, buffers, regions) {
        const {
          gl
        } = device;
        const cache = device.stateCache;
        const framebuffer = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
        let x = 0;
        let y = 0;
        let w = 1;
        let h = 1;
        switch (gpuTexture.glTarget) {
          case gl.TEXTURE_2D:
            {
              for (let k = 0; k < regions.length; k++) {
                const region = regions[k];
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gpuTexture.glTarget, gpuTexture.glTexture, region.texSubres.mipLevel);
                x = region.texOffset.x;
                y = region.texOffset.y;
                w = region.texExtent.width;
                h = region.texExtent.height;
                gl.readPixels(x, y, w, h, gpuTexture.glFormat, gpuTexture.glType, buffers[k]);
              }
              break;
            }
          default:
            {
              error('Unsupported GL texture type, copy texture to buffers failed.');
            }
        }
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        cache.glFramebuffer = null;
        gl.deleteFramebuffer(framebuffer);
      }
      function WebGLCmdFuncBlitTexture(device, srcTexture, dstTexture, regions, filter) {
        device.blitManager.draw(srcTexture, dstTexture, regions, filter);
      }

      class WebGLIndirectDrawInfos {
        constructor() {
          this.counts = void 0;
          this.offsets = void 0;
          this.instances = void 0;
          this.drawCount = 0;
          this.drawByIndex = false;
          this.instancedDraw = false;
          this.byteOffsets = void 0;
          this._capacity = 4;
          this.counts = new Int32Array(this._capacity);
          this.offsets = new Int32Array(this._capacity);
          this.instances = new Int32Array(this._capacity);
          this.byteOffsets = new Int32Array(this._capacity);
        }
        clearDraws() {
          this.drawCount = 0;
          this.drawByIndex = false;
          this.instancedDraw = false;
        }
        setDrawInfo(idx, info) {
          this._ensureCapacity(idx);
          this.drawByIndex = info.indexCount > 0;
          this.instancedDraw = !!info.instanceCount;
          this.drawCount = Math.max(idx + 1, this.drawCount);
          if (this.drawByIndex) {
            this.counts[idx] = info.indexCount;
            this.offsets[idx] = info.firstIndex;
          } else {
            this.counts[idx] = info.vertexCount;
            this.offsets[idx] = info.firstVertex;
          }
          this.instances[idx] = Math.max(1, info.instanceCount);
        }
        _ensureCapacity(target) {
          if (this._capacity > target) return;
          this._capacity = nextPow2(target);
          const counts = new Int32Array(this._capacity);
          const offsets = new Int32Array(this._capacity);
          const instances = new Int32Array(this._capacity);
          this.byteOffsets = new Int32Array(this._capacity);
          counts.set(this.counts);
          offsets.set(this.offsets);
          instances.set(this.instances);
          this.counts = counts;
          this.offsets = offsets;
          this.instances = instances;
        }
      }
      class IWebGLBlitManager {
        constructor() {
          this._gpuShader = null;
          this._gpuDescriptorSetLayout = null;
          this._gpuPipelineLayout = null;
          this._gpuPipelineState = null;
          this._gpuVertexBuffer = null;
          this._gpuInputAssembler = null;
          this._gpuPointSampler = null;
          this._gpuLinearSampler = null;
          this._gpuDescriptorSet = null;
          this._gpuUniformBuffer = null;
          this._drawInfo = null;
          this._glFramebuffer = null;
          this._uniformBuffer = null;
          const {
            gl
          } = WebGLDeviceManager.instance;
          const device = WebGLDeviceManager.instance;
          const samplerOffset = device.bindingMappingInfo.maxBlockCounts[0];
          this._gpuShader = {
            name: 'Blit Pass',
            blocks: [new UniformBlock(0, 0, `BlitParams`, [new Uniform(`tilingOffsetSrc`, Type$1.FLOAT4, 1), new Uniform(`tilingOffsetDst`, Type$1.FLOAT4, 1)], 1)],
            samplerTextures: [new UniformSamplerTexture(0, samplerOffset, 'textureSrc', Type$1.SAMPLER2D, 1)],
            subpassInputs: [],
            gpuStages: [{
              type: ShaderStageFlagBit.VERTEX,
              source: `
                    precision mediump float;

                    attribute vec2 a_position;
                    attribute vec2 a_texCoord;
            
                    uniform vec4 tilingOffsetSrc;
                    uniform vec4 tilingOffsetDst;
            
                    varying vec2 v_texCoord;
            
                    void main() {
                        v_texCoord = a_texCoord * tilingOffsetSrc.xy + tilingOffsetSrc.zw;
                        gl_Position = vec4((a_position + 1.0) * tilingOffsetDst.xy - 1.0 + tilingOffsetDst.zw * 2.0, 0, 1);
                    }`,
              glShader: null
            }, {
              type: ShaderStageFlagBit.FRAGMENT,
              source: `
                    precision mediump float;
                    uniform sampler2D textureSrc;

                    varying vec2 v_texCoord;
                    
                    void main() {
                        gl_FragColor = texture2D(textureSrc, v_texCoord);
                    }`,
              glShader: null
            }],
            glProgram: null,
            glInputs: [],
            glUniforms: [],
            glBlocks: [],
            glSamplerTextures: []
          };
          WebGLCmdFuncCreateShader(WebGLDeviceManager.instance, this._gpuShader);
          this._gpuDescriptorSetLayout = {
            bindings: [new DescriptorSetLayoutBinding(0, DescriptorType.UNIFORM_BUFFER, 1, ShaderStageFlagBit.VERTEX), new DescriptorSetLayoutBinding(samplerOffset, DescriptorType.SAMPLER_TEXTURE, 1, ShaderStageFlagBit.FRAGMENT)],
            dynamicBindings: [],
            descriptorIndices: [],
            descriptorCount: samplerOffset + 1
          };
          for (let i = 0; i < samplerOffset; i++) {
            this._gpuDescriptorSetLayout.descriptorIndices[i] = 0;
          }
          this._gpuDescriptorSetLayout.descriptorIndices.push(1);
          this._gpuPipelineLayout = {
            gpuSetLayouts: [this._gpuDescriptorSetLayout],
            dynamicOffsetCount: 0,
            dynamicOffsetOffsets: [0],
            dynamicOffsetIndices: [[]]
          };
          this._gpuPipelineState = {
            glPrimitive: gl.TRIANGLE_STRIP,
            gpuShader: this._gpuShader,
            gpuPipelineLayout: this._gpuPipelineLayout,
            rs: null,
            dss: new DepthStencilState(false, false),
            bs: null,
            dynamicStates: [],
            gpuRenderPass: null
          };
          this._gpuVertexBuffer = {
            usage: BufferUsageBit.VERTEX,
            memUsage: MemoryUsageBit.DEVICE,
            size: 16 * Float32Array.BYTES_PER_ELEMENT,
            stride: 4 * Float32Array.BYTES_PER_ELEMENT,
            buffer: null,
            vf32: null,
            indirects: new WebGLIndirectDrawInfos(),
            glTarget: 0,
            glBuffer: null
          };
          WebGLCmdFuncCreateBuffer(WebGLDeviceManager.instance, this._gpuVertexBuffer);
          WebGLDeviceManager.instance.memoryStatus.bufferSize += this._gpuVertexBuffer.size;
          const data = new Float32Array([-1.0, -1.0, 0.0, 0.0, 1.0, -1.0, 1.0, 0.0, -1.0, 1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0]);
          WebGLCmdFuncUpdateBuffer(WebGLDeviceManager.instance, this._gpuVertexBuffer, data, 0, data.length);
          this._gpuInputAssembler = {
            attributes: [new Attribute(`a_position`, Format.RG32F), new Attribute(`a_texCoord`, Format.RG32F)],
            gpuVertexBuffers: [this._gpuVertexBuffer],
            gpuIndexBuffer: null,
            gpuIndirectBuffer: null,
            glAttribs: [],
            glIndexType: 0,
            glVAOs: new Map()
          };
          WebGLCmdFuncCreateInputAssember(WebGLDeviceManager.instance, this._gpuInputAssembler);
          this._gpuPointSampler = {
            glMinFilter: 0x2600,
            glMagFilter: 0x2600,
            glWrapS: 0x2901,
            glWrapT: 0x2901,
            glWrapR: 0x2901
          };
          this._gpuLinearSampler = {
            glMinFilter: 0x2601,
            glMagFilter: 0x2601,
            glWrapS: 0x2901,
            glWrapT: 0x2901,
            glWrapR: 0x2901
          };
          this._uniformBuffer = new Float32Array(8);
          this._gpuUniformBuffer = {
            usage: BufferUsageBit.UNIFORM,
            memUsage: MemoryUsageBit.DEVICE,
            size: 8 * Float32Array.BYTES_PER_ELEMENT,
            stride: 8 * Float32Array.BYTES_PER_ELEMENT,
            buffer: this._uniformBuffer,
            vf32: null,
            indirects: new WebGLIndirectDrawInfos(),
            glTarget: 0,
            glBuffer: null
          };
          WebGLCmdFuncCreateBuffer(WebGLDeviceManager.instance, this._gpuUniformBuffer);
          WebGLDeviceManager.instance.memoryStatus.bufferSize += this._gpuUniformBuffer.size;
          this._gpuDescriptorSet = {
            gpuDescriptors: [{
              type: DescriptorType.UNIFORM_BUFFER,
              gpuBuffer: this._gpuUniformBuffer,
              gpuTexture: null,
              gpuSampler: null
            }, {
              type: DescriptorType.SAMPLER_TEXTURE,
              gpuBuffer: null,
              gpuTexture: null,
              gpuSampler: null
            }],
            descriptorIndices: this._gpuDescriptorSetLayout.descriptorIndices
          };
          this._drawInfo = new DrawInfo(4, 0, 0, 0, 0, 0, 0);
          this._glFramebuffer = WebGLDeviceManager.instance.gl.createFramebuffer();
        }
        destroy() {
          if (this._glFramebuffer) {
            WebGLDeviceManager.instance.gl.deleteFramebuffer(this._glFramebuffer);
            this._glFramebuffer = null;
          }
          if (this._gpuVertexBuffer) {
            WebGLDeviceManager.instance.memoryStatus.bufferSize -= this._gpuVertexBuffer.size;
            WebGLCmdFuncDestroyBuffer(WebGLDeviceManager.instance, this._gpuVertexBuffer);
          }
          if (this._gpuUniformBuffer) {
            WebGLDeviceManager.instance.memoryStatus.bufferSize -= this._gpuUniformBuffer.size;
            WebGLCmdFuncDestroyBuffer(WebGLDeviceManager.instance, this._gpuUniformBuffer);
          }
          if (this._gpuShader) {
            WebGLCmdFuncDestroyShader(WebGLDeviceManager.instance, this._gpuShader);
          }
          if (this._gpuInputAssembler) {
            WebGLCmdFuncDestroyInputAssembler(WebGLDeviceManager.instance, this._gpuInputAssembler);
          }
        }
        draw(gpuTextureSrc, gpuTextureDst, regions, filter) {
          const device = WebGLDeviceManager.instance;
          const {
            gl
          } = device;
          const stateCache = device.stateCache;
          const origFramebuffer = stateCache.glFramebuffer;
          gl.viewport(0, 0, gpuTextureDst.width, gpuTextureDst.height);
          gl.scissor(0, 0, gpuTextureDst.width, gpuTextureDst.height);
          if (!this._uniformBuffer || !this._gpuUniformBuffer || !this._gpuPipelineState || !this._gpuInputAssembler || !this._gpuDescriptorSet || !this._drawInfo) {
            return;
          }
          const descriptor = this._gpuDescriptorSet.gpuDescriptors[1];
          descriptor.gpuTexture = gpuTextureSrc;
          descriptor.gpuSampler = filter === Filter$1.POINT ? this._gpuPointSampler : this._gpuLinearSampler;
          const formatInfo = FormatInfos[gpuTextureDst.format];
          let attachment = gl.COLOR_ATTACHMENT0;
          if (formatInfo.hasStencil) {
            attachment = gl.DEPTH_STENCIL_ATTACHMENT;
          } else if (formatInfo.hasDepth) {
            attachment = gl.DEPTH_ATTACHMENT;
          }
          const regionIndices = regions.map((_, i) => i);
          regionIndices.sort((a, b) => regions[a].srcSubres.mipLevel - regions[b].srcSubres.mipLevel);
          if (stateCache.glFramebuffer !== this._glFramebuffer) {
            device.gl.bindFramebuffer(device.gl.FRAMEBUFFER, this._glFramebuffer);
            stateCache.glFramebuffer = this._glFramebuffer;
          }
          let mipLevel = regions[0].dstSubres.mipLevel;
          if (gpuTextureDst.glTexture) {
            gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gpuTextureDst.glTarget, gpuTextureDst.glTexture, mipLevel);
          } else {
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, attachment, gl.RENDERBUFFER, gpuTextureDst.glRenderbuffer);
          }
          for (let i = 0; i < regionIndices.length; ++i) {
            const region = regions[regionIndices[i]];
            if (gpuTextureSrc.glTexture && mipLevel !== region.srcSubres.mipLevel) {
              mipLevel = region.srcSubres.mipLevel;
              gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gpuTextureDst.glTarget, gpuTextureDst.glTexture, mipLevel);
            }
            const srcWidth = gpuTextureSrc.width;
            const srcHeight = gpuTextureSrc.height;
            const dstWidth = gpuTextureDst.width;
            const dstHeight = gpuTextureDst.height;
            this._uniformBuffer[0] = region.srcExtent.width / srcWidth;
            this._uniformBuffer[1] = region.srcExtent.height / srcHeight;
            this._uniformBuffer[2] = region.srcOffset.x / srcWidth;
            this._uniformBuffer[3] = region.srcOffset.y / srcHeight;
            this._uniformBuffer[4] = region.dstExtent.width / dstWidth;
            this._uniformBuffer[5] = region.dstExtent.height / dstHeight;
            this._uniformBuffer[6] = region.dstOffset.x / dstWidth;
            this._uniformBuffer[7] = region.dstOffset.y / dstHeight;
            WebGLCmdFuncUpdateBuffer(device, this._gpuUniformBuffer, this._uniformBuffer, 0, this._uniformBuffer.length * Float32Array.BYTES_PER_ELEMENT);
            WebGLCmdFuncBindStates(device, this._gpuPipelineState, this._gpuInputAssembler, [this._gpuDescriptorSet], [], null);
            WebGLCmdFuncDraw(device, this._drawInfo);
          }
          if (stateCache.glFramebuffer !== origFramebuffer) {
            device.gl.bindFramebuffer(device.gl.FRAMEBUFFER, origFramebuffer);
            stateCache.glFramebuffer = origFramebuffer;
          }
          const origViewport = stateCache.viewport;
          gl.viewport(origViewport.left, origViewport.top, origViewport.width, origViewport.height);
          const origScissor = stateCache.scissorRect;
          gl.scissor(origScissor.x, origScissor.y, origScissor.width, origScissor.height);
        }
      }

      class WebGLBuffer extends Buffer {
        constructor(...args) {
          super(...args);
          this._gpuBuffer = null;
          this._gpuBufferView = null;
          this._uniformBuffer = null;
        }
        get gpuBuffer() {
          return this._gpuBuffer;
        }
        get gpuBufferView() {
          return this._gpuBufferView;
        }
        initialize(info) {
          if ('buffer' in info) {
            this._isBufferView = true;
            const buffer = info.buffer;
            this._usage = buffer.usage;
            this._memUsage = buffer.memUsage;
            this._size = this._stride = info.range;
            this._count = 1;
            this._flags = buffer.flags;
            this._gpuBufferView = {
              gpuBuffer: buffer.gpuBuffer,
              offset: info.offset,
              range: info.range
            };
          } else {
            this._usage = info.usage;
            this._memUsage = info.memUsage;
            this._size = info.size;
            this._stride = Math.max(info.stride || this._size, 1);
            this._count = this._size / this._stride;
            this._flags = info.flags;
            if (this._usage & BufferUsageBit.UNIFORM && this._size > 0) {
              this._uniformBuffer = new Uint8Array(this._size);
            }
            this._gpuBuffer = {
              usage: this._usage,
              memUsage: this._memUsage,
              size: this._size,
              stride: this._stride,
              buffer: null,
              vf32: null,
              indirects: new WebGLIndirectDrawInfos(),
              glTarget: 0,
              glBuffer: null
            };
            if (this._usage & BufferUsageBit.UNIFORM) {
              this._gpuBuffer.buffer = this._uniformBuffer;
            }
            WebGLCmdFuncCreateBuffer(WebGLDeviceManager.instance, this._gpuBuffer);
            WebGLDeviceManager.instance.memoryStatus.bufferSize += this._size;
          }
        }
        destroy() {
          if (this._gpuBuffer) {
            WebGLCmdFuncDestroyBuffer(WebGLDeviceManager.instance, this._gpuBuffer);
            WebGLDeviceManager.instance.memoryStatus.bufferSize -= this._size;
            this._gpuBuffer = null;
          }
          if (this._gpuBufferView) {
            this._gpuBufferView = null;
          }
        }
        resize(size) {
          if (this._isBufferView) {
            console.warn('cannot resize buffer views!');
            return;
          }
          const oldSize = this._size;
          if (oldSize === size) {
            return;
          }
          this._size = size;
          this._count = this._size / this._stride;
          if (this._uniformBuffer) {
            this._uniformBuffer = new Uint8Array(size);
          }
          if (this._gpuBuffer) {
            if (this._uniformBuffer) {
              this._gpuBuffer.buffer = this._uniformBuffer;
            }
            this._gpuBuffer.size = size;
            if (size > 0) {
              WebGLCmdFuncResizeBuffer(WebGLDeviceManager.instance, this._gpuBuffer);
              WebGLDeviceManager.instance.memoryStatus.bufferSize -= oldSize;
              WebGLDeviceManager.instance.memoryStatus.bufferSize += size;
            }
          }
        }
        update(buffer, size) {
          if (this._isBufferView) {
            console.warn('cannot update through buffer views!');
            return;
          }
          let buffSize;
          if (size !== undefined) {
            buffSize = size;
          } else if (this._usage & BufferUsageBit.INDIRECT) {
            buffSize = 0;
          } else {
            buffSize = buffer.byteLength;
          }
          WebGLCmdFuncUpdateBuffer(WebGLDeviceManager.instance, this._gpuBuffer, buffer, 0, buffSize);
        }
      }

      class WebGLCommandPool {
        constructor(Clazz, count) {
          this._frees = void 0;
          this._freeIdx = 0;
          this._freeCmds = void 0;
          this._frees = new Array(count);
          this._freeCmds = new CachedArray(count);
          for (let i = 0; i < count; ++i) {
            this._frees[i] = new Clazz();
          }
          this._freeIdx = count - 1;
        }
        alloc(Clazz) {
          if (this._freeIdx < 0) {
            const size = this._frees.length * 2;
            const temp = this._frees;
            this._frees = new Array(size);
            const increase = size - temp.length;
            for (let i = 0; i < increase; ++i) {
              this._frees[i] = new Clazz();
            }
            for (let i = increase, j = 0; i < size; ++i, ++j) {
              this._frees[i] = temp[j];
            }
            this._freeIdx += increase;
          }
          const cmd = this._frees[this._freeIdx];
          this._frees[this._freeIdx--] = null;
          ++cmd.refCount;
          return cmd;
        }
        free(cmd) {
          if (--cmd.refCount === 0) {
            this._freeCmds.push(cmd);
          }
        }
        freeCmds(cmds) {
          for (let i = 0; i < cmds.length; ++i) {
            if (--cmds.array[i].refCount === 0) {
              this._freeCmds.push(cmds.array[i]);
            }
          }
        }
        release() {
          for (let i = 0; i < this._freeCmds.length; ++i) {
            const cmd = this._freeCmds.array[i];
            cmd.clear();
            this._frees[++this._freeIdx] = cmd;
          }
          this._freeCmds.clear();
        }
      }
      class WebGLCommandAllocator {
        constructor() {
          this.beginRenderPassCmdPool = void 0;
          this.bindStatesCmdPool = void 0;
          this.drawCmdPool = void 0;
          this.updateBufferCmdPool = void 0;
          this.copyBufferToTextureCmdPool = void 0;
          this.blitTextureCmdPool = void 0;
          this.beginRenderPassCmdPool = new WebGLCommandPool(WebGLCmdBeginRenderPass, 1);
          this.bindStatesCmdPool = new WebGLCommandPool(WebGLCmdBindStates, 1);
          this.drawCmdPool = new WebGLCommandPool(WebGLCmdDraw, 1);
          this.updateBufferCmdPool = new WebGLCommandPool(WebGLCmdUpdateBuffer, 1);
          this.copyBufferToTextureCmdPool = new WebGLCommandPool(WebGLCmdCopyBufferToTexture, 1);
          this.blitTextureCmdPool = new WebGLCommandPool(WebGLCmdBlitTexture, 1);
        }
        clearCmds(cmdPackage) {
          if (cmdPackage.beginRenderPassCmds.length) {
            this.beginRenderPassCmdPool.freeCmds(cmdPackage.beginRenderPassCmds);
            cmdPackage.beginRenderPassCmds.clear();
          }
          if (cmdPackage.bindStatesCmds.length) {
            this.bindStatesCmdPool.freeCmds(cmdPackage.bindStatesCmds);
            cmdPackage.bindStatesCmds.clear();
          }
          if (cmdPackage.drawCmds.length) {
            this.drawCmdPool.freeCmds(cmdPackage.drawCmds);
            cmdPackage.drawCmds.clear();
          }
          if (cmdPackage.updateBufferCmds.length) {
            this.updateBufferCmdPool.freeCmds(cmdPackage.updateBufferCmds);
            cmdPackage.updateBufferCmds.clear();
          }
          if (cmdPackage.copyBufferToTextureCmds.length) {
            this.copyBufferToTextureCmdPool.freeCmds(cmdPackage.copyBufferToTextureCmds);
            cmdPackage.copyBufferToTextureCmds.clear();
          }
          if (cmdPackage.blitTextureCmds.length) {
            this.blitTextureCmdPool.freeCmds(cmdPackage.blitTextureCmds);
            cmdPackage.blitTextureCmds.clear();
          }
          cmdPackage.cmds.clear();
        }
        releaseCmds() {
          this.beginRenderPassCmdPool.release();
          this.bindStatesCmdPool.release();
          this.drawCmdPool.release();
          this.updateBufferCmdPool.release();
          this.copyBufferToTextureCmdPool.release();
          this.blitTextureCmdPool.release();
        }
      }

      class WebGLCommandBuffer extends CommandBuffer {
        constructor(...args) {
          super(...args);
          this.cmdPackage = new WebGLCmdPackage();
          this._cmdAllocator = new WebGLCommandAllocator();
          this._isInRenderPass = false;
          this._curGPUPipelineState = null;
          this._curGPUInputAssembler = null;
          this._curGPUDescriptorSets = [];
          this._curDynamicOffsets = Array(8).fill(0);
          this._curDynamicStates = new DynamicStates();
          this._isStateInvalied = false;
        }
        initialize(info) {
          this._type = info.type;
          this._queue = info.queue;
          const setCount = WebGLDeviceManager.instance.bindingMappings.blockOffsets.length;
          for (let i = 0; i < setCount; i++) {
            this._curGPUDescriptorSets.push(null);
          }
        }
        destroy() {
          this._cmdAllocator.clearCmds(this.cmdPackage);
        }
        begin(renderPass, subpass = 0, frameBuffer) {
          this._cmdAllocator.clearCmds(this.cmdPackage);
          this._curGPUPipelineState = null;
          this._curGPUInputAssembler = null;
          this._curGPUDescriptorSets.length = 0;
          this._numDrawCalls = 0;
          this._numInstances = 0;
          this._numTris = 0;
        }
        end() {
          if (this._isStateInvalied) {
            this.bindStates();
          }
          this._isInRenderPass = false;
        }
        beginRenderPass(renderPass, framebuffer, renderArea, clearColors, clearDepth, clearStencil) {
          const cmd = this._cmdAllocator.beginRenderPassCmdPool.alloc(WebGLCmdBeginRenderPass);
          cmd.gpuRenderPass = renderPass.gpuRenderPass;
          cmd.gpuFramebuffer = framebuffer.gpuFramebuffer;
          cmd.renderArea.copy(renderArea);
          cmd.clearColors.length = clearColors.length;
          for (let i = 0; i < clearColors.length; ++i) {
            cmd.clearColors[i] = clearColors[i];
          }
          cmd.clearDepth = clearDepth;
          cmd.clearStencil = clearStencil;
          this.cmdPackage.beginRenderPassCmds.push(cmd);
          this.cmdPackage.cmds.push(WebGLCmd.BEGIN_RENDER_PASS);
          this._isInRenderPass = true;
        }
        endRenderPass() {
          this._isInRenderPass = false;
        }
        bindPipelineState(pipelineState) {
          const gpuPipelineState = pipelineState.gpuPipelineState;
          if (gpuPipelineState !== this._curGPUPipelineState) {
            this._curGPUPipelineState = gpuPipelineState;
            this._isStateInvalied = true;
          }
        }
        bindDescriptorSet(set, descriptorSet, dynamicOffsets) {
          const gpuDescriptorSet = descriptorSet.gpuDescriptorSet;
          if (gpuDescriptorSet !== this._curGPUDescriptorSets[set]) {
            this._curGPUDescriptorSets[set] = gpuDescriptorSet;
            this._isStateInvalied = true;
          }
          if (dynamicOffsets) {
            var _this$_curGPUPipeline;
            const gpuPipelineLayout = (_this$_curGPUPipeline = this._curGPUPipelineState) === null || _this$_curGPUPipeline === void 0 ? void 0 : _this$_curGPUPipeline.gpuPipelineLayout;
            if (gpuPipelineLayout) {
              const offsets = this._curDynamicOffsets;
              const idx = gpuPipelineLayout.dynamicOffsetOffsets[set];
              for (let i = 0; i < dynamicOffsets.length; i++) offsets[idx + i] = dynamicOffsets[i];
              this._isStateInvalied = true;
            }
          }
        }
        bindInputAssembler(inputAssembler) {
          const gpuInputAssembler = inputAssembler.gpuInputAssembler;
          this._curGPUInputAssembler = gpuInputAssembler;
          this._isStateInvalied = true;
        }
        setViewport(viewport) {
          const cache = this._curDynamicStates.viewport;
          if (cache.left !== viewport.left || cache.top !== viewport.top || cache.width !== viewport.width || cache.height !== viewport.height || cache.minDepth !== viewport.minDepth || cache.maxDepth !== viewport.maxDepth) {
            cache.left = viewport.left;
            cache.top = viewport.top;
            cache.width = viewport.width;
            cache.height = viewport.height;
            cache.minDepth = viewport.minDepth;
            cache.maxDepth = viewport.maxDepth;
            this._isStateInvalied = true;
          }
        }
        setScissor(scissor) {
          const cache = this._curDynamicStates.scissor;
          if (cache.x !== scissor.x || cache.y !== scissor.y || cache.width !== scissor.width || cache.height !== scissor.height) {
            cache.x = scissor.x;
            cache.y = scissor.y;
            cache.width = scissor.width;
            cache.height = scissor.height;
            this._isStateInvalied = true;
          }
        }
        setLineWidth(lineWidth) {
          if (this._curDynamicStates.lineWidth !== lineWidth) {
            this._curDynamicStates.lineWidth = lineWidth;
            this._isStateInvalied = true;
          }
        }
        setDepthBias(depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor) {
          const cache = this._curDynamicStates;
          if (cache.depthBiasConstant !== depthBiasConstantFactor || cache.depthBiasClamp !== depthBiasClamp || cache.depthBiasSlope !== depthBiasSlopeFactor) {
            cache.depthBiasConstant = depthBiasConstantFactor;
            cache.depthBiasClamp = depthBiasClamp;
            cache.depthBiasSlope = depthBiasSlopeFactor;
            this._isStateInvalied = true;
          }
        }
        setBlendConstants(blendConstants) {
          const cache = this._curDynamicStates.blendConstant;
          if (cache.x !== blendConstants.x || cache.y !== blendConstants.y || cache.z !== blendConstants.z || cache.w !== blendConstants.w) {
            cache.copy(blendConstants);
            this._isStateInvalied = true;
          }
        }
        setDepthBound(minDepthBounds, maxDepthBounds) {
          const cache = this._curDynamicStates;
          if (cache.depthMinBounds !== minDepthBounds || cache.depthMaxBounds !== maxDepthBounds) {
            cache.depthMinBounds = minDepthBounds;
            cache.depthMaxBounds = maxDepthBounds;
            this._isStateInvalied = true;
          }
        }
        setStencilWriteMask(face, writeMask) {
          const front = this._curDynamicStates.stencilStatesFront;
          const back = this._curDynamicStates.stencilStatesBack;
          if (face & StencilFace.FRONT) {
            if (front.writeMask !== writeMask) {
              front.writeMask = writeMask;
              this._isStateInvalied = true;
            }
          }
          if (face & StencilFace.BACK) {
            if (back.writeMask !== writeMask) {
              back.writeMask = writeMask;
              this._isStateInvalied = true;
            }
          }
        }
        setStencilCompareMask(face, reference, compareMask) {
          const front = this._curDynamicStates.stencilStatesFront;
          const back = this._curDynamicStates.stencilStatesBack;
          if (face & StencilFace.FRONT) {
            if (front.compareMask !== compareMask || front.reference !== reference) {
              front.reference = reference;
              front.compareMask = compareMask;
              this._isStateInvalied = true;
            }
          }
          if (face & StencilFace.BACK) {
            if (back.compareMask !== compareMask || back.reference !== reference) {
              back.reference = reference;
              back.compareMask = compareMask;
              this._isStateInvalied = true;
            }
          }
        }
        draw(infoOrAssembler) {
          if (this._type === CommandBufferType.PRIMARY && this._isInRenderPass || this._type === CommandBufferType.SECONDARY) {
            if (this._isStateInvalied) {
              this.bindStates();
            }
            const info = 'drawInfo' in infoOrAssembler ? infoOrAssembler.drawInfo : infoOrAssembler;
            const cmd = this._cmdAllocator.drawCmdPool.alloc(WebGLCmdDraw);
            cmd.drawInfo.copy(info);
            this.cmdPackage.drawCmds.push(cmd);
            this.cmdPackage.cmds.push(WebGLCmd.DRAW);
            ++this._numDrawCalls;
            this._numInstances += info.instanceCount;
            const indexCount = info.indexCount || info.vertexCount;
            if (this._curGPUPipelineState) {
              const glPrimitive = this._curGPUPipelineState.glPrimitive;
              switch (glPrimitive) {
                case 0x0004:
                  {
                    this._numTris += indexCount / 3 * Math.max(info.instanceCount, 1);
                    break;
                  }
                case 0x0005:
                case 0x0006:
                  {
                    this._numTris += (indexCount - 2) * Math.max(info.instanceCount, 1);
                    break;
                  }
              }
            }
          } else {
            console.error('Command \'draw\' must be recorded inside a render pass.');
          }
        }
        updateBuffer(buffer, data, size) {
          if (this._type === CommandBufferType.PRIMARY && !this._isInRenderPass || this._type === CommandBufferType.SECONDARY) {
            const gpuBuffer = buffer.gpuBuffer;
            if (gpuBuffer) {
              const cmd = this._cmdAllocator.updateBufferCmdPool.alloc(WebGLCmdUpdateBuffer);
              let buffSize = 0;
              let buff = null;
              if (buffer.usage & BufferUsageBit.INDIRECT) {
                buff = data;
              } else {
                if (size !== undefined) {
                  buffSize = size;
                } else {
                  buffSize = data.byteLength;
                }
                buff = data;
              }
              cmd.gpuBuffer = gpuBuffer;
              cmd.buffer = buff;
              cmd.offset = 0;
              cmd.size = buffSize;
              this.cmdPackage.updateBufferCmds.push(cmd);
              this.cmdPackage.cmds.push(WebGLCmd.UPDATE_BUFFER);
            }
          } else {
            console.error('Command \'updateBuffer\' must be recorded outside a render pass.');
          }
        }
        copyBuffersToTexture(buffers, texture, regions) {
          if (this._type === CommandBufferType.PRIMARY && !this._isInRenderPass || this._type === CommandBufferType.SECONDARY) {
            const gpuTexture = texture.gpuTexture;
            if (gpuTexture) {
              const cmd = this._cmdAllocator.copyBufferToTextureCmdPool.alloc(WebGLCmdCopyBufferToTexture);
              if (cmd) {
                cmd.gpuTexture = gpuTexture;
                cmd.regions = regions;
                cmd.buffers = buffers;
                this.cmdPackage.copyBufferToTextureCmds.push(cmd);
                this.cmdPackage.cmds.push(WebGLCmd.COPY_BUFFER_TO_TEXTURE);
              }
            }
          } else {
            console.error('Command \'copyBufferToTexture\' must be recorded outside a render pass.');
          }
        }
        execute(cmdBuffs, count) {
          for (let i = 0; i < count; ++i) {
            const webGLCmdBuff = cmdBuffs[i];
            for (let c = 0; c < webGLCmdBuff.cmdPackage.beginRenderPassCmds.length; ++c) {
              const cmd = webGLCmdBuff.cmdPackage.beginRenderPassCmds.array[c];
              ++cmd.refCount;
              this.cmdPackage.beginRenderPassCmds.push(cmd);
            }
            for (let c = 0; c < webGLCmdBuff.cmdPackage.bindStatesCmds.length; ++c) {
              const cmd = webGLCmdBuff.cmdPackage.bindStatesCmds.array[c];
              ++cmd.refCount;
              this.cmdPackage.bindStatesCmds.push(cmd);
            }
            for (let c = 0; c < webGLCmdBuff.cmdPackage.drawCmds.length; ++c) {
              const cmd = webGLCmdBuff.cmdPackage.drawCmds.array[c];
              ++cmd.refCount;
              this.cmdPackage.drawCmds.push(cmd);
            }
            for (let c = 0; c < webGLCmdBuff.cmdPackage.updateBufferCmds.length; ++c) {
              const cmd = webGLCmdBuff.cmdPackage.updateBufferCmds.array[c];
              ++cmd.refCount;
              this.cmdPackage.updateBufferCmds.push(cmd);
            }
            for (let c = 0; c < webGLCmdBuff.cmdPackage.copyBufferToTextureCmds.length; ++c) {
              const cmd = webGLCmdBuff.cmdPackage.copyBufferToTextureCmds.array[c];
              ++cmd.refCount;
              this.cmdPackage.copyBufferToTextureCmds.push(cmd);
            }
            for (let c = 0; c < webGLCmdBuff.cmdPackage.blitTextureCmds.length; ++c) {
              const cmd = webGLCmdBuff.cmdPackage.blitTextureCmds.array[c];
              ++cmd.refCount;
              this.cmdPackage.blitTextureCmds.push(cmd);
            }
            this.cmdPackage.cmds.concat(webGLCmdBuff.cmdPackage.cmds.array);
            this._numDrawCalls += webGLCmdBuff._numDrawCalls;
            this._numInstances += webGLCmdBuff._numInstances;
            this._numTris += webGLCmdBuff._numTris;
          }
        }
        pipelineBarrier(GeneralBarrier, bufferBarriers, buffers, textureBarriers, textures) {}
        bindStates() {
          const bindStatesCmd = this._cmdAllocator.bindStatesCmdPool.alloc(WebGLCmdBindStates);
          if (bindStatesCmd) {
            bindStatesCmd.gpuPipelineState = this._curGPUPipelineState;
            Array.prototype.push.apply(bindStatesCmd.gpuDescriptorSets, this._curGPUDescriptorSets);
            Array.prototype.push.apply(bindStatesCmd.dynamicOffsets, this._curDynamicOffsets);
            bindStatesCmd.gpuInputAssembler = this._curGPUInputAssembler;
            bindStatesCmd.dynamicStates.copy(this._curDynamicStates);
            this.cmdPackage.bindStatesCmds.push(bindStatesCmd);
            this.cmdPackage.cmds.push(WebGLCmd.BIND_STATES);
            this._isStateInvalied = false;
          }
        }
        blitTexture(srcTexture, dstTexture, regions, filter) {
          const blitTextureCmd = this._cmdAllocator.blitTextureCmdPool.alloc(WebGLCmdBlitTexture);
          blitTextureCmd.srcTexture = srcTexture.gpuTexture;
          blitTextureCmd.dstTexture = dstTexture.gpuTexture;
          blitTextureCmd.regions = regions;
          blitTextureCmd.filter = filter;
          ++this._numDrawCalls;
          this.cmdPackage.blitTextureCmds.push(blitTextureCmd);
          this.cmdPackage.cmds.push(WebGLCmd.BLIT_TEXTURE);
        }
      }

      class WebGLFramebuffer extends Framebuffer {
        constructor(...args) {
          super(...args);
          this._gpuFramebuffer = null;
        }
        get gpuFramebuffer() {
          return this._gpuFramebuffer;
        }
        initialize(info) {
          this._renderPass = info.renderPass;
          this._colorTextures = info.colorTextures || [];
          this._depthStencilTexture = info.depthStencilTexture || null;
          let lodLevel = 0;
          const gpuColorTextures = [];
          for (let i = 0; i < info.colorTextures.length; ++i) {
            const colorTexture = info.colorTextures[i];
            if (colorTexture) {
              gpuColorTextures.push(colorTexture.gpuTexture);
              lodLevel = colorTexture.lodLevel;
            }
          }
          let gpuDepthStencilTexture = null;
          if (info.depthStencilTexture) {
            gpuDepthStencilTexture = info.depthStencilTexture.gpuTexture;
            lodLevel = info.depthStencilTexture.lodLevel;
          }
          let width = Number.MAX_SAFE_INTEGER;
          let height = Number.MAX_SAFE_INTEGER;
          this._gpuFramebuffer = {
            gpuRenderPass: info.renderPass.gpuRenderPass,
            gpuColorTextures,
            gpuDepthStencilTexture,
            glFramebuffer: null,
            isOffscreen: true,
            get width() {
              if (this.isOffscreen) {
                return width;
              } else if (this.gpuColorTextures.length > 0) {
                return this.gpuColorTextures[0].width;
              } else {
                return this.gpuDepthStencilTexture.width;
              }
            },
            set width(val) {
              width = val;
            },
            get height() {
              if (this.isOffscreen) {
                return height;
              } else if (this.gpuColorTextures.length > 0) {
                return this.gpuColorTextures[0].height;
              } else {
                return this.gpuDepthStencilTexture.height;
              }
            },
            set height(val) {
              height = val;
            },
            lodLevel
          };
          WebGLCmdFuncCreateFramebuffer(WebGLDeviceManager.instance, this._gpuFramebuffer);
          this._width = this._gpuFramebuffer.width;
          this._height = this._gpuFramebuffer.height;
        }
        destroy() {
          if (this._gpuFramebuffer) {
            WebGLCmdFuncDestroyFramebuffer(WebGLDeviceManager.instance, this._gpuFramebuffer);
            this._gpuFramebuffer = null;
          }
        }
      }

      class WebGLInputAssembler extends InputAssembler {
        constructor(...args) {
          super(...args);
          this._gpuInputAssembler = null;
        }
        get gpuInputAssembler() {
          return this._gpuInputAssembler;
        }
        initialize(info) {
          if (info.vertexBuffers.length === 0) {
            console.error('InputAssemblerInfo.vertexBuffers is null.');
            return;
          }
          this._attributes = info.attributes;
          this._attributesHash = this.computeAttributesHash();
          this._vertexBuffers = info.vertexBuffers;
          if (info.indexBuffer) {
            this._indexBuffer = info.indexBuffer;
            this._drawInfo.indexCount = this._indexBuffer.size / this._indexBuffer.stride;
            this._drawInfo.firstIndex = 0;
          } else {
            const vertBuff = this._vertexBuffers[0];
            this._drawInfo.vertexCount = vertBuff.size / vertBuff.stride;
            this._drawInfo.firstVertex = 0;
            this._drawInfo.vertexOffset = 0;
          }
          this._drawInfo.instanceCount = 0;
          this._drawInfo.firstInstance = 0;
          this._indirectBuffer = info.indirectBuffer || null;
          const gpuVertexBuffers = new Array(info.vertexBuffers.length);
          for (let i = 0; i < info.vertexBuffers.length; ++i) {
            const vb = info.vertexBuffers[i];
            if (vb.gpuBuffer) {
              gpuVertexBuffers[i] = vb.gpuBuffer;
            }
          }
          let gpuIndexBuffer = null;
          let glIndexType = 0;
          if (info.indexBuffer) {
            gpuIndexBuffer = info.indexBuffer.gpuBuffer;
            if (gpuIndexBuffer) {
              switch (gpuIndexBuffer.stride) {
                case 1:
                  glIndexType = 0x1401;
                  break;
                case 2:
                  glIndexType = 0x1403;
                  break;
                case 4:
                  glIndexType = 0x1405;
                  break;
                default:
                  {
                    console.error('Error index buffer stride.');
                  }
              }
            }
          }
          let gpuIndirectBuffer = null;
          if (info.indirectBuffer) {
            gpuIndirectBuffer = info.indirectBuffer.gpuBuffer;
          }
          this._gpuInputAssembler = {
            attributes: info.attributes,
            gpuVertexBuffers,
            gpuIndexBuffer,
            gpuIndirectBuffer,
            glAttribs: [],
            glIndexType,
            glVAOs: new Map()
          };
          WebGLCmdFuncCreateInputAssember(WebGLDeviceManager.instance, this._gpuInputAssembler);
        }
        destroy() {
          const device = WebGLDeviceManager.instance;
          if (this._gpuInputAssembler && device.extensions.useVAO) {
            WebGLCmdFuncDestroyInputAssembler(device, this._gpuInputAssembler);
          }
          this._gpuInputAssembler = null;
        }
      }

      class WebGLDescriptorSetLayout extends DescriptorSetLayout {
        constructor(...args) {
          super(...args);
          this._gpuDescriptorSetLayout = null;
        }
        get gpuDescriptorSetLayout() {
          return this._gpuDescriptorSetLayout;
        }
        initialize(info) {
          Array.prototype.push.apply(this._bindings, info.bindings);
          let descriptorCount = 0;
          let maxBinding = -1;
          const flattenedIndices = [];
          for (let i = 0; i < this._bindings.length; i++) {
            const binding = this._bindings[i];
            flattenedIndices.push(descriptorCount);
            descriptorCount += binding.count;
            if (binding.binding > maxBinding) maxBinding = binding.binding;
          }
          this._bindingIndices = Array(maxBinding + 1).fill(-1);
          const descriptorIndices = this._descriptorIndices = Array(maxBinding + 1).fill(-1);
          for (let i = 0; i < this._bindings.length; i++) {
            const binding = this._bindings[i];
            this._bindingIndices[binding.binding] = i;
            descriptorIndices[binding.binding] = flattenedIndices[i];
          }
          const dynamicBindings = [];
          for (let i = 0; i < this._bindings.length; i++) {
            const binding = this._bindings[i];
            if (binding.descriptorType & DESCRIPTOR_DYNAMIC_TYPE) {
              for (let j = 0; j < binding.count; j++) {
                dynamicBindings.push(binding.binding);
              }
            }
          }
          this._gpuDescriptorSetLayout = {
            bindings: this._bindings,
            dynamicBindings,
            descriptorIndices,
            descriptorCount
          };
        }
        destroy() {
          this._bindings.length = 0;
        }
      }

      class WebGLPipelineLayout extends PipelineLayout {
        constructor(...args) {
          super(...args);
          this._gpuPipelineLayout = null;
        }
        get gpuPipelineLayout() {
          return this._gpuPipelineLayout;
        }
        initialize(info) {
          Array.prototype.push.apply(this._setLayouts, info.setLayouts);
          const dynamicOffsetIndices = [];
          const gpuSetLayouts = [];
          let dynamicOffsetCount = 0;
          const dynamicOffsetOffsets = [];
          for (let i = 0; i < this._setLayouts.length; i++) {
            const setLayout = this._setLayouts[i];
            const dynamicBindings = setLayout.gpuDescriptorSetLayout.dynamicBindings;
            const indices = Array(setLayout.bindingIndices.length).fill(-1);
            for (let j = 0; j < dynamicBindings.length; j++) {
              const binding = dynamicBindings[j];
              if (indices[binding] < 0) indices[binding] = dynamicOffsetCount + j;
            }
            gpuSetLayouts.push(setLayout.gpuDescriptorSetLayout);
            dynamicOffsetIndices.push(indices);
            dynamicOffsetOffsets.push(dynamicOffsetCount);
            dynamicOffsetCount += dynamicBindings.length;
          }
          this._gpuPipelineLayout = {
            gpuSetLayouts,
            dynamicOffsetIndices,
            dynamicOffsetCount,
            dynamicOffsetOffsets
          };
        }
        destroy() {
          this._setLayouts.length = 0;
        }
      }

      const WebGLPrimitives$1 = [0x0000, 0x0001, 0x0003, 0x0002, 0x0000, 0x0000, 0x0000, 0x0004, 0x0005, 0x0006, 0x0000, 0x0000, 0x0000, 0x0000];
      class WebGLPipelineState extends PipelineState {
        constructor(...args) {
          super(...args);
          this._gpuPipelineState = null;
        }
        get gpuPipelineState() {
          return this._gpuPipelineState;
        }
        initialize(info) {
          this._primitive = info.primitive;
          this._shader = info.shader;
          this._pipelineLayout = info.pipelineLayout;
          const bs = this._bs;
          if (info.blendState) {
            const bsInfo = info.blendState;
            const {
              targets
            } = bsInfo;
            if (targets) {
              targets.forEach((t, i) => {
                bs.setTarget(i, t);
              });
            }
            if (bsInfo.isA2C !== undefined) {
              bs.isA2C = bsInfo.isA2C;
            }
            if (bsInfo.isIndepend !== undefined) {
              bs.isIndepend = bsInfo.isIndepend;
            }
            if (bsInfo.blendColor !== undefined) {
              bs.blendColor = bsInfo.blendColor;
            }
          }
          Object.assign(this._rs, info.rasterizerState);
          Object.assign(this._dss, info.depthStencilState);
          this._is = info.inputState;
          this._renderPass = info.renderPass;
          this._dynamicStates = info.dynamicStates;
          const dynamicStates = [];
          for (let i = 0; i < 31; i++) {
            if (this._dynamicStates & 1 << i) {
              dynamicStates.push(1 << i);
            }
          }
          this._gpuPipelineState = {
            glPrimitive: WebGLPrimitives$1[info.primitive],
            gpuShader: info.shader.gpuShader,
            gpuPipelineLayout: info.pipelineLayout.gpuPipelineLayout,
            rs: info.rasterizerState,
            dss: info.depthStencilState,
            bs: info.blendState,
            gpuRenderPass: info.renderPass.gpuRenderPass,
            dynamicStates
          };
        }
        destroy() {
          this._gpuPipelineState = null;
        }
      }

      class WebGLPrimaryCommandBuffer extends WebGLCommandBuffer {
        beginRenderPass(renderPass, framebuffer, renderArea, clearColors, clearDepth, clearStencil) {
          WebGLCmdFuncBeginRenderPass(WebGLDeviceManager.instance, renderPass.gpuRenderPass, framebuffer.gpuFramebuffer, renderArea, clearColors, clearDepth, clearStencil);
          this._isInRenderPass = true;
        }
        draw(infoOrAssembler) {
          if (this._isInRenderPass) {
            if (this._isStateInvalied) {
              this.bindStates();
            }
            const info = 'drawInfo' in infoOrAssembler ? infoOrAssembler.drawInfo : infoOrAssembler;
            WebGLCmdFuncDraw(WebGLDeviceManager.instance, info);
            ++this._numDrawCalls;
            this._numInstances += info.instanceCount;
            const indexCount = info.indexCount || info.vertexCount;
            if (this._curGPUPipelineState) {
              const glPrimitive = this._curGPUPipelineState.glPrimitive;
              switch (glPrimitive) {
                case 0x0004:
                  {
                    this._numTris += indexCount / 3 * Math.max(info.instanceCount, 1);
                    break;
                  }
                case 0x0005:
                case 0x0006:
                  {
                    this._numTris += (indexCount - 2) * Math.max(info.instanceCount, 1);
                    break;
                  }
              }
            }
          } else {
            console.error('Command \'draw\' must be recorded inside a render pass.');
          }
        }
        setViewport(viewport) {
          const {
            stateCache: cache,
            gl
          } = WebGLDeviceManager.instance;
          if (cache.viewport.left !== viewport.left || cache.viewport.top !== viewport.top || cache.viewport.width !== viewport.width || cache.viewport.height !== viewport.height) {
            gl.viewport(viewport.left, viewport.top, viewport.width, viewport.height);
            cache.viewport.left = viewport.left;
            cache.viewport.top = viewport.top;
            cache.viewport.width = viewport.width;
            cache.viewport.height = viewport.height;
          }
        }
        setScissor(scissor) {
          const {
            stateCache: cache,
            gl
          } = WebGLDeviceManager.instance;
          if (cache.scissorRect.x !== scissor.x || cache.scissorRect.y !== scissor.y || cache.scissorRect.width !== scissor.width || cache.scissorRect.height !== scissor.height) {
            gl.scissor(scissor.x, scissor.y, scissor.width, scissor.height);
            cache.scissorRect.x = scissor.x;
            cache.scissorRect.y = scissor.y;
            cache.scissorRect.width = scissor.width;
            cache.scissorRect.height = scissor.height;
          }
        }
        updateBuffer(buffer, data, size) {
          if (!this._isInRenderPass) {
            const gpuBuffer = buffer.gpuBuffer;
            if (gpuBuffer) {
              let buffSize;
              if (size !== undefined) {
                buffSize = size;
              } else if (buffer.usage & BufferUsageBit.INDIRECT) {
                buffSize = 0;
              } else {
                buffSize = data.byteLength;
              }
              WebGLCmdFuncUpdateBuffer(WebGLDeviceManager.instance, gpuBuffer, data, 0, buffSize);
            }
          } else {
            console.error('Command \'updateBuffer\' must be recorded outside a render pass.');
          }
        }
        copyBuffersToTexture(buffers, texture, regions) {
          if (!this._isInRenderPass) {
            const gpuTexture = texture.gpuTexture;
            if (gpuTexture) {
              WebGLCmdFuncCopyBuffersToTexture(WebGLDeviceManager.instance, buffers, gpuTexture, regions);
            }
          } else {
            console.error('Command \'copyBufferToTexture\' must be recorded outside a render pass.');
          }
        }
        execute(cmdBuffs, count) {
          for (let i = 0; i < count; ++i) {
            const webGLCmdBuff = cmdBuffs[i];
            WebGLCmdFuncExecuteCmds(WebGLDeviceManager.instance, webGLCmdBuff.cmdPackage);
            this._numDrawCalls += webGLCmdBuff._numDrawCalls;
            this._numInstances += webGLCmdBuff._numInstances;
            this._numTris += webGLCmdBuff._numTris;
          }
        }
        bindStates() {
          WebGLCmdFuncBindStates(WebGLDeviceManager.instance, this._curGPUPipelineState, this._curGPUInputAssembler, this._curGPUDescriptorSets, this._curDynamicOffsets, this._curDynamicStates);
          this._isStateInvalied = false;
        }
        blitTexture(srcTexture, dstTexture, regions, filter) {
          const gpuTextureSrc = srcTexture.gpuTexture;
          const gpuTextureDst = dstTexture.gpuTexture;
          WebGLCmdFuncBlitTexture(WebGLDeviceManager.instance, gpuTextureSrc, gpuTextureDst, regions, filter);
        }
      }

      class WebGLQueue extends Queue {
        constructor(...args) {
          super(...args);
          this.numDrawCalls = 0;
          this.numInstances = 0;
          this.numTris = 0;
        }
        initialize(info) {
          this._type = info.type;
        }
        destroy() {}
        submit(cmdBuffs) {
          const len = cmdBuffs.length;
          for (let i = 0; i < len; i++) {
            const cmdBuff = cmdBuffs[i];
            this.numDrawCalls += cmdBuff.numDrawCalls;
            this.numInstances += cmdBuff.numInstances;
            this.numTris += cmdBuff.numTris;
          }
        }
        clear() {
          this.numDrawCalls = 0;
          this.numInstances = 0;
          this.numTris = 0;
        }
      }

      class WebGLRenderPass extends RenderPass {
        constructor(...args) {
          super(...args);
          this._gpuRenderPass = null;
        }
        get gpuRenderPass() {
          return this._gpuRenderPass;
        }
        initialize(info) {
          this._colorInfos = info.colorAttachments;
          this._depthStencilInfo = info.depthStencilAttachment;
          this._subpasses = info.subpasses;
          this._gpuRenderPass = {
            colorAttachments: this._colorInfos,
            depthStencilAttachment: this._depthStencilInfo
          };
          this._hash = this.computeHash();
        }
        destroy() {
          this._gpuRenderPass = null;
        }
      }

      const WebGLWraps$1 = [0x2901, 0x8370, 0x812F, 0x812F];
      class WebGLSampler extends Sampler {
        get gpuSampler() {
          return this._gpuSampler;
        }
        constructor(info, hash) {
          super(info, hash);
          this._gpuSampler = null;
          let glMinFilter = 0;
          let glMagFilter = 0;
          const minFilter = this._info.minFilter;
          const magFilter = this._info.magFilter;
          const mipFilter = this._info.mipFilter;
          if (minFilter === Filter$1.LINEAR || minFilter === Filter$1.ANISOTROPIC) {
            if (mipFilter === Filter$1.LINEAR || mipFilter === Filter$1.ANISOTROPIC) {
              glMinFilter = 0x2703;
            } else if (mipFilter === Filter$1.POINT) {
              glMinFilter = 0x2701;
            } else {
              glMinFilter = 0x2601;
            }
          } else if (mipFilter === Filter$1.LINEAR || mipFilter === Filter$1.ANISOTROPIC) {
            glMinFilter = 0x2702;
          } else if (mipFilter === Filter$1.POINT) {
            glMinFilter = 0x2700;
          } else {
            glMinFilter = 0x2600;
          }
          if (magFilter === Filter$1.LINEAR || magFilter === Filter$1.ANISOTROPIC) {
            glMagFilter = 0x2601;
          } else {
            glMagFilter = 0x2600;
          }
          const glWrapS = WebGLWraps$1[this._info.addressU];
          const glWrapT = WebGLWraps$1[this._info.addressV];
          const glWrapR = WebGLWraps$1[this._info.addressW];
          this._gpuSampler = {
            glMinFilter,
            glMagFilter,
            glWrapS,
            glWrapT,
            glWrapR
          };
        }
      }

      class WebGLShader extends Shader {
        constructor(...args) {
          super(...args);
          this._gpuShader = null;
        }
        get gpuShader() {
          if (this._gpuShader.glProgram === null) {
            WebGLCmdFuncCreateShader(WebGLDeviceManager.instance, this._gpuShader);
          }
          return this._gpuShader;
        }
        initialize(info) {
          this._name = info.name;
          this._stages = info.stages;
          this._attributes = info.attributes;
          this._blocks = info.blocks;
          this._samplers = info.samplers;
          this._gpuShader = {
            name: info.name,
            blocks: info.blocks.slice(),
            samplerTextures: info.samplerTextures.slice(),
            subpassInputs: info.subpassInputs.slice(),
            gpuStages: new Array(info.stages.length),
            glProgram: null,
            glInputs: [],
            glUniforms: [],
            glBlocks: [],
            glSamplerTextures: []
          };
          for (let i = 0; i < info.stages.length; ++i) {
            const stage = info.stages[i];
            this._gpuShader.gpuStages[i] = {
              type: stage.stage,
              source: stage.source,
              glShader: null
            };
          }
        }
        destroy() {
          if (this._gpuShader) {
            WebGLCmdFuncDestroyShader(WebGLDeviceManager.instance, this._gpuShader);
            this._gpuShader = null;
          }
        }
      }

      class WebGLStateCache {
        constructor() {
          this.glArrayBuffer = null;
          this.glElementArrayBuffer = null;
          this.glVAO = null;
          this.texUnit = 0;
          this.glTexUnits = [];
          this.glRenderbuffer = null;
          this.glFramebuffer = null;
          this.viewport = new Viewport();
          this.scissorRect = new Rect(0, 0, 0, 0);
          this.rs = new RasterizerState();
          this.dss = new DepthStencilState();
          this.bs = new BlendState();
          this.glProgram = null;
          this.glEnabledAttribLocs = [];
          this.glCurrentAttribLocs = [];
          this.texUnitCacheMap = {};
        }
        initialize(texUnit, vertexAttributes) {
          for (let i = 0; i < texUnit; ++i) this.glTexUnits.push({
            glTexture: null
          });
          this.glEnabledAttribLocs.length = vertexAttributes;
          this.glEnabledAttribLocs.fill(false);
          this.glCurrentAttribLocs.length = vertexAttributes;
          this.glCurrentAttribLocs.fill(false);
        }
      }

      class WebGLTexture extends Texture {
        constructor(...args) {
          super(...args);
          this._gpuTexture = null;
          this._lodLevel = 0;
        }
        get gpuTexture() {
          return this._gpuTexture;
        }
        get lodLevel() {
          return this._lodLevel;
        }
        initialize(info, isSwapchainTexture) {
          let texInfo = info;
          const viewInfo = info;
          if ('texture' in info) {
            texInfo = viewInfo.texture.info;
            this._isTextureView = true;
          }
          this._info.copy(texInfo);
          this._isPowerOf2 = IsPowerOf2(this._info.width) && IsPowerOf2(this._info.height);
          this._size = FormatSurfaceSize(this._info.format, this.width, this.height, this.depth, this._info.levelCount) * this._info.layerCount;
          if (!this._isTextureView) {
            this._gpuTexture = {
              type: texInfo.type,
              format: texInfo.format,
              usage: texInfo.usage,
              width: texInfo.width,
              height: texInfo.height,
              depth: texInfo.depth,
              size: this._size,
              arrayLayer: texInfo.layerCount,
              mipLevel: texInfo.levelCount,
              samples: texInfo.samples,
              flags: texInfo.flags,
              isPowerOf2: this._isPowerOf2,
              glTarget: 0,
              glInternalFmt: 0,
              glFormat: 0,
              glType: 0,
              glUsage: 0,
              glTexture: null,
              glRenderbuffer: null,
              glWrapS: 0,
              glWrapT: 0,
              glMinFilter: 0,
              glMagFilter: 0,
              isSwapchainTexture: isSwapchainTexture || false
            };
            if (!this._gpuTexture.isSwapchainTexture) {
              WebGLCmdFuncCreateTexture(WebGLDeviceManager.instance, this._gpuTexture);
              WebGLDeviceManager.instance.memoryStatus.textureSize += this._size;
            }
            this._viewInfo.texture = this;
            this._viewInfo.type = info.type;
            this._viewInfo.format = info.format;
            this._viewInfo.baseLevel = 0;
            this._viewInfo.levelCount = info.levelCount;
            this._viewInfo.baseLayer = 0;
            this._viewInfo.layerCount = info.layerCount;
          } else {
            this._viewInfo.copy(viewInfo);
            this._lodLevel = viewInfo.baseLevel;
            this._gpuTexture = viewInfo.texture._gpuTexture;
          }
        }
        destroy() {
          if (!this._isTextureView && this._gpuTexture) {
            WebGLCmdFuncDestroyTexture(WebGLDeviceManager.instance, this._gpuTexture);
            WebGLDeviceManager.instance.memoryStatus.textureSize -= this._size;
            this._gpuTexture = null;
          }
        }
        getGLTextureHandle() {
          const gpuTexture = this._gpuTexture;
          if (!gpuTexture) {
            return 0;
          }
          if (gpuTexture.glTexture) {
            return gpuTexture.glTexture;
          } else if (gpuTexture.glRenderbuffer) {
            return gpuTexture.glRenderbuffer;
          }
          return 0;
        }
        resize(width, height) {
          if (this._info.width === width && this._info.height === height) {
            return;
          }
          if (this._info.levelCount === WebGLTexture.getLevelCount(this._info.width, this._info.height)) {
            this._info.levelCount = WebGLTexture.getLevelCount(width, height);
          } else if (this._info.levelCount > 1) {
            this._info.levelCount = Math.min(this._info.levelCount, WebGLTexture.getLevelCount(width, height));
          }
          const oldSize = this._size;
          this._info.width = width;
          this._info.height = height;
          this._size = FormatSurfaceSize(this._info.format, this.width, this.height, this.depth, this._info.levelCount) * this._info.layerCount;
          if (!this._isTextureView && this._gpuTexture) {
            this._gpuTexture.width = width;
            this._gpuTexture.height = height;
            this._gpuTexture.size = this._size;
            if (!this._gpuTexture.isSwapchainTexture) {
              WebGLCmdFuncResizeTexture(WebGLDeviceManager.instance, this._gpuTexture);
              WebGLDeviceManager.instance.memoryStatus.textureSize -= oldSize;
              WebGLDeviceManager.instance.memoryStatus.textureSize += this._size;
            }
          }
        }
        initAsSwapchainTexture(info) {
          const texInfo = new TextureInfo();
          texInfo.format = info.format;
          texInfo.usage = FormatInfos[info.format].hasDepth ? TextureUsageBit.DEPTH_STENCIL_ATTACHMENT : TextureUsageBit.COLOR_ATTACHMENT;
          texInfo.width = info.width;
          texInfo.height = info.height;
          this.initialize(texInfo, true);
        }
      }

      const eventWebGLContextLost$1 = 'webglcontextlost';
      function initStates$1(gl) {
        gl.activeTexture(gl.TEXTURE0);
        gl.pixelStorei(gl.PACK_ALIGNMENT, 1);
        gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.enable(gl.SCISSOR_TEST);
        gl.enable(gl.CULL_FACE);
        gl.cullFace(gl.BACK);
        gl.frontFace(gl.CCW);
        gl.disable(gl.POLYGON_OFFSET_FILL);
        gl.polygonOffset(0.0, 0.0);
        gl.enable(gl.DEPTH_TEST);
        gl.depthMask(true);
        gl.depthFunc(gl.LESS);
        gl.depthRange(0.0, 1.0);
        gl.stencilFuncSeparate(gl.FRONT, gl.ALWAYS, 1, 0xffff);
        gl.stencilOpSeparate(gl.FRONT, gl.KEEP, gl.KEEP, gl.KEEP);
        gl.stencilMaskSeparate(gl.FRONT, 0xffff);
        gl.stencilFuncSeparate(gl.BACK, gl.ALWAYS, 1, 0xffff);
        gl.stencilOpSeparate(gl.BACK, gl.KEEP, gl.KEEP, gl.KEEP);
        gl.stencilMaskSeparate(gl.BACK, 0xffff);
        gl.disable(gl.STENCIL_TEST);
        gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
        gl.disable(gl.BLEND);
        gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
        gl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.ONE, gl.ZERO);
        gl.colorMask(true, true, true, true);
        gl.blendColor(0.0, 0.0, 0.0, 0.0);
      }
      function getExtension$1(gl, ext) {
        const prefixes = ['', 'WEBKIT_', 'MOZ_'];
        for (let i = 0; i < prefixes.length; ++i) {
          const _ext = gl.getExtension(prefixes[i] + ext);
          if (_ext) {
            return _ext;
          }
        }
        return null;
      }
      function getExtensions$1(gl) {
        const res = {
          EXT_texture_filter_anisotropic: getExtension$1(gl, 'EXT_texture_filter_anisotropic'),
          EXT_blend_minmax: getExtension$1(gl, 'EXT_blend_minmax'),
          EXT_frag_depth: getExtension$1(gl, 'EXT_frag_depth'),
          EXT_shader_texture_lod: getExtension$1(gl, 'EXT_shader_texture_lod'),
          EXT_sRGB: getExtension$1(gl, 'EXT_sRGB'),
          OES_vertex_array_object: getExtension$1(gl, 'OES_vertex_array_object'),
          EXT_color_buffer_half_float: getExtension$1(gl, 'EXT_color_buffer_half_float'),
          WEBGL_color_buffer_float: getExtension$1(gl, 'WEBGL_color_buffer_float'),
          WEBGL_compressed_texture_etc1: getExtension$1(gl, 'WEBGL_compressed_texture_etc1'),
          WEBGL_compressed_texture_etc: getExtension$1(gl, 'WEBGL_compressed_texture_etc'),
          WEBGL_compressed_texture_pvrtc: getExtension$1(gl, 'WEBGL_compressed_texture_pvrtc'),
          WEBGL_compressed_texture_s3tc: getExtension$1(gl, 'WEBGL_compressed_texture_s3tc'),
          WEBGL_compressed_texture_s3tc_srgb: getExtension$1(gl, 'WEBGL_compressed_texture_s3tc_srgb'),
          WEBGL_debug_shaders: getExtension$1(gl, 'WEBGL_debug_shaders'),
          WEBGL_draw_buffers: getExtension$1(gl, 'WEBGL_draw_buffers'),
          WEBGL_lose_context: getExtension$1(gl, 'WEBGL_lose_context'),
          WEBGL_depth_texture: getExtension$1(gl, 'WEBGL_depth_texture'),
          OES_texture_half_float: getExtension$1(gl, 'OES_texture_half_float'),
          OES_texture_half_float_linear: getExtension$1(gl, 'OES_texture_half_float_linear'),
          OES_texture_float: getExtension$1(gl, 'OES_texture_float'),
          OES_texture_float_linear: getExtension$1(gl, 'OES_texture_float_linear'),
          OES_standard_derivatives: getExtension$1(gl, 'OES_standard_derivatives'),
          OES_element_index_uint: getExtension$1(gl, 'OES_element_index_uint'),
          ANGLE_instanced_arrays: getExtension$1(gl, 'ANGLE_instanced_arrays'),
          WEBGL_debug_renderer_info: getExtension$1(gl, 'WEBGL_debug_renderer_info'),
          WEBGL_multi_draw: null,
          WEBGL_compressed_texture_astc: null,
          destroyShadersImmediately: true,
          noCompressedTexSubImage2D: false,
          isLocationActive: glLoc => !!glLoc,
          useVAO: false
        };
        {
          if (systemInfo.os !== OS.IOS || systemInfo.osMainVersion !== 14 || !systemInfo.isBrowser) {
            res.WEBGL_compressed_texture_astc = getExtension$1(gl, 'WEBGL_compressed_texture_astc');
          }
          if (systemInfo.os !== OS.ANDROID && systemInfo.os !== OS.IOS) {
            res.WEBGL_multi_draw = getExtension$1(gl, 'WEBGL_multi_draw');
          }
          if (systemInfo.browserType === BrowserType.UC) {
            res.ANGLE_instanced_arrays = null;
          }
          if (systemInfo.os === OS.IOS && systemInfo.osMainVersion <= 10 || (WECHAT_MINI_PROGRAM) ) {
            res.destroyShadersImmediately = false;
          }
        }
        if (res.OES_vertex_array_object) {
          res.useVAO = true;
        }
        return res;
      }
      function getContext$1(canvas) {
        let context = null;
        try {
          const webGLCtxAttribs = {
            alpha: macro.ENABLE_TRANSPARENT_CANVAS,
            antialias: EDITOR || macro.ENABLE_WEBGL_ANTIALIAS,
            depth: true,
            stencil: true,
            premultipliedAlpha: false,
            preserveDrawingBuffer: false,
            powerPreference: 'default',
            failIfMajorPerformanceCaveat: false
          };
          context = canvas.getContext('webgl', webGLCtxAttribs);
        } catch (err) {
          return null;
        }
        return context;
      }
      class WebGLSwapchain extends Swapchain {
        constructor(...args) {
          super(...args);
          this.stateCache = new WebGLStateCache();
          this.cmdAllocator = new WebGLCommandAllocator();
          this.nullTex2D = null;
          this.nullTexCube = null;
          this._canvas = null;
          this._webGLContextLostHandler = null;
          this._extensions = null;
          this._blitManager = null;
        }
        get extensions() {
          return this._extensions;
        }
        get blitManager() {
          return this._blitManager;
        }
        initialize(info) {
          this._canvas = info.windowHandle;
          this._webGLContextLostHandler = this._onWebGLContextLost.bind(this);
          this._canvas.addEventListener(eventWebGLContextLost$1, this._onWebGLContextLost);
          const gl = WebGLDeviceManager.instance.gl;
          this.stateCache.initialize(WebGLDeviceManager.instance.capabilities.maxTextureUnits, WebGLDeviceManager.instance.capabilities.maxVertexAttributes);
          this._extensions = getExtensions$1(gl);
          initStates$1(gl);
          const colorFmt = Format.RGBA8;
          let depthStencilFmt = Format.DEPTH_STENCIL;
          let depthBits = gl.getParameter(gl.DEPTH_BITS);
          const stencilBits = gl.getParameter(gl.STENCIL_BITS);
          if (depthBits && stencilBits) depthStencilFmt = Format.DEPTH_STENCIL;else if (depthBits) depthStencilFmt = Format.DEPTH;
          this._colorTexture = new WebGLTexture();
          this._colorTexture.initAsSwapchainTexture({
            swapchain: this,
            format: colorFmt,
            width: info.width,
            height: info.height
          });
          this._depthStencilTexture = new WebGLTexture();
          this._depthStencilTexture.initAsSwapchainTexture({
            swapchain: this,
            format: depthStencilFmt,
            width: info.width,
            height: info.height
          });
          this.nullTex2D = WebGLDeviceManager.instance.createTexture(new TextureInfo(TextureType.TEX2D, TextureUsageBit.SAMPLED, Format.RGBA8, 2, 2, TextureFlagBit.GEN_MIPMAP));
          this.nullTexCube = WebGLDeviceManager.instance.createTexture(new TextureInfo(TextureType.CUBE, TextureUsageBit.SAMPLED, Format.RGBA8, 2, 2, TextureFlagBit.GEN_MIPMAP, 6));
          const nullTexRegion = new BufferTextureCopy();
          nullTexRegion.texExtent.width = 2;
          nullTexRegion.texExtent.height = 2;
          const nullTexBuff = new Uint8Array(this.nullTex2D.size);
          nullTexBuff.fill(0);
          WebGLDeviceManager.instance.copyBuffersToTexture([nullTexBuff], this.nullTex2D, [nullTexRegion]);
          nullTexRegion.texSubres.layerCount = 6;
          WebGLDeviceManager.instance.copyBuffersToTexture([nullTexBuff, nullTexBuff, nullTexBuff, nullTexBuff, nullTexBuff, nullTexBuff], this.nullTexCube, [nullTexRegion]);
          this._blitManager = new IWebGLBlitManager();
        }
        destroy() {
          if (this._canvas && this._webGLContextLostHandler) {
            this._canvas.removeEventListener(eventWebGLContextLost$1, this._webGLContextLostHandler);
            this._webGLContextLostHandler = null;
          }
          if (this.nullTex2D) {
            this.nullTex2D.destroy();
            this.nullTex2D = null;
          }
          if (this.nullTexCube) {
            this.nullTexCube.destroy();
            this.nullTexCube = null;
          }
          if (this._blitManager) {
            this._blitManager.destroy();
            this._blitManager = null;
          }
          this._extensions = null;
          this._canvas = null;
        }
        resize(width, height, surfaceTransform) {
          if (this._colorTexture.width !== width || this._colorTexture.height !== height) {
            debug(`Resizing swapchain: ${width}x${height}`);
            this._canvas.width = width;
            this._canvas.height = height;
            this._colorTexture.resize(width, height);
            this._depthStencilTexture.resize(width, height);
          }
        }
        _onWebGLContextLost(event) {
          warnID(11000);
          warn(event);
        }
      }

      class BufferBarrier extends GFXObject {
        get info() {
          return this._info;
        }
        get hash() {
          return this._hash;
        }
        constructor(info, hash) {
          super(ObjectType.BUFFER_BARRIER);
          this._info = new BufferBarrierInfo();
          this._hash = 0;
          this._info.copy(info);
          this._hash = hash;
        }
        static computeHash(info) {
          let res = `${info.prevAccesses} ${info.nextAccesses}`;
          res += info.type;
          res += info.offset;
          res += info.size;
          res += info.discardContents;
          res += info.srcQueue ? info.srcQueue.type : 0;
          res += info.dstQueue ? info.dstQueue.type : 0;
          return murmurhash2_32_gc(res, 666);
        }
      }

      class WebGLDevice extends Device {
        constructor(...args) {
          super(...args);
          this._swapchain = null;
          this._context = null;
          this._bindingMappings = null;
          this._textureExclusive = new Array(Format.COUNT);
        }
        get gl() {
          return this._context;
        }
        get extensions() {
          return this._swapchain.extensions;
        }
        get stateCache() {
          return this._swapchain.stateCache;
        }
        get nullTex2D() {
          return this._swapchain.nullTex2D;
        }
        get nullTexCube() {
          return this._swapchain.nullTexCube;
        }
        get textureExclusive() {
          return this._textureExclusive;
        }
        get bindingMappings() {
          return this._bindingMappings;
        }
        get blitManager() {
          return this._swapchain.blitManager;
        }
        initialize(info) {
          WebGLDeviceManager.setInstance(this);
          this._gfxAPI = API.WEBGL;
          const mapping = this._bindingMappingInfo = info.bindingMappingInfo;
          const blockOffsets = [];
          const samplerTextureOffsets = [];
          const firstSet = mapping.setIndices[0];
          blockOffsets[firstSet] = 0;
          samplerTextureOffsets[firstSet] = 0;
          for (let i = 1; i < mapping.setIndices.length; ++i) {
            const curSet = mapping.setIndices[i];
            const prevSet = mapping.setIndices[i - 1];
            blockOffsets[curSet] = mapping.maxBlockCounts[prevSet] + blockOffsets[prevSet];
            samplerTextureOffsets[curSet] = mapping.maxSamplerTextureCounts[prevSet] + samplerTextureOffsets[prevSet];
          }
          for (let i = 0; i < mapping.setIndices.length; ++i) {
            const curSet = mapping.setIndices[i];
            samplerTextureOffsets[curSet] -= mapping.maxBlockCounts[curSet];
          }
          this._bindingMappings = {
            blockOffsets,
            samplerTextureOffsets,
            flexibleSet: mapping.setIndices[mapping.setIndices.length - 1]
          };
          const gl = this._context = getContext$1(Device.canvas);
          if (!gl) {
            console.error('This device does not support WebGL.');
            return false;
          }
          this._queue = this.createQueue(new QueueInfo(QueueType.GRAPHICS));
          this._cmdBuff = this.createCommandBuffer(new CommandBufferInfo(this._queue));
          this._caps.maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
          this._caps.maxVertexUniformVectors = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
          this._caps.maxFragmentUniformVectors = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
          this._caps.maxTextureUnits = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
          this._caps.maxVertexTextureUnits = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
          this._caps.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
          this._caps.maxCubeMapTextureSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
          this._caps.maxArrayTextureLayers = 0;
          this._caps.max3DTextureSize = 0;
          this._caps.maxUniformBufferBindings = 16;
          const extensions = gl.getSupportedExtensions();
          let extStr = '';
          if (extensions) {
            for (const ext of extensions) {
              extStr += `${ext} `;
            }
          }
          const exts = getExtensions$1(gl);
          if (exts.WEBGL_debug_renderer_info) {
            this._renderer = gl.getParameter(exts.WEBGL_debug_renderer_info.UNMASKED_RENDERER_WEBGL);
            this._vendor = gl.getParameter(exts.WEBGL_debug_renderer_info.UNMASKED_VENDOR_WEBGL);
          } else {
            this._renderer = gl.getParameter(gl.RENDERER);
            this._vendor = gl.getParameter(gl.VENDOR);
          }
          const version = gl.getParameter(gl.VERSION);
          this._features.fill(false);
          this.initFormatFeatures(exts);
          if (exts.EXT_blend_minmax) {
            this._features[Feature.BLEND_MINMAX] = true;
          }
          if (exts.OES_element_index_uint) {
            this._features[Feature.ELEMENT_INDEX_UINT] = true;
          }
          if (exts.ANGLE_instanced_arrays) {
            this._features[Feature.INSTANCED_ARRAYS] = true;
          }
          if (exts.WEBGL_draw_buffers) {
            this._features[Feature.MULTIPLE_RENDER_TARGETS] = true;
          }
          let compressedFormat = '';
          if (this.getFormatFeatures(Format.ETC_RGB8)) {
            compressedFormat += 'etc1 ';
          }
          if (this.getFormatFeatures(Format.ETC2_RGB8)) {
            compressedFormat += 'etc2 ';
          }
          if (this.getFormatFeatures(Format.BC1)) {
            compressedFormat += 'dxt ';
          }
          if (this.getFormatFeatures(Format.PVRTC_RGB2)) {
            compressedFormat += 'pvrtc ';
          }
          if (this.getFormatFeatures(Format.ASTC_RGBA_4X4)) {
            compressedFormat += 'astc ';
          }
          debug('WebGL device initialized.');
          debug(`RENDERER: ${this._renderer}`);
          debug(`VENDOR: ${this._vendor}`);
          debug(`VERSION: ${version}`);
          debug(`COMPRESSED_FORMAT: ${compressedFormat}`);
          debug(`EXTENSIONS: ${extStr}`);
          return true;
        }
        destroy() {
          if (this._queue) {
            this._queue.destroy();
            this._queue = null;
          }
          if (this._cmdBuff) {
            this._cmdBuff.destroy();
            this._cmdBuff = null;
          }
          this._swapchain = null;
        }
        flushCommands(cmdBuffs) {}
        acquire(swapchains) {}
        present() {
          const queue = this._queue;
          this._numDrawCalls = queue.numDrawCalls;
          this._numInstances = queue.numInstances;
          this._numTris = queue.numTris;
          queue.clear();
        }
        initFormatFeatures(exts) {
          this._formatFeatures.fill(FormatFeatureBit.NONE);
          this._textureExclusive.fill(true);
          const tempFeature = FormatFeatureBit.RENDER_TARGET | FormatFeatureBit.SAMPLED_TEXTURE | FormatFeatureBit.LINEAR_FILTER;
          this._formatFeatures[Format.RGB8] = tempFeature;
          this._formatFeatures[Format.R5G6B5] = tempFeature;
          this._textureExclusive[Format.R5G6B5] = false;
          this._formatFeatures[Format.RGBA8] = tempFeature;
          this._formatFeatures[Format.RGBA4] = tempFeature;
          this._textureExclusive[Format.RGBA4] = false;
          this._formatFeatures[Format.RGB5A1] = tempFeature;
          this._textureExclusive[Format.RGB5A1] = false;
          this._formatFeatures[Format.DEPTH] = FormatFeatureBit.RENDER_TARGET;
          this._textureExclusive[Format.DEPTH] = false;
          this._formatFeatures[Format.DEPTH_STENCIL] = FormatFeatureBit.RENDER_TARGET;
          this._textureExclusive[Format.DEPTH_STENCIL] = false;
          this._formatFeatures[Format.R8I] |= FormatFeatureBit.VERTEX_ATTRIBUTE;
          this._formatFeatures[Format.RG8I] |= FormatFeatureBit.VERTEX_ATTRIBUTE;
          this._formatFeatures[Format.RGB8I] |= FormatFeatureBit.VERTEX_ATTRIBUTE;
          this._formatFeatures[Format.RGBA8I] |= FormatFeatureBit.VERTEX_ATTRIBUTE;
          this._formatFeatures[Format.R8UI] |= FormatFeatureBit.VERTEX_ATTRIBUTE;
          this._formatFeatures[Format.RG8UI] |= FormatFeatureBit.VERTEX_ATTRIBUTE;
          this._formatFeatures[Format.RGB8UI] |= FormatFeatureBit.VERTEX_ATTRIBUTE;
          this._formatFeatures[Format.RGBA8UI] |= FormatFeatureBit.VERTEX_ATTRIBUTE;
          this._formatFeatures[Format.R8I] |= FormatFeatureBit.VERTEX_ATTRIBUTE;
          this._formatFeatures[Format.RG8I] |= FormatFeatureBit.VERTEX_ATTRIBUTE;
          this._formatFeatures[Format.RGB8I] |= FormatFeatureBit.VERTEX_ATTRIBUTE;
          this._formatFeatures[Format.RGBA8I] |= FormatFeatureBit.VERTEX_ATTRIBUTE;
          this._formatFeatures[Format.R8UI] |= FormatFeatureBit.VERTEX_ATTRIBUTE;
          this._formatFeatures[Format.RG8UI] |= FormatFeatureBit.VERTEX_ATTRIBUTE;
          this._formatFeatures[Format.RGB8UI] |= FormatFeatureBit.VERTEX_ATTRIBUTE;
          this._formatFeatures[Format.RGBA8UI] |= FormatFeatureBit.VERTEX_ATTRIBUTE;
          this._formatFeatures[Format.R32F] |= FormatFeatureBit.VERTEX_ATTRIBUTE;
          this._formatFeatures[Format.RG32F] |= FormatFeatureBit.VERTEX_ATTRIBUTE;
          this._formatFeatures[Format.RGB32F] |= FormatFeatureBit.VERTEX_ATTRIBUTE;
          this._formatFeatures[Format.RGBA32F] |= FormatFeatureBit.VERTEX_ATTRIBUTE;
          if (exts.EXT_sRGB) {
            this._formatFeatures[Format.SRGB8] = tempFeature;
            this._formatFeatures[Format.SRGB8_A8] = tempFeature;
            this._textureExclusive[Format.SRGB8_A8] = false;
          }
          if (exts.WEBGL_depth_texture) {
            this._formatFeatures[Format.DEPTH] |= tempFeature;
            this._formatFeatures[Format.DEPTH_STENCIL] |= tempFeature;
          }
          if (exts.WEBGL_color_buffer_float) {
            this._formatFeatures[Format.RGB32F] |= FormatFeatureBit.RENDER_TARGET;
            this._formatFeatures[Format.RGBA32F] |= FormatFeatureBit.RENDER_TARGET;
            this._textureExclusive[Format.RGB32F] = false;
            this._textureExclusive[Format.RGBA32F] = false;
          }
          if (exts.EXT_color_buffer_half_float) {
            this._formatFeatures[Format.RGB16F] |= FormatFeatureBit.RENDER_TARGET;
            this._formatFeatures[Format.RGBA16F] |= FormatFeatureBit.RENDER_TARGET;
            this._textureExclusive[Format.RGB16F] = false;
            this._textureExclusive[Format.RGBA16F] = false;
          }
          if (exts.OES_texture_float) {
            this._formatFeatures[Format.RGB32F] |= FormatFeatureBit.RENDER_TARGET | FormatFeatureBit.SAMPLED_TEXTURE;
            this._formatFeatures[Format.RGBA32F] |= FormatFeatureBit.RENDER_TARGET | FormatFeatureBit.SAMPLED_TEXTURE;
          }
          if (exts.OES_texture_half_float) {
            this._formatFeatures[Format.RGB16F] |= FormatFeatureBit.RENDER_TARGET | FormatFeatureBit.SAMPLED_TEXTURE;
            this._formatFeatures[Format.RGBA16F] |= FormatFeatureBit.RENDER_TARGET | FormatFeatureBit.SAMPLED_TEXTURE;
          }
          if (exts.OES_texture_float_linear) {
            this._formatFeatures[Format.RGB32F] |= FormatFeatureBit.LINEAR_FILTER;
            this._formatFeatures[Format.RGBA32F] |= FormatFeatureBit.LINEAR_FILTER;
          }
          if (exts.OES_texture_half_float_linear) {
            this._formatFeatures[Format.RGB16F] |= FormatFeatureBit.LINEAR_FILTER;
            this._formatFeatures[Format.RGBA16F] |= FormatFeatureBit.LINEAR_FILTER;
          }
          const compressedFeature = FormatFeatureBit.SAMPLED_TEXTURE | FormatFeatureBit.LINEAR_FILTER;
          if (exts.WEBGL_compressed_texture_etc1) {
            this._formatFeatures[Format.ETC_RGB8] = compressedFeature;
          }
          if (exts.WEBGL_compressed_texture_etc) {
            this._formatFeatures[Format.ETC2_RGB8] = compressedFeature;
            this._formatFeatures[Format.ETC2_RGBA8] = compressedFeature;
            this._formatFeatures[Format.ETC2_SRGB8] = compressedFeature;
            this._formatFeatures[Format.ETC2_SRGB8_A8] = compressedFeature;
            this._formatFeatures[Format.ETC2_RGB8_A1] = compressedFeature;
            this._formatFeatures[Format.ETC2_SRGB8_A1] = compressedFeature;
          }
          if (exts.WEBGL_compressed_texture_s3tc) {
            this._formatFeatures[Format.BC1] = compressedFeature;
            this._formatFeatures[Format.BC1_ALPHA] = compressedFeature;
            this._formatFeatures[Format.BC1_SRGB] = compressedFeature;
            this._formatFeatures[Format.BC1_SRGB_ALPHA] = compressedFeature;
            this._formatFeatures[Format.BC2] = compressedFeature;
            this._formatFeatures[Format.BC2_SRGB] = compressedFeature;
            this._formatFeatures[Format.BC3] = compressedFeature;
            this._formatFeatures[Format.BC3_SRGB] = compressedFeature;
          }
          if (exts.WEBGL_compressed_texture_pvrtc) {
            this._formatFeatures[Format.PVRTC_RGB2] |= compressedFeature;
            this._formatFeatures[Format.PVRTC_RGBA2] |= compressedFeature;
            this._formatFeatures[Format.PVRTC_RGB4] |= compressedFeature;
            this._formatFeatures[Format.PVRTC_RGBA4] |= compressedFeature;
          }
          if (exts.WEBGL_compressed_texture_astc) {
            this._formatFeatures[Format.ASTC_RGBA_4X4] |= compressedFeature;
            this._formatFeatures[Format.ASTC_RGBA_5X4] |= compressedFeature;
            this._formatFeatures[Format.ASTC_RGBA_5X5] |= compressedFeature;
            this._formatFeatures[Format.ASTC_RGBA_6X5] |= compressedFeature;
            this._formatFeatures[Format.ASTC_RGBA_6X6] |= compressedFeature;
            this._formatFeatures[Format.ASTC_RGBA_8X5] |= compressedFeature;
            this._formatFeatures[Format.ASTC_RGBA_8X6] |= compressedFeature;
            this._formatFeatures[Format.ASTC_RGBA_8X8] |= compressedFeature;
            this._formatFeatures[Format.ASTC_RGBA_10X5] |= compressedFeature;
            this._formatFeatures[Format.ASTC_RGBA_10X6] |= compressedFeature;
            this._formatFeatures[Format.ASTC_RGBA_10X8] |= compressedFeature;
            this._formatFeatures[Format.ASTC_RGBA_10X10] |= compressedFeature;
            this._formatFeatures[Format.ASTC_RGBA_12X10] |= compressedFeature;
            this._formatFeatures[Format.ASTC_RGBA_12X12] |= compressedFeature;
            this._formatFeatures[Format.ASTC_SRGBA_4X4] |= compressedFeature;
            this._formatFeatures[Format.ASTC_SRGBA_5X4] |= compressedFeature;
            this._formatFeatures[Format.ASTC_SRGBA_5X5] |= compressedFeature;
            this._formatFeatures[Format.ASTC_SRGBA_6X5] |= compressedFeature;
            this._formatFeatures[Format.ASTC_SRGBA_6X6] |= compressedFeature;
            this._formatFeatures[Format.ASTC_SRGBA_8X5] |= compressedFeature;
            this._formatFeatures[Format.ASTC_SRGBA_8X6] |= compressedFeature;
            this._formatFeatures[Format.ASTC_SRGBA_8X8] |= compressedFeature;
            this._formatFeatures[Format.ASTC_SRGBA_10X5] |= compressedFeature;
            this._formatFeatures[Format.ASTC_SRGBA_10X6] |= compressedFeature;
            this._formatFeatures[Format.ASTC_SRGBA_10X8] |= compressedFeature;
            this._formatFeatures[Format.ASTC_SRGBA_10X10] |= compressedFeature;
            this._formatFeatures[Format.ASTC_SRGBA_12X10] |= compressedFeature;
            this._formatFeatures[Format.ASTC_SRGBA_12X12] |= compressedFeature;
          }
        }
        createCommandBuffer(info) {
          const Ctor = info.type === CommandBufferType.PRIMARY ? WebGLPrimaryCommandBuffer : WebGLCommandBuffer;
          const cmdBuff = new Ctor();
          cmdBuff.initialize(info);
          return cmdBuff;
        }
        createSwapchain(info) {
          const swapchain = new WebGLSwapchain();
          this._swapchain = swapchain;
          swapchain.initialize(info);
          return swapchain;
        }
        createBuffer(info) {
          const buffer = new WebGLBuffer();
          buffer.initialize(info);
          return buffer;
        }
        createTexture(info) {
          const texture = new WebGLTexture();
          texture.initialize(info);
          return texture;
        }
        createDescriptorSet(info) {
          const descriptorSet = new WebGLDescriptorSet();
          descriptorSet.initialize(info);
          return descriptorSet;
        }
        createShader(info) {
          const shader = new WebGLShader();
          shader.initialize(info);
          return shader;
        }
        createInputAssembler(info) {
          const inputAssembler = new WebGLInputAssembler();
          inputAssembler.initialize(info);
          return inputAssembler;
        }
        createRenderPass(info) {
          const renderPass = new WebGLRenderPass();
          renderPass.initialize(info);
          return renderPass;
        }
        createFramebuffer(info) {
          const framebuffer = new WebGLFramebuffer();
          framebuffer.initialize(info);
          return framebuffer;
        }
        createDescriptorSetLayout(info) {
          const descriptorSetLayout = new WebGLDescriptorSetLayout();
          descriptorSetLayout.initialize(info);
          return descriptorSetLayout;
        }
        createPipelineLayout(info) {
          const pipelineLayout = new WebGLPipelineLayout();
          pipelineLayout.initialize(info);
          return pipelineLayout;
        }
        createPipelineState(info) {
          const pipelineState = new WebGLPipelineState();
          pipelineState.initialize(info);
          return pipelineState;
        }
        createQueue(info) {
          const queue = new WebGLQueue();
          queue.initialize(info);
          return queue;
        }
        getSampler(info) {
          const hash = Sampler.computeHash(info);
          if (!this._samplers.has(hash)) {
            this._samplers.set(hash, new WebGLSampler(info, hash));
          }
          return this._samplers.get(hash);
        }
        getSwapchains() {
          return [this._swapchain];
        }
        getGeneralBarrier(info) {
          const hash = GeneralBarrier.computeHash(info);
          if (!this._generalBarrierss.has(hash)) {
            this._generalBarrierss.set(hash, new GeneralBarrier(info, hash));
          }
          return this._generalBarrierss.get(hash);
        }
        getTextureBarrier(info) {
          const hash = TextureBarrier.computeHash(info);
          if (!this._textureBarriers.has(hash)) {
            this._textureBarriers.set(hash, new TextureBarrier(info, hash));
          }
          return this._textureBarriers.get(hash);
        }
        getBufferBarrier(info) {
          const hash = BufferBarrier.computeHash(info);
          if (!this._bufferBarriers.has(hash)) {
            this._bufferBarriers.set(hash, new BufferBarrier(info, hash));
          }
          return this._bufferBarriers.get(hash);
        }
        copyBuffersToTexture(buffers, texture, regions) {
          WebGLCmdFuncCopyBuffersToTexture(this, buffers, texture.gpuTexture, regions);
        }
        copyTextureToBuffers(texture, buffers, regions) {
          WebGLCmdFuncCopyTextureToBuffers(this, texture.gpuTexture, buffers, regions);
        }
        copyTexImagesToTexture(texImages, texture, regions) {
          WebGLCmdFuncCopyTexImagesToTexture(this, texImages, texture.gpuTexture, regions);
        }
      } exports('WebGLDevice', WebGLDevice);

      legacyCC.WebGLDevice = WebGLDevice;

      class WebGL2DescriptorSet extends DescriptorSet {
        constructor(...args) {
          super(...args);
          this._gpuDescriptorSet = null;
        }
        get gpuDescriptorSet() {
          return this._gpuDescriptorSet;
        }
        initialize(info) {
          this._layout = info.layout;
          const {
            bindings,
            descriptorIndices,
            descriptorCount
          } = info.layout.gpuDescriptorSetLayout;
          this._buffers = Array(descriptorCount).fill(null);
          this._textures = Array(descriptorCount).fill(null);
          this._samplers = Array(descriptorCount).fill(null);
          const gpuDescriptors = [];
          this._gpuDescriptorSet = {
            gpuDescriptors,
            descriptorIndices
          };
          for (let i = 0; i < bindings.length; ++i) {
            const binding = bindings[i];
            for (let j = 0; j < binding.count; j++) {
              gpuDescriptors.push({
                type: binding.descriptorType,
                gpuBuffer: null,
                gpuTextureView: null,
                gpuSampler: null
              });
            }
          }
        }
        destroy() {
          this._layout = null;
          this._gpuDescriptorSet = null;
        }
        update() {
          if (this._isDirty && this._gpuDescriptorSet) {
            const descriptors = this._gpuDescriptorSet.gpuDescriptors;
            for (let i = 0; i < descriptors.length; ++i) {
              if (descriptors[i].type & DESCRIPTOR_BUFFER_TYPE) {
                if (this._buffers[i]) {
                  descriptors[i].gpuBuffer = this._buffers[i].gpuBuffer;
                }
              } else if (descriptors[i].type & DESCRIPTOR_SAMPLER_TYPE) {
                if (this._textures[i]) {
                  descriptors[i].gpuTextureView = this._textures[i].gpuTextureView;
                }
                if (this._samplers[i]) {
                  descriptors[i].gpuSampler = this._samplers[i].gpuSampler;
                }
              }
            }
            this._isDirty = false;
          }
        }
      }

      let WebGL2EXT;
      (function (WebGL2EXT) {
        WebGL2EXT[WebGL2EXT["COMPRESSED_RGB_S3TC_DXT1_EXT"] = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT";
        WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA_S3TC_DXT1_EXT"] = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT";
        WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA_S3TC_DXT3_EXT"] = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT";
        WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA_S3TC_DXT5_EXT"] = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT";
        WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB_S3TC_DXT1_EXT"] = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT";
        WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT"] = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT";
        WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT"] = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT";
        WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT"] = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT";
        WebGL2EXT[WebGL2EXT["COMPRESSED_RGB_PVRTC_4BPPV1_IMG"] = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG";
        WebGL2EXT[WebGL2EXT["COMPRESSED_RGB_PVRTC_2BPPV1_IMG"] = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG";
        WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA_PVRTC_4BPPV1_IMG"] = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG";
        WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA_PVRTC_2BPPV1_IMG"] = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG";
        WebGL2EXT[WebGL2EXT["COMPRESSED_RGB_ETC1_WEBGL"] = 36196] = "COMPRESSED_RGB_ETC1_WEBGL";
        WebGL2EXT[WebGL2EXT["COMPRESSED_R11_EAC"] = 37488] = "COMPRESSED_R11_EAC";
        WebGL2EXT[WebGL2EXT["COMPRESSED_SIGNED_R11_EAC"] = 37489] = "COMPRESSED_SIGNED_R11_EAC";
        WebGL2EXT[WebGL2EXT["COMPRESSED_RG11_EAC"] = 37490] = "COMPRESSED_RG11_EAC";
        WebGL2EXT[WebGL2EXT["COMPRESSED_SIGNED_RG11_EAC"] = 37491] = "COMPRESSED_SIGNED_RG11_EAC";
        WebGL2EXT[WebGL2EXT["COMPRESSED_RGB8_ETC2"] = 37492] = "COMPRESSED_RGB8_ETC2";
        WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB8_ETC2"] = 37493] = "COMPRESSED_SRGB8_ETC2";
        WebGL2EXT[WebGL2EXT["COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37494] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2";
        WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37495] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2";
        WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA8_ETC2_EAC"] = 37496] = "COMPRESSED_RGBA8_ETC2_EAC";
        WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB8_ALPHA8_ETC2_EAC"] = 37497] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC";
        WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA_ASTC_4x4_KHR"] = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR";
        WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA_ASTC_5x4_KHR"] = 37809] = "COMPRESSED_RGBA_ASTC_5x4_KHR";
        WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA_ASTC_5x5_KHR"] = 37810] = "COMPRESSED_RGBA_ASTC_5x5_KHR";
        WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA_ASTC_6x5_KHR"] = 37811] = "COMPRESSED_RGBA_ASTC_6x5_KHR";
        WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA_ASTC_6x6_KHR"] = 37812] = "COMPRESSED_RGBA_ASTC_6x6_KHR";
        WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA_ASTC_8x5_KHR"] = 37813] = "COMPRESSED_RGBA_ASTC_8x5_KHR";
        WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA_ASTC_8x6_KHR"] = 37814] = "COMPRESSED_RGBA_ASTC_8x6_KHR";
        WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA_ASTC_8x8_KHR"] = 37815] = "COMPRESSED_RGBA_ASTC_8x8_KHR";
        WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA_ASTC_10x5_KHR"] = 37816] = "COMPRESSED_RGBA_ASTC_10x5_KHR";
        WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA_ASTC_10x6_KHR"] = 37817] = "COMPRESSED_RGBA_ASTC_10x6_KHR";
        WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA_ASTC_10x8_KHR"] = 37818] = "COMPRESSED_RGBA_ASTC_10x8_KHR";
        WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA_ASTC_10x10_KHR"] = 37819] = "COMPRESSED_RGBA_ASTC_10x10_KHR";
        WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA_ASTC_12x10_KHR"] = 37820] = "COMPRESSED_RGBA_ASTC_12x10_KHR";
        WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA_ASTC_12x12_KHR"] = 37821] = "COMPRESSED_RGBA_ASTC_12x12_KHR";
        WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR"] = 37840] = "COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR";
        WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR"] = 37841] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR";
        WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR"] = 37842] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR";
        WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR"] = 37843] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR";
        WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR"] = 37844] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR";
        WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR"] = 37845] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR";
        WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR"] = 37846] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR";
        WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR"] = 37847] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR";
        WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR"] = 37848] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR";
        WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR"] = 37849] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR";
        WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR"] = 37850] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR";
        WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR"] = 37851] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR";
        WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR"] = 37852] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR";
        WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR"] = 37853] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR";
      })(WebGL2EXT || (WebGL2EXT = {}));
      class WebGL2DeviceManager {
        static get instance() {
          return WebGL2DeviceManager._instance;
        }
        static setInstance(instance) {
          WebGL2DeviceManager._instance = instance;
        }
      }
      WebGL2DeviceManager._instance = null;

      const WebGLWraps = [0x2901, 0x8370, 0x812F, 0x812F];
      const _f32v4 = new Float32Array(4);
      function GFXFormatToWebGLType(format, gl) {
        switch (format) {
          case Format.R8:
            return gl.UNSIGNED_BYTE;
          case Format.R8SN:
            return gl.BYTE;
          case Format.R8UI:
            return gl.UNSIGNED_BYTE;
          case Format.R8I:
            return gl.BYTE;
          case Format.R16F:
            return gl.HALF_FLOAT;
          case Format.R16UI:
            return gl.UNSIGNED_SHORT;
          case Format.R16I:
            return gl.SHORT;
          case Format.R32F:
            return gl.FLOAT;
          case Format.R32UI:
            return gl.UNSIGNED_INT;
          case Format.R32I:
            return gl.INT;
          case Format.RG8:
            return gl.UNSIGNED_BYTE;
          case Format.RG8SN:
            return gl.BYTE;
          case Format.RG8UI:
            return gl.UNSIGNED_BYTE;
          case Format.RG8I:
            return gl.BYTE;
          case Format.RG16F:
            return gl.HALF_FLOAT;
          case Format.RG16UI:
            return gl.UNSIGNED_SHORT;
          case Format.RG16I:
            return gl.SHORT;
          case Format.RG32F:
            return gl.FLOAT;
          case Format.RG32UI:
            return gl.UNSIGNED_INT;
          case Format.RG32I:
            return gl.INT;
          case Format.RGB8:
            return gl.UNSIGNED_BYTE;
          case Format.SRGB8:
            return gl.UNSIGNED_BYTE;
          case Format.RGB8SN:
            return gl.BYTE;
          case Format.RGB8UI:
            return gl.UNSIGNED_BYTE;
          case Format.RGB8I:
            return gl.BYTE;
          case Format.RGB16F:
            return gl.HALF_FLOAT;
          case Format.RGB16UI:
            return gl.UNSIGNED_SHORT;
          case Format.RGB16I:
            return gl.SHORT;
          case Format.RGB32F:
            return gl.FLOAT;
          case Format.RGB32UI:
            return gl.UNSIGNED_INT;
          case Format.RGB32I:
            return gl.INT;
          case Format.BGRA8:
            return gl.UNSIGNED_BYTE;
          case Format.RGBA8:
            return gl.UNSIGNED_BYTE;
          case Format.SRGB8_A8:
            return gl.UNSIGNED_BYTE;
          case Format.RGBA8SN:
            return gl.BYTE;
          case Format.RGBA8UI:
            return gl.UNSIGNED_BYTE;
          case Format.RGBA8I:
            return gl.BYTE;
          case Format.RGBA16F:
            return gl.HALF_FLOAT;
          case Format.RGBA16UI:
            return gl.UNSIGNED_SHORT;
          case Format.RGBA16I:
            return gl.SHORT;
          case Format.RGBA32F:
            return gl.FLOAT;
          case Format.RGBA32UI:
            return gl.UNSIGNED_INT;
          case Format.RGBA32I:
            return gl.INT;
          case Format.R5G6B5:
            return gl.UNSIGNED_SHORT_5_6_5;
          case Format.R11G11B10F:
            return gl.UNSIGNED_INT_10F_11F_11F_REV;
          case Format.RGB5A1:
            return gl.UNSIGNED_SHORT_5_5_5_1;
          case Format.RGBA4:
            return gl.UNSIGNED_SHORT_4_4_4_4;
          case Format.RGB10A2:
            return gl.UNSIGNED_INT_2_10_10_10_REV;
          case Format.RGB10A2UI:
            return gl.UNSIGNED_INT_2_10_10_10_REV;
          case Format.RGB9E5:
            return gl.FLOAT;
          case Format.DEPTH:
            return gl.FLOAT;
          case Format.DEPTH_STENCIL:
            return gl.UNSIGNED_INT_24_8;
          case Format.BC1:
            return gl.UNSIGNED_BYTE;
          case Format.BC1_SRGB:
            return gl.UNSIGNED_BYTE;
          case Format.BC2:
            return gl.UNSIGNED_BYTE;
          case Format.BC2_SRGB:
            return gl.UNSIGNED_BYTE;
          case Format.BC3:
            return gl.UNSIGNED_BYTE;
          case Format.BC3_SRGB:
            return gl.UNSIGNED_BYTE;
          case Format.BC4:
            return gl.UNSIGNED_BYTE;
          case Format.BC4_SNORM:
            return gl.BYTE;
          case Format.BC5:
            return gl.UNSIGNED_BYTE;
          case Format.BC5_SNORM:
            return gl.BYTE;
          case Format.BC6H_SF16:
            return gl.FLOAT;
          case Format.BC6H_UF16:
            return gl.FLOAT;
          case Format.BC7:
            return gl.UNSIGNED_BYTE;
          case Format.BC7_SRGB:
            return gl.UNSIGNED_BYTE;
          case Format.ETC_RGB8:
            return gl.UNSIGNED_BYTE;
          case Format.ETC2_RGB8:
            return gl.UNSIGNED_BYTE;
          case Format.ETC2_SRGB8:
            return gl.UNSIGNED_BYTE;
          case Format.ETC2_RGB8_A1:
            return gl.UNSIGNED_BYTE;
          case Format.ETC2_SRGB8_A1:
            return gl.UNSIGNED_BYTE;
          case Format.EAC_R11:
            return gl.UNSIGNED_BYTE;
          case Format.EAC_R11SN:
            return gl.BYTE;
          case Format.EAC_RG11:
            return gl.UNSIGNED_BYTE;
          case Format.EAC_RG11SN:
            return gl.BYTE;
          case Format.PVRTC_RGB2:
            return gl.UNSIGNED_BYTE;
          case Format.PVRTC_RGBA2:
            return gl.UNSIGNED_BYTE;
          case Format.PVRTC_RGB4:
            return gl.UNSIGNED_BYTE;
          case Format.PVRTC_RGBA4:
            return gl.UNSIGNED_BYTE;
          case Format.PVRTC2_2BPP:
            return gl.UNSIGNED_BYTE;
          case Format.PVRTC2_4BPP:
            return gl.UNSIGNED_BYTE;
          case Format.ASTC_RGBA_4X4:
          case Format.ASTC_RGBA_5X4:
          case Format.ASTC_RGBA_5X5:
          case Format.ASTC_RGBA_6X5:
          case Format.ASTC_RGBA_6X6:
          case Format.ASTC_RGBA_8X5:
          case Format.ASTC_RGBA_8X6:
          case Format.ASTC_RGBA_8X8:
          case Format.ASTC_RGBA_10X5:
          case Format.ASTC_RGBA_10X6:
          case Format.ASTC_RGBA_10X8:
          case Format.ASTC_RGBA_10X10:
          case Format.ASTC_RGBA_12X10:
          case Format.ASTC_RGBA_12X12:
          case Format.ASTC_SRGBA_4X4:
          case Format.ASTC_SRGBA_5X4:
          case Format.ASTC_SRGBA_5X5:
          case Format.ASTC_SRGBA_6X5:
          case Format.ASTC_SRGBA_6X6:
          case Format.ASTC_SRGBA_8X5:
          case Format.ASTC_SRGBA_8X6:
          case Format.ASTC_SRGBA_8X8:
          case Format.ASTC_SRGBA_10X5:
          case Format.ASTC_SRGBA_10X6:
          case Format.ASTC_SRGBA_10X8:
          case Format.ASTC_SRGBA_10X10:
          case Format.ASTC_SRGBA_12X10:
          case Format.ASTC_SRGBA_12X12:
            return gl.UNSIGNED_BYTE;
          default:
            {
              return gl.UNSIGNED_BYTE;
            }
        }
      }
      function GFXFormatToWebGLInternalFormat(format, gl) {
        switch (format) {
          case Format.A8:
            return gl.ALPHA;
          case Format.L8:
            return gl.LUMINANCE;
          case Format.LA8:
            return gl.LUMINANCE_ALPHA;
          case Format.R8:
            return gl.R8;
          case Format.R8SN:
            return gl.R8_SNORM;
          case Format.R8UI:
            return gl.R8UI;
          case Format.R8I:
            return gl.R8I;
          case Format.RG8:
            return gl.RG8;
          case Format.RG8SN:
            return gl.RG8_SNORM;
          case Format.RG8UI:
            return gl.RG8UI;
          case Format.RG8I:
            return gl.RG8I;
          case Format.RGB8:
            return gl.RGB8;
          case Format.RGB8SN:
            return gl.RGB8_SNORM;
          case Format.RGB8UI:
            return gl.RGB8UI;
          case Format.RGB8I:
            return gl.RGB8I;
          case Format.BGRA8:
            return gl.RGBA8;
          case Format.RGBA8:
            return gl.RGBA8;
          case Format.RGBA8SN:
            return gl.RGBA8_SNORM;
          case Format.RGBA8UI:
            return gl.RGBA8UI;
          case Format.RGBA8I:
            return gl.RGBA8I;
          case Format.R16I:
            return gl.R16I;
          case Format.R16UI:
            return gl.R16UI;
          case Format.R16F:
            return gl.R16F;
          case Format.RG16I:
            return gl.RG16I;
          case Format.RG16UI:
            return gl.RG16UI;
          case Format.RG16F:
            return gl.RG16F;
          case Format.RGB16I:
            return gl.RGB16I;
          case Format.RGB16UI:
            return gl.RGB16UI;
          case Format.RGB16F:
            return gl.RGB16F;
          case Format.RGBA16I:
            return gl.RGBA16I;
          case Format.RGBA16UI:
            return gl.RGBA16UI;
          case Format.RGBA16F:
            return gl.RGBA16F;
          case Format.R32I:
            return gl.R32I;
          case Format.R32UI:
            return gl.R32UI;
          case Format.R32F:
            return gl.R32F;
          case Format.RG32I:
            return gl.RG32I;
          case Format.RG32UI:
            return gl.RG32UI;
          case Format.RG32F:
            return gl.RG32F;
          case Format.RGB32I:
            return gl.RGB32I;
          case Format.RGB32UI:
            return gl.RGB32UI;
          case Format.RGB32F:
            return gl.RGB32F;
          case Format.RGBA32I:
            return gl.RGBA32I;
          case Format.RGBA32UI:
            return gl.RGBA32UI;
          case Format.RGBA32F:
            return gl.RGBA32F;
          case Format.R5G6B5:
            return gl.RGB565;
          case Format.RGB5A1:
            return gl.RGB5_A1;
          case Format.RGBA4:
            return gl.RGBA4;
          case Format.SRGB8:
            return gl.SRGB8;
          case Format.SRGB8_A8:
            return gl.SRGB8_ALPHA8;
          case Format.RGB10A2:
            return gl.RGB10_A2;
          case Format.RGB10A2UI:
            return gl.RGB10_A2UI;
          case Format.R11G11B10F:
            return gl.R11F_G11F_B10F;
          case Format.DEPTH:
            return gl.DEPTH_COMPONENT32F;
          case Format.DEPTH_STENCIL:
            return gl.DEPTH24_STENCIL8;
          case Format.BC1:
            return WebGL2EXT.COMPRESSED_RGB_S3TC_DXT1_EXT;
          case Format.BC1_ALPHA:
            return WebGL2EXT.COMPRESSED_RGBA_S3TC_DXT1_EXT;
          case Format.BC1_SRGB:
            return WebGL2EXT.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          case Format.BC1_SRGB_ALPHA:
            return WebGL2EXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          case Format.BC2:
            return WebGL2EXT.COMPRESSED_RGBA_S3TC_DXT3_EXT;
          case Format.BC2_SRGB:
            return WebGL2EXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          case Format.BC3:
            return WebGL2EXT.COMPRESSED_RGBA_S3TC_DXT5_EXT;
          case Format.BC3_SRGB:
            return WebGL2EXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
          case Format.ETC_RGB8:
            return WebGL2EXT.COMPRESSED_RGB_ETC1_WEBGL;
          case Format.ETC2_RGB8:
            return WebGL2EXT.COMPRESSED_RGB8_ETC2;
          case Format.ETC2_SRGB8:
            return WebGL2EXT.COMPRESSED_SRGB8_ETC2;
          case Format.ETC2_RGB8_A1:
            return WebGL2EXT.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2;
          case Format.ETC2_SRGB8_A1:
            return WebGL2EXT.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2;
          case Format.ETC2_RGBA8:
            return WebGL2EXT.COMPRESSED_RGBA8_ETC2_EAC;
          case Format.ETC2_SRGB8_A8:
            return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC;
          case Format.EAC_R11:
            return WebGL2EXT.COMPRESSED_R11_EAC;
          case Format.EAC_R11SN:
            return WebGL2EXT.COMPRESSED_SIGNED_R11_EAC;
          case Format.EAC_RG11:
            return WebGL2EXT.COMPRESSED_RG11_EAC;
          case Format.EAC_RG11SN:
            return WebGL2EXT.COMPRESSED_SIGNED_RG11_EAC;
          case Format.PVRTC_RGB2:
            return WebGL2EXT.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
          case Format.PVRTC_RGBA2:
            return WebGL2EXT.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
          case Format.PVRTC_RGB4:
            return WebGL2EXT.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
          case Format.PVRTC_RGBA4:
            return WebGL2EXT.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
          case Format.ASTC_RGBA_4X4:
            return WebGL2EXT.COMPRESSED_RGBA_ASTC_4x4_KHR;
          case Format.ASTC_RGBA_5X4:
            return WebGL2EXT.COMPRESSED_RGBA_ASTC_5x4_KHR;
          case Format.ASTC_RGBA_5X5:
            return WebGL2EXT.COMPRESSED_RGBA_ASTC_5x5_KHR;
          case Format.ASTC_RGBA_6X5:
            return WebGL2EXT.COMPRESSED_RGBA_ASTC_6x5_KHR;
          case Format.ASTC_RGBA_6X6:
            return WebGL2EXT.COMPRESSED_RGBA_ASTC_6x6_KHR;
          case Format.ASTC_RGBA_8X5:
            return WebGL2EXT.COMPRESSED_RGBA_ASTC_8x5_KHR;
          case Format.ASTC_RGBA_8X6:
            return WebGL2EXT.COMPRESSED_RGBA_ASTC_8x6_KHR;
          case Format.ASTC_RGBA_8X8:
            return WebGL2EXT.COMPRESSED_RGBA_ASTC_8x8_KHR;
          case Format.ASTC_RGBA_10X5:
            return WebGL2EXT.COMPRESSED_RGBA_ASTC_10x5_KHR;
          case Format.ASTC_RGBA_10X6:
            return WebGL2EXT.COMPRESSED_RGBA_ASTC_10x6_KHR;
          case Format.ASTC_RGBA_10X8:
            return WebGL2EXT.COMPRESSED_RGBA_ASTC_10x8_KHR;
          case Format.ASTC_RGBA_10X10:
            return WebGL2EXT.COMPRESSED_RGBA_ASTC_10x10_KHR;
          case Format.ASTC_RGBA_12X10:
            return WebGL2EXT.COMPRESSED_RGBA_ASTC_12x10_KHR;
          case Format.ASTC_RGBA_12X12:
            return WebGL2EXT.COMPRESSED_RGBA_ASTC_12x12_KHR;
          case Format.ASTC_SRGBA_4X4:
            return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR;
          case Format.ASTC_SRGBA_5X4:
            return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR;
          case Format.ASTC_SRGBA_5X5:
            return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR;
          case Format.ASTC_SRGBA_6X5:
            return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR;
          case Format.ASTC_SRGBA_6X6:
            return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR;
          case Format.ASTC_SRGBA_8X5:
            return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR;
          case Format.ASTC_SRGBA_8X6:
            return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR;
          case Format.ASTC_SRGBA_8X8:
            return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR;
          case Format.ASTC_SRGBA_10X5:
            return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR;
          case Format.ASTC_SRGBA_10X6:
            return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR;
          case Format.ASTC_SRGBA_10X8:
            return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR;
          case Format.ASTC_SRGBA_10X10:
            return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR;
          case Format.ASTC_SRGBA_12X10:
            return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR;
          case Format.ASTC_SRGBA_12X12:
            return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR;
          default:
            {
              error('Unsupported Format, convert to WebGL internal format failed.');
              return gl.RGBA;
            }
        }
      }
      function GFXFormatToWebGLFormat(format, gl) {
        switch (format) {
          case Format.A8:
            return gl.ALPHA;
          case Format.L8:
            return gl.LUMINANCE;
          case Format.LA8:
            return gl.LUMINANCE_ALPHA;
          case Format.R8:
          case Format.R8SN:
            return gl.RED;
          case Format.R8UI:
          case Format.R8I:
            return gl.RED;
          case Format.RG8:
          case Format.RG8SN:
          case Format.RG8UI:
          case Format.RG8I:
            return gl.RG;
          case Format.RGB8:
          case Format.RGB8SN:
          case Format.RGB8UI:
          case Format.RGB8I:
            return gl.RGB;
          case Format.BGRA8:
          case Format.RGBA8:
          case Format.RGBA8SN:
          case Format.RGBA8UI:
          case Format.RGBA8I:
            return gl.RGBA;
          case Format.R16UI:
          case Format.R16I:
          case Format.R16F:
            return gl.RED;
          case Format.RG16UI:
          case Format.RG16I:
          case Format.RG16F:
            return gl.RG;
          case Format.RGB16UI:
          case Format.RGB16I:
          case Format.RGB16F:
            return gl.RGB;
          case Format.RGBA16UI:
          case Format.RGBA16I:
          case Format.RGBA16F:
            return gl.RGBA;
          case Format.R32UI:
          case Format.R32I:
          case Format.R32F:
            return gl.RED;
          case Format.RG32UI:
          case Format.RG32I:
          case Format.RG32F:
            return gl.RG;
          case Format.RGB32UI:
          case Format.RGB32I:
          case Format.RGB32F:
            return gl.RGB;
          case Format.RGBA32UI:
          case Format.RGBA32I:
          case Format.RGBA32F:
            return gl.RGBA;
          case Format.RGB10A2:
            return gl.RGBA;
          case Format.R11G11B10F:
            return gl.RGB;
          case Format.R5G6B5:
            return gl.RGB;
          case Format.RGB5A1:
            return gl.RGBA;
          case Format.RGBA4:
            return gl.RGBA;
          case Format.SRGB8:
            return gl.RGB;
          case Format.SRGB8_A8:
            return gl.RGBA;
          case Format.DEPTH:
            return gl.DEPTH_COMPONENT;
          case Format.DEPTH_STENCIL:
            return gl.DEPTH_STENCIL;
          case Format.BC1:
            return WebGL2EXT.COMPRESSED_RGB_S3TC_DXT1_EXT;
          case Format.BC1_ALPHA:
            return WebGL2EXT.COMPRESSED_RGBA_S3TC_DXT1_EXT;
          case Format.BC1_SRGB:
            return WebGL2EXT.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          case Format.BC1_SRGB_ALPHA:
            return WebGL2EXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          case Format.BC2:
            return WebGL2EXT.COMPRESSED_RGBA_S3TC_DXT3_EXT;
          case Format.BC2_SRGB:
            return WebGL2EXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          case Format.BC3:
            return WebGL2EXT.COMPRESSED_RGBA_S3TC_DXT5_EXT;
          case Format.BC3_SRGB:
            return WebGL2EXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
          case Format.ETC_RGB8:
            return WebGL2EXT.COMPRESSED_RGB_ETC1_WEBGL;
          case Format.ETC2_RGB8:
            return WebGL2EXT.COMPRESSED_RGB8_ETC2;
          case Format.ETC2_SRGB8:
            return WebGL2EXT.COMPRESSED_SRGB8_ETC2;
          case Format.ETC2_RGB8_A1:
            return WebGL2EXT.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2;
          case Format.ETC2_SRGB8_A1:
            return WebGL2EXT.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2;
          case Format.ETC2_RGBA8:
            return WebGL2EXT.COMPRESSED_RGBA8_ETC2_EAC;
          case Format.ETC2_SRGB8_A8:
            return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC;
          case Format.EAC_R11:
            return WebGL2EXT.COMPRESSED_R11_EAC;
          case Format.EAC_R11SN:
            return WebGL2EXT.COMPRESSED_SIGNED_R11_EAC;
          case Format.EAC_RG11:
            return WebGL2EXT.COMPRESSED_RG11_EAC;
          case Format.EAC_RG11SN:
            return WebGL2EXT.COMPRESSED_SIGNED_RG11_EAC;
          case Format.PVRTC_RGB2:
            return WebGL2EXT.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
          case Format.PVRTC_RGBA2:
            return WebGL2EXT.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
          case Format.PVRTC_RGB4:
            return WebGL2EXT.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
          case Format.PVRTC_RGBA4:
            return WebGL2EXT.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
          case Format.ASTC_RGBA_4X4:
            return WebGL2EXT.COMPRESSED_RGBA_ASTC_4x4_KHR;
          case Format.ASTC_RGBA_5X4:
            return WebGL2EXT.COMPRESSED_RGBA_ASTC_5x4_KHR;
          case Format.ASTC_RGBA_5X5:
            return WebGL2EXT.COMPRESSED_RGBA_ASTC_5x5_KHR;
          case Format.ASTC_RGBA_6X5:
            return WebGL2EXT.COMPRESSED_RGBA_ASTC_6x5_KHR;
          case Format.ASTC_RGBA_6X6:
            return WebGL2EXT.COMPRESSED_RGBA_ASTC_6x6_KHR;
          case Format.ASTC_RGBA_8X5:
            return WebGL2EXT.COMPRESSED_RGBA_ASTC_8x5_KHR;
          case Format.ASTC_RGBA_8X6:
            return WebGL2EXT.COMPRESSED_RGBA_ASTC_8x6_KHR;
          case Format.ASTC_RGBA_8X8:
            return WebGL2EXT.COMPRESSED_RGBA_ASTC_8x8_KHR;
          case Format.ASTC_RGBA_10X5:
            return WebGL2EXT.COMPRESSED_RGBA_ASTC_10x5_KHR;
          case Format.ASTC_RGBA_10X6:
            return WebGL2EXT.COMPRESSED_RGBA_ASTC_10x6_KHR;
          case Format.ASTC_RGBA_10X8:
            return WebGL2EXT.COMPRESSED_RGBA_ASTC_10x8_KHR;
          case Format.ASTC_RGBA_10X10:
            return WebGL2EXT.COMPRESSED_RGBA_ASTC_10x10_KHR;
          case Format.ASTC_RGBA_12X10:
            return WebGL2EXT.COMPRESSED_RGBA_ASTC_12x10_KHR;
          case Format.ASTC_RGBA_12X12:
            return WebGL2EXT.COMPRESSED_RGBA_ASTC_12x12_KHR;
          case Format.ASTC_SRGBA_4X4:
            return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR;
          case Format.ASTC_SRGBA_5X4:
            return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR;
          case Format.ASTC_SRGBA_5X5:
            return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR;
          case Format.ASTC_SRGBA_6X5:
            return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR;
          case Format.ASTC_SRGBA_6X6:
            return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR;
          case Format.ASTC_SRGBA_8X5:
            return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR;
          case Format.ASTC_SRGBA_8X6:
            return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR;
          case Format.ASTC_SRGBA_8X8:
            return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR;
          case Format.ASTC_SRGBA_10X5:
            return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR;
          case Format.ASTC_SRGBA_10X6:
            return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR;
          case Format.ASTC_SRGBA_10X8:
            return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR;
          case Format.ASTC_SRGBA_10X10:
            return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR;
          case Format.ASTC_SRGBA_12X10:
            return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR;
          case Format.ASTC_SRGBA_12X12:
            return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR;
          default:
            {
              error('Unsupported Format, convert to WebGL format failed.');
              return gl.RGBA;
            }
        }
      }
      function GFXTypeToWebGLType(type, gl) {
        switch (type) {
          case Type$1.BOOL:
            return gl.BOOL;
          case Type$1.BOOL2:
            return gl.BOOL_VEC2;
          case Type$1.BOOL3:
            return gl.BOOL_VEC3;
          case Type$1.BOOL4:
            return gl.BOOL_VEC4;
          case Type$1.INT:
            return gl.INT;
          case Type$1.INT2:
            return gl.INT_VEC2;
          case Type$1.INT3:
            return gl.INT_VEC3;
          case Type$1.INT4:
            return gl.INT_VEC4;
          case Type$1.UINT:
            return gl.UNSIGNED_INT;
          case Type$1.FLOAT:
            return gl.FLOAT;
          case Type$1.FLOAT2:
            return gl.FLOAT_VEC2;
          case Type$1.FLOAT3:
            return gl.FLOAT_VEC3;
          case Type$1.FLOAT4:
            return gl.FLOAT_VEC4;
          case Type$1.MAT2:
            return gl.FLOAT_MAT2;
          case Type$1.MAT2X3:
            return gl.FLOAT_MAT2x3;
          case Type$1.MAT2X4:
            return gl.FLOAT_MAT2x4;
          case Type$1.MAT3X2:
            return gl.FLOAT_MAT3x2;
          case Type$1.MAT3:
            return gl.FLOAT_MAT3;
          case Type$1.MAT3X4:
            return gl.FLOAT_MAT3x4;
          case Type$1.MAT4X2:
            return gl.FLOAT_MAT4x2;
          case Type$1.MAT4X3:
            return gl.FLOAT_MAT4x3;
          case Type$1.MAT4:
            return gl.FLOAT_MAT4;
          case Type$1.SAMPLER2D:
            return gl.SAMPLER_2D;
          case Type$1.SAMPLER2D_ARRAY:
            return gl.SAMPLER_2D_ARRAY;
          case Type$1.SAMPLER3D:
            return gl.SAMPLER_3D;
          case Type$1.SAMPLER_CUBE:
            return gl.SAMPLER_CUBE;
          default:
            {
              error('Unsupported GLType, convert to GL type failed.');
              return Type$1.UNKNOWN;
            }
        }
      }
      function WebGLTypeToGFXType(glType, gl) {
        switch (glType) {
          case gl.BOOL:
            return Type$1.BOOL;
          case gl.BOOL_VEC2:
            return Type$1.BOOL2;
          case gl.BOOL_VEC3:
            return Type$1.BOOL3;
          case gl.BOOL_VEC4:
            return Type$1.BOOL4;
          case gl.INT:
            return Type$1.INT;
          case gl.INT_VEC2:
            return Type$1.INT2;
          case gl.INT_VEC3:
            return Type$1.INT3;
          case gl.INT_VEC4:
            return Type$1.INT4;
          case gl.UNSIGNED_INT:
            return Type$1.UINT;
          case gl.UNSIGNED_INT_VEC2:
            return Type$1.UINT2;
          case gl.UNSIGNED_INT_VEC3:
            return Type$1.UINT3;
          case gl.UNSIGNED_INT_VEC4:
            return Type$1.UINT4;
          case gl.FLOAT:
            return Type$1.FLOAT;
          case gl.FLOAT_VEC2:
            return Type$1.FLOAT2;
          case gl.FLOAT_VEC3:
            return Type$1.FLOAT3;
          case gl.FLOAT_VEC4:
            return Type$1.FLOAT4;
          case gl.FLOAT_MAT2:
            return Type$1.MAT2;
          case gl.FLOAT_MAT2x3:
            return Type$1.MAT2X3;
          case gl.FLOAT_MAT2x4:
            return Type$1.MAT2X4;
          case gl.FLOAT_MAT3x2:
            return Type$1.MAT3X2;
          case gl.FLOAT_MAT3:
            return Type$1.MAT3;
          case gl.FLOAT_MAT3x4:
            return Type$1.MAT3X4;
          case gl.FLOAT_MAT4x2:
            return Type$1.MAT4X2;
          case gl.FLOAT_MAT4x3:
            return Type$1.MAT4X3;
          case gl.FLOAT_MAT4:
            return Type$1.MAT4;
          case gl.SAMPLER_2D:
            return Type$1.SAMPLER2D;
          case gl.SAMPLER_2D_ARRAY:
            return Type$1.SAMPLER2D_ARRAY;
          case gl.SAMPLER_3D:
            return Type$1.SAMPLER3D;
          case gl.SAMPLER_CUBE:
            return Type$1.SAMPLER_CUBE;
          default:
            {
              error('Unsupported GLType, convert to Type failed.');
              return Type$1.UNKNOWN;
            }
        }
      }
      function WebGLGetTypeSize(glType, gl) {
        switch (glType) {
          case gl.BOOL:
            return 4;
          case gl.BOOL_VEC2:
            return 8;
          case gl.BOOL_VEC3:
            return 12;
          case gl.BOOL_VEC4:
            return 16;
          case gl.INT:
            return 4;
          case gl.INT_VEC2:
            return 8;
          case gl.INT_VEC3:
            return 12;
          case gl.INT_VEC4:
            return 16;
          case gl.UNSIGNED_INT:
            return 4;
          case gl.UNSIGNED_INT_VEC2:
            return 8;
          case gl.UNSIGNED_INT_VEC3:
            return 12;
          case gl.UNSIGNED_INT_VEC4:
            return 16;
          case gl.FLOAT:
            return 4;
          case gl.FLOAT_VEC2:
            return 8;
          case gl.FLOAT_VEC3:
            return 12;
          case gl.FLOAT_VEC4:
            return 16;
          case gl.FLOAT_MAT2:
            return 16;
          case gl.FLOAT_MAT2x3:
            return 24;
          case gl.FLOAT_MAT2x4:
            return 32;
          case gl.FLOAT_MAT3x2:
            return 24;
          case gl.FLOAT_MAT3:
            return 36;
          case gl.FLOAT_MAT3x4:
            return 48;
          case gl.FLOAT_MAT4x2:
            return 32;
          case gl.FLOAT_MAT4x3:
            return 48;
          case gl.FLOAT_MAT4:
            return 64;
          case gl.SAMPLER_2D:
            return 4;
          case gl.SAMPLER_2D_ARRAY:
            return 4;
          case gl.SAMPLER_2D_ARRAY_SHADOW:
            return 4;
          case gl.SAMPLER_3D:
            return 4;
          case gl.SAMPLER_CUBE:
            return 4;
          case gl.INT_SAMPLER_2D:
            return 4;
          case gl.INT_SAMPLER_2D_ARRAY:
            return 4;
          case gl.INT_SAMPLER_3D:
            return 4;
          case gl.INT_SAMPLER_CUBE:
            return 4;
          case gl.UNSIGNED_INT_SAMPLER_2D:
            return 4;
          case gl.UNSIGNED_INT_SAMPLER_2D_ARRAY:
            return 4;
          case gl.UNSIGNED_INT_SAMPLER_3D:
            return 4;
          case gl.UNSIGNED_INT_SAMPLER_CUBE:
            return 4;
          default:
            {
              error('Unsupported GLType, get type failed.');
              return 0;
            }
        }
      }
      function WebGLGetComponentCount(glType, gl) {
        switch (glType) {
          case gl.FLOAT_MAT2:
            return 2;
          case gl.FLOAT_MAT2x3:
            return 2;
          case gl.FLOAT_MAT2x4:
            return 2;
          case gl.FLOAT_MAT3x2:
            return 3;
          case gl.FLOAT_MAT3:
            return 3;
          case gl.FLOAT_MAT3x4:
            return 3;
          case gl.FLOAT_MAT4x2:
            return 4;
          case gl.FLOAT_MAT4x3:
            return 4;
          case gl.FLOAT_MAT4:
            return 4;
          default:
            {
              return 1;
            }
        }
      }
      const WebGLCmpFuncs = [0x0200, 0x0201, 0x0202, 0x0203, 0x0204, 0x0205, 0x0206, 0x0207];
      const WebGLStencilOps = [0x0000, 0x1E00, 0x1E01, 0x1E02, 0x1E03, 0x150A, 0x8507, 0x8508];
      const WebGLBlendOps = [0x8006, 0x800A, 0x800B, 0x8007, 0x8008];
      const WebGLBlendFactors = [0x0000, 0x0001, 0x0302, 0x0304, 0x0303, 0x0305, 0x0300, 0x0306, 0x0301, 0x0307, 0x0308, 0x8001, 0x8002, 0x8003, 0x8004];
      let WebGL2Cmd;
      (function (WebGL2Cmd) {
        WebGL2Cmd[WebGL2Cmd["BEGIN_RENDER_PASS"] = 0] = "BEGIN_RENDER_PASS";
        WebGL2Cmd[WebGL2Cmd["END_RENDER_PASS"] = 1] = "END_RENDER_PASS";
        WebGL2Cmd[WebGL2Cmd["BIND_STATES"] = 2] = "BIND_STATES";
        WebGL2Cmd[WebGL2Cmd["DRAW"] = 3] = "DRAW";
        WebGL2Cmd[WebGL2Cmd["UPDATE_BUFFER"] = 4] = "UPDATE_BUFFER";
        WebGL2Cmd[WebGL2Cmd["COPY_BUFFER_TO_TEXTURE"] = 5] = "COPY_BUFFER_TO_TEXTURE";
        WebGL2Cmd[WebGL2Cmd["BLIT_TEXTURE"] = 6] = "BLIT_TEXTURE";
        WebGL2Cmd[WebGL2Cmd["COUNT"] = 7] = "COUNT";
      })(WebGL2Cmd || (WebGL2Cmd = {}));
      class WebGL2CmdObject {
        constructor(type) {
          this.cmdType = void 0;
          this.refCount = 0;
          this.cmdType = type;
        }
      }
      class WebGL2CmdBeginRenderPass extends WebGL2CmdObject {
        constructor() {
          super(WebGL2Cmd.BEGIN_RENDER_PASS);
          this.gpuRenderPass = null;
          this.gpuFramebuffer = null;
          this.renderArea = new Rect();
          this.clearColors = [];
          this.clearDepth = 1.0;
          this.clearStencil = 0;
        }
        clear() {
          this.gpuFramebuffer = null;
          this.clearColors.length = 0;
        }
      }
      class WebGL2CmdBindStates extends WebGL2CmdObject {
        constructor() {
          super(WebGL2Cmd.BIND_STATES);
          this.gpuPipelineState = null;
          this.gpuInputAssembler = null;
          this.gpuDescriptorSets = [];
          this.dynamicOffsets = [];
          this.dynamicStates = new DynamicStates();
        }
        clear() {
          this.gpuPipelineState = null;
          this.gpuInputAssembler = null;
          this.gpuDescriptorSets.length = 0;
          this.dynamicOffsets.length = 0;
        }
      }
      class WebGL2CmdDraw extends WebGL2CmdObject {
        constructor() {
          super(WebGL2Cmd.DRAW);
          this.drawInfo = new DrawInfo();
        }
        clear() {}
      }
      class WebGL2CmdUpdateBuffer extends WebGL2CmdObject {
        constructor() {
          super(WebGL2Cmd.UPDATE_BUFFER);
          this.gpuBuffer = null;
          this.buffer = null;
          this.offset = 0;
          this.size = 0;
        }
        clear() {
          this.gpuBuffer = null;
          this.buffer = null;
        }
      }
      class WebGL2CmdCopyBufferToTexture extends WebGL2CmdObject {
        constructor() {
          super(WebGL2Cmd.COPY_BUFFER_TO_TEXTURE);
          this.gpuTexture = null;
          this.buffers = [];
          this.regions = [];
        }
        clear() {
          this.gpuTexture = null;
          this.buffers.length = 0;
          this.regions.length = 0;
        }
      }
      class WebGL2CmdBlitTexture extends WebGL2CmdObject {
        constructor() {
          super(WebGL2Cmd.BLIT_TEXTURE);
          this.srcTexture = null;
          this.dstTexture = null;
          this.regions = [];
          this.filter = Filter$1.LINEAR;
        }
        clear() {
          this.srcTexture = null;
          this.dstTexture = null;
          this.regions.length = 0;
        }
      }
      class WebGL2CmdPackage {
        constructor() {
          this.cmds = new CachedArray(1);
          this.beginRenderPassCmds = new CachedArray(1);
          this.bindStatesCmds = new CachedArray(1);
          this.drawCmds = new CachedArray(1);
          this.updateBufferCmds = new CachedArray(1);
          this.copyBufferToTextureCmds = new CachedArray(1);
          this.blitTextureCmds = new CachedArray(1);
        }
        clearCmds(allocator) {
          if (this.beginRenderPassCmds.length) {
            allocator.beginRenderPassCmdPool.freeCmds(this.beginRenderPassCmds);
            this.beginRenderPassCmds.clear();
          }
          if (this.bindStatesCmds.length) {
            allocator.bindStatesCmdPool.freeCmds(this.bindStatesCmds);
            this.bindStatesCmds.clear();
          }
          if (this.drawCmds.length) {
            allocator.drawCmdPool.freeCmds(this.drawCmds);
            this.drawCmds.clear();
          }
          if (this.updateBufferCmds.length) {
            allocator.updateBufferCmdPool.freeCmds(this.updateBufferCmds);
            this.updateBufferCmds.clear();
          }
          if (this.copyBufferToTextureCmds.length) {
            allocator.copyBufferToTextureCmdPool.freeCmds(this.copyBufferToTextureCmds);
            this.copyBufferToTextureCmds.clear();
          }
          if (this.blitTextureCmds.length) {
            allocator.blitTextureCmdPool.freeCmds(this.blitTextureCmds);
            this.blitTextureCmds.clear();
          }
          this.cmds.clear();
        }
      }
      function WebGL2CmdFuncCreateBuffer(device, gpuBuffer) {
        const {
          gl
        } = device;
        const cache = device.stateCache;
        const glUsage = gpuBuffer.memUsage & MemoryUsageBit.HOST ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;
        if (gpuBuffer.usage & BufferUsageBit.VERTEX) {
          gpuBuffer.glTarget = gl.ARRAY_BUFFER;
          const glBuffer = gl.createBuffer();
          if (glBuffer) {
            gpuBuffer.glBuffer = glBuffer;
            if (gpuBuffer.size > 0) {
              if (device.extensions.useVAO) {
                if (cache.glVAO) {
                  gl.bindVertexArray(null);
                  cache.glVAO = null;
                }
              }
              gfxStateCache.gpuInputAssembler = null;
              if (device.stateCache.glArrayBuffer !== gpuBuffer.glBuffer) {
                gl.bindBuffer(gl.ARRAY_BUFFER, gpuBuffer.glBuffer);
                device.stateCache.glArrayBuffer = gpuBuffer.glBuffer;
              }
              gl.bufferData(gl.ARRAY_BUFFER, gpuBuffer.size, glUsage);
              gl.bindBuffer(gl.ARRAY_BUFFER, null);
              device.stateCache.glArrayBuffer = null;
            }
          }
        } else if (gpuBuffer.usage & BufferUsageBit.INDEX) {
          gpuBuffer.glTarget = gl.ELEMENT_ARRAY_BUFFER;
          const glBuffer = gl.createBuffer();
          if (glBuffer) {
            gpuBuffer.glBuffer = glBuffer;
            if (gpuBuffer.size > 0) {
              if (device.extensions.useVAO) {
                if (cache.glVAO) {
                  gl.bindVertexArray(null);
                  cache.glVAO = null;
                }
              }
              gfxStateCache.gpuInputAssembler = null;
              if (device.stateCache.glElementArrayBuffer !== gpuBuffer.glBuffer) {
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.glBuffer);
                device.stateCache.glElementArrayBuffer = gpuBuffer.glBuffer;
              }
              gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.size, glUsage);
              gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
              device.stateCache.glElementArrayBuffer = null;
            }
          }
        } else if (gpuBuffer.usage & BufferUsageBit.UNIFORM) {
          gpuBuffer.glTarget = gl.UNIFORM_BUFFER;
          const glBuffer = gl.createBuffer();
          if (glBuffer && gpuBuffer.size > 0) {
            gpuBuffer.glBuffer = glBuffer;
            if (device.stateCache.glUniformBuffer !== gpuBuffer.glBuffer) {
              gl.bindBuffer(gl.UNIFORM_BUFFER, gpuBuffer.glBuffer);
              device.stateCache.glUniformBuffer = gpuBuffer.glBuffer;
            }
            gl.bufferData(gl.UNIFORM_BUFFER, gpuBuffer.size, glUsage);
            gl.bindBuffer(gl.UNIFORM_BUFFER, null);
            device.stateCache.glUniformBuffer = null;
          }
        } else if (gpuBuffer.usage & BufferUsageBit.INDIRECT) {
          gpuBuffer.glTarget = gl.NONE;
        } else if (gpuBuffer.usage & BufferUsageBit.TRANSFER_DST) {
          gpuBuffer.glTarget = gl.NONE;
        } else if (gpuBuffer.usage & BufferUsageBit.TRANSFER_SRC) {
          gpuBuffer.glTarget = gl.NONE;
        } else {
          error('Unsupported BufferType, create buffer failed.');
          gpuBuffer.glTarget = gl.NONE;
        }
      }
      function WebGL2CmdFuncDestroyBuffer(device, gpuBuffer) {
        const {
          gl
        } = device;
        const cache = device.stateCache;
        if (gpuBuffer.glBuffer) {
          switch (gpuBuffer.glTarget) {
            case gl.ARRAY_BUFFER:
              if (device.extensions.useVAO) {
                if (cache.glVAO) {
                  gl.bindVertexArray(null);
                  device.stateCache.glVAO = null;
                }
              }
              gfxStateCache.gpuInputAssembler = null;
              gl.bindBuffer(gl.ARRAY_BUFFER, null);
              device.stateCache.glArrayBuffer = null;
              break;
            case gl.ELEMENT_ARRAY_BUFFER:
              if (device.extensions.useVAO) {
                if (cache.glVAO) {
                  gl.bindVertexArray(null);
                  device.stateCache.glVAO = null;
                }
              }
              gfxStateCache.gpuInputAssembler = null;
              gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
              device.stateCache.glElementArrayBuffer = null;
              break;
            case gl.UNIFORM_BUFFER:
              gl.bindBuffer(gl.UNIFORM_BUFFER, null);
              device.stateCache.glUniformBuffer = null;
              break;
          }
          gl.deleteBuffer(gpuBuffer.glBuffer);
          gpuBuffer.glBuffer = null;
        }
      }
      function WebGL2CmdFuncResizeBuffer(device, gpuBuffer) {
        const {
          gl
        } = device;
        const cache = device.stateCache;
        const glUsage = gpuBuffer.memUsage & MemoryUsageBit.HOST ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;
        if (gpuBuffer.usage & BufferUsageBit.VERTEX) {
          if (device.extensions.useVAO) {
            if (cache.glVAO) {
              gl.bindVertexArray(null);
              cache.glVAO = null;
            }
          }
          gfxStateCache.gpuInputAssembler = null;
          if (cache.glArrayBuffer !== gpuBuffer.glBuffer) {
            gl.bindBuffer(gl.ARRAY_BUFFER, gpuBuffer.glBuffer);
          }
          if (gpuBuffer.buffer) {
            gl.bufferData(gl.ARRAY_BUFFER, gpuBuffer.buffer, glUsage);
          } else {
            gl.bufferData(gl.ARRAY_BUFFER, gpuBuffer.size, glUsage);
          }
          gl.bindBuffer(gl.ARRAY_BUFFER, null);
          cache.glArrayBuffer = null;
        } else if (gpuBuffer.usage & BufferUsageBit.INDEX) {
          if (device.extensions.useVAO) {
            if (cache.glVAO) {
              gl.bindVertexArray(null);
              cache.glVAO = null;
            }
          }
          gfxStateCache.gpuInputAssembler = null;
          if (device.stateCache.glElementArrayBuffer !== gpuBuffer.glBuffer) {
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.glBuffer);
          }
          if (gpuBuffer.buffer) {
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.buffer, glUsage);
          } else {
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.size, glUsage);
          }
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
          device.stateCache.glElementArrayBuffer = null;
        } else if (gpuBuffer.usage & BufferUsageBit.UNIFORM) {
          if (device.stateCache.glUniformBuffer !== gpuBuffer.glBuffer) {
            gl.bindBuffer(gl.UNIFORM_BUFFER, gpuBuffer.glBuffer);
          }
          gl.bufferData(gl.UNIFORM_BUFFER, gpuBuffer.size, glUsage);
          gl.bindBuffer(gl.UNIFORM_BUFFER, null);
          device.stateCache.glUniformBuffer = null;
        } else if (gpuBuffer.usage & BufferUsageBit.INDIRECT || gpuBuffer.usage & BufferUsageBit.TRANSFER_DST || gpuBuffer.usage & BufferUsageBit.TRANSFER_SRC) {
          gpuBuffer.glTarget = gl.NONE;
        } else {
          error('Unsupported BufferType, create buffer failed.');
          gpuBuffer.glTarget = gl.NONE;
        }
      }
      function WebGL2CmdFuncUpdateBuffer(device, gpuBuffer, buffer, offset, size) {
        if (gpuBuffer.usage & BufferUsageBit.INDIRECT) {
          gpuBuffer.indirects.clearDraws();
          const drawInfos = buffer.drawInfos;
          for (let i = 0; i < drawInfos.length; ++i) {
            gpuBuffer.indirects.setDrawInfo(offset + i, drawInfos[i]);
          }
        } else {
          const buff = buffer;
          const {
            gl
          } = device;
          const cache = device.stateCache;
          switch (gpuBuffer.glTarget) {
            case gl.ARRAY_BUFFER:
              {
                if (device.extensions.useVAO) {
                  if (cache.glVAO) {
                    gl.bindVertexArray(null);
                    cache.glVAO = null;
                  }
                }
                gfxStateCache.gpuInputAssembler = null;
                if (cache.glArrayBuffer !== gpuBuffer.glBuffer) {
                  gl.bindBuffer(gl.ARRAY_BUFFER, gpuBuffer.glBuffer);
                  cache.glArrayBuffer = gpuBuffer.glBuffer;
                }
                if (size === buff.byteLength) {
                  gl.bufferSubData(gpuBuffer.glTarget, offset, buff);
                } else {
                  gl.bufferSubData(gpuBuffer.glTarget, offset, buff.slice(0, size));
                }
                break;
              }
            case gl.ELEMENT_ARRAY_BUFFER:
              {
                if (device.extensions.useVAO) {
                  if (cache.glVAO) {
                    gl.bindVertexArray(null);
                    cache.glVAO = null;
                  }
                }
                gfxStateCache.gpuInputAssembler = null;
                if (cache.glElementArrayBuffer !== gpuBuffer.glBuffer) {
                  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.glBuffer);
                  cache.glElementArrayBuffer = gpuBuffer.glBuffer;
                }
                if (size === buff.byteLength) {
                  gl.bufferSubData(gpuBuffer.glTarget, offset, buff);
                } else {
                  gl.bufferSubData(gpuBuffer.glTarget, offset, buff.slice(0, size));
                }
                break;
              }
            case gl.UNIFORM_BUFFER:
              {
                if (cache.glUniformBuffer !== gpuBuffer.glBuffer) {
                  gl.bindBuffer(gl.UNIFORM_BUFFER, gpuBuffer.glBuffer);
                  cache.glUniformBuffer = gpuBuffer.glBuffer;
                }
                if (size === buff.byteLength) {
                  gl.bufferSubData(gpuBuffer.glTarget, offset, buff);
                } else {
                  gl.bufferSubData(gpuBuffer.glTarget, offset, new Float32Array(buff, 0, size / 4));
                }
                break;
              }
            default:
              {
                error('Unsupported BufferType, update buffer failed.');
              }
          }
        }
      }
      function WebGL2CmdFuncCreateTexture(device, gpuTexture) {
        const {
          gl
        } = device;
        gpuTexture.glInternalFmt = GFXFormatToWebGLInternalFormat(gpuTexture.format, gl);
        gpuTexture.glFormat = GFXFormatToWebGLFormat(gpuTexture.format, gl);
        gpuTexture.glType = GFXFormatToWebGLType(gpuTexture.format, gl);
        let w = gpuTexture.width;
        let h = gpuTexture.height;
        const d = gpuTexture.depth;
        const l = gpuTexture.arrayLayer;
        switch (gpuTexture.type) {
          case TextureType.TEX2D:
            {
              gpuTexture.glTarget = gl.TEXTURE_2D;
              const maxSize = Math.max(w, h);
              if (maxSize > device.capabilities.maxTextureSize) {
                errorID(9100, maxSize, device.capabilities.maxTextureSize);
              }
              if (gpuTexture.samples === SampleCount.X1) {
                gpuTexture.glTexture = gl.createTexture();
                if (gpuTexture.size > 0) {
                  const glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];
                  if (glTexUnit.glTexture !== gpuTexture.glTexture) {
                    gl.bindTexture(gl.TEXTURE_2D, gpuTexture.glTexture);
                    glTexUnit.glTexture = gpuTexture.glTexture;
                  }
                  if (FormatInfos[gpuTexture.format].isCompressed) {
                    for (let i = 0; i < gpuTexture.mipLevel; ++i) {
                      const imgSize = FormatSize(gpuTexture.format, w, h, 1);
                      const view = new Uint8Array(imgSize);
                      gl.compressedTexImage2D(gl.TEXTURE_2D, i, gpuTexture.glInternalFmt, w, h, 0, view);
                      w = Math.max(1, w >> 1);
                      h = Math.max(1, h >> 1);
                    }
                  } else {
                    gl.texStorage2D(gl.TEXTURE_2D, gpuTexture.mipLevel, gpuTexture.glInternalFmt, w, h);
                  }
                }
              } else {
                gpuTexture.glRenderbuffer = gl.createRenderbuffer();
                if (gpuTexture.size > 0) {
                  if (device.stateCache.glRenderbuffer !== gpuTexture.glRenderbuffer) {
                    gl.bindRenderbuffer(gl.RENDERBUFFER, gpuTexture.glRenderbuffer);
                    device.stateCache.glRenderbuffer = gpuTexture.glRenderbuffer;
                  }
                  gl.renderbufferStorageMultisample(gl.RENDERBUFFER, gpuTexture.samples, gpuTexture.glInternalFmt, gpuTexture.width, gpuTexture.height);
                }
              }
              break;
            }
          case TextureType.TEX2D_ARRAY:
            {
              gpuTexture.glTarget = gl.TEXTURE_2D_ARRAY;
              const maxSize = Math.max(w, h);
              if (maxSize > device.capabilities.maxTextureSize) {
                errorID(9100, maxSize, device.capabilities.maxTextureSize);
              }
              if (l > device.capabilities.maxArrayTextureLayers) {
                errorID(9100, l, device.capabilities.maxArrayTextureLayers);
              }
              gpuTexture.glTexture = gl.createTexture();
              if (gpuTexture.size > 0) {
                const glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];
                if (glTexUnit.glTexture !== gpuTexture.glTexture) {
                  gl.bindTexture(gl.TEXTURE_2D_ARRAY, gpuTexture.glTexture);
                  glTexUnit.glTexture = gpuTexture.glTexture;
                }
                if (FormatInfos[gpuTexture.format].isCompressed) {
                  for (let i = 0; i < gpuTexture.mipLevel; ++i) {
                    const imgSize = FormatSize(gpuTexture.format, w, h, l);
                    const view = new Uint8Array(imgSize);
                    gl.compressedTexImage3D(gl.TEXTURE_2D_ARRAY, i, gpuTexture.glInternalFmt, w, h, l, 0, view);
                    w = Math.max(1, w >> 1);
                    h = Math.max(1, h >> 1);
                  }
                } else {
                  gl.texStorage3D(gl.TEXTURE_2D_ARRAY, gpuTexture.mipLevel, gpuTexture.glInternalFmt, w, h, l);
                }
              }
              break;
            }
          case TextureType.TEX3D:
            {
              gpuTexture.glTarget = gl.TEXTURE_3D;
              const maxSize = Math.max(Math.max(w, h), d);
              if (maxSize > device.capabilities.max3DTextureSize) {
                errorID(9100, maxSize, device.capabilities.max3DTextureSize);
              }
              gpuTexture.glTexture = gl.createTexture();
              if (gpuTexture.size > 0) {
                const glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];
                if (glTexUnit.glTexture !== gpuTexture.glTexture) {
                  gl.bindTexture(gl.TEXTURE_3D, gpuTexture.glTexture);
                  glTexUnit.glTexture = gpuTexture.glTexture;
                }
                if (FormatInfos[gpuTexture.format].isCompressed) {
                  for (let i = 0; i < gpuTexture.mipLevel; ++i) {
                    const imgSize = FormatSize(gpuTexture.format, w, h, d);
                    const view = new Uint8Array(imgSize);
                    gl.compressedTexImage3D(gl.TEXTURE_3D, i, gpuTexture.glInternalFmt, w, h, d, 0, view);
                    w = Math.max(1, w >> 1);
                    h = Math.max(1, h >> 1);
                  }
                } else {
                  gl.texStorage3D(gl.TEXTURE_3D, gpuTexture.mipLevel, gpuTexture.glInternalFmt, w, h, d);
                }
              }
              break;
            }
          case TextureType.CUBE:
            {
              gpuTexture.glTarget = gl.TEXTURE_CUBE_MAP;
              const maxSize = Math.max(w, h);
              if (maxSize > device.capabilities.maxCubeMapTextureSize) {
                errorID(9100, maxSize, device.capabilities.maxTextureSize);
              }
              gpuTexture.glTexture = gl.createTexture();
              if (gpuTexture.size > 0) {
                const glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];
                if (glTexUnit.glTexture !== gpuTexture.glTexture) {
                  gl.bindTexture(gl.TEXTURE_CUBE_MAP, gpuTexture.glTexture);
                  glTexUnit.glTexture = gpuTexture.glTexture;
                }
                if (FormatInfos[gpuTexture.format].isCompressed) {
                  for (let i = 0; i < gpuTexture.mipLevel; ++i) {
                    const imgSize = FormatSize(gpuTexture.format, w, h, 1);
                    const view = new Uint8Array(imgSize);
                    for (let f = 0; f < 6; ++f) {
                      gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, i, gpuTexture.glInternalFmt, w, h, 0, view);
                    }
                    w = Math.max(1, w >> 1);
                    h = Math.max(1, h >> 1);
                  }
                } else {
                  gl.texStorage2D(gl.TEXTURE_CUBE_MAP, gpuTexture.mipLevel, gpuTexture.glInternalFmt, w, h);
                }
              }
              break;
            }
          default:
            {
              error('Unsupported TextureType, create texture failed.');
              gpuTexture.type = TextureType.TEX2D;
              gpuTexture.glTarget = gl.TEXTURE_2D;
            }
        }
      }
      function WebGL2CmdFuncDestroyTexture(device, gpuTexture) {
        const {
          gl
        } = device;
        if (gpuTexture.glTexture) {
          const glTexUnits = device.stateCache.glTexUnits;
          let texUnit = device.stateCache.texUnit;
          gl.deleteTexture(gpuTexture.glTexture);
          for (let i = 0; i < glTexUnits.length; ++i) {
            if (glTexUnits[i].glTexture === gpuTexture.glTexture) {
              gl.activeTexture(gl.TEXTURE0 + i);
              texUnit = i;
              gl.bindTexture(gpuTexture.glTarget, null);
              glTexUnits[i].glTexture = null;
            }
          }
          device.stateCache.texUnit = texUnit;
          gpuTexture.glTexture = null;
        }
        if (gpuTexture.glRenderbuffer) {
          let glRenderbuffer = device.stateCache.glRenderbuffer;
          gl.deleteRenderbuffer(gpuTexture.glRenderbuffer);
          if (glRenderbuffer === gpuTexture.glRenderbuffer) {
            gl.bindRenderbuffer(gl.RENDERBUFFER, null);
            glRenderbuffer = null;
          }
          gpuTexture.glRenderbuffer = null;
        }
      }
      function WebGL2CmdFuncResizeTexture(device, gpuTexture) {
        if (!gpuTexture.size) return;
        const {
          gl
        } = device;
        let w = gpuTexture.width;
        let h = gpuTexture.height;
        const d = gpuTexture.depth;
        const l = gpuTexture.arrayLayer;
        switch (gpuTexture.type) {
          case TextureType.TEX2D:
            {
              gpuTexture.glTarget = gl.TEXTURE_2D;
              const maxSize = Math.max(w, h);
              if (maxSize > device.capabilities.maxTextureSize) {
                errorID(9100, maxSize, device.capabilities.maxTextureSize);
              }
              if (gpuTexture.samples === SampleCount.X1) {
                const glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];
                if (glTexUnit.glTexture !== gpuTexture.glTexture) {
                  gl.bindTexture(gl.TEXTURE_2D, gpuTexture.glTexture);
                  glTexUnit.glTexture = gpuTexture.glTexture;
                }
                if (FormatInfos[gpuTexture.format].isCompressed) {
                  for (let i = 0; i < gpuTexture.mipLevel; ++i) {
                    const imgSize = FormatSize(gpuTexture.format, w, h, 1);
                    const view = new Uint8Array(imgSize);
                    gl.compressedTexImage2D(gl.TEXTURE_2D, i, gpuTexture.glInternalFmt, w, h, 0, view);
                    w = Math.max(1, w >> 1);
                    h = Math.max(1, h >> 1);
                  }
                } else {
                  WebGL2CmdFuncDestroyTexture(device, gpuTexture);
                  WebGL2CmdFuncCreateTexture(device, gpuTexture);
                }
              } else if (gpuTexture.glRenderbuffer) {
                if (device.stateCache.glRenderbuffer !== gpuTexture.glRenderbuffer) {
                  gl.bindRenderbuffer(gl.RENDERBUFFER, gpuTexture.glRenderbuffer);
                  device.stateCache.glRenderbuffer = gpuTexture.glRenderbuffer;
                }
                gl.renderbufferStorageMultisample(gl.RENDERBUFFER, gpuTexture.samples, gpuTexture.glInternalFmt, gpuTexture.width, gpuTexture.height);
              }
              break;
            }
          case TextureType.TEX2D_ARRAY:
            {
              gpuTexture.glTarget = gl.TEXTURE_2D_ARRAY;
              const maxSize = Math.max(w, h);
              if (maxSize > device.capabilities.maxTextureSize) {
                errorID(9100, maxSize, device.capabilities.maxTextureSize);
              }
              if (l > device.capabilities.maxArrayTextureLayers) {
                errorID(9100, l, device.capabilities.maxArrayTextureLayers);
              }
              gpuTexture.glTexture = gl.createTexture();
              if (gpuTexture.size > 0) {
                const glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];
                if (glTexUnit.glTexture !== gpuTexture.glTexture) {
                  gl.bindTexture(gl.TEXTURE_2D_ARRAY, gpuTexture.glTexture);
                  glTexUnit.glTexture = gpuTexture.glTexture;
                }
                if (FormatInfos[gpuTexture.format].isCompressed) {
                  for (let i = 0; i < gpuTexture.mipLevel; ++i) {
                    const imgSize = FormatSize(gpuTexture.format, w, h, l);
                    const view = new Uint8Array(imgSize);
                    gl.compressedTexImage3D(gl.TEXTURE_2D_ARRAY, i, gpuTexture.glInternalFmt, w, h, l, 0, view);
                    w = Math.max(1, w >> 1);
                    h = Math.max(1, h >> 1);
                  }
                } else {
                  gl.texStorage3D(gl.TEXTURE_2D_ARRAY, gpuTexture.mipLevel, gpuTexture.glInternalFmt, w, h, l);
                }
              }
              break;
            }
          case TextureType.TEX3D:
            {
              gpuTexture.glTarget = gl.TEXTURE_3D;
              const maxSize = Math.max(Math.max(w, h), d);
              if (maxSize > device.capabilities.max3DTextureSize) {
                errorID(9100, maxSize, device.capabilities.max3DTextureSize);
              }
              gpuTexture.glTexture = gl.createTexture();
              if (gpuTexture.size > 0) {
                const glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];
                if (glTexUnit.glTexture !== gpuTexture.glTexture) {
                  gl.bindTexture(gl.TEXTURE_3D, gpuTexture.glTexture);
                  glTexUnit.glTexture = gpuTexture.glTexture;
                }
                if (FormatInfos[gpuTexture.format].isCompressed) {
                  for (let i = 0; i < gpuTexture.mipLevel; ++i) {
                    const imgSize = FormatSize(gpuTexture.format, w, h, d);
                    const view = new Uint8Array(imgSize);
                    gl.compressedTexImage3D(gl.TEXTURE_3D, i, gpuTexture.glInternalFmt, w, h, d, 0, view);
                    w = Math.max(1, w >> 1);
                    h = Math.max(1, h >> 1);
                  }
                } else {
                  gl.texStorage3D(gl.TEXTURE_3D, gpuTexture.mipLevel, gpuTexture.glInternalFmt, w, h, d);
                }
              }
              break;
            }
          case TextureType.CUBE:
            {
              gpuTexture.type = TextureType.CUBE;
              gpuTexture.glTarget = gl.TEXTURE_CUBE_MAP;
              const maxSize = Math.max(w, h);
              if (maxSize > device.capabilities.maxCubeMapTextureSize) {
                errorID(9100, maxSize, device.capabilities.maxTextureSize);
              }
              const glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];
              if (glTexUnit.glTexture !== gpuTexture.glTexture) {
                gl.bindTexture(gl.TEXTURE_CUBE_MAP, gpuTexture.glTexture);
                glTexUnit.glTexture = gpuTexture.glTexture;
              }
              if (FormatInfos[gpuTexture.format].isCompressed) {
                for (let f = 0; f < 6; ++f) {
                  w = gpuTexture.width;
                  h = gpuTexture.height;
                  for (let i = 0; i < gpuTexture.mipLevel; ++i) {
                    const imgSize = FormatSize(gpuTexture.format, w, h, 1);
                    const view = new Uint8Array(imgSize);
                    gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, i, gpuTexture.glInternalFmt, w, h, 0, view);
                    w = Math.max(1, w >> 1);
                    h = Math.max(1, h >> 1);
                  }
                }
              } else {
                WebGL2CmdFuncDestroyTexture(device, gpuTexture);
                WebGL2CmdFuncCreateTexture(device, gpuTexture);
              }
              break;
            }
          default:
            {
              error('Unsupported TextureType, create texture failed.');
              gpuTexture.type = TextureType.TEX2D;
              gpuTexture.glTarget = gl.TEXTURE_2D;
            }
        }
      }
      function WebGL2CmdFuncPrepareSamplerInfo(device, gpuSampler) {
        const {
          gl
        } = device;
        if (gpuSampler.minFilter === Filter$1.LINEAR || gpuSampler.minFilter === Filter$1.ANISOTROPIC) {
          if (gpuSampler.mipFilter === Filter$1.LINEAR || gpuSampler.mipFilter === Filter$1.ANISOTROPIC) {
            gpuSampler.glMinFilter = gl.LINEAR_MIPMAP_LINEAR;
          } else if (gpuSampler.mipFilter === Filter$1.POINT) {
            gpuSampler.glMinFilter = gl.LINEAR_MIPMAP_NEAREST;
          } else {
            gpuSampler.glMinFilter = gl.LINEAR;
          }
        } else if (gpuSampler.mipFilter === Filter$1.LINEAR || gpuSampler.mipFilter === Filter$1.ANISOTROPIC) {
          gpuSampler.glMinFilter = gl.NEAREST_MIPMAP_LINEAR;
        } else if (gpuSampler.mipFilter === Filter$1.POINT) {
          gpuSampler.glMinFilter = gl.NEAREST_MIPMAP_NEAREST;
        } else {
          gpuSampler.glMinFilter = gl.NEAREST;
        }
        if (gpuSampler.magFilter === Filter$1.LINEAR || gpuSampler.magFilter === Filter$1.ANISOTROPIC) {
          gpuSampler.glMagFilter = gl.LINEAR;
        } else {
          gpuSampler.glMagFilter = gl.NEAREST;
        }
        gpuSampler.glWrapS = WebGLWraps[gpuSampler.addressU];
        gpuSampler.glWrapT = WebGLWraps[gpuSampler.addressV];
        gpuSampler.glWrapR = WebGLWraps[gpuSampler.addressW];
      }
      function WebGL2CmdFuncDestroySampler(device, gpuSampler) {
        const {
          gl
        } = device;
        const it = gpuSampler.glSamplers.values();
        const res = it.next();
        while (!res.done) {
          gl.deleteSampler(res.value);
          const glSamplerUnits = device.stateCache.glSamplerUnits;
          for (let i = 0; i < glSamplerUnits.length; ++i) {
            if (glSamplerUnits[i] === res.value) {
              gl.bindSampler(i, null);
              glSamplerUnits[i] = null;
            }
          }
        }
        gpuSampler.glSamplers.clear();
      }
      function WebGL2CmdFuncCreateFramebuffer(device, gpuFramebuffer) {
        for (let i = 0; i < gpuFramebuffer.gpuColorViews.length; ++i) {
          const tex = gpuFramebuffer.gpuColorViews[i].gpuTexture;
          if (tex.isSwapchainTexture) {
            gpuFramebuffer.isOffscreen = false;
            return;
          }
        }
        const {
          gl
        } = device;
        const attachments = [];
        const glFramebuffer = gl.createFramebuffer();
        if (glFramebuffer) {
          gpuFramebuffer.glFramebuffer = glFramebuffer;
          if (device.stateCache.glFramebuffer !== gpuFramebuffer.glFramebuffer) {
            gl.bindFramebuffer(gl.FRAMEBUFFER, gpuFramebuffer.glFramebuffer);
          }
          for (let i = 0; i < gpuFramebuffer.gpuColorViews.length; ++i) {
            const colorTextureView = gpuFramebuffer.gpuColorViews[i];
            const colorTexture = colorTextureView.gpuTexture;
            if (colorTexture) {
              if (colorTexture.glTexture) {
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, colorTexture.glTarget, colorTexture.glTexture, colorTextureView.baseLevel);
              } else {
                gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.RENDERBUFFER, colorTexture.glRenderbuffer);
              }
              attachments.push(gl.COLOR_ATTACHMENT0 + i);
              gpuFramebuffer.width = Math.min(gpuFramebuffer.width, colorTexture.width >> colorTextureView.baseLevel);
              gpuFramebuffer.height = Math.min(gpuFramebuffer.height, colorTexture.height >> colorTextureView.baseLevel);
            }
          }
          const dstView = gpuFramebuffer.gpuDepthStencilView;
          if (dstView) {
            const dst = dstView.gpuTexture;
            const glAttachment = FormatInfos[dst.format].hasStencil ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;
            if (dst.glTexture) {
              gl.framebufferTexture2D(gl.FRAMEBUFFER, glAttachment, dst.glTarget, dst.glTexture, gpuFramebuffer.gpuDepthStencilView.baseLevel);
            } else {
              gl.framebufferRenderbuffer(gl.FRAMEBUFFER, glAttachment, gl.RENDERBUFFER, dst.glRenderbuffer);
            }
            gpuFramebuffer.width = Math.min(gpuFramebuffer.width, dst.width >> dstView.baseLevel);
            gpuFramebuffer.height = Math.min(gpuFramebuffer.height, dst.height >> dstView.baseLevel);
          }
          gl.drawBuffers(attachments);
          const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
          if (status !== gl.FRAMEBUFFER_COMPLETE) {
            switch (status) {
              case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                {
                  error('glCheckFramebufferStatus() - FRAMEBUFFER_INCOMPLETE_ATTACHMENT');
                  break;
                }
              case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                {
                  error('glCheckFramebufferStatus() - FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT');
                  break;
                }
              case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                {
                  error('glCheckFramebufferStatus() - FRAMEBUFFER_INCOMPLETE_DIMENSIONS');
                  break;
                }
              case gl.FRAMEBUFFER_UNSUPPORTED:
                {
                  error('glCheckFramebufferStatus() - FRAMEBUFFER_UNSUPPORTED');
                  break;
                }
            }
          }
          if (device.stateCache.glFramebuffer !== gpuFramebuffer.glFramebuffer) {
            gl.bindFramebuffer(gl.FRAMEBUFFER, device.stateCache.glFramebuffer);
          }
        }
      }
      function WebGL2CmdFuncDestroyFramebuffer(device, gpuFramebuffer) {
        if (gpuFramebuffer.glFramebuffer) {
          device.gl.deleteFramebuffer(gpuFramebuffer.glFramebuffer);
          if (device.stateCache.glFramebuffer === gpuFramebuffer.glFramebuffer) {
            device.gl.bindFramebuffer(device.gl.FRAMEBUFFER, null);
            device.stateCache.glFramebuffer = null;
          }
          gpuFramebuffer.glFramebuffer = null;
        }
      }
      function WebGL2CmdFuncCreateShader(device, gpuShader) {
        const {
          gl
        } = device;
        for (let k = 0; k < gpuShader.gpuStages.length; k++) {
          const gpuStage = gpuShader.gpuStages[k];
          let glShaderType = 0;
          let shaderTypeStr = '';
          let lineNumber = 1;
          switch (gpuStage.type) {
            case ShaderStageFlagBit.VERTEX:
              {
                shaderTypeStr = 'VertexShader';
                glShaderType = gl.VERTEX_SHADER;
                break;
              }
            case ShaderStageFlagBit.FRAGMENT:
              {
                shaderTypeStr = 'FragmentShader';
                glShaderType = gl.FRAGMENT_SHADER;
                break;
              }
            default:
              {
                error('Unsupported ShaderType.');
                return;
              }
          }
          const glShader = gl.createShader(glShaderType);
          if (glShader) {
            gpuStage.glShader = glShader;
            gl.shaderSource(gpuStage.glShader, `#version 300 es\n${gpuStage.source}`);
            gl.compileShader(gpuStage.glShader);
            if (!gl.getShaderParameter(gpuStage.glShader, gl.COMPILE_STATUS)) {
              error(`${shaderTypeStr} in '${gpuShader.name}' compilation failed.`);
              error('Shader source dump:', gpuStage.source.replace(/^|\n/g, () => `\n${lineNumber++} `));
              error(gl.getShaderInfoLog(gpuStage.glShader));
              for (let l = 0; l < gpuShader.gpuStages.length; l++) {
                const stage = gpuShader.gpuStages[k];
                if (stage.glShader) {
                  gl.deleteShader(stage.glShader);
                  stage.glShader = null;
                }
              }
              return;
            }
          }
        }
        const glProgram = gl.createProgram();
        if (!glProgram) {
          return;
        }
        gpuShader.glProgram = glProgram;
        const enableEffectImport = !!(legacyCC.rendering && legacyCC.rendering.enableEffectImport);
        for (let k = 0; k < gpuShader.gpuStages.length; k++) {
          const gpuStage = gpuShader.gpuStages[k];
          gl.attachShader(gpuShader.glProgram, gpuStage.glShader);
        }
        gl.linkProgram(gpuShader.glProgram);
        for (let k = 0; k < gpuShader.gpuStages.length; k++) {
          const gpuStage = gpuShader.gpuStages[k];
          if (gpuStage.glShader) {
            gl.detachShader(gpuShader.glProgram, gpuStage.glShader);
            gl.deleteShader(gpuStage.glShader);
            gpuStage.glShader = null;
          }
        }
        if (gl.getProgramParameter(gpuShader.glProgram, gl.LINK_STATUS)) {
          debug(`Shader '${gpuShader.name}' compilation succeeded.`);
        } else {
          error(`Failed to link shader '${gpuShader.name}'.`);
          error(gl.getProgramInfoLog(gpuShader.glProgram));
          return;
        }
        const activeAttribCount = gl.getProgramParameter(gpuShader.glProgram, gl.ACTIVE_ATTRIBUTES);
        gpuShader.glInputs = new Array(activeAttribCount);
        for (let i = 0; i < activeAttribCount; ++i) {
          const attribInfo = gl.getActiveAttrib(gpuShader.glProgram, i);
          if (attribInfo) {
            let varName;
            const nameOffset = attribInfo.name.indexOf('[');
            if (nameOffset !== -1) {
              varName = attribInfo.name.substr(0, nameOffset);
            } else {
              varName = attribInfo.name;
            }
            const glLoc = gl.getAttribLocation(gpuShader.glProgram, varName);
            const type = WebGLTypeToGFXType(attribInfo.type, gl);
            const stride = WebGLGetTypeSize(attribInfo.type, gl);
            gpuShader.glInputs[i] = {
              name: varName,
              type,
              stride,
              count: attribInfo.size,
              size: stride * attribInfo.size,
              glType: attribInfo.type,
              glLoc
            };
          }
        }
        const activeBlockCount = gl.getProgramParameter(gpuShader.glProgram, gl.ACTIVE_UNIFORM_BLOCKS);
        let blockName;
        let blockIdx;
        let blockSize;
        let block;
        if (activeBlockCount) {
          gpuShader.glBlocks = new Array(activeBlockCount);
          for (let b = 0; b < activeBlockCount; ++b) {
            blockName = gl.getActiveUniformBlockName(gpuShader.glProgram, b);
            const nameOffset = blockName.indexOf('[');
            if (nameOffset !== -1) {
              blockName = blockName.substr(0, nameOffset);
            }
            block = null;
            for (let k = 0; k < gpuShader.blocks.length; k++) {
              if (gpuShader.blocks[k].name === blockName) {
                block = gpuShader.blocks[k];
                break;
              }
            }
            if (!block) {
              error(`Block '${blockName}' does not bound`);
            } else {
              blockIdx = b;
              blockSize = gl.getActiveUniformBlockParameter(gpuShader.glProgram, blockIdx, gl.UNIFORM_BLOCK_DATA_SIZE);
              const glBinding = enableEffectImport ? block.flattened : block.binding + (device.bindingMappings.blockOffsets[block.set] || 0);
              gl.uniformBlockBinding(gpuShader.glProgram, blockIdx, glBinding);
              gpuShader.glBlocks[b] = {
                set: block.set,
                binding: block.binding,
                idx: blockIdx,
                name: blockName,
                size: blockSize,
                glBinding
              };
            }
          }
        }
        for (let i = 0; i < gpuShader.subpassInputs.length; ++i) {
          const subpassInput = gpuShader.subpassInputs[i];
          gpuShader.samplerTextures.push(new UniformSamplerTexture(subpassInput.set, subpassInput.binding, subpassInput.name, Type$1.SAMPLER2D, subpassInput.count));
        }
        if (gpuShader.samplerTextures.length > 0) {
          gpuShader.glSamplerTextures = new Array(gpuShader.samplerTextures.length);
          for (let i = 0; i < gpuShader.samplerTextures.length; ++i) {
            const sampler = gpuShader.samplerTextures[i];
            gpuShader.glSamplerTextures[i] = {
              set: sampler.set,
              binding: sampler.binding,
              name: sampler.name,
              type: sampler.type,
              count: sampler.count,
              units: [],
              glUnits: null,
              glType: GFXTypeToWebGLType(sampler.type, gl),
              glLoc: null
            };
          }
        }
        const glActiveSamplers = [];
        const glActiveSamplerLocations = [];
        const texUnitCacheMap = device.stateCache.texUnitCacheMap;
        if (!enableEffectImport) {
          let flexibleSetBaseOffset = 0;
          for (let i = 0; i < gpuShader.blocks.length; ++i) {
            if (gpuShader.blocks[i].set === device.bindingMappings.flexibleSet) {
              flexibleSetBaseOffset++;
            }
          }
          let arrayOffset = 0;
          for (let i = 0; i < gpuShader.samplerTextures.length; ++i) {
            const sampler = gpuShader.samplerTextures[i];
            const glLoc = gl.getUniformLocation(gpuShader.glProgram, sampler.name);
            if (glLoc && glLoc.id !== -1) {
              glActiveSamplers.push(gpuShader.glSamplerTextures[i]);
              glActiveSamplerLocations.push(glLoc);
            }
            if (texUnitCacheMap[sampler.name] === undefined) {
              let binding = sampler.binding + device.bindingMappings.samplerTextureOffsets[sampler.set] + arrayOffset;
              if (sampler.set === device.bindingMappings.flexibleSet) {
                binding -= flexibleSetBaseOffset;
              }
              texUnitCacheMap[sampler.name] = binding % device.capabilities.maxTextureUnits;
              arrayOffset += sampler.count - 1;
            }
          }
        } else {
          for (let i = 0; i < gpuShader.samplerTextures.length; ++i) {
            const sampler = gpuShader.samplerTextures[i];
            const glLoc = gl.getUniformLocation(gpuShader.glProgram, sampler.name);
            if (glLoc && glLoc.id !== -1) {
              glActiveSamplers.push(gpuShader.glSamplerTextures[i]);
              glActiveSamplerLocations.push(glLoc);
            }
            if (texUnitCacheMap[sampler.name] === undefined) {
              texUnitCacheMap[sampler.name] = sampler.flattened % device.capabilities.maxTextureUnits;
            }
          }
        }
        if (glActiveSamplers.length) {
          const usedTexUnits = [];
          for (let i = 0; i < glActiveSamplers.length; ++i) {
            const glSampler = glActiveSamplers[i];
            let cachedUnit = texUnitCacheMap[glSampler.name];
            if (cachedUnit !== undefined) {
              glSampler.glLoc = glActiveSamplerLocations[i];
              for (let t = 0; t < glSampler.count; ++t) {
                while (usedTexUnits[cachedUnit]) {
                  cachedUnit = (cachedUnit + 1) % device.capabilities.maxTextureUnits;
                }
                glSampler.units.push(cachedUnit);
                usedTexUnits[cachedUnit] = true;
              }
            }
          }
          let unitIdx = 0;
          for (let i = 0; i < glActiveSamplers.length; ++i) {
            const glSampler = glActiveSamplers[i];
            if (!glSampler.glLoc) {
              glSampler.glLoc = glActiveSamplerLocations[i];
              while (usedTexUnits[unitIdx]) {
                unitIdx++;
              }
              for (let t = 0; t < glSampler.count; ++t) {
                while (usedTexUnits[unitIdx]) {
                  unitIdx = (unitIdx + 1) % device.capabilities.maxTextureUnits;
                }
                if (texUnitCacheMap[glSampler.name] === undefined) {
                  texUnitCacheMap[glSampler.name] = unitIdx;
                }
                glSampler.units.push(unitIdx);
                usedTexUnits[unitIdx] = true;
              }
            }
          }
          if (device.stateCache.glProgram !== gpuShader.glProgram) {
            gl.useProgram(gpuShader.glProgram);
          }
          for (let k = 0; k < glActiveSamplers.length; k++) {
            const glSampler = glActiveSamplers[k];
            glSampler.glUnits = new Int32Array(glSampler.units);
            gl.uniform1iv(glSampler.glLoc, glSampler.glUnits);
          }
          if (device.stateCache.glProgram !== gpuShader.glProgram) {
            gl.useProgram(device.stateCache.glProgram);
          }
        }
        gpuShader.glSamplerTextures = glActiveSamplers;
      }
      function WebGL2CmdFuncDestroyShader(device, gpuShader) {
        if (gpuShader.glProgram) {
          device.gl.deleteProgram(gpuShader.glProgram);
          if (device.stateCache.glProgram === gpuShader.glProgram) {
            device.gl.useProgram(null);
            device.stateCache.glProgram = null;
          }
          gpuShader.glProgram = null;
        }
      }
      function WebGL2CmdFuncCreateInputAssember(device, gpuInputAssembler) {
        const {
          gl
        } = device;
        gpuInputAssembler.glAttribs = new Array(gpuInputAssembler.attributes.length);
        const offsets = [0, 0, 0, 0, 0, 0, 0, 0];
        for (let i = 0; i < gpuInputAssembler.attributes.length; ++i) {
          const attrib = gpuInputAssembler.attributes[i];
          const stream = attrib.stream !== undefined ? attrib.stream : 0;
          const gpuBuffer = gpuInputAssembler.gpuVertexBuffers[stream];
          const glType = GFXFormatToWebGLType(attrib.format, gl);
          const {
            size
          } = FormatInfos[attrib.format];
          gpuInputAssembler.glAttribs[i] = {
            name: attrib.name,
            glBuffer: gpuBuffer.glBuffer,
            glType,
            size,
            count: FormatInfos[attrib.format].count,
            stride: gpuBuffer.stride,
            componentCount: WebGLGetComponentCount(glType, gl),
            isNormalized: attrib.isNormalized !== undefined ? attrib.isNormalized : false,
            isInstanced: attrib.isInstanced !== undefined ? attrib.isInstanced : false,
            offset: offsets[stream]
          };
          offsets[stream] += size;
        }
      }
      function WebGL2CmdFuncDestroyInputAssembler(device, gpuInputAssembler) {
        const it = gpuInputAssembler.glVAOs.values();
        let res = it.next();
        const {
          gl
        } = device;
        let glVAO = device.stateCache.glVAO;
        while (!res.done) {
          gl.deleteVertexArray(res.value);
          if (glVAO === res.value) {
            gl.bindVertexArray(null);
            glVAO = null;
          }
          res = it.next();
        }
        device.stateCache.glVAO = glVAO;
        gpuInputAssembler.glVAOs.clear();
      }
      const gfxStateCache = {
        gpuPipelineState: null,
        gpuInputAssembler: null,
        glPrimitive: 0,
        invalidateAttachments: []
      };
      function WebGL2CmdFuncBeginRenderPass(device, gpuRenderPass, gpuFramebuffer, renderArea, clearColors, clearDepth, clearStencil) {
        const {
          gl
        } = device;
        const cache = device.stateCache;
        let clears = 0;
        if (gpuFramebuffer && gpuRenderPass) {
          if (cache.glFramebuffer !== gpuFramebuffer.glFramebuffer) {
            gl.bindFramebuffer(gl.FRAMEBUFFER, gpuFramebuffer.glFramebuffer);
            cache.glFramebuffer = gpuFramebuffer.glFramebuffer;
          }
          if (cache.viewport.left !== renderArea.x || cache.viewport.top !== renderArea.y || cache.viewport.width !== renderArea.width || cache.viewport.height !== renderArea.height) {
            gl.viewport(renderArea.x, renderArea.y, renderArea.width, renderArea.height);
            cache.viewport.left = renderArea.x;
            cache.viewport.top = renderArea.y;
            cache.viewport.width = renderArea.width;
            cache.viewport.height = renderArea.height;
          }
          if (cache.scissorRect.x !== renderArea.x || cache.scissorRect.y !== renderArea.y || cache.scissorRect.width !== renderArea.width || cache.scissorRect.height !== renderArea.height) {
            gl.scissor(renderArea.x, renderArea.y, renderArea.width, renderArea.height);
            cache.scissorRect.x = renderArea.x;
            cache.scissorRect.y = renderArea.y;
            cache.scissorRect.width = renderArea.width;
            cache.scissorRect.height = renderArea.height;
          }
          gfxStateCache.invalidateAttachments.length = 0;
          for (let j = 0; j < clearColors.length; ++j) {
            const colorAttachment = gpuRenderPass.colorAttachments[j];
            if (colorAttachment.format !== Format.UNKNOWN) {
              switch (colorAttachment.loadOp) {
                case LoadOp.LOAD:
                  break;
                case LoadOp.CLEAR:
                  {
                    if (cache.bs.targets[0].blendColorMask !== ColorMask.ALL) {
                      gl.colorMask(true, true, true, true);
                    }
                    if (gpuRenderPass.colorAttachments.length === 1) {
                      const clearColor = clearColors[0];
                      gl.clearColor(clearColor.x, clearColor.y, clearColor.z, clearColor.w);
                      clears |= gl.COLOR_BUFFER_BIT;
                    } else {
                      _f32v4[0] = clearColors[j].x;
                      _f32v4[1] = clearColors[j].y;
                      _f32v4[2] = clearColors[j].z;
                      _f32v4[3] = clearColors[j].w;
                      gl.clearBufferfv(gl.COLOR, j, _f32v4);
                    }
                    break;
                  }
                case LoadOp.DISCARD:
                  {
                    gfxStateCache.invalidateAttachments.push(gl.COLOR_ATTACHMENT0 + j);
                    break;
                  }
              }
            }
          }
          if (gpuRenderPass.depthStencilAttachment) {
            if (gpuRenderPass.depthStencilAttachment.format !== Format.UNKNOWN) {
              switch (gpuRenderPass.depthStencilAttachment.depthLoadOp) {
                case LoadOp.LOAD:
                  break;
                case LoadOp.CLEAR:
                  {
                    if (!cache.dss.depthWrite) {
                      gl.depthMask(true);
                    }
                    gl.clearDepth(clearDepth);
                    clears |= gl.DEPTH_BUFFER_BIT;
                    break;
                  }
                case LoadOp.DISCARD:
                  {
                    gfxStateCache.invalidateAttachments.push(gl.DEPTH_ATTACHMENT);
                    break;
                  }
              }
              if (FormatInfos[gpuRenderPass.depthStencilAttachment.format].hasStencil) {
                switch (gpuRenderPass.depthStencilAttachment.stencilLoadOp) {
                  case LoadOp.LOAD:
                    break;
                  case LoadOp.CLEAR:
                    {
                      if (!cache.dss.stencilWriteMaskFront) {
                        gl.stencilMaskSeparate(gl.FRONT, 0xffff);
                      }
                      if (!cache.dss.stencilWriteMaskBack) {
                        gl.stencilMaskSeparate(gl.BACK, 0xffff);
                      }
                      gl.clearStencil(clearStencil);
                      clears |= gl.STENCIL_BUFFER_BIT;
                      break;
                    }
                  case LoadOp.DISCARD:
                    {
                      gfxStateCache.invalidateAttachments.push(gl.STENCIL_ATTACHMENT);
                      break;
                    }
                }
              }
            }
          }
          if (gpuFramebuffer.glFramebuffer && gfxStateCache.invalidateAttachments.length) {
            gl.invalidateFramebuffer(gl.FRAMEBUFFER, gfxStateCache.invalidateAttachments);
          }
          if (clears) {
            gl.clear(clears);
          }
          if (clears & gl.COLOR_BUFFER_BIT) {
            const colorMask = cache.bs.targets[0].blendColorMask;
            if (colorMask !== ColorMask.ALL) {
              const r = (colorMask & ColorMask.R) !== ColorMask.NONE;
              const g = (colorMask & ColorMask.G) !== ColorMask.NONE;
              const b = (colorMask & ColorMask.B) !== ColorMask.NONE;
              const a = (colorMask & ColorMask.A) !== ColorMask.NONE;
              gl.colorMask(r, g, b, a);
            }
          }
          if (clears & gl.DEPTH_BUFFER_BIT && !cache.dss.depthWrite) {
            gl.depthMask(false);
          }
          if (clears & gl.STENCIL_BUFFER_BIT) {
            if (!cache.dss.stencilWriteMaskFront) {
              gl.stencilMaskSeparate(gl.FRONT, 0);
            }
            if (!cache.dss.stencilWriteMaskBack) {
              gl.stencilMaskSeparate(gl.BACK, 0);
            }
          }
        }
      }
      function WebGL2CmdFuncBindStates(device, gpuPipelineState, gpuInputAssembler, gpuDescriptorSets, dynamicOffsets, dynamicStates) {
        const {
          gl
        } = device;
        const cache = device.stateCache;
        const gpuShader = gpuPipelineState && gpuPipelineState.gpuShader;
        let isShaderChanged = false;
        if (gpuPipelineState && gfxStateCache.gpuPipelineState !== gpuPipelineState) {
          gfxStateCache.gpuPipelineState = gpuPipelineState;
          gfxStateCache.glPrimitive = gpuPipelineState.glPrimitive;
          if (gpuShader) {
            const {
              glProgram
            } = gpuShader;
            if (cache.glProgram !== glProgram) {
              gl.useProgram(glProgram);
              cache.glProgram = glProgram;
              isShaderChanged = true;
            }
          }
          const {
            rs
          } = gpuPipelineState;
          if (rs) {
            if (cache.rs.cullMode !== rs.cullMode) {
              switch (rs.cullMode) {
                case CullMode.NONE:
                  {
                    gl.disable(gl.CULL_FACE);
                    break;
                  }
                case CullMode.FRONT:
                  {
                    gl.enable(gl.CULL_FACE);
                    gl.cullFace(gl.FRONT);
                    break;
                  }
                case CullMode.BACK:
                  {
                    gl.enable(gl.CULL_FACE);
                    gl.cullFace(gl.BACK);
                    break;
                  }
              }
              device.stateCache.rs.cullMode = rs.cullMode;
            }
            const isFrontFaceCCW = rs.isFrontFaceCCW;
            if (device.stateCache.rs.isFrontFaceCCW !== isFrontFaceCCW) {
              gl.frontFace(isFrontFaceCCW ? gl.CCW : gl.CW);
              device.stateCache.rs.isFrontFaceCCW = isFrontFaceCCW;
            }
            if (device.stateCache.rs.depthBias !== rs.depthBias || device.stateCache.rs.depthBiasSlop !== rs.depthBiasSlop) {
              gl.polygonOffset(rs.depthBias, rs.depthBiasSlop);
              device.stateCache.rs.depthBias = rs.depthBias;
              device.stateCache.rs.depthBiasSlop = rs.depthBiasSlop;
            }
            if (device.stateCache.rs.lineWidth !== rs.lineWidth) {
              gl.lineWidth(rs.lineWidth);
              device.stateCache.rs.lineWidth = rs.lineWidth;
            }
          }
          const {
            dss
          } = gpuPipelineState;
          if (dss) {
            if (cache.dss.depthTest !== dss.depthTest) {
              if (dss.depthTest) {
                gl.enable(gl.DEPTH_TEST);
              } else {
                gl.disable(gl.DEPTH_TEST);
              }
              cache.dss.depthTest = dss.depthTest;
            }
            if (cache.dss.depthWrite !== dss.depthWrite) {
              gl.depthMask(dss.depthWrite);
              cache.dss.depthWrite = dss.depthWrite;
            }
            if (cache.dss.depthFunc !== dss.depthFunc) {
              gl.depthFunc(WebGLCmpFuncs[dss.depthFunc]);
              cache.dss.depthFunc = dss.depthFunc;
            }
            if (cache.dss.stencilTestFront !== dss.stencilTestFront || cache.dss.stencilTestBack !== dss.stencilTestBack) {
              if (dss.stencilTestFront || dss.stencilTestBack) {
                gl.enable(gl.STENCIL_TEST);
              } else {
                gl.disable(gl.STENCIL_TEST);
              }
              cache.dss.stencilTestFront = dss.stencilTestFront;
              cache.dss.stencilTestBack = dss.stencilTestBack;
            }
            if (cache.dss.stencilFuncFront !== dss.stencilFuncFront || cache.dss.stencilRefFront !== dss.stencilRefFront || cache.dss.stencilReadMaskFront !== dss.stencilReadMaskFront) {
              gl.stencilFuncSeparate(gl.FRONT, WebGLCmpFuncs[dss.stencilFuncFront], dss.stencilRefFront, dss.stencilReadMaskFront);
              cache.dss.stencilFuncFront = dss.stencilFuncFront;
              cache.dss.stencilRefFront = dss.stencilRefFront;
              cache.dss.stencilReadMaskFront = dss.stencilReadMaskFront;
            }
            if (cache.dss.stencilFailOpFront !== dss.stencilFailOpFront || cache.dss.stencilZFailOpFront !== dss.stencilZFailOpFront || cache.dss.stencilPassOpFront !== dss.stencilPassOpFront) {
              gl.stencilOpSeparate(gl.FRONT, WebGLStencilOps[dss.stencilFailOpFront], WebGLStencilOps[dss.stencilZFailOpFront], WebGLStencilOps[dss.stencilPassOpFront]);
              cache.dss.stencilFailOpFront = dss.stencilFailOpFront;
              cache.dss.stencilZFailOpFront = dss.stencilZFailOpFront;
              cache.dss.stencilPassOpFront = dss.stencilPassOpFront;
            }
            if (cache.dss.stencilWriteMaskFront !== dss.stencilWriteMaskFront) {
              gl.stencilMaskSeparate(gl.FRONT, dss.stencilWriteMaskFront);
              cache.dss.stencilWriteMaskFront = dss.stencilWriteMaskFront;
            }
            if (cache.dss.stencilFuncBack !== dss.stencilFuncBack || cache.dss.stencilRefBack !== dss.stencilRefBack || cache.dss.stencilReadMaskBack !== dss.stencilReadMaskBack) {
              gl.stencilFuncSeparate(gl.BACK, WebGLCmpFuncs[dss.stencilFuncBack], dss.stencilRefBack, dss.stencilReadMaskBack);
              cache.dss.stencilFuncBack = dss.stencilFuncBack;
              cache.dss.stencilRefBack = dss.stencilRefBack;
              cache.dss.stencilReadMaskBack = dss.stencilReadMaskBack;
            }
            if (cache.dss.stencilFailOpBack !== dss.stencilFailOpBack || cache.dss.stencilZFailOpBack !== dss.stencilZFailOpBack || cache.dss.stencilPassOpBack !== dss.stencilPassOpBack) {
              gl.stencilOpSeparate(gl.BACK, WebGLStencilOps[dss.stencilFailOpBack], WebGLStencilOps[dss.stencilZFailOpBack], WebGLStencilOps[dss.stencilPassOpBack]);
              cache.dss.stencilFailOpBack = dss.stencilFailOpBack;
              cache.dss.stencilZFailOpBack = dss.stencilZFailOpBack;
              cache.dss.stencilPassOpBack = dss.stencilPassOpBack;
            }
            if (cache.dss.stencilWriteMaskBack !== dss.stencilWriteMaskBack) {
              gl.stencilMaskSeparate(gl.BACK, dss.stencilWriteMaskBack);
              cache.dss.stencilWriteMaskBack = dss.stencilWriteMaskBack;
            }
          }
          const {
            bs
          } = gpuPipelineState;
          if (bs) {
            if (cache.bs.isA2C !== bs.isA2C) {
              if (bs.isA2C) {
                gl.enable(gl.SAMPLE_ALPHA_TO_COVERAGE);
              } else {
                gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
              }
              cache.bs.isA2C = bs.isA2C;
            }
            if (cache.bs.blendColor.x !== bs.blendColor.x || cache.bs.blendColor.y !== bs.blendColor.y || cache.bs.blendColor.z !== bs.blendColor.z || cache.bs.blendColor.w !== bs.blendColor.w) {
              gl.blendColor(bs.blendColor.x, bs.blendColor.y, bs.blendColor.z, bs.blendColor.w);
              cache.bs.blendColor.x = bs.blendColor.x;
              cache.bs.blendColor.y = bs.blendColor.y;
              cache.bs.blendColor.z = bs.blendColor.z;
              cache.bs.blendColor.w = bs.blendColor.w;
            }
            const target0 = bs.targets[0];
            const target0Cache = cache.bs.targets[0];
            if (target0Cache.blend !== target0.blend) {
              if (target0.blend) {
                gl.enable(gl.BLEND);
              } else {
                gl.disable(gl.BLEND);
              }
              target0Cache.blend = target0.blend;
            }
            if (target0Cache.blendEq !== target0.blendEq || target0Cache.blendAlphaEq !== target0.blendAlphaEq) {
              gl.blendEquationSeparate(WebGLBlendOps[target0.blendEq], WebGLBlendOps[target0.blendAlphaEq]);
              target0Cache.blendEq = target0.blendEq;
              target0Cache.blendAlphaEq = target0.blendAlphaEq;
            }
            if (target0Cache.blendSrc !== target0.blendSrc || target0Cache.blendDst !== target0.blendDst || target0Cache.blendSrcAlpha !== target0.blendSrcAlpha || target0Cache.blendDstAlpha !== target0.blendDstAlpha) {
              gl.blendFuncSeparate(WebGLBlendFactors[target0.blendSrc], WebGLBlendFactors[target0.blendDst], WebGLBlendFactors[target0.blendSrcAlpha], WebGLBlendFactors[target0.blendDstAlpha]);
              target0Cache.blendSrc = target0.blendSrc;
              target0Cache.blendDst = target0.blendDst;
              target0Cache.blendSrcAlpha = target0.blendSrcAlpha;
              target0Cache.blendDstAlpha = target0.blendDstAlpha;
            }
            if (target0Cache.blendColorMask !== target0.blendColorMask) {
              gl.colorMask((target0.blendColorMask & ColorMask.R) !== ColorMask.NONE, (target0.blendColorMask & ColorMask.G) !== ColorMask.NONE, (target0.blendColorMask & ColorMask.B) !== ColorMask.NONE, (target0.blendColorMask & ColorMask.A) !== ColorMask.NONE);
              target0Cache.blendColorMask = target0.blendColorMask;
            }
          }
        }
        if (gpuPipelineState && gpuPipelineState.gpuPipelineLayout && gpuShader) {
          const blockLen = gpuShader.glBlocks.length;
          const {
            dynamicOffsetIndices
          } = gpuPipelineState.gpuPipelineLayout;
          for (let j = 0; j < blockLen; j++) {
            const glBlock = gpuShader.glBlocks[j];
            const gpuDescriptorSet = gpuDescriptorSets[glBlock.set];
            const descriptorIndex = gpuDescriptorSet && gpuDescriptorSet.descriptorIndices[glBlock.binding];
            const gpuDescriptor = descriptorIndex >= 0 && gpuDescriptorSet.gpuDescriptors[descriptorIndex];
            if (!gpuDescriptor || !gpuDescriptor.gpuBuffer) {
              continue;
            }
            const dynamicOffsetIndexSet = dynamicOffsetIndices[glBlock.set];
            const dynamicOffsetIndex = dynamicOffsetIndexSet && dynamicOffsetIndexSet[glBlock.binding];
            let offset = gpuDescriptor.gpuBuffer.glOffset;
            if (dynamicOffsetIndex >= 0) {
              offset += dynamicOffsets[dynamicOffsetIndex];
            }
            if (cache.glBindUBOs[glBlock.glBinding] !== gpuDescriptor.gpuBuffer.glBuffer || cache.glBindUBOOffsets[glBlock.glBinding] !== offset) {
              if (offset) {
                gl.bindBufferRange(gl.UNIFORM_BUFFER, glBlock.glBinding, gpuDescriptor.gpuBuffer.glBuffer, offset, gpuDescriptor.gpuBuffer.size);
              } else {
                gl.bindBufferBase(gl.UNIFORM_BUFFER, glBlock.glBinding, gpuDescriptor.gpuBuffer.glBuffer);
              }
              cache.glUniformBuffer = cache.glBindUBOs[glBlock.glBinding] = gpuDescriptor.gpuBuffer.glBuffer;
              cache.glBindUBOOffsets[glBlock.glBinding] = offset;
            }
          }
          const samplerLen = gpuShader.glSamplerTextures.length;
          for (let i = 0; i < samplerLen; i++) {
            const glSampler = gpuShader.glSamplerTextures[i];
            const gpuDescriptorSet = gpuDescriptorSets[glSampler.set];
            let descriptorIndex = gpuDescriptorSet && gpuDescriptorSet.descriptorIndices[glSampler.binding];
            let gpuDescriptor = descriptorIndex >= 0 && gpuDescriptorSet.gpuDescriptors[descriptorIndex];
            for (let l = 0; l < glSampler.units.length; l++) {
              const texUnit = glSampler.units[l];
              const glTexUnit = cache.glTexUnits[texUnit];
              if (!gpuDescriptor || !gpuDescriptor.gpuTextureView || !gpuDescriptor.gpuTextureView.gpuTexture || !gpuDescriptor.gpuSampler) {
                continue;
              }
              const gpuTextureView = gpuDescriptor.gpuTextureView;
              const gpuTexture = gpuTextureView.gpuTexture;
              const minLod = gpuTextureView.baseLevel;
              const maxLod = minLod + gpuTextureView.levelCount;
              if (gpuTexture.size > 0) {
                if (glTexUnit.glTexture !== gpuTexture.glTexture) {
                  if (cache.texUnit !== texUnit) {
                    gl.activeTexture(gl.TEXTURE0 + texUnit);
                    cache.texUnit = texUnit;
                  }
                  if (gpuTexture.glTexture) {
                    gl.bindTexture(gpuTexture.glTarget, gpuTexture.glTexture);
                  } else {
                    gl.bindTexture(gpuTexture.glTarget, device.nullTex2D.gpuTexture.glTexture);
                  }
                  glTexUnit.glTexture = gpuTexture.glTexture;
                }
                const {
                  gpuSampler
                } = gpuDescriptor;
                const glSampler = gpuSampler.getGLSampler(device, minLod, maxLod);
                if (cache.glSamplerUnits[texUnit] !== glSampler) {
                  gl.bindSampler(texUnit, glSampler);
                  cache.glSamplerUnits[texUnit] = glSampler;
                }
              }
              gpuDescriptor = gpuDescriptorSet.gpuDescriptors[++descriptorIndex];
            }
          }
        }
        if (gpuInputAssembler && gpuShader && (isShaderChanged || gfxStateCache.gpuInputAssembler !== gpuInputAssembler)) {
          gfxStateCache.gpuInputAssembler = gpuInputAssembler;
          if (device.extensions.useVAO) {
            let glVAO = gpuInputAssembler.glVAOs.get(gpuShader.glProgram);
            if (!glVAO) {
              glVAO = gl.createVertexArray();
              gpuInputAssembler.glVAOs.set(gpuShader.glProgram, glVAO);
              gl.bindVertexArray(glVAO);
              gl.bindBuffer(gl.ARRAY_BUFFER, null);
              gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
              cache.glArrayBuffer = null;
              cache.glElementArrayBuffer = null;
              let glAttrib;
              for (let j = 0; j < gpuShader.glInputs.length; j++) {
                const glInput = gpuShader.glInputs[j];
                glAttrib = null;
                for (let k = 0; k < gpuInputAssembler.glAttribs.length; k++) {
                  const attrib = gpuInputAssembler.glAttribs[k];
                  if (attrib.name === glInput.name) {
                    glAttrib = attrib;
                    break;
                  }
                }
                if (glAttrib) {
                  if (cache.glArrayBuffer !== glAttrib.glBuffer) {
                    gl.bindBuffer(gl.ARRAY_BUFFER, glAttrib.glBuffer);
                    cache.glArrayBuffer = glAttrib.glBuffer;
                  }
                  for (let c = 0; c < glAttrib.componentCount; ++c) {
                    const glLoc = glInput.glLoc + c;
                    const attribOffset = glAttrib.offset + glAttrib.size * c;
                    gl.enableVertexAttribArray(glLoc);
                    cache.glCurrentAttribLocs[glLoc] = true;
                    gl.vertexAttribPointer(glLoc, glAttrib.count, glAttrib.glType, glAttrib.isNormalized, glAttrib.stride, attribOffset);
                    gl.vertexAttribDivisor(glLoc, glAttrib.isInstanced ? 1 : 0);
                  }
                }
              }
              const gpuBuffer = gpuInputAssembler.gpuIndexBuffer;
              if (gpuBuffer) {
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.glBuffer);
              }
              gl.bindVertexArray(null);
              gl.bindBuffer(gl.ARRAY_BUFFER, null);
              gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
              cache.glArrayBuffer = null;
              cache.glElementArrayBuffer = null;
            }
            if (cache.glVAO !== glVAO) {
              gl.bindVertexArray(glVAO);
              cache.glVAO = glVAO;
            }
          } else {
            for (let a = 0; a < device.capabilities.maxVertexAttributes; ++a) {
              cache.glCurrentAttribLocs[a] = false;
            }
            for (let j = 0; j < gpuShader.glInputs.length; j++) {
              const glInput = gpuShader.glInputs[j];
              let glAttrib = null;
              for (let k = 0; k < gpuInputAssembler.glAttribs.length; k++) {
                const attrib = gpuInputAssembler.glAttribs[k];
                if (attrib.name === glInput.name) {
                  glAttrib = attrib;
                  break;
                }
              }
              if (glAttrib) {
                if (cache.glArrayBuffer !== glAttrib.glBuffer) {
                  gl.bindBuffer(gl.ARRAY_BUFFER, glAttrib.glBuffer);
                  cache.glArrayBuffer = glAttrib.glBuffer;
                }
                for (let c = 0; c < glAttrib.componentCount; ++c) {
                  const glLoc = glInput.glLoc + c;
                  const attribOffset = glAttrib.offset + glAttrib.size * c;
                  if (!cache.glEnabledAttribLocs[glLoc] && glLoc >= 0) {
                    gl.enableVertexAttribArray(glLoc);
                    cache.glEnabledAttribLocs[glLoc] = true;
                  }
                  cache.glCurrentAttribLocs[glLoc] = true;
                  gl.vertexAttribPointer(glLoc, glAttrib.count, glAttrib.glType, glAttrib.isNormalized, glAttrib.stride, attribOffset);
                  gl.vertexAttribDivisor(glLoc, glAttrib.isInstanced ? 1 : 0);
                }
              }
            }
            const gpuBuffer = gpuInputAssembler.gpuIndexBuffer;
            if (gpuBuffer) {
              if (cache.glElementArrayBuffer !== gpuBuffer.glBuffer) {
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.glBuffer);
                cache.glElementArrayBuffer = gpuBuffer.glBuffer;
              }
            }
            for (let a = 0; a < device.capabilities.maxVertexAttributes; ++a) {
              if (cache.glEnabledAttribLocs[a] !== cache.glCurrentAttribLocs[a]) {
                gl.disableVertexAttribArray(a);
                cache.glEnabledAttribLocs[a] = false;
              }
            }
          }
        }
        if (gpuPipelineState && gpuPipelineState.dynamicStates.length) {
          const dsLen = gpuPipelineState.dynamicStates.length;
          for (let k = 0; k < dsLen; k++) {
            const dynamicState = gpuPipelineState.dynamicStates[k];
            switch (dynamicState) {
              case DynamicStateFlagBit.LINE_WIDTH:
                {
                  if (cache.rs.lineWidth !== dynamicStates.lineWidth) {
                    gl.lineWidth(dynamicStates.lineWidth);
                    cache.rs.lineWidth = dynamicStates.lineWidth;
                  }
                  break;
                }
              case DynamicStateFlagBit.DEPTH_BIAS:
                {
                  if (cache.rs.depthBias !== dynamicStates.depthBiasConstant || cache.rs.depthBiasSlop !== dynamicStates.depthBiasSlope) {
                    gl.polygonOffset(dynamicStates.depthBiasConstant, dynamicStates.depthBiasSlope);
                    cache.rs.depthBias = dynamicStates.depthBiasConstant;
                    cache.rs.depthBiasSlop = dynamicStates.depthBiasSlope;
                  }
                  break;
                }
              case DynamicStateFlagBit.BLEND_CONSTANTS:
                {
                  const blendConstant = dynamicStates.blendConstant;
                  if (cache.bs.blendColor.x !== blendConstant.x || cache.bs.blendColor.y !== blendConstant.y || cache.bs.blendColor.z !== blendConstant.z || cache.bs.blendColor.w !== blendConstant.w) {
                    gl.blendColor(blendConstant.x, blendConstant.y, blendConstant.z, blendConstant.w);
                    cache.bs.blendColor.copy(blendConstant);
                  }
                  break;
                }
              case DynamicStateFlagBit.STENCIL_WRITE_MASK:
                {
                  const front = dynamicStates.stencilStatesFront;
                  const back = dynamicStates.stencilStatesBack;
                  if (cache.dss.stencilWriteMaskFront !== front.writeMask) {
                    gl.stencilMaskSeparate(gl.FRONT, front.writeMask);
                    cache.dss.stencilWriteMaskFront = front.writeMask;
                  }
                  if (cache.dss.stencilWriteMaskBack !== back.writeMask) {
                    gl.stencilMaskSeparate(gl.BACK, back.writeMask);
                    cache.dss.stencilWriteMaskBack = back.writeMask;
                  }
                  break;
                }
              case DynamicStateFlagBit.STENCIL_COMPARE_MASK:
                {
                  const front = dynamicStates.stencilStatesFront;
                  const back = dynamicStates.stencilStatesBack;
                  if (cache.dss.stencilRefFront !== front.reference || cache.dss.stencilReadMaskFront !== front.compareMask) {
                    gl.stencilFuncSeparate(gl.FRONT, WebGLCmpFuncs[cache.dss.stencilFuncFront], front.reference, front.compareMask);
                    cache.dss.stencilRefFront = front.reference;
                    cache.dss.stencilReadMaskFront = front.compareMask;
                  }
                  if (cache.dss.stencilRefBack !== back.reference || cache.dss.stencilReadMaskBack !== back.compareMask) {
                    gl.stencilFuncSeparate(gl.BACK, WebGLCmpFuncs[cache.dss.stencilFuncBack], back.reference, back.compareMask);
                    cache.dss.stencilRefBack = back.reference;
                    cache.dss.stencilReadMaskBack = back.compareMask;
                  }
                  break;
                }
            }
          }
        }
      }
      function WebGL2CmdFuncDraw(device, drawInfo) {
        const {
          gl
        } = device;
        const {
          gpuInputAssembler,
          glPrimitive
        } = gfxStateCache;
        const md = device.extensions.WEBGL_multi_draw;
        if (gpuInputAssembler) {
          const indexBuffer = gpuInputAssembler.gpuIndexBuffer;
          if (gpuInputAssembler.gpuIndirectBuffer) {
            const {
              indirects
            } = gpuInputAssembler.gpuIndirectBuffer;
            if (indirects.drawByIndex) {
              for (let j = 0; j < indirects.drawCount; j++) {
                indirects.byteOffsets[j] = indirects.offsets[j] * indexBuffer.stride;
              }
              if (md) {
                if (indirects.instancedDraw) {
                  md.multiDrawElementsInstancedWEBGL(glPrimitive, indirects.counts, 0, gpuInputAssembler.glIndexType, indirects.byteOffsets, 0, indirects.instances, 0, indirects.drawCount);
                } else {
                  md.multiDrawElementsWEBGL(glPrimitive, indirects.counts, 0, gpuInputAssembler.glIndexType, indirects.byteOffsets, 0, indirects.drawCount);
                }
              } else {
                for (let j = 0; j < indirects.drawCount; j++) {
                  if (indirects.instances[j]) {
                    gl.drawElementsInstanced(glPrimitive, indirects.counts[j], gpuInputAssembler.glIndexType, indirects.byteOffsets[j], indirects.instances[j]);
                  } else {
                    gl.drawElements(glPrimitive, indirects.counts[j], gpuInputAssembler.glIndexType, indirects.byteOffsets[j]);
                  }
                }
              }
            } else if (md) {
              if (indirects.instancedDraw) {
                md.multiDrawArraysInstancedWEBGL(glPrimitive, indirects.offsets, 0, indirects.counts, 0, indirects.instances, 0, indirects.drawCount);
              } else {
                md.multiDrawArraysWEBGL(glPrimitive, indirects.offsets, 0, indirects.counts, 0, indirects.drawCount);
              }
            } else {
              for (let j = 0; j < indirects.drawCount; j++) {
                if (indirects.instances[j]) {
                  gl.drawArraysInstanced(glPrimitive, indirects.offsets[j], indirects.counts[j], indirects.instances[j]);
                } else {
                  gl.drawArrays(glPrimitive, indirects.offsets[j], indirects.counts[j]);
                }
              }
            }
          } else if (drawInfo.instanceCount) {
            if (indexBuffer) {
              if (drawInfo.indexCount > 0) {
                const offset = drawInfo.firstIndex * indexBuffer.stride;
                gl.drawElementsInstanced(glPrimitive, drawInfo.indexCount, gpuInputAssembler.glIndexType, offset, drawInfo.instanceCount);
              }
            } else if (drawInfo.vertexCount > 0) {
              gl.drawArraysInstanced(glPrimitive, drawInfo.firstVertex, drawInfo.vertexCount, drawInfo.instanceCount);
            }
          } else if (indexBuffer) {
            if (drawInfo.indexCount > 0) {
              const offset = drawInfo.firstIndex * indexBuffer.stride;
              gl.drawElements(glPrimitive, drawInfo.indexCount, gpuInputAssembler.glIndexType, offset);
            }
          } else if (drawInfo.vertexCount > 0) {
            gl.drawArrays(glPrimitive, drawInfo.firstVertex, drawInfo.vertexCount);
          }
        }
      }
      const cmdIds = new Array(WebGL2Cmd.COUNT);
      function WebGL2CmdFuncExecuteCmds(device, cmdPackage) {
        cmdIds.fill(0);
        for (let i = 0; i < cmdPackage.cmds.length; ++i) {
          const cmd = cmdPackage.cmds.array[i];
          const cmdId = cmdIds[cmd]++;
          switch (cmd) {
            case WebGL2Cmd.BEGIN_RENDER_PASS:
              {
                const cmd0 = cmdPackage.beginRenderPassCmds.array[cmdId];
                WebGL2CmdFuncBeginRenderPass(device, cmd0.gpuRenderPass, cmd0.gpuFramebuffer, cmd0.renderArea, cmd0.clearColors, cmd0.clearDepth, cmd0.clearStencil);
                break;
              }
            case WebGL2Cmd.BIND_STATES:
              {
                const cmd2 = cmdPackage.bindStatesCmds.array[cmdId];
                WebGL2CmdFuncBindStates(device, cmd2.gpuPipelineState, cmd2.gpuInputAssembler, cmd2.gpuDescriptorSets, cmd2.dynamicOffsets, cmd2.dynamicStates);
                break;
              }
            case WebGL2Cmd.DRAW:
              {
                const cmd3 = cmdPackage.drawCmds.array[cmdId];
                WebGL2CmdFuncDraw(device, cmd3.drawInfo);
                break;
              }
            case WebGL2Cmd.UPDATE_BUFFER:
              {
                const cmd4 = cmdPackage.updateBufferCmds.array[cmdId];
                WebGL2CmdFuncUpdateBuffer(device, cmd4.gpuBuffer, cmd4.buffer, cmd4.offset, cmd4.size);
                break;
              }
            case WebGL2Cmd.COPY_BUFFER_TO_TEXTURE:
              {
                const cmd5 = cmdPackage.copyBufferToTextureCmds.array[cmdId];
                WebGL2CmdFuncCopyBuffersToTexture(device, cmd5.buffers, cmd5.gpuTexture, cmd5.regions);
                break;
              }
            case WebGL2Cmd.BLIT_TEXTURE:
              {
                const cmd6 = cmdPackage.blitTextureCmds.array[cmdId];
                WebGL2CmdFuncBlitTexture(device, cmd6.srcTexture, cmd6.dstTexture, cmd6.regions, cmd6.filter);
                break;
              }
          }
        }
      }
      function toUseTexImage2D(texImages, regions) {
        if (texImages.length > 1 || regions.length > 1) return false;
        const isVideoElement = texImages[0] instanceof HTMLVideoElement;
        if (isVideoElement) {
          const videoElement = texImages[0];
          const isSameSize = regions[0].texOffset.x === 0 && regions[0].texOffset.y === 0 && regions[0].texExtent.width === videoElement.videoWidth && regions[0].texExtent.height === videoElement.videoHeight;
          return isSameSize;
        }
        return false;
      }
      function WebGL2CmdFuncCopyTexImagesToTexture(device, texImages, gpuTexture, regions) {
        const {
          gl
        } = device;
        const glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];
        if (glTexUnit.glTexture !== gpuTexture.glTexture) {
          gl.bindTexture(gpuTexture.glTarget, gpuTexture.glTexture);
          glTexUnit.glTexture = gpuTexture.glTexture;
        }
        let n = 0;
        let f = 0;
        switch (gpuTexture.glTarget) {
          case gl.TEXTURE_2D:
            {
              if (toUseTexImage2D(texImages, regions)) {
                gl.texImage2D(gl.TEXTURE_2D, regions[0].texSubres.mipLevel, gpuTexture.glInternalFmt, regions[0].texExtent.width, regions[0].texExtent.height, 0, gpuTexture.glFormat, gpuTexture.glType, texImages[0]);
              } else {
                for (let k = 0; k < regions.length; k++) {
                  const region = regions[k];
                  gl.texSubImage2D(gl.TEXTURE_2D, region.texSubres.mipLevel, region.texOffset.x, region.texOffset.y, gpuTexture.glFormat, gpuTexture.glType, texImages[n++]);
                }
              }
              break;
            }
          case gl.TEXTURE_CUBE_MAP:
            {
              for (let k = 0; k < regions.length; k++) {
                const region = regions[k];
                const fcount = region.texSubres.baseArrayLayer + region.texSubres.layerCount;
                for (f = region.texSubres.baseArrayLayer; f < fcount; ++f) {
                  gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, region.texSubres.mipLevel, region.texOffset.x, region.texOffset.y, gpuTexture.glFormat, gpuTexture.glType, texImages[n++]);
                }
              }
              break;
            }
          default:
            {
              error('Unsupported GL texture type, copy buffer to texture failed.');
            }
        }
        if (gpuTexture.flags & TextureFlagBit.GEN_MIPMAP) {
          gl.generateMipmap(gpuTexture.glTarget);
        }
      }
      let stagingBuffer = new Uint8Array(1);
      function pixelBufferPick(buffer, format, offset, stride, extent) {
        const blockHeight = formatAlignment(format).height;
        const bufferSize = FormatSize(format, extent.width, extent.height, extent.depth);
        const rowStrideSize = FormatSize(format, stride.width, 1, 1);
        const sliceStrideSize = FormatSize(format, stride.width, stride.height, 1);
        const destRowSize = FormatSize(format, extent.width, 1, 1);
        const ArrayBufferCtor = getTypedArrayConstructor(FormatInfos[format]);
        if (stagingBuffer.byteLength < bufferSize) {
          stagingBuffer = new Uint8Array(bufferSize);
        }
        let destOffset = 0;
        let bufferOffset = offset;
        for (let i = 0; i < extent.depth; i++) {
          bufferOffset = offset + sliceStrideSize * i;
          for (let j = 0; j < extent.height; j += blockHeight) {
            stagingBuffer.subarray(destOffset, destOffset + destRowSize).set(new Uint8Array(buffer.buffer, buffer.byteOffset + bufferOffset, destRowSize));
            destOffset += destRowSize;
            bufferOffset += rowStrideSize;
          }
        }
        const length = bufferSize / ArrayBufferCtor.BYTES_PER_ELEMENT;
        assertID(Number.isInteger(length), 9101);
        return new ArrayBufferCtor(stagingBuffer.buffer, 0, length);
      }
      function WebGL2CmdFuncCopyBuffersToTexture(device, buffers, gpuTexture, regions) {
        const {
          gl
        } = device;
        const glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];
        if (glTexUnit.glTexture !== gpuTexture.glTexture) {
          gl.bindTexture(gpuTexture.glTarget, gpuTexture.glTexture);
          glTexUnit.glTexture = gpuTexture.glTexture;
        }
        let n = 0;
        let f = 0;
        const fmtInfo = FormatInfos[gpuTexture.format];
        const ArrayBufferCtor = getTypedArrayConstructor(fmtInfo);
        const {
          isCompressed
        } = fmtInfo;
        const blockSize = formatAlignment(gpuTexture.format);
        const extent = new Extent();
        const offset = new Offset();
        const stride = new Extent();
        switch (gpuTexture.glTarget) {
          case gl.TEXTURE_2D:
            {
              for (let k = 0; k < regions.length; k++) {
                const region = regions[k];
                const mipLevel = region.texSubres.mipLevel;
                offset.x = region.texOffset.x === 0 ? 0 : alignTo(region.texOffset.x, blockSize.width);
                offset.y = region.texOffset.y === 0 ? 0 : alignTo(region.texOffset.y, blockSize.height);
                extent.width = region.texExtent.width < blockSize.width ? region.texExtent.width : alignTo(region.texExtent.width, blockSize.width);
                extent.height = region.texExtent.height < blockSize.height ? region.texExtent.width : alignTo(region.texExtent.height, blockSize.height);
                stride.width = region.buffStride > 0 ? region.buffStride : extent.width;
                stride.height = region.buffTexHeight > 0 ? region.buffTexHeight : extent.height;
                const destWidth = region.texExtent.width + offset.x === gpuTexture.width >> mipLevel ? region.texExtent.width : extent.width;
                const destHeight = region.texExtent.height + offset.y === gpuTexture.height >> mipLevel ? region.texExtent.height : extent.height;
                let pixels;
                const buffer = buffers[n++];
                if (stride.width === extent.width && stride.height === extent.height) {
                  const length = FormatSize(gpuTexture.format, destWidth, destHeight, 1) / ArrayBufferCtor.BYTES_PER_ELEMENT;
                  assertID(Number.isInteger(length), 9101);
                  pixels = new ArrayBufferCtor(buffer.buffer, buffer.byteOffset + region.buffOffset, length);
                } else {
                  pixels = pixelBufferPick(buffer, gpuTexture.format, region.buffOffset, stride, extent);
                }
                if (!isCompressed) {
                  gl.texSubImage2D(gl.TEXTURE_2D, mipLevel, offset.x, offset.y, destWidth, destHeight, gpuTexture.glFormat, gpuTexture.glType, pixels);
                } else if (gpuTexture.glInternalFmt !== WebGL2EXT.COMPRESSED_RGB_ETC1_WEBGL) {
                  gl.compressedTexSubImage2D(gl.TEXTURE_2D, mipLevel, offset.x, offset.y, destWidth, destHeight, gpuTexture.glFormat, pixels);
                } else {
                  gl.compressedTexImage2D(gl.TEXTURE_2D, mipLevel, gpuTexture.glInternalFmt, destWidth, destHeight, 0, pixels);
                }
              }
              break;
            }
          case gl.TEXTURE_2D_ARRAY:
            {
              for (let k = 0; k < regions.length; k++) {
                const region = regions[k];
                const mipLevel = region.texSubres.mipLevel;
                offset.x = region.texOffset.x === 0 ? 0 : alignTo(region.texOffset.x, blockSize.width);
                offset.y = region.texOffset.y === 0 ? 0 : alignTo(region.texOffset.y, blockSize.height);
                extent.width = region.texExtent.width < blockSize.width ? region.texExtent.width : alignTo(region.texExtent.width, blockSize.width);
                extent.height = region.texExtent.height < blockSize.height ? region.texExtent.width : alignTo(region.texExtent.height, blockSize.height);
                extent.depth = 1;
                stride.width = region.buffStride > 0 ? region.buffStride : extent.width;
                stride.height = region.buffTexHeight > 0 ? region.buffTexHeight : extent.height;
                const destWidth = region.texExtent.width + offset.x === gpuTexture.width >> mipLevel ? region.texExtent.width : extent.width;
                const destHeight = region.texExtent.height + offset.y === gpuTexture.height >> mipLevel ? region.texExtent.height : extent.height;
                const fcount = region.texSubres.baseArrayLayer + region.texSubres.layerCount;
                for (f = region.texSubres.baseArrayLayer; f < fcount; ++f) {
                  offset.z = f;
                  let pixels;
                  const buffer = buffers[n++];
                  if (stride.width === extent.width && stride.height === extent.height) {
                    const length = FormatSize(gpuTexture.format, destWidth, destHeight, 1) / ArrayBufferCtor.BYTES_PER_ELEMENT;
                    assertID(Number.isInteger(length), 9101);
                    pixels = new ArrayBufferCtor(buffer.buffer, buffer.byteOffset + region.buffOffset, length);
                  } else {
                    pixels = pixelBufferPick(buffer, gpuTexture.format, region.buffOffset, stride, extent);
                  }
                  if (!isCompressed) {
                    gl.texSubImage3D(gl.TEXTURE_2D_ARRAY, mipLevel, offset.x, offset.y, offset.z, destWidth, destHeight, extent.depth, gpuTexture.glFormat, gpuTexture.glType, pixels);
                  } else if (gpuTexture.glInternalFmt !== WebGL2EXT.COMPRESSED_RGB_ETC1_WEBGL) {
                    gl.compressedTexSubImage3D(gl.TEXTURE_2D_ARRAY, mipLevel, offset.x, offset.y, offset.z, destWidth, destHeight, extent.depth, gpuTexture.glFormat, pixels);
                  } else {
                    gl.compressedTexImage3D(gl.TEXTURE_2D_ARRAY, mipLevel, gpuTexture.glInternalFmt, destWidth, destHeight, extent.depth, 0, pixels);
                  }
                }
              }
              break;
            }
          case gl.TEXTURE_3D:
            {
              for (let k = 0; k < regions.length; k++) {
                const region = regions[k];
                const mipLevel = region.texSubres.mipLevel;
                offset.x = region.texOffset.x === 0 ? 0 : alignTo(region.texOffset.x, blockSize.width);
                offset.y = region.texOffset.y === 0 ? 0 : alignTo(region.texOffset.y, blockSize.height);
                offset.z = region.texOffset.z;
                extent.width = region.texExtent.width < blockSize.width ? region.texExtent.width : alignTo(region.texExtent.width, blockSize.width);
                extent.height = region.texExtent.height < blockSize.height ? region.texExtent.width : alignTo(region.texExtent.height, blockSize.height);
                extent.depth = region.texExtent.depth;
                stride.width = region.buffStride > 0 ? region.buffStride : extent.width;
                stride.height = region.buffTexHeight > 0 ? region.buffTexHeight : extent.height;
                const destWidth = region.texExtent.width + offset.x === gpuTexture.width >> mipLevel ? region.texExtent.width : extent.width;
                const destHeight = region.texExtent.height + offset.y === gpuTexture.height >> mipLevel ? region.texExtent.height : extent.height;
                let pixels;
                const buffer = buffers[n++];
                if (stride.width === extent.width && stride.height === extent.height) {
                  const length = FormatSize(gpuTexture.format, destWidth, destHeight, extent.depth) / ArrayBufferCtor.BYTES_PER_ELEMENT;
                  assertID(Number.isInteger(length), 9101);
                  pixels = new ArrayBufferCtor(buffer.buffer, buffer.byteOffset + region.buffOffset, length);
                } else {
                  pixels = pixelBufferPick(buffer, gpuTexture.format, region.buffOffset, stride, extent);
                }
                if (!isCompressed) {
                  gl.texSubImage3D(gl.TEXTURE_2D_ARRAY, mipLevel, offset.x, offset.y, offset.z, destWidth, destHeight, extent.depth, gpuTexture.glFormat, gpuTexture.glType, pixels);
                } else if (gpuTexture.glInternalFmt !== WebGL2EXT.COMPRESSED_RGB_ETC1_WEBGL) {
                  gl.compressedTexSubImage3D(gl.TEXTURE_2D_ARRAY, mipLevel, offset.x, offset.y, offset.z, destWidth, destHeight, extent.depth, gpuTexture.glFormat, pixels);
                } else {
                  gl.compressedTexImage3D(gl.TEXTURE_2D_ARRAY, mipLevel, gpuTexture.glInternalFmt, destWidth, destHeight, extent.depth, 0, pixels);
                }
              }
              break;
            }
          case gl.TEXTURE_CUBE_MAP:
            {
              for (let k = 0; k < regions.length; k++) {
                const region = regions[k];
                const mipLevel = region.texSubres.mipLevel;
                offset.x = region.texOffset.x === 0 ? 0 : alignTo(region.texOffset.x, blockSize.width);
                offset.y = region.texOffset.y === 0 ? 0 : alignTo(region.texOffset.y, blockSize.height);
                extent.width = region.texExtent.width < blockSize.width ? region.texExtent.width : alignTo(region.texExtent.width, blockSize.width);
                extent.height = region.texExtent.height < blockSize.height ? region.texExtent.width : alignTo(region.texExtent.height, blockSize.height);
                stride.width = region.buffStride > 0 ? region.buffStride : extent.width;
                stride.height = region.buffTexHeight > 0 ? region.buffTexHeight : extent.height;
                const destWidth = region.texExtent.width + offset.x === gpuTexture.width >> mipLevel ? region.texExtent.width : extent.width;
                const destHeight = region.texExtent.height + offset.y === gpuTexture.height >> mipLevel ? region.texExtent.height : extent.height;
                const fcount = region.texSubres.baseArrayLayer + region.texSubres.layerCount;
                for (f = region.texSubres.baseArrayLayer; f < fcount; ++f) {
                  let pixels;
                  const buffer = buffers[n++];
                  if (stride.width === extent.width && stride.height === extent.height) {
                    const length = FormatSize(gpuTexture.format, destWidth, destHeight, 1) / ArrayBufferCtor.BYTES_PER_ELEMENT;
                    assertID(Number.isInteger(length), 9101);
                    pixels = new ArrayBufferCtor(buffer.buffer, buffer.byteOffset + region.buffOffset, length);
                  } else {
                    pixels = pixelBufferPick(buffer, gpuTexture.format, region.buffOffset, stride, extent);
                  }
                  if (!isCompressed) {
                    gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, mipLevel, offset.x, offset.y, destWidth, destHeight, gpuTexture.glFormat, gpuTexture.glType, pixels);
                  } else if (gpuTexture.glInternalFmt !== WebGL2EXT.COMPRESSED_RGB_ETC1_WEBGL) {
                    gl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, mipLevel, offset.x, offset.y, destWidth, destHeight, gpuTexture.glFormat, pixels);
                  } else {
                    gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, mipLevel, gpuTexture.glInternalFmt, destWidth, destHeight, 0, pixels);
                  }
                }
              }
              break;
            }
          default:
            {
              error('Unsupported GL texture type, copy buffer to texture failed.');
            }
        }
        if (gpuTexture.flags & TextureFlagBit.GEN_MIPMAP) {
          gl.generateMipmap(gpuTexture.glTarget);
        }
      }
      function WebGL2CmdFuncCopyTextureToBuffers(device, gpuTexture, buffers, regions) {
        const {
          gl
        } = device;
        const cache = device.stateCache;
        const framebuffer = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
        let x = 0;
        let y = 0;
        let w = 1;
        let h = 1;
        switch (gpuTexture.glTarget) {
          case gl.TEXTURE_2D:
            {
              for (let k = 0; k < regions.length; k++) {
                const region = regions[k];
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gpuTexture.glTarget, gpuTexture.glTexture, region.texSubres.mipLevel);
                x = region.texOffset.x;
                y = region.texOffset.y;
                w = region.texExtent.width;
                h = region.texExtent.height;
                gl.readPixels(x, y, w, h, gpuTexture.glFormat, gpuTexture.glType, buffers[k]);
              }
              break;
            }
          default:
            {
              error('Unsupported GL texture type, copy texture to buffers failed.');
            }
        }
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        cache.glFramebuffer = null;
        gl.deleteFramebuffer(framebuffer);
      }
      function WebGL2CmdFuncBlitTexture(device, src, dst, regions, filter) {
        const {
          gl
        } = device;
        const cache = device.stateCache;
        const blitManager = device.blitManager;
        if (!blitManager) {
          return;
        }
        const glFilter = filter === Filter$1.LINEAR || filter === Filter$1.ANISOTROPIC ? gl.LINEAR : gl.NEAREST;
        const srcFramebuffer = blitManager.srcFramebuffer;
        const dstFramebuffer = blitManager.dstFramebuffer;
        const origReadFBO = cache.glReadFramebuffer;
        const origDrawFBO = cache.glFramebuffer;
        let srcMip = regions[0].srcSubres.mipLevel;
        let dstMip = regions[0].dstSubres.mipLevel;
        const blitInfo = formatInfo => {
          let mask = 0;
          let attachment = gl.COLOR_ATTACHMENT0;
          if (formatInfo.hasStencil) {
            attachment = gl.DEPTH_STENCIL_ATTACHMENT;
          } else if (formatInfo.hasDepth) {
            attachment = gl.DEPTH_ATTACHMENT;
          }
          if (formatInfo.hasDepth || formatInfo.hasStencil) {
            if (formatInfo.hasDepth) {
              mask |= gl.DEPTH_BUFFER_BIT;
            }
            if (formatInfo.hasStencil) {
              mask |= gl.STENCIL_BUFFER_BIT;
            }
          } else {
            mask |= gl.COLOR_BUFFER_BIT;
          }
          return {
            mask,
            attachment
          };
        };
        const regionIndices = regions.map((_, i) => i);
        regionIndices.sort((a, b) => regions[a].srcSubres.mipLevel - regions[b].srcSubres.mipLevel);
        const {
          mask: srcMask,
          attachment: srcAttachment
        } = blitInfo(FormatInfos[src.format]);
        const {
          mask: dstMask,
          attachment: dstAttachment
        } = blitInfo(FormatInfos[dst.format]);
        if (cache.glReadFramebuffer !== srcFramebuffer) {
          gl.bindFramebuffer(gl.READ_FRAMEBUFFER, srcFramebuffer);
          cache.glReadFramebuffer = srcFramebuffer;
        }
        if (cache.glFramebuffer !== dstFramebuffer) {
          gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, dstFramebuffer);
          cache.glFramebuffer = dstFramebuffer;
        }
        if (src.glTexture) {
          gl.framebufferTexture2D(gl.READ_FRAMEBUFFER, srcAttachment, src.glTarget, src.glTexture, srcMip);
        } else {
          gl.framebufferRenderbuffer(gl.READ_FRAMEBUFFER, srcAttachment, gl.RENDERBUFFER, src.glRenderbuffer);
        }
        if (dst.glTexture) {
          gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER, dstAttachment, dst.glTarget, dst.glTexture, dstMip);
        } else {
          gl.framebufferRenderbuffer(gl.DRAW_FRAMEBUFFER, dstAttachment, gl.RENDERBUFFER, dst.glRenderbuffer);
        }
        for (let i = 0; i < regionIndices.length; i++) {
          const region = regions[regionIndices[i]];
          if (src.glTexture && srcMip !== region.srcSubres.mipLevel) {
            srcMip = region.srcSubres.mipLevel;
            gl.framebufferTexture2D(gl.READ_FRAMEBUFFER, srcAttachment, src.glTarget, src.glTexture, srcMip);
          }
          if (dst.glTexture && dstMip !== region.dstSubres.mipLevel) {
            dstMip = region.dstSubres.mipLevel;
            gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER, dstAttachment, dst.glTarget, dst.glTexture, dstMip);
          }
          gl.blitFramebuffer(region.srcOffset.x, region.srcOffset.y, region.srcOffset.x + region.srcExtent.width, region.srcOffset.y + region.srcExtent.height, region.dstOffset.x, region.dstOffset.y, region.dstOffset.x + region.dstExtent.width, region.dstOffset.y + region.dstExtent.height, srcMask, glFilter);
        }
        if (cache.glReadFramebuffer !== origReadFBO) {
          gl.bindFramebuffer(gl.READ_FRAMEBUFFER, origReadFBO);
          cache.glReadFramebuffer = origReadFBO;
        }
        if (cache.glFramebuffer !== origDrawFBO) {
          gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, origDrawFBO);
          cache.glFramebuffer = origDrawFBO;
        }
      }

      class WebGL2IndirectDrawInfos {
        constructor() {
          this.counts = void 0;
          this.offsets = void 0;
          this.instances = void 0;
          this.drawCount = 0;
          this.drawByIndex = false;
          this.instancedDraw = false;
          this.byteOffsets = void 0;
          this._capacity = 4;
          this.counts = new Int32Array(this._capacity);
          this.offsets = new Int32Array(this._capacity);
          this.instances = new Int32Array(this._capacity);
          this.byteOffsets = new Int32Array(this._capacity);
        }
        clearDraws() {
          this.drawCount = 0;
          this.drawByIndex = false;
          this.instancedDraw = false;
        }
        setDrawInfo(idx, info) {
          this._ensureCapacity(idx);
          this.drawByIndex = info.indexCount > 0;
          this.instancedDraw = !!info.instanceCount;
          this.drawCount = Math.max(idx + 1, this.drawCount);
          if (this.drawByIndex) {
            this.counts[idx] = info.indexCount;
            this.offsets[idx] = info.firstIndex;
          } else {
            this.counts[idx] = info.vertexCount;
            this.offsets[idx] = info.firstVertex;
          }
          this.instances[idx] = Math.max(1, info.instanceCount);
        }
        _ensureCapacity(target) {
          if (this._capacity > target) return;
          this._capacity = nextPow2(target);
          const counts = new Int32Array(this._capacity);
          const offsets = new Int32Array(this._capacity);
          const instances = new Int32Array(this._capacity);
          this.byteOffsets = new Int32Array(this._capacity);
          counts.set(this.counts);
          offsets.set(this.offsets);
          instances.set(this.instances);
          this.counts = counts;
          this.offsets = offsets;
          this.instances = instances;
        }
      }
      class IWebGL2BlitManager {
        get srcFramebuffer() {
          return this._srcFramebuffer;
        }
        get dstFramebuffer() {
          return this._dstFramebuffer;
        }
        constructor() {
          this._srcFramebuffer = void 0;
          this._dstFramebuffer = void 0;
          const {
            gl
          } = WebGL2DeviceManager.instance;
          this._srcFramebuffer = gl.createFramebuffer();
          this._dstFramebuffer = gl.createFramebuffer();
        }
        destroy() {
          const {
            gl
          } = WebGL2DeviceManager.instance;
          gl.deleteFramebuffer(this._srcFramebuffer);
          gl.deleteFramebuffer(this._dstFramebuffer);
        }
      }

      class WebGL2Buffer extends Buffer {
        constructor(...args) {
          super(...args);
          this._gpuBuffer = null;
        }
        get gpuBuffer() {
          return this._gpuBuffer;
        }
        initialize(info) {
          if ('buffer' in info) {
            this._isBufferView = true;
            const buffer = info.buffer;
            this._usage = buffer.usage;
            this._memUsage = buffer.memUsage;
            this._size = this._stride = info.range;
            this._count = 1;
            this._flags = buffer.flags;
            this._gpuBuffer = {
              usage: this._usage,
              memUsage: this._memUsage,
              size: this._size,
              stride: this._stride,
              buffer: null,
              indirects: buffer.gpuBuffer.indirects,
              glTarget: buffer.gpuBuffer.glTarget,
              glBuffer: buffer.gpuBuffer.glBuffer,
              glOffset: info.offset
            };
          } else {
            this._usage = info.usage;
            this._memUsage = info.memUsage;
            this._size = info.size;
            this._stride = Math.max(info.stride || this._size, 1);
            this._count = this._size / this._stride;
            this._flags = info.flags;
            this._gpuBuffer = {
              usage: this._usage,
              memUsage: this._memUsage,
              size: this._size,
              stride: this._stride,
              buffer: null,
              indirects: new WebGL2IndirectDrawInfos(),
              glTarget: 0,
              glBuffer: null,
              glOffset: 0
            };
            WebGL2CmdFuncCreateBuffer(WebGL2DeviceManager.instance, this._gpuBuffer);
            WebGL2DeviceManager.instance.memoryStatus.bufferSize += this._size;
          }
        }
        destroy() {
          if (this._gpuBuffer) {
            if (!this._isBufferView) {
              WebGL2CmdFuncDestroyBuffer(WebGL2DeviceManager.instance, this._gpuBuffer);
              WebGL2DeviceManager.instance.memoryStatus.bufferSize -= this._size;
            }
            this._gpuBuffer = null;
          }
        }
        resize(size) {
          if (this._isBufferView) {
            console.warn('cannot resize buffer views!');
            return;
          }
          const oldSize = this._size;
          if (oldSize === size) {
            return;
          }
          this._size = size;
          this._count = this._size / this._stride;
          if (this._gpuBuffer) {
            this._gpuBuffer.size = size;
            if (size > 0) {
              WebGL2CmdFuncResizeBuffer(WebGL2DeviceManager.instance, this._gpuBuffer);
              WebGL2DeviceManager.instance.memoryStatus.bufferSize -= oldSize;
              WebGL2DeviceManager.instance.memoryStatus.bufferSize += size;
            }
          }
        }
        update(buffer, size) {
          if (this._isBufferView) {
            console.warn('cannot update through buffer views!');
            return;
          }
          let buffSize;
          if (size !== undefined) {
            buffSize = size;
          } else if (this._usage & BufferUsageBit.INDIRECT) {
            buffSize = 0;
          } else {
            buffSize = buffer.byteLength;
          }
          WebGL2CmdFuncUpdateBuffer(WebGL2DeviceManager.instance, this._gpuBuffer, buffer, 0, buffSize);
        }
      }

      class WebGL2CommandPool {
        constructor(Clazz, count) {
          this._frees = void 0;
          this._freeIdx = 0;
          this._freeCmds = void 0;
          this._frees = new Array(count);
          this._freeCmds = new CachedArray(count);
          for (let i = 0; i < count; ++i) {
            this._frees[i] = new Clazz();
          }
          this._freeIdx = count - 1;
        }
        alloc(Clazz) {
          if (this._freeIdx < 0) {
            const size = this._frees.length * 2;
            const temp = this._frees;
            this._frees = new Array(size);
            const increase = size - temp.length;
            for (let i = 0; i < increase; ++i) {
              this._frees[i] = new Clazz();
            }
            for (let i = increase, j = 0; i < size; ++i, ++j) {
              this._frees[i] = temp[j];
            }
            this._freeIdx += increase;
          }
          const cmd = this._frees[this._freeIdx];
          this._frees[this._freeIdx--] = null;
          ++cmd.refCount;
          return cmd;
        }
        free(cmd) {
          if (--cmd.refCount === 0) {
            this._freeCmds.push(cmd);
          }
        }
        freeCmds(cmds) {
          for (let i = 0; i < cmds.length; ++i) {
            if (--cmds.array[i].refCount === 0) {
              this._freeCmds.push(cmds.array[i]);
            }
          }
        }
        release() {
          for (let i = 0; i < this._freeCmds.length; ++i) {
            const cmd = this._freeCmds.array[i];
            cmd.clear();
            this._frees[++this._freeIdx] = cmd;
          }
          this._freeCmds.clear();
        }
      }
      class WebGL2CommandAllocator {
        constructor() {
          this.beginRenderPassCmdPool = void 0;
          this.bindStatesCmdPool = void 0;
          this.drawCmdPool = void 0;
          this.updateBufferCmdPool = void 0;
          this.copyBufferToTextureCmdPool = void 0;
          this.blitTextureCmdPool = void 0;
          this.beginRenderPassCmdPool = new WebGL2CommandPool(WebGL2CmdBeginRenderPass, 1);
          this.bindStatesCmdPool = new WebGL2CommandPool(WebGL2CmdBindStates, 1);
          this.drawCmdPool = new WebGL2CommandPool(WebGL2CmdDraw, 1);
          this.updateBufferCmdPool = new WebGL2CommandPool(WebGL2CmdUpdateBuffer, 1);
          this.copyBufferToTextureCmdPool = new WebGL2CommandPool(WebGL2CmdCopyBufferToTexture, 1);
          this.blitTextureCmdPool = new WebGL2CommandPool(WebGL2CmdBlitTexture, 1);
        }
        clearCmds(cmdPackage) {
          if (cmdPackage.beginRenderPassCmds.length) {
            this.beginRenderPassCmdPool.freeCmds(cmdPackage.beginRenderPassCmds);
            cmdPackage.beginRenderPassCmds.clear();
          }
          if (cmdPackage.bindStatesCmds.length) {
            this.bindStatesCmdPool.freeCmds(cmdPackage.bindStatesCmds);
            cmdPackage.bindStatesCmds.clear();
          }
          if (cmdPackage.drawCmds.length) {
            this.drawCmdPool.freeCmds(cmdPackage.drawCmds);
            cmdPackage.drawCmds.clear();
          }
          if (cmdPackage.updateBufferCmds.length) {
            this.updateBufferCmdPool.freeCmds(cmdPackage.updateBufferCmds);
            cmdPackage.updateBufferCmds.clear();
          }
          if (cmdPackage.copyBufferToTextureCmds.length) {
            this.copyBufferToTextureCmdPool.freeCmds(cmdPackage.copyBufferToTextureCmds);
            cmdPackage.copyBufferToTextureCmds.clear();
          }
          if (cmdPackage.blitTextureCmds.length) {
            this.blitTextureCmdPool.freeCmds(cmdPackage.blitTextureCmds);
            cmdPackage.blitTextureCmds.clear();
          }
          cmdPackage.cmds.clear();
        }
        releaseCmds() {
          this.beginRenderPassCmdPool.release();
          this.bindStatesCmdPool.release();
          this.drawCmdPool.release();
          this.updateBufferCmdPool.release();
          this.copyBufferToTextureCmdPool.release();
          this.blitTextureCmdPool.release();
        }
      }

      class WebGL2CommandBuffer extends CommandBuffer {
        constructor(...args) {
          super(...args);
          this.cmdPackage = new WebGL2CmdPackage();
          this._cmdAllocator = new WebGL2CommandAllocator();
          this._isInRenderPass = false;
          this._curGPUPipelineState = null;
          this._curGPUDescriptorSets = [];
          this._curGPUInputAssembler = null;
          this._curDynamicOffsets = Array(8).fill(0);
          this._curDynamicStates = new DynamicStates();
          this._isStateInvalied = false;
        }
        initialize(info) {
          this._type = info.type;
          this._queue = info.queue;
          const setCount = WebGL2DeviceManager.instance.bindingMappings.blockOffsets.length;
          for (let i = 0; i < setCount; i++) {
            this._curGPUDescriptorSets.push(null);
          }
        }
        destroy() {
          this._cmdAllocator.clearCmds(this.cmdPackage);
        }
        begin(renderPass, subpass = 0, frameBuffer) {
          this._cmdAllocator.clearCmds(this.cmdPackage);
          this._curGPUPipelineState = null;
          this._curGPUInputAssembler = null;
          this._curGPUDescriptorSets.length = 0;
          this._numDrawCalls = 0;
          this._numInstances = 0;
          this._numTris = 0;
        }
        end() {
          if (this._isStateInvalied) {
            this.bindStates();
          }
          this._isInRenderPass = false;
        }
        beginRenderPass(renderPass, framebuffer, renderArea, clearColors, clearDepth, clearStencil) {
          const cmd = this._cmdAllocator.beginRenderPassCmdPool.alloc(WebGL2CmdBeginRenderPass);
          cmd.gpuRenderPass = renderPass.gpuRenderPass;
          cmd.gpuFramebuffer = framebuffer.gpuFramebuffer;
          cmd.renderArea.copy(renderArea);
          for (let i = 0; i < clearColors.length; ++i) {
            cmd.clearColors[i] = clearColors[i];
          }
          cmd.clearDepth = clearDepth;
          cmd.clearStencil = clearStencil;
          this.cmdPackage.beginRenderPassCmds.push(cmd);
          this.cmdPackage.cmds.push(WebGL2Cmd.BEGIN_RENDER_PASS);
          this._isInRenderPass = true;
        }
        endRenderPass() {
          this._isInRenderPass = false;
        }
        bindPipelineState(pipelineState) {
          const gpuPipelineState = pipelineState.gpuPipelineState;
          if (gpuPipelineState !== this._curGPUPipelineState) {
            this._curGPUPipelineState = gpuPipelineState;
            this._isStateInvalied = true;
          }
        }
        bindDescriptorSet(set, descriptorSet, dynamicOffsets) {
          const gpuDescriptorSets = descriptorSet.gpuDescriptorSet;
          if (gpuDescriptorSets !== this._curGPUDescriptorSets[set]) {
            this._curGPUDescriptorSets[set] = gpuDescriptorSets;
            this._isStateInvalied = true;
          }
          if (dynamicOffsets) {
            var _this$_curGPUPipeline;
            const gpuPipelineLayout = (_this$_curGPUPipeline = this._curGPUPipelineState) === null || _this$_curGPUPipeline === void 0 ? void 0 : _this$_curGPUPipeline.gpuPipelineLayout;
            if (gpuPipelineLayout) {
              const offsets = this._curDynamicOffsets;
              const idx = gpuPipelineLayout.dynamicOffsetOffsets[set];
              for (let i = 0; i < dynamicOffsets.length; i++) offsets[idx + i] = dynamicOffsets[i];
              this._isStateInvalied = true;
            }
          }
        }
        bindInputAssembler(inputAssembler) {
          const gpuInputAssembler = inputAssembler.gpuInputAssembler;
          this._curGPUInputAssembler = gpuInputAssembler;
          this._isStateInvalied = true;
        }
        setViewport(viewport) {
          const cache = this._curDynamicStates.viewport;
          if (cache.left !== viewport.left || cache.top !== viewport.top || cache.width !== viewport.width || cache.height !== viewport.height || cache.minDepth !== viewport.minDepth || cache.maxDepth !== viewport.maxDepth) {
            cache.left = viewport.left;
            cache.top = viewport.top;
            cache.width = viewport.width;
            cache.height = viewport.height;
            cache.minDepth = viewport.minDepth;
            cache.maxDepth = viewport.maxDepth;
            this._isStateInvalied = true;
          }
        }
        setScissor(scissor) {
          const cache = this._curDynamicStates.scissor;
          if (cache.x !== scissor.x || cache.y !== scissor.y || cache.width !== scissor.width || cache.height !== scissor.height) {
            cache.x = scissor.x;
            cache.y = scissor.y;
            cache.width = scissor.width;
            cache.height = scissor.height;
            this._isStateInvalied = true;
          }
        }
        setLineWidth(lineWidth) {
          if (this._curDynamicStates.lineWidth !== lineWidth) {
            this._curDynamicStates.lineWidth = lineWidth;
            this._isStateInvalied = true;
          }
        }
        setDepthBias(depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor) {
          const cache = this._curDynamicStates;
          if (cache.depthBiasConstant !== depthBiasConstantFactor || cache.depthBiasClamp !== depthBiasClamp || cache.depthBiasSlope !== depthBiasSlopeFactor) {
            cache.depthBiasConstant = depthBiasConstantFactor;
            cache.depthBiasClamp = depthBiasClamp;
            cache.depthBiasSlope = depthBiasSlopeFactor;
            this._isStateInvalied = true;
          }
        }
        setBlendConstants(blendConstants) {
          const cache = this._curDynamicStates.blendConstant;
          if (cache.x !== blendConstants.x || cache.y !== blendConstants.y || cache.z !== blendConstants.z || cache.w !== blendConstants.w) {
            cache.copy(blendConstants);
            this._isStateInvalied = true;
          }
        }
        setDepthBound(minDepthBounds, maxDepthBounds) {
          const cache = this._curDynamicStates;
          if (cache.depthMinBounds !== minDepthBounds || cache.depthMaxBounds !== maxDepthBounds) {
            cache.depthMinBounds = minDepthBounds;
            cache.depthMaxBounds = maxDepthBounds;
            this._isStateInvalied = true;
          }
        }
        setStencilWriteMask(face, writeMask) {
          const front = this._curDynamicStates.stencilStatesFront;
          const back = this._curDynamicStates.stencilStatesBack;
          if (face & StencilFace.FRONT) {
            if (front.writeMask !== writeMask) {
              front.writeMask = writeMask;
              this._isStateInvalied = true;
            }
          }
          if (face & StencilFace.BACK) {
            if (back.writeMask !== writeMask) {
              back.writeMask = writeMask;
              this._isStateInvalied = true;
            }
          }
        }
        setStencilCompareMask(face, reference, compareMask) {
          const front = this._curDynamicStates.stencilStatesFront;
          const back = this._curDynamicStates.stencilStatesBack;
          if (face & StencilFace.FRONT) {
            if (front.compareMask !== compareMask || front.reference !== reference) {
              front.reference = reference;
              front.compareMask = compareMask;
              this._isStateInvalied = true;
            }
          }
          if (face & StencilFace.BACK) {
            if (back.compareMask !== compareMask || back.reference !== reference) {
              back.reference = reference;
              back.compareMask = compareMask;
              this._isStateInvalied = true;
            }
          }
        }
        draw(infoOrAssembler) {
          if (this._type === CommandBufferType.PRIMARY && this._isInRenderPass || this._type === CommandBufferType.SECONDARY) {
            if (this._isStateInvalied) {
              this.bindStates();
            }
            const info = 'drawInfo' in infoOrAssembler ? infoOrAssembler.drawInfo : infoOrAssembler;
            const cmd = this._cmdAllocator.drawCmdPool.alloc(WebGL2CmdDraw);
            cmd.drawInfo.copy(info);
            this.cmdPackage.drawCmds.push(cmd);
            this.cmdPackage.cmds.push(WebGL2Cmd.DRAW);
            ++this._numDrawCalls;
            this._numInstances += info.instanceCount;
            const indexCount = info.indexCount || info.vertexCount;
            if (this._curGPUPipelineState) {
              const glPrimitive = this._curGPUPipelineState.glPrimitive;
              switch (glPrimitive) {
                case 0x0004:
                  {
                    this._numTris += indexCount / 3 * Math.max(info.instanceCount, 1);
                    break;
                  }
                case 0x0005:
                case 0x0006:
                  {
                    this._numTris += (indexCount - 2) * Math.max(info.instanceCount, 1);
                    break;
                  }
              }
            }
          } else {
            console.error('Command \'draw\' must be recorded inside a render pass.');
          }
        }
        updateBuffer(buffer, data, size) {
          if (this._type === CommandBufferType.PRIMARY && !this._isInRenderPass || this._type === CommandBufferType.SECONDARY) {
            const gpuBuffer = buffer.gpuBuffer;
            if (gpuBuffer) {
              const cmd = this._cmdAllocator.updateBufferCmdPool.alloc(WebGL2CmdUpdateBuffer);
              let buffSize = 0;
              let buff = null;
              if (buffer.usage & BufferUsageBit.INDIRECT) {
                buff = data;
              } else {
                if (size !== undefined) {
                  buffSize = size;
                } else {
                  buffSize = data.byteLength;
                }
                buff = data;
              }
              cmd.gpuBuffer = gpuBuffer;
              cmd.buffer = buff;
              cmd.offset = 0;
              cmd.size = buffSize;
              this.cmdPackage.updateBufferCmds.push(cmd);
              this.cmdPackage.cmds.push(WebGL2Cmd.UPDATE_BUFFER);
            }
          } else {
            console.error('Command \'updateBuffer\' must be recorded outside a render pass.');
          }
        }
        copyBuffersToTexture(buffers, texture, regions) {
          if (this._type === CommandBufferType.PRIMARY && !this._isInRenderPass || this._type === CommandBufferType.SECONDARY) {
            const gpuTexture = texture.gpuTexture;
            if (gpuTexture) {
              const cmd = this._cmdAllocator.copyBufferToTextureCmdPool.alloc(WebGL2CmdCopyBufferToTexture);
              cmd.gpuTexture = gpuTexture;
              cmd.regions = regions;
              cmd.buffers = buffers;
              this.cmdPackage.copyBufferToTextureCmds.push(cmd);
              this.cmdPackage.cmds.push(WebGL2Cmd.COPY_BUFFER_TO_TEXTURE);
            }
          } else {
            console.error('Command \'copyBufferToTexture\' must be recorded outside a render pass.');
          }
        }
        execute(cmdBuffs, count) {
          for (let i = 0; i < count; ++i) {
            const webGL2CmdBuff = cmdBuffs[i];
            for (let c = 0; c < webGL2CmdBuff.cmdPackage.beginRenderPassCmds.length; ++c) {
              const cmd = webGL2CmdBuff.cmdPackage.beginRenderPassCmds.array[c];
              ++cmd.refCount;
              this.cmdPackage.beginRenderPassCmds.push(cmd);
            }
            for (let c = 0; c < webGL2CmdBuff.cmdPackage.bindStatesCmds.length; ++c) {
              const cmd = webGL2CmdBuff.cmdPackage.bindStatesCmds.array[c];
              ++cmd.refCount;
              this.cmdPackage.bindStatesCmds.push(cmd);
            }
            for (let c = 0; c < webGL2CmdBuff.cmdPackage.drawCmds.length; ++c) {
              const cmd = webGL2CmdBuff.cmdPackage.drawCmds.array[c];
              ++cmd.refCount;
              this.cmdPackage.drawCmds.push(cmd);
            }
            for (let c = 0; c < webGL2CmdBuff.cmdPackage.updateBufferCmds.length; ++c) {
              const cmd = webGL2CmdBuff.cmdPackage.updateBufferCmds.array[c];
              ++cmd.refCount;
              this.cmdPackage.updateBufferCmds.push(cmd);
            }
            for (let c = 0; c < webGL2CmdBuff.cmdPackage.copyBufferToTextureCmds.length; ++c) {
              const cmd = webGL2CmdBuff.cmdPackage.copyBufferToTextureCmds.array[c];
              ++cmd.refCount;
              this.cmdPackage.copyBufferToTextureCmds.push(cmd);
            }
            for (let c = 0; c < webGL2CmdBuff.cmdPackage.blitTextureCmds.length; ++c) {
              const cmd = webGL2CmdBuff.cmdPackage.blitTextureCmds.array[c];
              ++cmd.refCount;
              this.cmdPackage.blitTextureCmds.push(cmd);
            }
            this.cmdPackage.cmds.concat(webGL2CmdBuff.cmdPackage.cmds.array);
            this._numDrawCalls += webGL2CmdBuff._numDrawCalls;
            this._numInstances += webGL2CmdBuff._numInstances;
            this._numTris += webGL2CmdBuff._numTris;
          }
        }
        pipelineBarrier(GeneralBarrier, bufferBarriers, buffers, textureBarriers, textures) {}
        bindStates() {
          const bindStatesCmd = this._cmdAllocator.bindStatesCmdPool.alloc(WebGL2CmdBindStates);
          bindStatesCmd.gpuPipelineState = this._curGPUPipelineState;
          Array.prototype.push.apply(bindStatesCmd.gpuDescriptorSets, this._curGPUDescriptorSets);
          Array.prototype.push.apply(bindStatesCmd.dynamicOffsets, this._curDynamicOffsets);
          bindStatesCmd.gpuInputAssembler = this._curGPUInputAssembler;
          bindStatesCmd.dynamicStates = this._curDynamicStates;
          this.cmdPackage.bindStatesCmds.push(bindStatesCmd);
          this.cmdPackage.cmds.push(WebGL2Cmd.BIND_STATES);
          this._isStateInvalied = false;
        }
        blitTexture(srcTexture, dstTexture, regions, filter) {
          const blitTextureCmd = this._cmdAllocator.blitTextureCmdPool.alloc(WebGL2CmdBlitTexture);
          blitTextureCmd.srcTexture = srcTexture.gpuTexture;
          blitTextureCmd.dstTexture = dstTexture.gpuTexture;
          blitTextureCmd.regions = regions;
          blitTextureCmd.filter = filter;
          ++this._numDrawCalls;
          this.cmdPackage.blitTextureCmds.push(blitTextureCmd);
          this.cmdPackage.cmds.push(WebGL2Cmd.BLIT_TEXTURE);
        }
      }

      class WebGL2Framebuffer extends Framebuffer {
        constructor(...args) {
          super(...args);
          this._gpuFramebuffer = null;
        }
        get gpuFramebuffer() {
          return this._gpuFramebuffer;
        }
        initialize(info) {
          this._renderPass = info.renderPass;
          this._colorTextures = info.colorTextures || [];
          this._depthStencilTexture = info.depthStencilTexture || null;
          const gpuColorViews = [];
          for (let i = 0; i < info.colorTextures.length; i++) {
            const colorTexture = info.colorTextures[i];
            if (colorTexture) {
              gpuColorViews.push(colorTexture.gpuTextureView);
            }
          }
          let gpuDepthStencilView = null;
          if (info.depthStencilTexture) {
            gpuDepthStencilView = info.depthStencilTexture.gpuTextureView;
          }
          let width = Number.MAX_SAFE_INTEGER;
          let height = Number.MAX_SAFE_INTEGER;
          this._gpuFramebuffer = {
            gpuRenderPass: info.renderPass.gpuRenderPass,
            gpuColorViews,
            gpuDepthStencilView,
            glFramebuffer: null,
            isOffscreen: true,
            get width() {
              if (this.isOffscreen) {
                return width;
              } else if (this.gpuColorViews.length > 0) {
                return this.gpuColorViews[0].gpuTexture.width;
              } else {
                return this.gpuDepthStencilView.gpuTexture.width;
              }
            },
            set width(val) {
              width = val;
            },
            get height() {
              if (this.isOffscreen) {
                return height;
              } else if (this.gpuColorViews.length > 0) {
                return this.gpuColorViews[0].gpuTexture.height;
              } else {
                return this.gpuDepthStencilView.gpuTexture.height;
              }
            },
            set height(val) {
              height = val;
            }
          };
          WebGL2CmdFuncCreateFramebuffer(WebGL2DeviceManager.instance, this._gpuFramebuffer);
          this._width = this._gpuFramebuffer.width;
          this._height = this._gpuFramebuffer.height;
        }
        destroy() {
          if (this._gpuFramebuffer) {
            WebGL2CmdFuncDestroyFramebuffer(WebGL2DeviceManager.instance, this._gpuFramebuffer);
            this._gpuFramebuffer = null;
          }
        }
      }

      class WebGL2InputAssembler extends InputAssembler {
        constructor(...args) {
          super(...args);
          this._gpuInputAssembler = null;
        }
        get gpuInputAssembler() {
          return this._gpuInputAssembler;
        }
        initialize(info) {
          if (info.vertexBuffers.length === 0) {
            console.error('InputAssemblerInfo.vertexBuffers is null.');
            return;
          }
          this._attributes = info.attributes;
          this._attributesHash = this.computeAttributesHash();
          this._vertexBuffers = info.vertexBuffers;
          if (info.indexBuffer) {
            this._indexBuffer = info.indexBuffer;
            this._drawInfo.indexCount = this._indexBuffer.size / this._indexBuffer.stride;
            this._drawInfo.firstIndex = 0;
          } else {
            const vertBuff = this._vertexBuffers[0];
            this._drawInfo.vertexCount = vertBuff.size / vertBuff.stride;
            this._drawInfo.firstVertex = 0;
            this._drawInfo.vertexOffset = 0;
          }
          this._drawInfo.instanceCount = 0;
          this._drawInfo.firstInstance = 0;
          this._indirectBuffer = info.indirectBuffer || null;
          const gpuVertexBuffers = new Array(info.vertexBuffers.length);
          for (let i = 0; i < info.vertexBuffers.length; ++i) {
            const vb = info.vertexBuffers[i];
            if (vb.gpuBuffer) {
              gpuVertexBuffers[i] = vb.gpuBuffer;
            }
          }
          let gpuIndexBuffer = null;
          let glIndexType = 0;
          if (info.indexBuffer) {
            gpuIndexBuffer = info.indexBuffer.gpuBuffer;
            if (gpuIndexBuffer) {
              switch (gpuIndexBuffer.stride) {
                case 1:
                  glIndexType = 0x1401;
                  break;
                case 2:
                  glIndexType = 0x1403;
                  break;
                case 4:
                  glIndexType = 0x1405;
                  break;
                default:
                  {
                    console.error('Illegal index buffer stride.');
                  }
              }
            }
          }
          let gpuIndirectBuffer = null;
          if (info.indirectBuffer) {
            gpuIndirectBuffer = info.indirectBuffer.gpuBuffer;
          }
          this._gpuInputAssembler = {
            attributes: info.attributes,
            gpuVertexBuffers,
            gpuIndexBuffer,
            gpuIndirectBuffer,
            glAttribs: [],
            glIndexType,
            glVAOs: new Map()
          };
          WebGL2CmdFuncCreateInputAssember(WebGL2DeviceManager.instance, this._gpuInputAssembler);
        }
        destroy() {
          const device = WebGL2DeviceManager.instance;
          if (this._gpuInputAssembler && device.extensions.useVAO) {
            WebGL2CmdFuncDestroyInputAssembler(device, this._gpuInputAssembler);
          }
          this._gpuInputAssembler = null;
        }
      }

      class WebGL2DescriptorSetLayout extends DescriptorSetLayout {
        constructor(...args) {
          super(...args);
          this._gpuDescriptorSetLayout = null;
        }
        get gpuDescriptorSetLayout() {
          return this._gpuDescriptorSetLayout;
        }
        initialize(info) {
          Array.prototype.push.apply(this._bindings, info.bindings);
          let descriptorCount = 0;
          let maxBinding = -1;
          const flattenedIndices = [];
          for (let i = 0; i < this._bindings.length; i++) {
            const binding = this._bindings[i];
            flattenedIndices.push(descriptorCount);
            descriptorCount += binding.count;
            if (binding.binding > maxBinding) maxBinding = binding.binding;
          }
          this._bindingIndices = Array(maxBinding + 1).fill(-1);
          const descriptorIndices = this._descriptorIndices = Array(maxBinding + 1).fill(-1);
          for (let i = 0; i < this._bindings.length; i++) {
            const binding = this._bindings[i];
            this._bindingIndices[binding.binding] = i;
            descriptorIndices[binding.binding] = flattenedIndices[i];
          }
          const dynamicBindings = [];
          for (let i = 0; i < this._bindings.length; i++) {
            const binding = this._bindings[i];
            if (binding.descriptorType & DESCRIPTOR_DYNAMIC_TYPE) {
              for (let j = 0; j < binding.count; j++) {
                dynamicBindings.push(binding.binding);
              }
            }
          }
          this._gpuDescriptorSetLayout = {
            bindings: this._bindings,
            dynamicBindings,
            descriptorIndices,
            descriptorCount
          };
        }
        destroy() {
          this._bindings.length = 0;
        }
      }

      class WebGL2PipelineLayout extends PipelineLayout {
        constructor(...args) {
          super(...args);
          this._gpuPipelineLayout = null;
        }
        get gpuPipelineLayout() {
          return this._gpuPipelineLayout;
        }
        initialize(info) {
          Array.prototype.push.apply(this._setLayouts, info.setLayouts);
          const dynamicOffsetIndices = [];
          const gpuSetLayouts = [];
          let dynamicOffsetCount = 0;
          const dynamicOffsetOffsets = [];
          for (let i = 0; i < this._setLayouts.length; i++) {
            const setLayout = this._setLayouts[i];
            const dynamicBindings = setLayout.gpuDescriptorSetLayout.dynamicBindings;
            const indices = Array(setLayout.bindingIndices.length).fill(-1);
            for (let j = 0; j < dynamicBindings.length; j++) {
              const binding = dynamicBindings[j];
              if (indices[binding] < 0) indices[binding] = dynamicOffsetCount + j;
            }
            gpuSetLayouts.push(setLayout.gpuDescriptorSetLayout);
            dynamicOffsetIndices.push(indices);
            dynamicOffsetOffsets.push(dynamicOffsetCount);
            dynamicOffsetCount += dynamicBindings.length;
          }
          this._gpuPipelineLayout = {
            gpuSetLayouts,
            dynamicOffsetIndices,
            dynamicOffsetCount,
            dynamicOffsetOffsets
          };
        }
        destroy() {
          this._setLayouts.length = 0;
        }
      }

      const WebGLPrimitives = [0x0000, 0x0001, 0x0003, 0x0002, 0x0000, 0x0000, 0x0000, 0x0004, 0x0005, 0x0006, 0x0000, 0x0000, 0x0000, 0x0000];
      class WebGL2PipelineState extends PipelineState {
        constructor(...args) {
          super(...args);
          this._gpuPipelineState = null;
        }
        get gpuPipelineState() {
          return this._gpuPipelineState;
        }
        initialize(info) {
          this._primitive = info.primitive;
          this._shader = info.shader;
          this._pipelineLayout = info.pipelineLayout;
          const bs = this._bs;
          if (info.blendState) {
            const bsInfo = info.blendState;
            const {
              targets
            } = bsInfo;
            if (targets) {
              targets.forEach((t, i) => {
                bs.setTarget(i, t);
              });
            }
            if (bsInfo.isA2C !== undefined) {
              bs.isA2C = bsInfo.isA2C;
            }
            if (bsInfo.isIndepend !== undefined) {
              bs.isIndepend = bsInfo.isIndepend;
            }
            if (bsInfo.blendColor !== undefined) {
              bs.blendColor = bsInfo.blendColor;
            }
          }
          Object.assign(this._rs, info.rasterizerState);
          Object.assign(this._dss, info.depthStencilState);
          this._is = info.inputState;
          this._renderPass = info.renderPass;
          this._dynamicStates = info.dynamicStates;
          const dynamicStates = [];
          for (let i = 0; i < 31; i++) {
            if (this._dynamicStates & 1 << i) {
              dynamicStates.push(1 << i);
            }
          }
          this._gpuPipelineState = {
            glPrimitive: WebGLPrimitives[info.primitive],
            gpuShader: info.shader.gpuShader,
            gpuPipelineLayout: info.pipelineLayout.gpuPipelineLayout,
            rs: info.rasterizerState,
            dss: info.depthStencilState,
            bs: info.blendState,
            gpuRenderPass: info.renderPass.gpuRenderPass,
            dynamicStates
          };
        }
        destroy() {
          this._gpuPipelineState = null;
        }
      }

      class WebGL2PrimaryCommandBuffer extends WebGL2CommandBuffer {
        beginRenderPass(renderPass, framebuffer, renderArea, clearColors, clearDepth, clearStencil) {
          WebGL2CmdFuncBeginRenderPass(WebGL2DeviceManager.instance, renderPass.gpuRenderPass, framebuffer.gpuFramebuffer, renderArea, clearColors, clearDepth, clearStencil);
          this._isInRenderPass = true;
        }
        draw(infoOrAssembler) {
          if (this._isInRenderPass) {
            if (this._isStateInvalied) {
              this.bindStates();
            }
            const info = 'drawInfo' in infoOrAssembler ? infoOrAssembler.drawInfo : infoOrAssembler;
            WebGL2CmdFuncDraw(WebGL2DeviceManager.instance, info);
            ++this._numDrawCalls;
            this._numInstances += info.instanceCount;
            const indexCount = info.indexCount || info.vertexCount;
            if (this._curGPUPipelineState) {
              const glPrimitive = this._curGPUPipelineState.glPrimitive;
              switch (glPrimitive) {
                case 0x0004:
                  {
                    this._numTris += indexCount / 3 * Math.max(info.instanceCount, 1);
                    break;
                  }
                case 0x0005:
                case 0x0006:
                  {
                    this._numTris += (indexCount - 2) * Math.max(info.instanceCount, 1);
                    break;
                  }
              }
            }
          } else {
            console.error('Command \'draw\' must be recorded inside a render pass.');
          }
        }
        setViewport(viewport) {
          const {
            stateCache: cache,
            gl
          } = WebGL2DeviceManager.instance;
          if (cache.viewport.left !== viewport.left || cache.viewport.top !== viewport.top || cache.viewport.width !== viewport.width || cache.viewport.height !== viewport.height) {
            gl.viewport(viewport.left, viewport.top, viewport.width, viewport.height);
            cache.viewport.left = viewport.left;
            cache.viewport.top = viewport.top;
            cache.viewport.width = viewport.width;
            cache.viewport.height = viewport.height;
          }
        }
        setScissor(scissor) {
          const {
            stateCache: cache,
            gl
          } = WebGL2DeviceManager.instance;
          if (cache.scissorRect.x !== scissor.x || cache.scissorRect.y !== scissor.y || cache.scissorRect.width !== scissor.width || cache.scissorRect.height !== scissor.height) {
            gl.scissor(scissor.x, scissor.y, scissor.width, scissor.height);
            cache.scissorRect.x = scissor.x;
            cache.scissorRect.y = scissor.y;
            cache.scissorRect.width = scissor.width;
            cache.scissorRect.height = scissor.height;
          }
        }
        updateBuffer(buffer, data, size) {
          if (!this._isInRenderPass) {
            const gpuBuffer = buffer.gpuBuffer;
            if (gpuBuffer) {
              let buffSize;
              if (size !== undefined) {
                buffSize = size;
              } else if (buffer.usage & BufferUsageBit.INDIRECT) {
                buffSize = 0;
              } else {
                buffSize = data.byteLength;
              }
              WebGL2CmdFuncUpdateBuffer(WebGL2DeviceManager.instance, gpuBuffer, data, 0, buffSize);
            }
          } else {
            console.error('Command \'updateBuffer\' must be recorded outside a render pass.');
          }
        }
        copyBuffersToTexture(buffers, texture, regions) {
          if (!this._isInRenderPass) {
            const gpuTexture = texture.gpuTexture;
            if (gpuTexture) {
              WebGL2CmdFuncCopyBuffersToTexture(WebGL2DeviceManager.instance, buffers, gpuTexture, regions);
            }
          } else {
            console.error('Command \'copyBufferToTexture\' must be recorded outside a render pass.');
          }
        }
        execute(cmdBuffs, count) {
          for (let i = 0; i < count; ++i) {
            const webGL2CmdBuff = cmdBuffs[i];
            WebGL2CmdFuncExecuteCmds(WebGL2DeviceManager.instance, webGL2CmdBuff.cmdPackage);
            this._numDrawCalls += webGL2CmdBuff._numDrawCalls;
            this._numInstances += webGL2CmdBuff._numInstances;
            this._numTris += webGL2CmdBuff._numTris;
          }
        }
        bindStates() {
          WebGL2CmdFuncBindStates(WebGL2DeviceManager.instance, this._curGPUPipelineState, this._curGPUInputAssembler, this._curGPUDescriptorSets, this._curDynamicOffsets, this._curDynamicStates);
          this._isStateInvalied = false;
        }
        blitTexture(srcTexture, dstTexture, regions, filter) {
          const gpuTextureSrc = srcTexture.gpuTexture;
          const gpuTextureDst = dstTexture.gpuTexture;
          WebGL2CmdFuncBlitTexture(WebGL2DeviceManager.instance, gpuTextureSrc, gpuTextureDst, regions, filter);
        }
      }

      class WebGL2Queue extends Queue {
        constructor(...args) {
          super(...args);
          this.numDrawCalls = 0;
          this.numInstances = 0;
          this.numTris = 0;
        }
        initialize(info) {
          this._type = info.type;
        }
        destroy() {}
        submit(cmdBuffs) {
          for (let i = 0; i < cmdBuffs.length; i++) {
            const cmdBuff = cmdBuffs[i];
            this.numDrawCalls += cmdBuff.numDrawCalls;
            this.numInstances += cmdBuff.numInstances;
            this.numTris += cmdBuff.numTris;
          }
        }
        clear() {
          this.numDrawCalls = 0;
          this.numInstances = 0;
          this.numTris = 0;
        }
      }

      class WebGL2RenderPass extends RenderPass {
        constructor(...args) {
          super(...args);
          this._gpuRenderPass = null;
        }
        get gpuRenderPass() {
          return this._gpuRenderPass;
        }
        initialize(info) {
          this._colorInfos = info.colorAttachments;
          this._depthStencilInfo = info.depthStencilAttachment;
          this._subpasses = info.subpasses;
          this._gpuRenderPass = {
            colorAttachments: this._colorInfos,
            depthStencilAttachment: this._depthStencilInfo
          };
          this._hash = this.computeHash();
        }
        destroy() {
          this._gpuRenderPass = null;
        }
      }

      class WebGL2Sampler extends Sampler {
        get gpuSampler() {
          return this._gpuSampler;
        }
        constructor(info, hash) {
          super(info, hash);
          this._gpuSampler = null;
          this._gpuSampler = {
            glSamplers: new Map(),
            minFilter: this._info.minFilter,
            magFilter: this._info.magFilter,
            mipFilter: this._info.mipFilter,
            addressU: this._info.addressU,
            addressV: this._info.addressV,
            addressW: this._info.addressW,
            glMinFilter: 0,
            glMagFilter: 0,
            glWrapS: 0,
            glWrapT: 0,
            glWrapR: 0,
            getGLSampler(device, minLod, maxLod) {
              const {
                gl
              } = device;
              const samplerHash = minLod << 16 | maxLod;
              if (!this.glSamplers.has(samplerHash)) {
                const glSampler = gl.createSampler();
                if (glSampler) {
                  this.glSamplers.set(samplerHash, glSampler);
                  gl.samplerParameteri(glSampler, gl.TEXTURE_MIN_FILTER, this.glMinFilter);
                  gl.samplerParameteri(glSampler, gl.TEXTURE_MAG_FILTER, this.glMagFilter);
                  gl.samplerParameteri(glSampler, gl.TEXTURE_WRAP_S, this.glWrapS);
                  gl.samplerParameteri(glSampler, gl.TEXTURE_WRAP_T, this.glWrapT);
                  gl.samplerParameteri(glSampler, gl.TEXTURE_WRAP_R, this.glWrapR);
                  gl.samplerParameterf(glSampler, gl.TEXTURE_MIN_LOD, minLod);
                  gl.samplerParameterf(glSampler, gl.TEXTURE_MAX_LOD, maxLod);
                }
              }
              const sampler = this.glSamplers.get(samplerHash);
              return sampler;
            }
          };
          WebGL2CmdFuncPrepareSamplerInfo(WebGL2DeviceManager.instance, this._gpuSampler);
        }
        destroy() {
          if (this._gpuSampler) {
            WebGL2CmdFuncDestroySampler(WebGL2DeviceManager.instance, this._gpuSampler);
            this._gpuSampler = null;
          }
        }
      }

      class WebGL2Shader extends Shader {
        constructor(...args) {
          super(...args);
          this._gpuShader = null;
        }
        get gpuShader() {
          if (this._gpuShader.glProgram === null) {
            WebGL2CmdFuncCreateShader(WebGL2DeviceManager.instance, this._gpuShader);
          }
          return this._gpuShader;
        }
        initialize(info) {
          this._name = info.name;
          this._stages = info.stages;
          this._attributes = info.attributes;
          this._blocks = info.blocks;
          this._samplers = info.samplers;
          this._gpuShader = {
            name: info.name,
            blocks: info.blocks.slice(),
            samplerTextures: info.samplerTextures.slice(),
            subpassInputs: info.subpassInputs.slice(),
            gpuStages: new Array(info.stages.length),
            glProgram: null,
            glInputs: [],
            glUniforms: [],
            glBlocks: [],
            glSamplerTextures: []
          };
          for (let i = 0; i < info.stages.length; ++i) {
            const stage = info.stages[i];
            this._gpuShader.gpuStages[i] = {
              type: stage.stage,
              source: stage.source,
              glShader: null
            };
          }
        }
        destroy() {
          if (this._gpuShader) {
            WebGL2CmdFuncDestroyShader(WebGL2DeviceManager.instance, this._gpuShader);
            this._gpuShader = null;
          }
        }
      }

      class WebGL2StateCache {
        constructor() {
          this.glArrayBuffer = null;
          this.glElementArrayBuffer = null;
          this.glUniformBuffer = null;
          this.glBindUBOs = [];
          this.glBindUBOOffsets = [];
          this.glVAO = null;
          this.texUnit = 0;
          this.glTexUnits = [];
          this.glSamplerUnits = [];
          this.glRenderbuffer = null;
          this.glFramebuffer = null;
          this.glReadFramebuffer = null;
          this.viewport = new Viewport();
          this.scissorRect = new Rect(0, 0, 0, 0);
          this.rs = new RasterizerState();
          this.dss = new DepthStencilState();
          this.bs = new BlendState();
          this.glProgram = null;
          this.glEnabledAttribLocs = [];
          this.glCurrentAttribLocs = [];
          this.texUnitCacheMap = {};
        }
        initialize(texUnit, bufferBindings, vertexAttributes) {
          for (let i = 0; i < texUnit; ++i) this.glTexUnits.push({
            glTexture: null
          });
          this.glSamplerUnits.length = texUnit;
          this.glSamplerUnits.fill(null);
          this.glBindUBOs.length = bufferBindings;
          this.glBindUBOs.fill(null);
          this.glBindUBOOffsets.length = bufferBindings;
          this.glBindUBOOffsets.fill(0);
          this.glEnabledAttribLocs.length = vertexAttributes;
          this.glEnabledAttribLocs.fill(false);
          this.glCurrentAttribLocs.length = vertexAttributes;
          this.glCurrentAttribLocs.fill(false);
        }
      }

      class WebGL2Texture extends Texture {
        constructor(...args) {
          super(...args);
          this._gpuTexture = null;
          this._gpuTextureView = null;
        }
        get gpuTexture() {
          return this._gpuTexture;
        }
        get gpuTextureView() {
          return this._gpuTextureView;
        }
        initialize(info, isSwapchainTexture) {
          let texInfo = info;
          const viewInfo = info;
          if ('texture' in info) {
            texInfo = viewInfo.texture.info;
            this._isTextureView = true;
          }
          this._info.copy(texInfo);
          this._isPowerOf2 = IsPowerOf2(this._info.width) && IsPowerOf2(this._info.height);
          this._size = FormatSurfaceSize(this._info.format, this.width, this.height, this.depth, this._info.levelCount) * this._info.layerCount;
          if (!this._isTextureView) {
            this._gpuTexture = {
              type: texInfo.type,
              format: texInfo.format,
              usage: texInfo.usage,
              width: texInfo.width,
              height: texInfo.height,
              depth: texInfo.depth,
              size: this._size,
              arrayLayer: texInfo.layerCount,
              mipLevel: texInfo.levelCount,
              samples: texInfo.samples,
              flags: texInfo.flags,
              isPowerOf2: this._isPowerOf2,
              glTarget: 0,
              glInternalFmt: 0,
              glFormat: 0,
              glType: 0,
              glUsage: 0,
              glTexture: null,
              glRenderbuffer: null,
              glWrapS: 0,
              glWrapT: 0,
              glMinFilter: 0,
              glMagFilter: 0,
              isSwapchainTexture: isSwapchainTexture || false
            };
            if (!this._gpuTexture.isSwapchainTexture && this._gpuTexture) {
              WebGL2CmdFuncCreateTexture(WebGL2DeviceManager.instance, this._gpuTexture);
              WebGL2DeviceManager.instance.memoryStatus.textureSize += this._size;
            }
            this._viewInfo.texture = this;
            this._viewInfo.type = info.type;
            this._viewInfo.format = info.format;
            this._viewInfo.baseLevel = 0;
            this._viewInfo.levelCount = info.levelCount;
            this._viewInfo.baseLayer = 0;
            this._viewInfo.layerCount = info.layerCount;
            this._gpuTextureView = {
              gpuTexture: this._gpuTexture,
              type: this._viewInfo.type,
              format: this._viewInfo.format,
              baseLevel: this._viewInfo.baseLevel,
              levelCount: this._viewInfo.levelCount
            };
          } else {
            var _this$_gpuTexture;
            this._viewInfo.copy(viewInfo);
            this._gpuTexture = viewInfo.texture._gpuTexture;
            if (((_this$_gpuTexture = this._gpuTexture) === null || _this$_gpuTexture === void 0 ? void 0 : _this$_gpuTexture.format) !== texInfo.format) {
              console.log('GPU memory alias is not supported');
              return;
            }
            this._gpuTextureView = {
              gpuTexture: this._gpuTexture,
              type: viewInfo.type,
              format: viewInfo.format,
              baseLevel: viewInfo.baseLevel,
              levelCount: viewInfo.levelCount
            };
          }
        }
        destroy() {
          if (!this._isTextureView && this._gpuTexture) {
            WebGL2CmdFuncDestroyTexture(WebGL2DeviceManager.instance, this._gpuTexture);
            WebGL2DeviceManager.instance.memoryStatus.textureSize -= this._size;
            this._gpuTexture = null;
          }
        }
        getGLTextureHandle() {
          const gpuTexture = this._gpuTexture;
          if (!gpuTexture) {
            return 0;
          }
          if (gpuTexture.glTexture) {
            return gpuTexture.glTexture;
          } else if (gpuTexture.glRenderbuffer) {
            return gpuTexture.glRenderbuffer;
          }
          return 0;
        }
        resize(width, height) {
          if (this._info.width === width && this._info.height === height) {
            return;
          }
          if (this._info.levelCount === WebGL2Texture.getLevelCount(this._info.width, this._info.height)) {
            this._info.levelCount = WebGL2Texture.getLevelCount(width, height);
          } else if (this._info.levelCount > 1) {
            this._info.levelCount = Math.min(this._info.levelCount, WebGL2Texture.getLevelCount(width, height));
          }
          const oldSize = this._size;
          this._info.width = width;
          this._info.height = height;
          this._size = FormatSurfaceSize(this._info.format, this.width, this.height, this.depth, this._info.levelCount) * this._info.layerCount;
          if (!this._isTextureView && this._gpuTexture) {
            this._gpuTexture.width = width;
            this._gpuTexture.height = height;
            this._gpuTexture.size = this._size;
            if (!this._gpuTexture.isSwapchainTexture) {
              WebGL2CmdFuncResizeTexture(WebGL2DeviceManager.instance, this._gpuTexture);
              WebGL2DeviceManager.instance.memoryStatus.textureSize -= oldSize;
              WebGL2DeviceManager.instance.memoryStatus.textureSize += this._size;
            }
          }
        }
        initAsSwapchainTexture(info) {
          const texInfo = new TextureInfo();
          texInfo.format = info.format;
          texInfo.usage = FormatInfos[info.format].hasDepth ? TextureUsageBit.DEPTH_STENCIL_ATTACHMENT : TextureUsageBit.COLOR_ATTACHMENT;
          texInfo.width = info.width;
          texInfo.height = info.height;
          this.initialize(texInfo, true);
        }
      }

      const eventWebGLContextLost = 'webglcontextlost';
      function initStates(gl) {
        gl.activeTexture(gl.TEXTURE0);
        gl.pixelStorei(gl.PACK_ALIGNMENT, 1);
        gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.enable(gl.SCISSOR_TEST);
        gl.enable(gl.CULL_FACE);
        gl.cullFace(gl.BACK);
        gl.frontFace(gl.CCW);
        gl.polygonOffset(0.0, 0.0);
        gl.enable(gl.DEPTH_TEST);
        gl.depthMask(true);
        gl.depthFunc(gl.LESS);
        gl.stencilFuncSeparate(gl.FRONT, gl.ALWAYS, 1, 0xffff);
        gl.stencilOpSeparate(gl.FRONT, gl.KEEP, gl.KEEP, gl.KEEP);
        gl.stencilMaskSeparate(gl.FRONT, 0xffff);
        gl.stencilFuncSeparate(gl.BACK, gl.ALWAYS, 1, 0xffff);
        gl.stencilOpSeparate(gl.BACK, gl.KEEP, gl.KEEP, gl.KEEP);
        gl.stencilMaskSeparate(gl.BACK, 0xffff);
        gl.disable(gl.STENCIL_TEST);
        gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
        gl.disable(gl.BLEND);
        gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
        gl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.ONE, gl.ZERO);
        gl.colorMask(true, true, true, true);
        gl.blendColor(0.0, 0.0, 0.0, 0.0);
      }
      function getExtension(gl, ext) {
        const prefixes = ['', 'WEBKIT_', 'MOZ_'];
        for (let i = 0; i < prefixes.length; ++i) {
          const _ext = gl.getExtension(prefixes[i] + ext);
          if (_ext) {
            return _ext;
          }
        }
        return null;
      }
      function getExtensions(gl) {
        const res = {
          EXT_texture_filter_anisotropic: getExtension(gl, 'EXT_texture_filter_anisotropic'),
          EXT_color_buffer_half_float: getExtension(gl, 'EXT_color_buffer_half_float'),
          EXT_color_buffer_float: getExtension(gl, 'EXT_color_buffer_float'),
          WEBGL_compressed_texture_etc1: getExtension(gl, 'WEBGL_compressed_texture_etc1'),
          WEBGL_compressed_texture_etc: getExtension(gl, 'WEBGL_compressed_texture_etc'),
          WEBGL_compressed_texture_pvrtc: getExtension(gl, 'WEBGL_compressed_texture_pvrtc'),
          WEBGL_compressed_texture_astc: getExtension(gl, 'WEBGL_compressed_texture_astc'),
          WEBGL_compressed_texture_s3tc: getExtension(gl, 'WEBGL_compressed_texture_s3tc'),
          WEBGL_compressed_texture_s3tc_srgb: getExtension(gl, 'WEBGL_compressed_texture_s3tc_srgb'),
          WEBGL_debug_shaders: getExtension(gl, 'WEBGL_debug_shaders'),
          WEBGL_lose_context: getExtension(gl, 'WEBGL_lose_context'),
          WEBGL_debug_renderer_info: getExtension(gl, 'WEBGL_debug_renderer_info'),
          OES_texture_half_float_linear: getExtension(gl, 'OES_texture_half_float_linear'),
          OES_texture_float_linear: getExtension(gl, 'OES_texture_float_linear'),
          WEBGL_multi_draw: null,
          useVAO: true
        };
        {
          if (systemInfo.os !== OS.ANDROID && systemInfo.os !== OS.IOS) {
            res.WEBGL_multi_draw = getExtension(gl, 'WEBGL_multi_draw');
          }
        }
        return res;
      }
      function getContext(canvas) {
        let context = null;
        try {
          var _globalThis$__globalX;
          if ((_globalThis$__globalX = globalThis.__globalXR) !== null && _globalThis$__globalX !== void 0 && _globalThis$__globalX.webxrCompatible) {
            const glAttribs = {
              alpha: macro.ENABLE_TRANSPARENT_CANVAS,
              antialias: EDITOR || macro.ENABLE_WEBGL_ANTIALIAS,
              depth: true,
              stencil: true,
              premultipliedAlpha: false,
              preserveDrawingBuffer: false,
              powerPreference: 'default',
              failIfMajorPerformanceCaveat: false,
              xrCompatible: true
            };
            context = canvas.getContext('webgl2', glAttribs);
            return context;
          }
          const webGLCtxAttribs = {
            alpha: macro.ENABLE_TRANSPARENT_CANVAS,
            antialias: EDITOR || macro.ENABLE_WEBGL_ANTIALIAS,
            depth: true,
            stencil: true,
            premultipliedAlpha: false,
            preserveDrawingBuffer: false,
            powerPreference: 'default',
            failIfMajorPerformanceCaveat: false
          };
          context = canvas.getContext('webgl2', webGLCtxAttribs);
        } catch (err) {
          return null;
        }
        return context;
      }
      class WebGL2Swapchain extends Swapchain {
        constructor(...args) {
          super(...args);
          this.stateCache = new WebGL2StateCache();
          this.nullTex2D = null;
          this.nullTexCube = null;
          this._canvas = null;
          this._webGL2ContextLostHandler = null;
          this._extensions = null;
          this._blitManager = null;
        }
        get extensions() {
          return this._extensions;
        }
        get blitManager() {
          return this._blitManager;
        }
        initialize(info) {
          this._canvas = info.windowHandle;
          this._webGL2ContextLostHandler = this._onWebGLContextLost.bind(this);
          this._canvas.addEventListener(eventWebGLContextLost, this._onWebGLContextLost);
          const gl = WebGL2DeviceManager.instance.gl;
          this.stateCache.initialize(WebGL2DeviceManager.instance.capabilities.maxTextureUnits, WebGL2DeviceManager.instance.capabilities.maxUniformBufferBindings, WebGL2DeviceManager.instance.capabilities.maxVertexAttributes);
          this._extensions = getExtensions(gl);
          initStates(gl);
          const colorFmt = Format.RGBA8;
          let depthStencilFmt = Format.DEPTH_STENCIL;
          const depthBits = gl.getParameter(gl.DEPTH_BITS);
          const stencilBits = gl.getParameter(gl.STENCIL_BITS);
          if (depthBits && stencilBits) depthStencilFmt = Format.DEPTH_STENCIL;else if (depthBits) depthStencilFmt = Format.DEPTH;
          this._colorTexture = new WebGL2Texture();
          this._colorTexture.initAsSwapchainTexture({
            swapchain: this,
            format: colorFmt,
            width: info.width,
            height: info.height
          });
          this._depthStencilTexture = new WebGL2Texture();
          this._depthStencilTexture.initAsSwapchainTexture({
            swapchain: this,
            format: depthStencilFmt,
            width: info.width,
            height: info.height
          });
          this.nullTex2D = WebGL2DeviceManager.instance.createTexture(new TextureInfo(TextureType.TEX2D, TextureUsageBit.SAMPLED, Format.RGBA8, 2, 2, TextureFlagBit.NONE));
          this.nullTexCube = WebGL2DeviceManager.instance.createTexture(new TextureInfo(TextureType.CUBE, TextureUsageBit.SAMPLED, Format.RGBA8, 2, 2, TextureFlagBit.NONE, 6));
          const nullTexRegion = new BufferTextureCopy();
          nullTexRegion.texExtent.width = 2;
          nullTexRegion.texExtent.height = 2;
          const nullTexBuff = new Uint8Array(this.nullTex2D.size);
          nullTexBuff.fill(0);
          WebGL2DeviceManager.instance.copyBuffersToTexture([nullTexBuff], this.nullTex2D, [nullTexRegion]);
          nullTexRegion.texSubres.layerCount = 6;
          WebGL2DeviceManager.instance.copyBuffersToTexture([nullTexBuff, nullTexBuff, nullTexBuff, nullTexBuff, nullTexBuff, nullTexBuff], this.nullTexCube, [nullTexRegion]);
          this._blitManager = new IWebGL2BlitManager();
        }
        destroy() {
          if (this._canvas && this._webGL2ContextLostHandler) {
            this._canvas.removeEventListener(eventWebGLContextLost, this._webGL2ContextLostHandler);
            this._webGL2ContextLostHandler = null;
          }
          if (this.nullTex2D) {
            this.nullTex2D.destroy();
            this.nullTex2D = null;
          }
          if (this.nullTexCube) {
            this.nullTexCube.destroy();
            this.nullTexCube = null;
          }
          if (this._blitManager) {
            this._blitManager.destroy();
            this._blitManager = null;
          }
          this._extensions = null;
          this._canvas = null;
        }
        resize(width, height, surfaceTransform) {
          if (this._colorTexture.width !== width || this._colorTexture.height !== height) {
            debug(`Resizing swapchain: ${width}x${height}`);
            this._canvas.width = width;
            this._canvas.height = height;
            this._colorTexture.resize(width, height);
            this._depthStencilTexture.resize(width, height);
          }
        }
        _onWebGLContextLost(event) {
          warnID(11000);
          warn(event);
        }
      }

      class WebGL2Device extends Device {
        constructor(...args) {
          super(...args);
          this._swapchain = null;
          this._context = null;
          this._bindingMappings = null;
          this._textureExclusive = new Array(Format.COUNT);
        }
        get gl() {
          return this._context;
        }
        get extensions() {
          return this._swapchain.extensions;
        }
        get stateCache() {
          return this._swapchain.stateCache;
        }
        get nullTex2D() {
          return this._swapchain.nullTex2D;
        }
        get nullTexCube() {
          return this._swapchain.nullTexCube;
        }
        get textureExclusive() {
          return this._textureExclusive;
        }
        get bindingMappings() {
          return this._bindingMappings;
        }
        get blitManager() {
          return this._swapchain.blitManager;
        }
        initialize(info) {
          WebGL2DeviceManager.setInstance(this);
          this._gfxAPI = API.WEBGL2;
          const mapping = this._bindingMappingInfo = info.bindingMappingInfo;
          const blockOffsets = [];
          const samplerTextureOffsets = [];
          const firstSet = mapping.setIndices[0];
          blockOffsets[firstSet] = 0;
          samplerTextureOffsets[firstSet] = 0;
          for (let i = 1; i < mapping.setIndices.length; ++i) {
            const curSet = mapping.setIndices[i];
            const prevSet = mapping.setIndices[i - 1];
            blockOffsets[curSet] = mapping.maxBlockCounts[prevSet] + blockOffsets[prevSet];
            samplerTextureOffsets[curSet] = mapping.maxSamplerTextureCounts[prevSet] + samplerTextureOffsets[prevSet];
          }
          for (let i = 0; i < mapping.setIndices.length; ++i) {
            const curSet = mapping.setIndices[i];
            samplerTextureOffsets[curSet] -= mapping.maxBlockCounts[curSet];
          }
          this._bindingMappings = {
            blockOffsets,
            samplerTextureOffsets,
            flexibleSet: mapping.setIndices[mapping.setIndices.length - 1]
          };
          const gl = this._context = getContext(Device.canvas);
          if (!gl) {
            console.error('This device does not support WebGL2.');
            return false;
          }
          this._queue = this.createQueue(new QueueInfo(QueueType.GRAPHICS));
          this._cmdBuff = this.createCommandBuffer(new CommandBufferInfo(this._queue));
          this._caps.maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
          this._caps.maxVertexUniformVectors = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
          if (systemInfo.os === OS.IOS) {
            const maxVertexUniformVectors = this._caps.maxVertexUniformVectors;
            if (sys.browserType === BrowserType.WECHAT) {
              this._caps.maxVertexUniformVectors = maxVertexUniformVectors < 256 ? maxVertexUniformVectors : 256;
            } else if (sys.browserType === BrowserType.SAFARI) {
              this._caps.maxVertexUniformVectors = maxVertexUniformVectors < 512 ? maxVertexUniformVectors : 512;
            }
          }
          this._caps.maxFragmentUniformVectors = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
          this._caps.maxTextureUnits = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
          this._caps.maxVertexTextureUnits = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
          this._caps.maxUniformBufferBindings = gl.getParameter(gl.MAX_UNIFORM_BUFFER_BINDINGS);
          this._caps.maxUniformBlockSize = gl.getParameter(gl.MAX_UNIFORM_BLOCK_SIZE);
          this._caps.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
          this._caps.maxCubeMapTextureSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
          this._caps.maxArrayTextureLayers = gl.getParameter(gl.MAX_ARRAY_TEXTURE_LAYERS);
          this._caps.max3DTextureSize = gl.getParameter(gl.MAX_3D_TEXTURE_SIZE);
          this._caps.uboOffsetAlignment = gl.getParameter(gl.UNIFORM_BUFFER_OFFSET_ALIGNMENT);
          const extensions = gl.getSupportedExtensions();
          let extStr = '';
          if (extensions) {
            for (const ext of extensions) {
              extStr += `${ext} `;
            }
          }
          const exts = getExtensions(gl);
          if (exts.WEBGL_debug_renderer_info) {
            this._renderer = gl.getParameter(exts.WEBGL_debug_renderer_info.UNMASKED_RENDERER_WEBGL);
            this._vendor = gl.getParameter(exts.WEBGL_debug_renderer_info.UNMASKED_VENDOR_WEBGL);
          } else {
            this._renderer = gl.getParameter(gl.RENDERER);
            this._vendor = gl.getParameter(gl.VENDOR);
          }
          const version = gl.getParameter(gl.VERSION);
          this._features.fill(false);
          this.initFormatFeatures(exts);
          this._features[Feature.ELEMENT_INDEX_UINT] = true;
          this._features[Feature.INSTANCED_ARRAYS] = true;
          this._features[Feature.MULTIPLE_RENDER_TARGETS] = true;
          this._features[Feature.BLEND_MINMAX] = true;
          let compressedFormat = '';
          if (this.getFormatFeatures(Format.ETC_RGB8)) {
            compressedFormat += 'etc1 ';
          }
          if (this.getFormatFeatures(Format.ETC2_RGB8)) {
            compressedFormat += 'etc2 ';
          }
          if (this.getFormatFeatures(Format.BC1)) {
            compressedFormat += 'dxt ';
          }
          if (this.getFormatFeatures(Format.PVRTC_RGB2)) {
            compressedFormat += 'pvrtc ';
          }
          if (this.getFormatFeatures(Format.ASTC_RGBA_4X4)) {
            compressedFormat += 'astc ';
          }
          debug('WebGL2 device initialized.');
          debug(`RENDERER: ${this._renderer}`);
          debug(`VENDOR: ${this._vendor}`);
          debug(`VERSION: ${version}`);
          debug(`COMPRESSED_FORMAT: ${compressedFormat}`);
          debug(`EXTENSIONS: ${extStr}`);
          return true;
        }
        destroy() {
          if (this._queue) {
            this._queue.destroy();
            this._queue = null;
          }
          if (this._cmdBuff) {
            this._cmdBuff.destroy();
            this._cmdBuff = null;
          }
          const it = this._samplers.values();
          let res = it.next();
          while (!res.done) {
            res.value.destroy();
            res = it.next();
          }
          this._swapchain = null;
        }
        flushCommands(cmdBuffs) {}
        acquire(swapchains) {}
        present() {
          const queue = this._queue;
          this._numDrawCalls = queue.numDrawCalls;
          this._numInstances = queue.numInstances;
          this._numTris = queue.numTris;
          queue.clear();
        }
        initFormatFeatures(exts) {
          this._formatFeatures.fill(FormatFeatureBit.NONE);
          this._textureExclusive.fill(true);
          let tempFeature = FormatFeatureBit.RENDER_TARGET | FormatFeatureBit.SAMPLED_TEXTURE | FormatFeatureBit.STORAGE_TEXTURE | FormatFeatureBit.LINEAR_FILTER | FormatFeatureBit.VERTEX_ATTRIBUTE;
          this._formatFeatures[Format.R8] = tempFeature;
          this._formatFeatures[Format.RG8] = tempFeature;
          this._formatFeatures[Format.RGB8] = tempFeature;
          this._formatFeatures[Format.RGBA8] = tempFeature;
          tempFeature = FormatFeatureBit.RENDER_TARGET | FormatFeatureBit.SAMPLED_TEXTURE | FormatFeatureBit.STORAGE_TEXTURE | FormatFeatureBit.LINEAR_FILTER;
          this._formatFeatures[Format.R8SN] = tempFeature;
          this._formatFeatures[Format.RG8SN] = tempFeature;
          this._formatFeatures[Format.RGB8SN] = tempFeature;
          this._formatFeatures[Format.RGBA8SN] = tempFeature;
          this._formatFeatures[Format.R5G6B5] = tempFeature;
          this._formatFeatures[Format.RGBA4] = tempFeature;
          this._formatFeatures[Format.RGB5A1] = tempFeature;
          this._formatFeatures[Format.RGB10A2] = tempFeature;
          this._formatFeatures[Format.SRGB8] = tempFeature;
          this._formatFeatures[Format.SRGB8_A8] = tempFeature;
          this._formatFeatures[Format.R11G11B10F] = tempFeature;
          this._formatFeatures[Format.RGB9E5] = tempFeature;
          this._formatFeatures[Format.DEPTH] = tempFeature;
          this._formatFeatures[Format.DEPTH_STENCIL] = tempFeature;
          this._formatFeatures[Format.RGB10A2UI] = FormatFeatureBit.RENDER_TARGET | FormatFeatureBit.STORAGE_TEXTURE | FormatFeatureBit.SAMPLED_TEXTURE | FormatFeatureBit.LINEAR_FILTER;
          tempFeature = FormatFeatureBit.RENDER_TARGET | FormatFeatureBit.SAMPLED_TEXTURE | FormatFeatureBit.STORAGE_TEXTURE | FormatFeatureBit.VERTEX_ATTRIBUTE;
          this._formatFeatures[Format.R16F] = tempFeature;
          this._formatFeatures[Format.RG16F] = tempFeature;
          this._formatFeatures[Format.RGB16F] = tempFeature;
          this._formatFeatures[Format.RGBA16F] = tempFeature;
          tempFeature = FormatFeatureBit.STORAGE_TEXTURE | FormatFeatureBit.SAMPLED_TEXTURE | FormatFeatureBit.VERTEX_ATTRIBUTE;
          this._formatFeatures[Format.R32F] = tempFeature;
          this._formatFeatures[Format.RG32F] = tempFeature;
          this._formatFeatures[Format.RGB32F] = tempFeature;
          this._formatFeatures[Format.RGBA32F] = tempFeature;
          this._formatFeatures[Format.RGB10A2UI] = FormatFeatureBit.RENDER_TARGET | FormatFeatureBit.STORAGE_TEXTURE | FormatFeatureBit.SAMPLED_TEXTURE | FormatFeatureBit.LINEAR_FILTER;
          tempFeature = FormatFeatureBit.RENDER_TARGET | FormatFeatureBit.STORAGE_TEXTURE | FormatFeatureBit.SAMPLED_TEXTURE | FormatFeatureBit.LINEAR_FILTER | FormatFeatureBit.VERTEX_ATTRIBUTE;
          this._formatFeatures[Format.R8I] = tempFeature;
          this._formatFeatures[Format.R8UI] = tempFeature;
          this._formatFeatures[Format.R16I] = tempFeature;
          this._formatFeatures[Format.R16UI] = tempFeature;
          this._formatFeatures[Format.R32I] = tempFeature;
          this._formatFeatures[Format.R32UI] = tempFeature;
          this._formatFeatures[Format.RG8I] = tempFeature;
          this._formatFeatures[Format.RG8UI] = tempFeature;
          this._formatFeatures[Format.RG16I] = tempFeature;
          this._formatFeatures[Format.RG16UI] = tempFeature;
          this._formatFeatures[Format.RG32I] = tempFeature;
          this._formatFeatures[Format.RG32UI] = tempFeature;
          this._formatFeatures[Format.RGB8I] = tempFeature;
          this._formatFeatures[Format.RGB8UI] = tempFeature;
          this._formatFeatures[Format.RGB16I] = tempFeature;
          this._formatFeatures[Format.RGB16UI] = tempFeature;
          this._formatFeatures[Format.RGB32I] = tempFeature;
          this._formatFeatures[Format.RGB32UI] = tempFeature;
          this._formatFeatures[Format.RGBA8I] = tempFeature;
          this._formatFeatures[Format.RGBA8UI] = tempFeature;
          this._formatFeatures[Format.RGBA16I] = tempFeature;
          this._formatFeatures[Format.RGBA16UI] = tempFeature;
          this._formatFeatures[Format.RGBA32I] = tempFeature;
          this._formatFeatures[Format.RGBA32UI] = tempFeature;
          this._textureExclusive[Format.R8] = false;
          this._textureExclusive[Format.RG8] = false;
          this._textureExclusive[Format.RGB8] = false;
          this._textureExclusive[Format.R5G6B5] = false;
          this._textureExclusive[Format.RGBA4] = false;
          this._textureExclusive[Format.RGB5A1] = false;
          this._textureExclusive[Format.RGBA8] = false;
          this._textureExclusive[Format.RGB10A2] = false;
          this._textureExclusive[Format.RGB10A2UI] = false;
          this._textureExclusive[Format.SRGB8_A8] = false;
          this._textureExclusive[Format.R8I] = false;
          this._textureExclusive[Format.R8UI] = false;
          this._textureExclusive[Format.R16I] = false;
          this._textureExclusive[Format.R16UI] = false;
          this._textureExclusive[Format.R32I] = false;
          this._textureExclusive[Format.R32UI] = false;
          this._textureExclusive[Format.RG8I] = false;
          this._textureExclusive[Format.RG8UI] = false;
          this._textureExclusive[Format.RG16I] = false;
          this._textureExclusive[Format.RG16UI] = false;
          this._textureExclusive[Format.RG32I] = false;
          this._textureExclusive[Format.RG32UI] = false;
          this._textureExclusive[Format.RGBA8I] = false;
          this._textureExclusive[Format.RGBA8UI] = false;
          this._textureExclusive[Format.RGBA16I] = false;
          this._textureExclusive[Format.RGBA16UI] = false;
          this._textureExclusive[Format.RGBA32I] = false;
          this._textureExclusive[Format.RGBA32UI] = false;
          this._textureExclusive[Format.DEPTH] = false;
          this._textureExclusive[Format.DEPTH_STENCIL] = false;
          if (exts.EXT_color_buffer_float) {
            this._formatFeatures[Format.R32F] |= FormatFeatureBit.RENDER_TARGET;
            this._formatFeatures[Format.RG32F] |= FormatFeatureBit.RENDER_TARGET;
            this._formatFeatures[Format.RGBA32F] |= FormatFeatureBit.RENDER_TARGET;
            this._textureExclusive[Format.R32F] = false;
            this._textureExclusive[Format.RG32F] = false;
            this._textureExclusive[Format.RGBA32F] = false;
          }
          if (exts.EXT_color_buffer_half_float) {
            this._textureExclusive[Format.R16F] = false;
            this._textureExclusive[Format.RG16F] = false;
            this._textureExclusive[Format.RGBA16F] = false;
          }
          if (exts.OES_texture_float_linear) {
            this._formatFeatures[Format.RGB32F] |= FormatFeatureBit.LINEAR_FILTER;
            this._formatFeatures[Format.RGBA32F] |= FormatFeatureBit.LINEAR_FILTER;
            this._formatFeatures[Format.R32F] |= FormatFeatureBit.LINEAR_FILTER;
            this._formatFeatures[Format.RG32F] |= FormatFeatureBit.LINEAR_FILTER;
          }
          if (exts.OES_texture_half_float_linear) {
            this._formatFeatures[Format.RGB16F] |= FormatFeatureBit.LINEAR_FILTER;
            this._formatFeatures[Format.RGBA16F] |= FormatFeatureBit.LINEAR_FILTER;
            this._formatFeatures[Format.R16F] |= FormatFeatureBit.LINEAR_FILTER;
            this._formatFeatures[Format.RG16F] |= FormatFeatureBit.LINEAR_FILTER;
          }
          const compressedFeature = FormatFeatureBit.SAMPLED_TEXTURE | FormatFeatureBit.LINEAR_FILTER;
          if (exts.WEBGL_compressed_texture_etc1) {
            this._formatFeatures[Format.ETC_RGB8] = compressedFeature;
          }
          if (exts.WEBGL_compressed_texture_etc) {
            this._formatFeatures[Format.ETC2_RGB8] = compressedFeature;
            this._formatFeatures[Format.ETC2_RGBA8] = compressedFeature;
            this._formatFeatures[Format.ETC2_SRGB8] = compressedFeature;
            this._formatFeatures[Format.ETC2_SRGB8_A8] = compressedFeature;
            this._formatFeatures[Format.ETC2_RGB8_A1] = compressedFeature;
            this._formatFeatures[Format.ETC2_SRGB8_A1] = compressedFeature;
          }
          if (exts.WEBGL_compressed_texture_s3tc) {
            this._formatFeatures[Format.BC1] = compressedFeature;
            this._formatFeatures[Format.BC1_ALPHA] = compressedFeature;
            this._formatFeatures[Format.BC1_SRGB] = compressedFeature;
            this._formatFeatures[Format.BC1_SRGB_ALPHA] = compressedFeature;
            this._formatFeatures[Format.BC2] = compressedFeature;
            this._formatFeatures[Format.BC2_SRGB] = compressedFeature;
            this._formatFeatures[Format.BC3] = compressedFeature;
            this._formatFeatures[Format.BC3_SRGB] = compressedFeature;
          }
          if (exts.WEBGL_compressed_texture_pvrtc) {
            this._formatFeatures[Format.PVRTC_RGB2] = compressedFeature;
            this._formatFeatures[Format.PVRTC_RGBA2] = compressedFeature;
            this._formatFeatures[Format.PVRTC_RGB4] = compressedFeature;
            this._formatFeatures[Format.PVRTC_RGBA4] = compressedFeature;
          }
          if (exts.WEBGL_compressed_texture_astc) {
            this._formatFeatures[Format.ASTC_RGBA_4X4] = compressedFeature;
            this._formatFeatures[Format.ASTC_RGBA_5X4] = compressedFeature;
            this._formatFeatures[Format.ASTC_RGBA_5X5] = compressedFeature;
            this._formatFeatures[Format.ASTC_RGBA_6X5] = compressedFeature;
            this._formatFeatures[Format.ASTC_RGBA_6X6] = compressedFeature;
            this._formatFeatures[Format.ASTC_RGBA_8X5] = compressedFeature;
            this._formatFeatures[Format.ASTC_RGBA_8X6] = compressedFeature;
            this._formatFeatures[Format.ASTC_RGBA_8X8] = compressedFeature;
            this._formatFeatures[Format.ASTC_RGBA_10X5] = compressedFeature;
            this._formatFeatures[Format.ASTC_RGBA_10X6] = compressedFeature;
            this._formatFeatures[Format.ASTC_RGBA_10X8] = compressedFeature;
            this._formatFeatures[Format.ASTC_RGBA_10X10] = compressedFeature;
            this._formatFeatures[Format.ASTC_RGBA_12X10] = compressedFeature;
            this._formatFeatures[Format.ASTC_RGBA_12X12] = compressedFeature;
            this._formatFeatures[Format.ASTC_SRGBA_4X4] = compressedFeature;
            this._formatFeatures[Format.ASTC_SRGBA_5X4] = compressedFeature;
            this._formatFeatures[Format.ASTC_SRGBA_5X5] = compressedFeature;
            this._formatFeatures[Format.ASTC_SRGBA_6X5] = compressedFeature;
            this._formatFeatures[Format.ASTC_SRGBA_6X6] = compressedFeature;
            this._formatFeatures[Format.ASTC_SRGBA_8X5] = compressedFeature;
            this._formatFeatures[Format.ASTC_SRGBA_8X6] = compressedFeature;
            this._formatFeatures[Format.ASTC_SRGBA_8X8] = compressedFeature;
            this._formatFeatures[Format.ASTC_SRGBA_10X5] = compressedFeature;
            this._formatFeatures[Format.ASTC_SRGBA_10X6] = compressedFeature;
            this._formatFeatures[Format.ASTC_SRGBA_10X8] = compressedFeature;
            this._formatFeatures[Format.ASTC_SRGBA_10X10] = compressedFeature;
            this._formatFeatures[Format.ASTC_SRGBA_12X10] = compressedFeature;
            this._formatFeatures[Format.ASTC_SRGBA_12X12] = compressedFeature;
          }
        }
        createCommandBuffer(info) {
          const Ctor = info.type === CommandBufferType.PRIMARY ? WebGL2PrimaryCommandBuffer : WebGL2CommandBuffer;
          const cmdBuff = new Ctor();
          cmdBuff.initialize(info);
          return cmdBuff;
        }
        createSwapchain(info) {
          const swapchain = new WebGL2Swapchain();
          this._swapchain = swapchain;
          swapchain.initialize(info);
          return swapchain;
        }
        createBuffer(info) {
          const buffer = new WebGL2Buffer();
          buffer.initialize(info);
          return buffer;
        }
        createTexture(info) {
          const texture = new WebGL2Texture();
          texture.initialize(info);
          return texture;
        }
        createDescriptorSet(info) {
          const descriptorSet = new WebGL2DescriptorSet();
          descriptorSet.initialize(info);
          return descriptorSet;
        }
        createShader(info) {
          const shader = new WebGL2Shader();
          shader.initialize(info);
          return shader;
        }
        createInputAssembler(info) {
          const inputAssembler = new WebGL2InputAssembler();
          inputAssembler.initialize(info);
          return inputAssembler;
        }
        createRenderPass(info) {
          const renderPass = new WebGL2RenderPass();
          renderPass.initialize(info);
          return renderPass;
        }
        createFramebuffer(info) {
          const framebuffer = new WebGL2Framebuffer();
          framebuffer.initialize(info);
          return framebuffer;
        }
        createDescriptorSetLayout(info) {
          const descriptorSetLayout = new WebGL2DescriptorSetLayout();
          descriptorSetLayout.initialize(info);
          return descriptorSetLayout;
        }
        createPipelineLayout(info) {
          const pipelineLayout = new WebGL2PipelineLayout();
          pipelineLayout.initialize(info);
          return pipelineLayout;
        }
        createPipelineState(info) {
          const pipelineState = new WebGL2PipelineState();
          pipelineState.initialize(info);
          return pipelineState;
        }
        createQueue(info) {
          const queue = new WebGL2Queue();
          queue.initialize(info);
          return queue;
        }
        getSampler(info) {
          const hash = Sampler.computeHash(info);
          if (!this._samplers.has(hash)) {
            this._samplers.set(hash, new WebGL2Sampler(info, hash));
          }
          return this._samplers.get(hash);
        }
        getSwapchains() {
          return [this._swapchain];
        }
        getGeneralBarrier(info) {
          const hash = GeneralBarrier.computeHash(info);
          if (!this._generalBarrierss.has(hash)) {
            this._generalBarrierss.set(hash, new GeneralBarrier(info, hash));
          }
          return this._generalBarrierss.get(hash);
        }
        getTextureBarrier(info) {
          const hash = TextureBarrier.computeHash(info);
          if (!this._textureBarriers.has(hash)) {
            this._textureBarriers.set(hash, new TextureBarrier(info, hash));
          }
          return this._textureBarriers.get(hash);
        }
        getBufferBarrier(info) {
          const hash = BufferBarrier.computeHash(info);
          if (!this._bufferBarriers.has(hash)) {
            this._bufferBarriers.set(hash, new BufferBarrier(info, hash));
          }
          return this._bufferBarriers.get(hash);
        }
        copyBuffersToTexture(buffers, texture, regions) {
          WebGL2CmdFuncCopyBuffersToTexture(this, buffers, texture.gpuTexture, regions);
        }
        copyTextureToBuffers(texture, buffers, regions) {
          WebGL2CmdFuncCopyTextureToBuffers(this, texture.gpuTexture, buffers, regions);
        }
        copyTexImagesToTexture(texImages, texture, regions) {
          WebGL2CmdFuncCopyTexImagesToTexture(this, texImages, texture.gpuTexture, regions);
        }
      } exports('WebGL2Device', WebGL2Device);

      legacyCC.WebGL2Device = WebGL2Device;

      const DURATION_INFINITY = -1;
      const START_SIZE_EQUAL_TO_END_SIZE = -1;
      const START_RADIUS_EQUAL_TO_END_RADIUS = -1;
      const EmitterMode = Enum({
        GRAVITY: 0,
        RADIUS: 1
      });
      const PositionType = Enum({
        FREE: 0,
        RELATIVE: 1,
        GROUPED: 2
      });

      const ZERO_VEC2 = new Vec2(0, 0);
      const _pos = new Vec2();
      const _tpa = new Vec2();
      const _tpb = new Vec2();
      const _tpc = new Vec2();
      const formatBytes = getComponentPerVertex(vfmtPosUvColor);
      function getWorldRotation(node) {
        let rotation = 0;
        let tempNode = node;
        while (tempNode) {
          rotation += tempNode.eulerAngles.z;
          tempNode = tempNode.parent;
        }
        return rotation;
      }
      class Particle {
        constructor() {
          this.pos = new Vec2(0, 0);
          this.startPos = new Vec2(0, 0);
          this.color = new Color$1(0, 0, 0, 255);
          this.deltaColor = {
            r: 0,
            g: 0,
            b: 0,
            a: 255
          };
          this.size = 0;
          this.deltaSize = 0;
          this.rotation = 0;
          this.deltaRotation = 0;
          this.timeToLive = 0;
          this.drawPos = new Vec2(0, 0);
          this.aspectRatio = 1;
          this.dir = new Vec2(0, 0);
          this.radialAccel = 0;
          this.tangentialAccel = 0;
          this.angle = 0;
          this.degreesPerSecond = 0;
          this.radius = 0;
          this.deltaRadius = 0;
        }
      }
      class ParticlePool extends Pool$1 {
        get() {
          return this._get() || new Particle();
        }
      }
      const pool = new ParticlePool(par => {
        par.pos.set(ZERO_VEC2);
        par.startPos.set(ZERO_VEC2);
        par.color._val = 0xFF000000;
        par.deltaColor.r = par.deltaColor.g = par.deltaColor.b = 0;
        par.deltaColor.a = 255;
        par.size = 0;
        par.deltaSize = 0;
        par.rotation = 0;
        par.deltaRotation = 0;
        par.timeToLive = 0;
        par.drawPos.set(ZERO_VEC2);
        par.aspectRatio = 1;
        par.dir.set(ZERO_VEC2);
        par.radialAccel = 0;
        par.tangentialAccel = 0;
        par.angle = 0;
        par.degreesPerSecond = 0;
        par.radius = 0;
        par.deltaRadius = 0;
      }, 1024);
      class Simulator {
        constructor(system) {
          this.particles = [];
          this.active = false;
          this.uvFilled = 0;
          this.finished = false;
          this.readyToPlay = true;
          this.elapsed = 0;
          this.emitCounter = 0;
          this._worldRotation = 0;
          this.sys = system;
          this.particles = [];
          this.active = false;
          this.readyToPlay = true;
          this.finished = false;
          this.elapsed = 0;
          this.emitCounter = 0;
          this.uvFilled = 0;
          this._worldRotation = 0;
        }
        stop() {
          this.active = false;
          this.readyToPlay = false;
          this.elapsed = this.sys.duration;
          this.emitCounter = 0;
        }
        reset() {
          this.active = true;
          this.readyToPlay = true;
          this.elapsed = 0;
          this.emitCounter = 0;
          this.finished = false;
          const particles = this.particles;
          for (let id = 0; id < particles.length; ++id) pool.put(particles[id]);
          particles.length = 0;
        }
        emitParticle(pos) {
          const psys = this.sys;
          const particle = pool.get();
          this.particles.push(particle);
          particle.timeToLive = psys.life + psys.lifeVar * (random() - 0.5) * 2;
          const timeToLive = particle.timeToLive = Math.max(0, particle.timeToLive);
          particle.pos.x = psys.sourcePos.x + psys.posVar.x * (random() - 0.5) * 2;
          particle.pos.y = psys.sourcePos.y + psys.posVar.y * (random() - 0.5) * 2;
          let sr = 0;
          let sg = 0;
          let sb = 0;
          let sa = 0;
          const startColor = psys.startColor;
          const startColorVar = psys.startColorVar;
          const endColor = psys.endColor;
          const endColorVar = psys.endColorVar;
          particle.color.r = sr = clampf(startColor.r + startColorVar.r * (random() - 0.5) * 2, 0, 255);
          particle.color.g = sg = clampf(startColor.g + startColorVar.g * (random() - 0.5) * 2, 0, 255);
          particle.color.b = sb = clampf(startColor.b + startColorVar.b * (random() - 0.5) * 2, 0, 255);
          particle.color.a = sa = clampf(startColor.a + startColorVar.a * (random() - 0.5) * 2, 0, 255);
          particle.deltaColor.r = (clampf(endColor.r + endColorVar.r * (random() - 0.5) * 2, 0, 255) - sr) / timeToLive;
          particle.deltaColor.g = (clampf(endColor.g + endColorVar.g * (random() - 0.5) * 2, 0, 255) - sg) / timeToLive;
          particle.deltaColor.b = (clampf(endColor.b + endColorVar.b * (random() - 0.5) * 2, 0, 255) - sb) / timeToLive;
          particle.deltaColor.a = (clampf(endColor.a + endColorVar.a * (random() - 0.5) * 2, 0, 255) - sa) / timeToLive;
          let startS = psys.startSize + psys.startSizeVar * (random() - 0.5) * 2;
          startS = Math.max(0, startS);
          particle.size = startS;
          if (psys.endSize === START_SIZE_EQUAL_TO_END_SIZE) {
            particle.deltaSize = 0;
          } else {
            let endS = psys.endSize + psys.endSizeVar * (random() - 0.5) * 2;
            endS = Math.max(0, endS);
            particle.deltaSize = (endS - startS) / timeToLive;
          }
          const startA = psys.startSpin + psys.startSpinVar * (random() - 0.5) * 2;
          const endA = psys.endSpin + psys.endSpinVar * (random() - 0.5) * 2;
          particle.rotation = startA;
          particle.deltaRotation = (endA - startA) / timeToLive;
          particle.startPos.x = pos.x;
          particle.startPos.y = pos.y;
          particle.aspectRatio = psys.aspectRatio || 1;
          const a = degreesToRadians(psys.angle + this._worldRotation + psys.angleVar * (random() - 0.5) * 2);
          if (psys.emitterMode === EmitterMode.GRAVITY) {
            const s = psys.speed + psys.speedVar * (random() - 0.5) * 2;
            particle.dir.x = Math.cos(a);
            particle.dir.y = Math.sin(a);
            particle.dir.multiplyScalar(s);
            particle.radialAccel = psys.radialAccel + psys.radialAccelVar * (random() - 0.5) * 2;
            particle.tangentialAccel = psys.tangentialAccel + psys.tangentialAccelVar * (random() - 0.5) * 2;
            if (psys.rotationIsDir) {
              particle.rotation = -radiansToDegrees(Math.atan2(particle.dir.y, particle.dir.x));
            }
          } else {
            const startRadius = psys.startRadius + psys.startRadiusVar * (random() - 0.5) * 2;
            const endRadius = psys.endRadius + psys.endRadiusVar * (random() - 0.5) * 2;
            particle.radius = startRadius;
            particle.deltaRadius = psys.endRadius === START_RADIUS_EQUAL_TO_END_RADIUS ? 0 : (endRadius - startRadius) / timeToLive;
            particle.angle = a;
            particle.degreesPerSecond = degreesToRadians(psys.rotatePerS + psys.rotatePerSVar * (random() - 0.5) * 2);
          }
        }
        updateUVs(force) {
          const renderData = this.renderData;
          if (renderData && this.sys._renderSpriteFrame) {
            const vbuf = renderData.vData;
            const uv = this.sys._renderSpriteFrame.uv;
            const start = force ? 0 : this.uvFilled;
            const particleCount = this.particles.length;
            for (let i = start; i < particleCount; i++) {
              const offset = i * formatBytes * 4;
              vbuf[offset + 3] = uv[0];
              vbuf[offset + 4] = uv[1];
              vbuf[offset + 12] = uv[2];
              vbuf[offset + 13] = uv[3];
              vbuf[offset + 21] = uv[4];
              vbuf[offset + 22] = uv[5];
              vbuf[offset + 30] = uv[6];
              vbuf[offset + 31] = uv[7];
            }
            this.uvFilled = particleCount;
          }
        }
        updateParticleBuffer(particle, pos, buffer, offset) {
          const vbuf = buffer.vData;
          const x = pos.x;
          const y = pos.y;
          let width = particle.size;
          let height = width;
          const aspectRatio = particle.aspectRatio;
          if (aspectRatio > 1) {
            height = width / aspectRatio;
          } else {
            width = height * aspectRatio;
          }
          const halfWidth = width / 2;
          const halfHeight = height / 2;
          if (particle.rotation) {
            const x1 = -halfWidth;
            const y1 = -halfHeight;
            const x2 = halfWidth;
            const y2 = halfHeight;
            const rad = -degreesToRadians(particle.rotation);
            const cr = Math.cos(rad);
            const sr = Math.sin(rad);
            vbuf[offset] = x1 * cr - y1 * sr + x;
            vbuf[offset + 1] = x1 * sr + y1 * cr + y;
            vbuf[offset + 2] = 0;
            vbuf[offset + 9] = x2 * cr - y1 * sr + x;
            vbuf[offset + 10] = x2 * sr + y1 * cr + y;
            vbuf[offset + 11] = 0;
            vbuf[offset + 18] = x1 * cr - y2 * sr + x;
            vbuf[offset + 19] = x1 * sr + y2 * cr + y;
            vbuf[offset + 20] = 0;
            vbuf[offset + 27] = x2 * cr - y2 * sr + x;
            vbuf[offset + 28] = x2 * sr + y2 * cr + y;
            vbuf[offset + 29] = 0;
          } else {
            vbuf[offset] = x - halfWidth;
            vbuf[offset + 1] = y - halfHeight;
            vbuf[offset + 2] = 0;
            vbuf[offset + 9] = x + halfWidth;
            vbuf[offset + 10] = y - halfHeight;
            vbuf[offset + 11] = 0;
            vbuf[offset + 18] = x - halfWidth;
            vbuf[offset + 19] = y + halfHeight;
            vbuf[offset + 20] = 0;
            vbuf[offset + 27] = x + halfWidth;
            vbuf[offset + 28] = y + halfHeight;
            vbuf[offset + 29] = 0;
          }
          Color$1.toArray(vbuf, particle.color, offset + 5);
          Color$1.toArray(vbuf, particle.color, offset + 14);
          Color$1.toArray(vbuf, particle.color, offset + 23);
          Color$1.toArray(vbuf, particle.color, offset + 32);
        }
        step(dt) {
          const assembler = this.sys.assembler;
          const psys = this.sys;
          const node = psys.node;
          const particles = this.particles;
          dt = dt > assembler.maxParticleDeltaTime ? assembler.maxParticleDeltaTime : dt;
          node.updateWorldTransform();
          if (psys.positionType === PositionType.FREE) {
            this._worldRotation = getWorldRotation(node);
            const m = node.worldMatrix;
            _pos.x = m.m12;
            _pos.y = m.m13;
          } else if (psys.positionType === PositionType.RELATIVE) {
            this._worldRotation = node.eulerAngles.z;
            _pos.x = node.position.x;
            _pos.y = node.position.y;
          } else {
            this._worldRotation = 0;
          }
          if (this.active && psys.emissionRate) {
            const rate = 1.0 / psys.emissionRate;
            if (particles.length < psys.totalParticles) this.emitCounter += dt;
            while (particles.length < psys.totalParticles && this.emitCounter > rate) {
              this.emitParticle(_pos);
              this.emitCounter -= rate;
            }
            this.elapsed += dt;
            if (psys.duration !== -1 && psys.duration < this.elapsed) {
              psys.stopSystem();
            }
          }
          const renderData = this.renderData;
          const particleCount = particles.length;
          renderData.reset();
          this.requestData(particleCount * 4, particleCount * 6);
          if (particleCount > this.uvFilled) {
            this.updateUVs();
          }
          let particleIdx = 0;
          while (particleIdx < particles.length) {
            _tpa.x = _tpa.y = _tpb.x = _tpb.y = _tpc.x = _tpc.y = 0;
            const particle = particles[particleIdx];
            particle.timeToLive -= dt;
            if (particle.timeToLive > 0) {
              if (psys.emitterMode === EmitterMode.GRAVITY) {
                const tmp = _tpc;
                const radial = _tpa;
                const tangential = _tpb;
                if (particle.pos.x || particle.pos.y) {
                  radial.set(particle.pos);
                  radial.normalize();
                }
                tangential.set(radial);
                radial.multiplyScalar(particle.radialAccel);
                const newy = tangential.x;
                tangential.x = -tangential.y;
                tangential.y = newy;
                tangential.multiplyScalar(particle.tangentialAccel);
                tmp.set(radial);
                tmp.add(tangential);
                tmp.add(psys.gravity);
                tmp.multiplyScalar(dt);
                particle.dir.add(tmp);
                tmp.set(particle.dir);
                tmp.multiplyScalar(dt);
                particle.pos.add(tmp);
              } else {
                particle.angle += particle.degreesPerSecond * dt;
                particle.radius += particle.deltaRadius * dt;
                particle.pos.x = -Math.cos(particle.angle) * particle.radius;
                particle.pos.y = -Math.sin(particle.angle) * particle.radius;
              }
              particle.color.r += particle.deltaColor.r * dt;
              particle.color.g += particle.deltaColor.g * dt;
              particle.color.b += particle.deltaColor.b * dt;
              particle.color.a += particle.deltaColor.a * dt;
              particle.size += particle.deltaSize * dt;
              if (particle.size < 0) {
                particle.size = 0;
              }
              particle.rotation += particle.deltaRotation * dt;
              const newPos = _tpa;
              newPos.set(particle.pos);
              if (psys.positionType !== PositionType.GROUPED) {
                newPos.add(particle.startPos);
              }
              const offset = formatBytes * particleIdx * 4;
              this.updateParticleBuffer(particle, newPos, renderData, offset);
              ++particleIdx;
            } else {
              const deadParticle = particles[particleIdx];
              if (particleIdx !== particles.length - 1) {
                particles[particleIdx] = particles[particles.length - 1];
              }
              pool.put(deadParticle);
              particles.length--;
              renderData.resize(renderData.vertexCount - 4, renderData.indexCount - 6);
            }
          }
          this.renderData.material = this.sys.getRenderMaterial(0);
          this.renderData.frame = this.sys._renderSpriteFrame;
          renderData.setRenderDrawInfoAttributes();
          if (particles.length === 0 && !this.active && !this.readyToPlay) {
            this.finished = true;
            psys._finishedSimulation();
          }
        }
        requestData(vertexCount, indexCount) {
          let offset = this.renderData.indexCount;
          this.renderData.request(vertexCount, indexCount);
          const count = this.renderData.indexCount / 6;
          const buffer = this.renderData.iData;
          for (let i = offset; i < count; i++) {
            const vId = i * 4;
            buffer[offset++] = vId;
            buffer[offset++] = vId + 1;
            buffer[offset++] = vId + 2;
            buffer[offset++] = vId + 1;
            buffer[offset++] = vId + 3;
            buffer[offset++] = vId + 2;
          }
        }
        initDrawInfo() {
          const renderData = this.renderData;
          renderData.setRenderDrawInfoAttributes();
        }
      }

      var _dec$k, _class$j, _class2$h, _initializer$g;
      const {
        ccclass,
        serializable,
        editable
      } = _decorator;
      let ParticleAsset = exports('ParticleAsset', (_dec$k = ccclass('cc.ParticleAsset'), _dec$k(_class$j = (_class2$h = class ParticleAsset extends Asset {
        constructor(...args) {
          super(...args);
          this.spriteFrame = _initializer$g && _initializer$g();
        }
      }, (_initializer$g = applyDecoratedInitializer(_class2$h.prototype, "spriteFrame", [serializable], function () {
        return null;
      })), _class2$h)) || _class$j));
      legacyCC.ParticleAsset = ParticleAsset;

      /** @license zlib.js 2012 - imaya [ https://github.com/imaya/zlib.js ] The MIT License */
      var window$1 = {};
      (function () {

        function i(a) {
          throw a;
        }
        var r = void 0,
          v = !0,
          aa = this;
        function y(a, c) {
          var b = a.split("."),
            e = aa;
          !(b[0] in e) && e.execScript && e.execScript("var " + b[0]);
          for (var f; b.length && (f = b.shift());) !b.length && c !== r ? e[f] = c : e = e[f] ? e[f] : e[f] = {};
        }
        var H = "undefined" !== typeof Uint8Array && "undefined" !== typeof Uint16Array && "undefined" !== typeof Uint32Array;
        function ba(a) {
          if ("string" === typeof a) {
            var c = a.split(""),
              b,
              e;
            b = 0;
            for (e = c.length; b < e; b++) c[b] = (c[b].charCodeAt(0) & 255) >>> 0;
            a = c;
          }
          for (var f = 1, d = 0, g = a.length, h, m = 0; 0 < g;) {
            h = 1024 < g ? 1024 : g;
            g -= h;
            do f += a[m++], d += f; while (--h);
            f %= 65521;
            d %= 65521;
          }
          return (d << 16 | f) >>> 0;
        }
        function J(a, c) {
          this.index = "number" === typeof c ? c : 0;
          this.i = 0;
          this.buffer = a instanceof (H ? Uint8Array : Array) ? a : new (H ? Uint8Array : Array)(32768);
          2 * this.buffer.length <= this.index && i(Error("invalid index"));
          this.buffer.length <= this.index && this.f();
        }
        J.prototype.f = function () {
          var a = this.buffer,
            c,
            b = a.length,
            e = new (H ? Uint8Array : Array)(b << 1);
          if (H) e.set(a);else for (c = 0; c < b; ++c) e[c] = a[c];
          return this.buffer = e;
        };
        J.prototype.d = function (a, c, b) {
          var e = this.buffer,
            f = this.index,
            d = this.i,
            g = e[f],
            h;
          b && 1 < c && (a = 8 < c ? (N[a & 255] << 24 | N[a >>> 8 & 255] << 16 | N[a >>> 16 & 255] << 8 | N[a >>> 24 & 255]) >> 32 - c : N[a] >> 8 - c);
          if (8 > c + d) g = g << c | a, d += c;else for (h = 0; h < c; ++h) g = g << 1 | a >> c - h - 1 & 1, 8 === ++d && (d = 0, e[f++] = N[g], g = 0, f === e.length && (e = this.f()));
          e[f] = g;
          this.buffer = e;
          this.i = d;
          this.index = f;
        };
        J.prototype.finish = function () {
          var a = this.buffer,
            c = this.index,
            b;
          0 < this.i && (a[c] <<= 8 - this.i, a[c] = N[a[c]], c++);
          H ? b = a.subarray(0, c) : (a.length = c, b = a);
          return b;
        };
        var ca = new (H ? Uint8Array : Array)(256),
          ha;
        for (ha = 0; 256 > ha; ++ha) {
          for (var R = ha, ia = R, ja = 7, R = R >>> 1; R; R >>>= 1) ia <<= 1, ia |= R & 1, --ja;
          ca[ha] = (ia << ja & 255) >>> 0;
        }
        var N = ca;
        function la(a) {
          this.buffer = new (H ? Uint16Array : Array)(2 * a);
          this.length = 0;
        }
        la.prototype.getParent = function (a) {
          return 2 * ((a - 2) / 4 | 0);
        };
        la.prototype.push = function (a, c) {
          var b,
            e,
            f = this.buffer,
            d;
          b = this.length;
          f[this.length++] = c;
          for (f[this.length++] = a; 0 < b;) if (e = this.getParent(b), f[b] > f[e]) d = f[b], f[b] = f[e], f[e] = d, d = f[b + 1], f[b + 1] = f[e + 1], f[e + 1] = d, b = e;else break;
          return this.length;
        };
        la.prototype.pop = function () {
          var a,
            c,
            b = this.buffer,
            e,
            f,
            d;
          c = b[0];
          a = b[1];
          this.length -= 2;
          b[0] = b[this.length];
          b[1] = b[this.length + 1];
          for (d = 0;;) {
            f = 2 * d + 2;
            if (f >= this.length) break;
            f + 2 < this.length && b[f + 2] > b[f] && (f += 2);
            if (b[f] > b[d]) e = b[d], b[d] = b[f], b[f] = e, e = b[d + 1], b[d + 1] = b[f + 1], b[f + 1] = e;else break;
            d = f;
          }
          return {
            index: a,
            value: c,
            length: this.length
          };
        };
        function S(a) {
          var c = a.length,
            b = 0,
            e = Number.POSITIVE_INFINITY,
            f,
            d,
            g,
            h,
            m,
            j,
            s,
            n,
            l;
          for (n = 0; n < c; ++n) a[n] > b && (b = a[n]), a[n] < e && (e = a[n]);
          f = 1 << b;
          d = new (H ? Uint32Array : Array)(f);
          g = 1;
          h = 0;
          for (m = 2; g <= b;) {
            for (n = 0; n < c; ++n) if (a[n] === g) {
              j = 0;
              s = h;
              for (l = 0; l < g; ++l) j = j << 1 | s & 1, s >>= 1;
              for (l = j; l < f; l += m) d[l] = g << 16 | n;
              ++h;
            }
            ++g;
            h <<= 1;
            m <<= 1;
          }
          return [d, b, e];
        }
        function ma(a, c) {
          this.h = pa;
          this.w = 0;
          this.input = a;
          this.b = 0;
          c && (c.lazy && (this.w = c.lazy), "number" === typeof c.compressionType && (this.h = c.compressionType), c.outputBuffer && (this.a = H && c.outputBuffer instanceof Array ? new Uint8Array(c.outputBuffer) : c.outputBuffer), "number" === typeof c.outputIndex && (this.b = c.outputIndex));
          this.a || (this.a = new (H ? Uint8Array : Array)(32768));
        }
        var pa = 2,
          qa = {
            NONE: 0,
            r: 1,
            j: pa,
            N: 3
          },
          ra = [],
          T;
        for (T = 0; 288 > T; T++) switch (v) {
          case 143 >= T:
            ra.push([T + 48, 8]);
            break;
          case 255 >= T:
            ra.push([T - 144 + 400, 9]);
            break;
          case 279 >= T:
            ra.push([T - 256 + 0, 7]);
            break;
          case 287 >= T:
            ra.push([T - 280 + 192, 8]);
            break;
          default:
            i("invalid literal: " + T);
        }
        ma.prototype.n = function () {
          var a,
            c,
            b,
            e,
            f = this.input;
          switch (this.h) {
            case 0:
              b = 0;
              for (e = f.length; b < e;) {
                c = H ? f.subarray(b, b + 65535) : f.slice(b, b + 65535);
                b += c.length;
                var d = c,
                  g = b === e,
                  h = r,
                  m = r,
                  j = r,
                  s = r,
                  n = r,
                  l = this.a,
                  q = this.b;
                if (H) {
                  for (l = new Uint8Array(this.a.buffer); l.length <= q + d.length + 5;) l = new Uint8Array(l.length << 1);
                  l.set(this.a);
                }
                h = g ? 1 : 0;
                l[q++] = h | 0;
                m = d.length;
                j = ~m + 65536 & 65535;
                l[q++] = m & 255;
                l[q++] = m >>> 8 & 255;
                l[q++] = j & 255;
                l[q++] = j >>> 8 & 255;
                if (H) l.set(d, q), q += d.length, l = l.subarray(0, q);else {
                  s = 0;
                  for (n = d.length; s < n; ++s) l[q++] = d[s];
                  l.length = q;
                }
                this.b = q;
                this.a = l;
              }
              break;
            case 1:
              var E = new J(new Uint8Array(this.a.buffer), this.b);
              E.d(1, 1, v);
              E.d(1, 2, v);
              var t = sa(this, f),
                z,
                K,
                A;
              z = 0;
              for (K = t.length; z < K; z++) if (A = t[z], J.prototype.d.apply(E, ra[A]), 256 < A) E.d(t[++z], t[++z], v), E.d(t[++z], 5), E.d(t[++z], t[++z], v);else if (256 === A) break;
              this.a = E.finish();
              this.b = this.a.length;
              break;
            case pa:
              var x = new J(new Uint8Array(this.a), this.b),
                B,
                k,
                p,
                D,
                C,
                da = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],
                W,
                Ma,
                ea,
                Na,
                na,
                va = Array(19),
                Oa,
                $,
                oa,
                F,
                Pa;
              B = pa;
              x.d(1, 1, v);
              x.d(B, 2, v);
              k = sa(this, f);
              W = ta(this.L, 15);
              Ma = ua(W);
              ea = ta(this.K, 7);
              Na = ua(ea);
              for (p = 286; 257 < p && 0 === W[p - 1]; p--);
              for (D = 30; 1 < D && 0 === ea[D - 1]; D--);
              var Qa = p,
                Ra = D,
                M = new (H ? Uint32Array : Array)(Qa + Ra),
                u,
                O,
                w,
                fa,
                L = new (H ? Uint32Array : Array)(316),
                I,
                G,
                P = new (H ? Uint8Array : Array)(19);
              for (u = O = 0; u < Qa; u++) M[O++] = W[u];
              for (u = 0; u < Ra; u++) M[O++] = ea[u];
              if (!H) {
                u = 0;
                for (fa = P.length; u < fa; ++u) P[u] = 0;
              }
              u = I = 0;
              for (fa = M.length; u < fa; u += O) {
                for (O = 1; u + O < fa && M[u + O] === M[u]; ++O);
                w = O;
                if (0 === M[u]) {
                  if (3 > w) for (; 0 < w--;) L[I++] = 0, P[0]++;else for (; 0 < w;) G = 138 > w ? w : 138, G > w - 3 && G < w && (G = w - 3), 10 >= G ? (L[I++] = 17, L[I++] = G - 3, P[17]++) : (L[I++] = 18, L[I++] = G - 11, P[18]++), w -= G;
                } else if (L[I++] = M[u], P[M[u]]++, w--, 3 > w) for (; 0 < w--;) L[I++] = M[u], P[M[u]]++;else for (; 0 < w;) G = 6 > w ? w : 6, G > w - 3 && G < w && (G = w - 3), L[I++] = 16, L[I++] = G - 3, P[16]++, w -= G;
              }
              a = H ? L.subarray(0, I) : L.slice(0, I);
              na = ta(P, 7);
              for (F = 0; 19 > F; F++) va[F] = na[da[F]];
              for (C = 19; 4 < C && 0 === va[C - 1]; C--);
              Oa = ua(na);
              x.d(p - 257, 5, v);
              x.d(D - 1, 5, v);
              x.d(C - 4, 4, v);
              for (F = 0; F < C; F++) x.d(va[F], 3, v);
              F = 0;
              for (Pa = a.length; F < Pa; F++) if ($ = a[F], x.d(Oa[$], na[$], v), 16 <= $) {
                F++;
                switch ($) {
                  case 16:
                    oa = 2;
                    break;
                  case 17:
                    oa = 3;
                    break;
                  case 18:
                    oa = 7;
                    break;
                  default:
                    i("invalid code: " + $);
                }
                x.d(a[F], oa, v);
              }
              var Sa = [Ma, W],
                Ta = [Na, ea],
                Q,
                Ua,
                ga,
                ya,
                Va,
                Wa,
                Xa,
                Ya;
              Va = Sa[0];
              Wa = Sa[1];
              Xa = Ta[0];
              Ya = Ta[1];
              Q = 0;
              for (Ua = k.length; Q < Ua; ++Q) if (ga = k[Q], x.d(Va[ga], Wa[ga], v), 256 < ga) x.d(k[++Q], k[++Q], v), ya = k[++Q], x.d(Xa[ya], Ya[ya], v), x.d(k[++Q], k[++Q], v);else if (256 === ga) break;
              this.a = x.finish();
              this.b = this.a.length;
              break;
            default:
              i("invalid compression type");
          }
          return this.a;
        };
        function wa(a, c) {
          this.length = a;
          this.G = c;
        }
        function xa() {
          var a = za;
          switch (v) {
            case 3 === a:
              return [257, a - 3, 0];
            case 4 === a:
              return [258, a - 4, 0];
            case 5 === a:
              return [259, a - 5, 0];
            case 6 === a:
              return [260, a - 6, 0];
            case 7 === a:
              return [261, a - 7, 0];
            case 8 === a:
              return [262, a - 8, 0];
            case 9 === a:
              return [263, a - 9, 0];
            case 10 === a:
              return [264, a - 10, 0];
            case 12 >= a:
              return [265, a - 11, 1];
            case 14 >= a:
              return [266, a - 13, 1];
            case 16 >= a:
              return [267, a - 15, 1];
            case 18 >= a:
              return [268, a - 17, 1];
            case 22 >= a:
              return [269, a - 19, 2];
            case 26 >= a:
              return [270, a - 23, 2];
            case 30 >= a:
              return [271, a - 27, 2];
            case 34 >= a:
              return [272, a - 31, 2];
            case 42 >= a:
              return [273, a - 35, 3];
            case 50 >= a:
              return [274, a - 43, 3];
            case 58 >= a:
              return [275, a - 51, 3];
            case 66 >= a:
              return [276, a - 59, 3];
            case 82 >= a:
              return [277, a - 67, 4];
            case 98 >= a:
              return [278, a - 83, 4];
            case 114 >= a:
              return [279, a - 99, 4];
            case 130 >= a:
              return [280, a - 115, 4];
            case 162 >= a:
              return [281, a - 131, 5];
            case 194 >= a:
              return [282, a - 163, 5];
            case 226 >= a:
              return [283, a - 195, 5];
            case 257 >= a:
              return [284, a - 227, 5];
            case 258 === a:
              return [285, a - 258, 0];
            default:
              i("invalid length: " + a);
          }
        }
        var Aa = [],
          za,
          Ba;
        for (za = 3; 258 >= za; za++) Ba = xa(), Aa[za] = Ba[2] << 24 | Ba[1] << 16 | Ba[0];
        var Ca = H ? new Uint32Array(Aa) : Aa;
        function sa(a, c) {
          function b(a, c) {
            var b = a.G,
              d = [],
              e = 0,
              f;
            f = Ca[a.length];
            d[e++] = f & 65535;
            d[e++] = f >> 16 & 255;
            d[e++] = f >> 24;
            var g;
            switch (v) {
              case 1 === b:
                g = [0, b - 1, 0];
                break;
              case 2 === b:
                g = [1, b - 2, 0];
                break;
              case 3 === b:
                g = [2, b - 3, 0];
                break;
              case 4 === b:
                g = [3, b - 4, 0];
                break;
              case 6 >= b:
                g = [4, b - 5, 1];
                break;
              case 8 >= b:
                g = [5, b - 7, 1];
                break;
              case 12 >= b:
                g = [6, b - 9, 2];
                break;
              case 16 >= b:
                g = [7, b - 13, 2];
                break;
              case 24 >= b:
                g = [8, b - 17, 3];
                break;
              case 32 >= b:
                g = [9, b - 25, 3];
                break;
              case 48 >= b:
                g = [10, b - 33, 4];
                break;
              case 64 >= b:
                g = [11, b - 49, 4];
                break;
              case 96 >= b:
                g = [12, b - 65, 5];
                break;
              case 128 >= b:
                g = [13, b - 97, 5];
                break;
              case 192 >= b:
                g = [14, b - 129, 6];
                break;
              case 256 >= b:
                g = [15, b - 193, 6];
                break;
              case 384 >= b:
                g = [16, b - 257, 7];
                break;
              case 512 >= b:
                g = [17, b - 385, 7];
                break;
              case 768 >= b:
                g = [18, b - 513, 8];
                break;
              case 1024 >= b:
                g = [19, b - 769, 8];
                break;
              case 1536 >= b:
                g = [20, b - 1025, 9];
                break;
              case 2048 >= b:
                g = [21, b - 1537, 9];
                break;
              case 3072 >= b:
                g = [22, b - 2049, 10];
                break;
              case 4096 >= b:
                g = [23, b - 3073, 10];
                break;
              case 6144 >= b:
                g = [24, b - 4097, 11];
                break;
              case 8192 >= b:
                g = [25, b - 6145, 11];
                break;
              case 12288 >= b:
                g = [26, b - 8193, 12];
                break;
              case 16384 >= b:
                g = [27, b - 12289, 12];
                break;
              case 24576 >= b:
                g = [28, b - 16385, 13];
                break;
              case 32768 >= b:
                g = [29, b - 24577, 13];
                break;
              default:
                i("invalid distance");
            }
            f = g;
            d[e++] = f[0];
            d[e++] = f[1];
            d[e++] = f[2];
            var h, j;
            h = 0;
            for (j = d.length; h < j; ++h) l[q++] = d[h];
            t[d[0]]++;
            z[d[3]]++;
            E = a.length + c - 1;
            n = null;
          }
          var e,
            f,
            d,
            g,
            h,
            m = {},
            j,
            s,
            n,
            l = H ? new Uint16Array(2 * c.length) : [],
            q = 0,
            E = 0,
            t = new (H ? Uint32Array : Array)(286),
            z = new (H ? Uint32Array : Array)(30),
            K = a.w,
            A;
          if (!H) {
            for (d = 0; 285 >= d;) t[d++] = 0;
            for (d = 0; 29 >= d;) z[d++] = 0;
          }
          t[256] = 1;
          e = 0;
          for (f = c.length; e < f; ++e) {
            d = h = 0;
            for (g = 3; d < g && e + d !== f; ++d) h = h << 8 | c[e + d];
            m[h] === r && (m[h] = []);
            j = m[h];
            if (!(0 < E--)) {
              for (; 0 < j.length && 32768 < e - j[0];) j.shift();
              if (e + 3 >= f) {
                n && b(n, -1);
                d = 0;
                for (g = f - e; d < g; ++d) A = c[e + d], l[q++] = A, ++t[A];
                break;
              }
              if (0 < j.length) {
                var x = r,
                  B = r,
                  k = 0,
                  p = r,
                  D = r,
                  C = r,
                  da = r,
                  W = c.length,
                  D = 0,
                  da = j.length;
                a: for (; D < da; D++) {
                  x = j[da - D - 1];
                  p = 3;
                  if (3 < k) {
                    for (C = k; 3 < C; C--) if (c[x + C - 1] !== c[e + C - 1]) continue a;
                    p = k;
                  }
                  for (; 258 > p && e + p < W && c[x + p] === c[e + p];) ++p;
                  p > k && (B = x, k = p);
                  if (258 === p) break;
                }
                s = new wa(k, e - B);
                n ? n.length < s.length ? (A = c[e - 1], l[q++] = A, ++t[A], b(s, 0)) : b(n, -1) : s.length < K ? n = s : b(s, 0);
              } else n ? b(n, -1) : (A = c[e], l[q++] = A, ++t[A]);
            }
            j.push(e);
          }
          l[q++] = 256;
          t[256]++;
          a.L = t;
          a.K = z;
          return H ? l.subarray(0, q) : l;
        }
        function ta(a, c) {
          function b(a) {
            var c = z[a][K[a]];
            c === n ? (b(a + 1), b(a + 1)) : --E[c];
            ++K[a];
          }
          var e = a.length,
            f = new la(572),
            d = new (H ? Uint8Array : Array)(e),
            g,
            h,
            m,
            j,
            s;
          if (!H) for (j = 0; j < e; j++) d[j] = 0;
          for (j = 0; j < e; ++j) 0 < a[j] && f.push(j, a[j]);
          g = Array(f.length / 2);
          h = new (H ? Uint32Array : Array)(f.length / 2);
          if (1 === g.length) return d[f.pop().index] = 1, d;
          j = 0;
          for (s = f.length / 2; j < s; ++j) g[j] = f.pop(), h[j] = g[j].value;
          var n = h.length,
            l = new (H ? Uint16Array : Array)(c),
            q = new (H ? Uint8Array : Array)(c),
            E = new (H ? Uint8Array : Array)(n),
            t = Array(c),
            z = Array(c),
            K = Array(c),
            A = (1 << c) - n,
            x = 1 << c - 1,
            B,
            k,
            p,
            D,
            C;
          l[c - 1] = n;
          for (k = 0; k < c; ++k) A < x ? q[k] = 0 : (q[k] = 1, A -= x), A <<= 1, l[c - 2 - k] = (l[c - 1 - k] / 2 | 0) + n;
          l[0] = q[0];
          t[0] = Array(l[0]);
          z[0] = Array(l[0]);
          for (k = 1; k < c; ++k) l[k] > 2 * l[k - 1] + q[k] && (l[k] = 2 * l[k - 1] + q[k]), t[k] = Array(l[k]), z[k] = Array(l[k]);
          for (B = 0; B < n; ++B) E[B] = c;
          for (p = 0; p < l[c - 1]; ++p) t[c - 1][p] = h[p], z[c - 1][p] = p;
          for (B = 0; B < c; ++B) K[B] = 0;
          1 === q[c - 1] && (--E[0], ++K[c - 1]);
          for (k = c - 2; 0 <= k; --k) {
            D = B = 0;
            C = K[k + 1];
            for (p = 0; p < l[k]; p++) D = t[k + 1][C] + t[k + 1][C + 1], D > h[B] ? (t[k][p] = D, z[k][p] = n, C += 2) : (t[k][p] = h[B], z[k][p] = B, ++B);
            K[k] = 0;
            1 === q[k] && b(k);
          }
          m = E;
          j = 0;
          for (s = g.length; j < s; ++j) d[g[j].index] = m[j];
          return d;
        }
        function ua(a) {
          var c = new (H ? Uint16Array : Array)(a.length),
            b = [],
            e = [],
            f = 0,
            d,
            g,
            h,
            m;
          d = 0;
          for (g = a.length; d < g; d++) b[a[d]] = (b[a[d]] | 0) + 1;
          d = 1;
          for (g = 16; d <= g; d++) e[d] = f, f += b[d] | 0, f > 1 << d && i("overcommitted"), f <<= 1;
          65536 > f && i("undercommitted");
          d = 0;
          for (g = a.length; d < g; d++) {
            f = e[a[d]];
            e[a[d]] += 1;
            h = c[d] = 0;
            for (m = a[d]; h < m; h++) c[d] = c[d] << 1 | f & 1, f >>>= 1;
          }
          return c;
        }
        function Da(a, c) {
          this.input = a;
          this.a = new (H ? Uint8Array : Array)(32768);
          this.h = U.j;
          var b = {},
            e;
          if ((c || !(c = {})) && "number" === typeof c.compressionType) this.h = c.compressionType;
          for (e in c) b[e] = c[e];
          b.outputBuffer = this.a;
          this.z = new ma(this.input, b);
        }
        var U = qa;
        Da.prototype.n = function () {
          var a,
            c,
            b,
            e,
            f,
            d,
            g,
            h = 0;
          g = this.a;
          a = Ea;
          switch (a) {
            case Ea:
              c = Math.LOG2E * Math.log(32768) - 8;
              break;
            default:
              i(Error("invalid compression method"));
          }
          b = c << 4 | a;
          g[h++] = b;
          switch (a) {
            case Ea:
              switch (this.h) {
                case U.NONE:
                  f = 0;
                  break;
                case U.r:
                  f = 1;
                  break;
                case U.j:
                  f = 2;
                  break;
                default:
                  i(Error("unsupported compression type"));
              }
              break;
            default:
              i(Error("invalid compression method"));
          }
          e = f << 6 | 0;
          g[h++] = e | 31 - (256 * b + e) % 31;
          d = ba(this.input);
          this.z.b = h;
          g = this.z.n();
          h = g.length;
          H && (g = new Uint8Array(g.buffer), g.length <= h + 4 && (this.a = new Uint8Array(g.length + 4), this.a.set(g), g = this.a), g = g.subarray(0, h + 4));
          g[h++] = d >> 24 & 255;
          g[h++] = d >> 16 & 255;
          g[h++] = d >> 8 & 255;
          g[h++] = d & 255;
          return g;
        };
        y("Zlib.Deflate", Da);
        y("Zlib.Deflate.compress", function (a, c) {
          return new Da(a, c).n();
        });
        y("Zlib.Deflate.CompressionType", U);
        y("Zlib.Deflate.CompressionType.NONE", U.NONE);
        y("Zlib.Deflate.CompressionType.FIXED", U.r);
        y("Zlib.Deflate.CompressionType.DYNAMIC", U.j);
        function V(a, c) {
          this.k = [];
          this.l = 32768;
          this.e = this.g = this.c = this.q = 0;
          this.input = H ? new Uint8Array(a) : a;
          this.s = !1;
          this.m = Fa;
          this.B = !1;
          if (c || !(c = {})) c.index && (this.c = c.index), c.bufferSize && (this.l = c.bufferSize), c.bufferType && (this.m = c.bufferType), c.resize && (this.B = c.resize);
          switch (this.m) {
            case Ga:
              this.b = 32768;
              this.a = new (H ? Uint8Array : Array)(32768 + this.l + 258);
              break;
            case Fa:
              this.b = 0;
              this.a = new (H ? Uint8Array : Array)(this.l);
              this.f = this.J;
              this.t = this.H;
              this.o = this.I;
              break;
            default:
              i(Error("invalid inflate mode"));
          }
        }
        var Ga = 0,
          Fa = 1,
          Ha = {
            D: Ga,
            C: Fa
          };
        V.prototype.p = function () {
          for (; !this.s;) {
            var a = X(this, 3);
            a & 1 && (this.s = v);
            a >>>= 1;
            switch (a) {
              case 0:
                var c = this.input,
                  b = this.c,
                  e = this.a,
                  f = this.b,
                  d = r,
                  g = r,
                  h = r,
                  m = e.length,
                  j = r;
                this.e = this.g = 0;
                d = c[b++];
                d === r && i(Error("invalid uncompressed block header: LEN (first byte)"));
                g = d;
                d = c[b++];
                d === r && i(Error("invalid uncompressed block header: LEN (second byte)"));
                g |= d << 8;
                d = c[b++];
                d === r && i(Error("invalid uncompressed block header: NLEN (first byte)"));
                h = d;
                d = c[b++];
                d === r && i(Error("invalid uncompressed block header: NLEN (second byte)"));
                h |= d << 8;
                g === ~h && i(Error("invalid uncompressed block header: length verify"));
                b + g > c.length && i(Error("input buffer is broken"));
                switch (this.m) {
                  case Ga:
                    for (; f + g > e.length;) {
                      j = m - f;
                      g -= j;
                      if (H) e.set(c.subarray(b, b + j), f), f += j, b += j;else for (; j--;) e[f++] = c[b++];
                      this.b = f;
                      e = this.f();
                      f = this.b;
                    }
                    break;
                  case Fa:
                    for (; f + g > e.length;) e = this.f({
                      v: 2
                    });
                    break;
                  default:
                    i(Error("invalid inflate mode"));
                }
                if (H) e.set(c.subarray(b, b + g), f), f += g, b += g;else for (; g--;) e[f++] = c[b++];
                this.c = b;
                this.b = f;
                this.a = e;
                break;
              case 1:
                this.o(Ia, Ja);
                break;
              case 2:
                Ka(this);
                break;
              default:
                i(Error("unknown BTYPE: " + a));
            }
          }
          return this.t();
        };
        var La = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],
          Za = H ? new Uint16Array(La) : La,
          $a = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 258, 258],
          ab = H ? new Uint16Array($a) : $a,
          bb = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0],
          cb = H ? new Uint8Array(bb) : bb,
          db = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577],
          eb = H ? new Uint16Array(db) : db,
          fb = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13],
          gb = H ? new Uint8Array(fb) : fb,
          hb = new (H ? Uint8Array : Array)(288),
          Y,
          ib;
        Y = 0;
        for (ib = hb.length; Y < ib; ++Y) hb[Y] = 143 >= Y ? 8 : 255 >= Y ? 9 : 279 >= Y ? 7 : 8;
        var Ia = S(hb),
          jb = new (H ? Uint8Array : Array)(30),
          kb,
          lb;
        kb = 0;
        for (lb = jb.length; kb < lb; ++kb) jb[kb] = 5;
        var Ja = S(jb);
        function X(a, c) {
          for (var b = a.g, e = a.e, f = a.input, d = a.c, g; e < c;) g = f[d++], g === r && i(Error("input buffer is broken")), b |= g << e, e += 8;
          g = b & (1 << c) - 1;
          a.g = b >>> c;
          a.e = e - c;
          a.c = d;
          return g;
        }
        function mb(a, c) {
          for (var b = a.g, e = a.e, f = a.input, d = a.c, g = c[0], h = c[1], m, j, s; e < h;) m = f[d++], m === r && i(Error("input buffer is broken")), b |= m << e, e += 8;
          j = g[b & (1 << h) - 1];
          s = j >>> 16;
          a.g = b >> s;
          a.e = e - s;
          a.c = d;
          return j & 65535;
        }
        function Ka(a) {
          function c(a, b, c) {
            var d, e, f, g;
            for (g = 0; g < a;) switch (d = mb(this, b), d) {
              case 16:
                for (f = 3 + X(this, 2); f--;) c[g++] = e;
                break;
              case 17:
                for (f = 3 + X(this, 3); f--;) c[g++] = 0;
                e = 0;
                break;
              case 18:
                for (f = 11 + X(this, 7); f--;) c[g++] = 0;
                e = 0;
                break;
              default:
                e = c[g++] = d;
            }
            return c;
          }
          var b = X(a, 5) + 257,
            e = X(a, 5) + 1,
            f = X(a, 4) + 4,
            d = new (H ? Uint8Array : Array)(Za.length),
            g,
            h,
            m,
            j;
          for (j = 0; j < f; ++j) d[Za[j]] = X(a, 3);
          g = S(d);
          h = new (H ? Uint8Array : Array)(b);
          m = new (H ? Uint8Array : Array)(e);
          a.o(S(c.call(a, b, g, h)), S(c.call(a, e, g, m)));
        }
        V.prototype.o = function (a, c) {
          var b = this.a,
            e = this.b;
          this.u = a;
          for (var f = b.length - 258, d, g, h, m; 256 !== (d = mb(this, a));) if (256 > d) e >= f && (this.b = e, b = this.f(), e = this.b), b[e++] = d;else {
            g = d - 257;
            m = ab[g];
            0 < cb[g] && (m += X(this, cb[g]));
            d = mb(this, c);
            h = eb[d];
            0 < gb[d] && (h += X(this, gb[d]));
            e >= f && (this.b = e, b = this.f(), e = this.b);
            for (; m--;) b[e] = b[e++ - h];
          }
          for (; 8 <= this.e;) this.e -= 8, this.c--;
          this.b = e;
        };
        V.prototype.I = function (a, c) {
          var b = this.a,
            e = this.b;
          this.u = a;
          for (var f = b.length, d, g, h, m; 256 !== (d = mb(this, a));) if (256 > d) e >= f && (b = this.f(), f = b.length), b[e++] = d;else {
            g = d - 257;
            m = ab[g];
            0 < cb[g] && (m += X(this, cb[g]));
            d = mb(this, c);
            h = eb[d];
            0 < gb[d] && (h += X(this, gb[d]));
            e + m > f && (b = this.f(), f = b.length);
            for (; m--;) b[e] = b[e++ - h];
          }
          for (; 8 <= this.e;) this.e -= 8, this.c--;
          this.b = e;
        };
        V.prototype.f = function () {
          var a = new (H ? Uint8Array : Array)(this.b - 32768),
            c = this.b - 32768,
            b,
            e,
            f = this.a;
          if (H) a.set(f.subarray(32768, a.length));else {
            b = 0;
            for (e = a.length; b < e; ++b) a[b] = f[b + 32768];
          }
          this.k.push(a);
          this.q += a.length;
          if (H) f.set(f.subarray(c, c + 32768));else for (b = 0; 32768 > b; ++b) f[b] = f[c + b];
          this.b = 32768;
          return f;
        };
        V.prototype.J = function (a) {
          var c,
            b = this.input.length / this.c + 1 | 0,
            e,
            f,
            d,
            g = this.input,
            h = this.a;
          a && ("number" === typeof a.v && (b = a.v), "number" === typeof a.F && (b += a.F));
          2 > b ? (e = (g.length - this.c) / this.u[2], d = 258 * (e / 2) | 0, f = d < h.length ? h.length + d : h.length << 1) : f = h.length * b;
          H ? (c = new Uint8Array(f), c.set(h)) : c = h;
          return this.a = c;
        };
        V.prototype.t = function () {
          var a = 0,
            c = this.a,
            b = this.k,
            e,
            f = new (H ? Uint8Array : Array)(this.q + (this.b - 32768)),
            d,
            g,
            h,
            m;
          if (0 === b.length) return H ? this.a.subarray(32768, this.b) : this.a.slice(32768, this.b);
          d = 0;
          for (g = b.length; d < g; ++d) {
            e = b[d];
            h = 0;
            for (m = e.length; h < m; ++h) f[a++] = e[h];
          }
          d = 32768;
          for (g = this.b; d < g; ++d) f[a++] = c[d];
          this.k = [];
          return this.buffer = f;
        };
        V.prototype.H = function () {
          var a,
            c = this.b;
          H ? this.B ? (a = new Uint8Array(c), a.set(this.a.subarray(0, c))) : a = this.a.subarray(0, c) : (this.a.length > c && (this.a.length = c), a = this.a);
          return this.buffer = a;
        };
        function nb(a, c) {
          var b, e;
          this.input = a;
          this.c = 0;
          if (c || !(c = {})) c.index && (this.c = c.index), c.verify && (this.M = c.verify);
          b = a[this.c++];
          e = a[this.c++];
          switch (b & 15) {
            case Ea:
              this.method = Ea;
              break;
            default:
              i(Error("unsupported compression method"));
          }
          0 !== ((b << 8) + e) % 31 && i(Error("invalid fcheck flag:" + ((b << 8) + e) % 31));
          e & 32 && i(Error("fdict flag is not supported"));
          this.A = new V(a, {
            index: this.c,
            bufferSize: c.bufferSize,
            bufferType: c.bufferType,
            resize: c.resize
          });
        }
        nb.prototype.p = function () {
          var a = this.input,
            c,
            b;
          c = this.A.p();
          this.c = this.A.c;
          this.M && (b = (a[this.c++] << 24 | a[this.c++] << 16 | a[this.c++] << 8 | a[this.c++]) >>> 0, b !== ba(c) && i(Error("invalid adler-32 checksum")));
          return c;
        };
        y("Zlib.Inflate", nb);
        y("Zlib.Inflate.BufferType", Ha);
        Ha.ADAPTIVE = Ha.C;
        Ha.BLOCK = Ha.D;
        y("Zlib.Inflate.prototype.decompress", nb.prototype.p);
        var tb = new (H ? Uint8Array : Array)(288),
          Z,
          ub;
        Z = 0;
        for (ub = tb.length; Z < ub; ++Z) tb[Z] = 143 >= Z ? 8 : 255 >= Z ? 9 : 279 >= Z ? 7 : 8;
        S(tb);
        var vb = new (H ? Uint8Array : Array)(30),
          wb,
          xb;
        wb = 0;
        for (xb = vb.length; wb < xb; ++wb) vb[wb] = 5;
        S(vb);
        var Ea = 8;
      }).call(window$1);
      var _p = window$1.Zlib;
      _p.Deflate = _p["Deflate"];
      _p.Deflate.compress = _p.Deflate["compress"];
      _p.Inflate = _p["Inflate"];
      _p.Inflate.BufferType = _p.Inflate["BufferType"];
      _p.Inflate.prototype.decompress = _p.Inflate.prototype["decompress"];

      class PNGReader {
        constructor(data) {
          this.pos = 8;
          this.palette = [];
          this.imgData = [];
          this.text = {};
          this.width = 0;
          this.height = 0;
          this.bits = 0;
          this.colorType = 0;
          this.compressionMethod = 0;
          this.filterMethod = 0;
          this.interlaceMethod = 0;
          this.colors = 0;
          this.hasAlphaChannel = false;
          this.pixelBitlength = 0;
          this.data = data;
          this.transparency = {
            indexed: [],
            rgb: 0,
            grayscale: 0
          };
          let frame;
          let _i = 0;
          let _j = 0;
          let chunkSize = 0;
          while (true) {
            chunkSize = this.readUInt32();
            const section = (() => {
              const _results = [];
              for (_i = 0; _i < 4; ++_i) {
                _results.push(String.fromCharCode(this.data[this.pos++]));
              }
              return _results;
            }).call(this).join('');
            switch (section) {
              case 'IHDR':
                this.width = this.readUInt32();
                this.height = this.readUInt32();
                this.bits = this.data[this.pos++];
                this.colorType = this.data[this.pos++];
                this.compressionMethod = this.data[this.pos++];
                this.filterMethod = this.data[this.pos++];
                this.interlaceMethod = this.data[this.pos++];
                break;
              case 'acTL':
                this.animation = {
                  numFrames: this.readUInt32(),
                  numPlays: this.readUInt32() || Infinity,
                  frames: []
                };
                break;
              case 'PLTE':
                this.palette = this.read(chunkSize);
                break;
              case 'fcTL':
                if (frame) {
                  this.animation.frames.push(frame);
                }
                this.pos += 4;
                frame = {
                  width: this.readUInt32(),
                  height: this.readUInt32(),
                  xOffset: this.readUInt32(),
                  yOffset: this.readUInt32()
                };
                const delayNum = this.readUInt16();
                const delayDen = this.readUInt16() || 100;
                frame.delay = 1000 * delayNum / delayDen;
                frame.disposeOp = this.data[this.pos++];
                frame.blendOp = this.data[this.pos++];
                frame.data = [];
                break;
              case 'IDAT':
              case 'fdAT':
                if (section === 'fdAT') {
                  this.pos += 4;
                  chunkSize -= 4;
                }
                data = (frame != null ? frame.data : void 0) || this.imgData;
                for (_i = 0; chunkSize >= 0 ? _i < chunkSize : _i > chunkSize; chunkSize >= 0 ? ++_i : --_i) {
                  data.push(this.data[this.pos++]);
                }
                break;
              case 'tRNS':
                this.transparency = {};
                switch (this.colorType) {
                  case 3:
                    this.transparency.indexed = this.read(chunkSize);
                    const ccshort = 255 - this.transparency.indexed.length;
                    if (ccshort > 0) {
                      for (_j = 0; ccshort >= 0 ? _j < ccshort : _j > ccshort; ccshort >= 0 ? ++_j : --_j) {
                        this.transparency.indexed.push(255);
                      }
                    }
                    break;
                  case 0:
                    this.transparency.grayscale = this.read(chunkSize)[0];
                    break;
                  case 2:
                    this.transparency.rgb = this.read(chunkSize);
                }
                break;
              case 'tEXt':
                const text = this.read(chunkSize);
                const index = text.indexOf(0);
                const key = String.fromCharCode.apply(String, text.slice(0, index));
                this.text[key] = String.fromCharCode.apply(String, text.slice(index + 1));
                break;
              case 'IEND':
                if (frame) {
                  this.animation.frames.push(frame);
                }
                this.colors = (() => {
                  switch (this.colorType) {
                    case 0:
                    case 3:
                    case 4:
                      return 1;
                    case 2:
                    case 6:
                      return 3;
                  }
                }).call(this);
                const _ref = this.colorType;
                this.hasAlphaChannel = _ref === 4 || _ref === 6;
                const colors = this.colors + (this.hasAlphaChannel ? 1 : 0);
                this.pixelBitlength = this.bits * colors;
                this.colorSpace = (() => {
                  switch (this.colors) {
                    case 1:
                      return 'DeviceGray';
                    case 3:
                      return 'DeviceRGB';
                  }
                }).call(this);
                if (!(this.imgData instanceof Uint8Array)) {
                  this.imgData = new Uint8Array(this.imgData);
                }
                return;
              default:
                this.pos += chunkSize;
            }
            this.pos += 4;
            if (this.pos > this.data.length) {
              throw new Error(getError(6017));
            }
          }
        }
        read(bytes) {
          let _i = 0;
          const _results = [];
          for (_i = 0; bytes >= 0 ? _i < bytes : _i > bytes; bytes >= 0 ? ++_i : --_i) {
            _results.push(this.data[this.pos++]);
          }
          return _results;
        }
        readUInt32() {
          const b1 = this.data[this.pos++] << 24;
          const b2 = this.data[this.pos++] << 16;
          const b3 = this.data[this.pos++] << 8;
          const b4 = this.data[this.pos++];
          return b1 | b2 | b3 | b4;
        }
        readUInt16() {
          const b1 = this.data[this.pos++] << 8;
          const b2 = this.data[this.pos++];
          return b1 | b2;
        }
        decodePixels(data) {
          if (data == null) {
            data = this.imgData;
          }
          if (data.length === 0) {
            return new Uint8Array(0);
          }
          const inflate = new _p.Inflate(data, {
            index: 0,
            verify: false
          });
          data = inflate.decompress();
          const pixelBytes = this.pixelBitlength / 8;
          const scanlineLength = pixelBytes * this.width;
          const pixels = new Uint8Array(scanlineLength * this.height);
          const length = data.length;
          let row = 0;
          let pos = 0;
          let c = 0;
          let ccbyte = 0;
          let col = 0;
          let i = 0;
          let _i = 0;
          let _j = 0;
          let _k = 0;
          let _l = 0;
          let _m = 0;
          let left = 0;
          let p = 0;
          let pa = 0;
          let paeth = 0;
          let pb = 0;
          let pc = 0;
          let upper = 0;
          let upperLeft = 0;
          while (pos < length) {
            switch (data[pos++]) {
              case 0:
                for (i = _i = 0; _i < scanlineLength; i = _i += 1) {
                  pixels[c++] = data[pos++];
                }
                break;
              case 1:
                for (i = _j = 0; _j < scanlineLength; i = _j += 1) {
                  ccbyte = data[pos++];
                  left = i < pixelBytes ? 0 : pixels[c - pixelBytes];
                  pixels[c++] = (ccbyte + left) % 256;
                }
                break;
              case 2:
                for (i = _k = 0; _k < scanlineLength; i = _k += 1) {
                  ccbyte = data[pos++];
                  col = (i - i % pixelBytes) / pixelBytes;
                  upper = row && pixels[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];
                  pixels[c++] = (upper + ccbyte) % 256;
                }
                break;
              case 3:
                for (i = _l = 0; _l < scanlineLength; i = _l += 1) {
                  ccbyte = data[pos++];
                  col = (i - i % pixelBytes) / pixelBytes;
                  left = i < pixelBytes ? 0 : pixels[c - pixelBytes];
                  upper = row && pixels[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];
                  pixels[c++] = (ccbyte + Math.floor((left + upper) / 2)) % 256;
                }
                break;
              case 4:
                for (i = _m = 0; _m < scanlineLength; i = _m += 1) {
                  ccbyte = data[pos++];
                  col = (i - i % pixelBytes) / pixelBytes;
                  left = i < pixelBytes ? 0 : pixels[c - pixelBytes];
                  if (row === 0) {
                    upper = upperLeft = 0;
                  } else {
                    upper = pixels[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];
                    upperLeft = col && pixels[(row - 1) * scanlineLength + (col - 1) * pixelBytes + i % pixelBytes];
                  }
                  p = left + upper - upperLeft;
                  pa = Math.abs(p - left);
                  pb = Math.abs(p - upper);
                  pc = Math.abs(p - upperLeft);
                  if (pa <= pb && pa <= pc) {
                    paeth = left;
                  } else if (pb <= pc) {
                    paeth = upper;
                  } else {
                    paeth = upperLeft;
                  }
                  pixels[c++] = (ccbyte + paeth) % 256;
                }
                break;
              default:
                throw new Error(getError(6018, data[pos - 1]));
            }
            row++;
          }
          return pixels;
        }
        copyToImageData(imageData, pixels) {
          let alpha = this.hasAlphaChannel;
          let palette;
          let colors = this.colors;
          if (this.palette.length) {
            palette = this._decodedPalette != null ? this._decodedPalette : this._decodedPalette = this.decodePalette();
            colors = 4;
            alpha = true;
          }
          const data = imageData.data || imageData;
          const length = data.length;
          const input = palette || pixels;
          let i = 0;
          let j = 0;
          let k = 0;
          let v = 0;
          if (colors === 1) {
            while (i < length) {
              k = palette ? pixels[i / 4] * 4 : j;
              v = input[k++];
              data[i++] = v;
              data[i++] = v;
              data[i++] = v;
              data[i++] = alpha ? input[k++] : 255;
              j = k;
            }
          } else {
            while (i < length) {
              k = palette ? pixels[i / 4] * 4 : j;
              data[i++] = input[k++];
              data[i++] = input[k++];
              data[i++] = input[k++];
              data[i++] = alpha ? input[k++] : 255;
              j = k;
            }
          }
        }
        decodePalette() {
          const palette = this.palette;
          const transparency = this.transparency.indexed || [];
          const ret = new Uint8Array((transparency.length || 0) + palette.length);
          let pos = 0;
          let c = 0;
          let _ref1 = 0;
          for (let i = 0, _i = 0, _ref = palette.length; _i < _ref; i = _i += 3) {
            ret[pos++] = palette[i];
            ret[pos++] = palette[i + 1];
            ret[pos++] = palette[i + 2];
            _ref1 = transparency[c++];
            ret[pos++] = _ref1 != null ? _ref1 : 255;
          }
          return ret;
        }
        render(canvas) {
          canvas.width = this.width;
          canvas.height = this.height;
          const ctx = canvas.getContext('2d');
          const data = ctx.createImageData(this.width, this.height);
          this.copyToImageData(data, this.decodePixels(null));
          return ctx.putImageData(data, 0, 0);
        }
      }

      class TiffReader {
        constructor() {
          this._littleEndian = false;
          this._tiffData = [];
          this._fileDirectories = [];
        }
        getUint8(offset) {
          return this._tiffData[offset];
        }
        getUint16(offset) {
          if (this._littleEndian) return this._tiffData[offset + 1] << 8 | this._tiffData[offset];else return this._tiffData[offset] << 8 | this._tiffData[offset + 1];
        }
        getUint32(offset) {
          const a = this._tiffData;
          if (this._littleEndian) return a[offset + 3] << 24 | a[offset + 2] << 16 | a[offset + 1] << 8 | a[offset];else return a[offset] << 24 | a[offset + 1] << 16 | a[offset + 2] << 8 | a[offset + 3];
        }
        checkLittleEndian() {
          const BOM = this.getUint16(0);
          if (BOM === 0x4949) {
            this._littleEndian = true;
          } else if (BOM === 0x4D4D) {
            this._littleEndian = false;
          } else {
            console.log(BOM);
            throw TypeError(getError(6019));
          }
          return this._littleEndian;
        }
        hasTowel() {
          if (this.getUint16(2) !== 42) {
            throw RangeError(getError(6020));
          }
          return true;
        }
        getFieldTypeName(fieldType) {
          const typeNames = fieldTypeNames;
          if (fieldType in typeNames) {
            return typeNames[fieldType];
          }
          return null;
        }
        getFieldTagName(fieldTag) {
          const tagNames = fieldTagNames;
          if (fieldTag in tagNames) {
            return tagNames[fieldTag];
          } else {
            logID(6021, fieldTag);
            return `Tag${fieldTag}`;
          }
        }
        getFieldTypeLength(fieldTypeName) {
          if (['BYTE', 'ASCII', 'SBYTE', 'UNDEFINED'].indexOf(fieldTypeName) !== -1) {
            return 1;
          } else if (['SHORT', 'SSHORT'].indexOf(fieldTypeName) !== -1) {
            return 2;
          } else if (['LONG', 'SLONG', 'FLOAT'].indexOf(fieldTypeName) !== -1) {
            return 4;
          } else if (['RATIONAL', 'SRATIONAL', 'DOUBLE'].indexOf(fieldTypeName) !== -1) {
            return 8;
          }
          return 0;
        }
        getFieldValues(fieldTagName, fieldTypeName, typeCount, valueOffset) {
          const fieldValues = [];
          const fieldTypeLength = this.getFieldTypeLength(fieldTypeName);
          const fieldValueSize = fieldTypeLength * typeCount;
          if (fieldValueSize <= 4) {
            if (this._littleEndian === false) fieldValues.push(valueOffset >>> (4 - fieldTypeLength) * 8);else fieldValues.push(valueOffset);
          } else {
            for (let i = 0; i < typeCount; i++) {
              const indexOffset = fieldTypeLength * i;
              if (fieldTypeLength >= 8) {
                if (['RATIONAL', 'SRATIONAL'].indexOf(fieldTypeName) !== -1) {
                  fieldValues.push(this.getUint32(valueOffset + indexOffset));
                  fieldValues.push(this.getUint32(valueOffset + indexOffset + 4));
                } else {
                  logID(8000);
                }
              } else {
                fieldValues.push(this.getBytes(fieldTypeLength, valueOffset + indexOffset));
              }
            }
          }
          if (fieldTypeName === 'ASCII') {
            fieldValues.forEach((e, i, a) => {
              a[i] = String.fromCharCode(e);
            });
          }
          return fieldValues;
        }
        getBytes(numBytes, offset) {
          if (numBytes <= 0) {
            logID(8001);
          } else if (numBytes <= 1) {
            return this.getUint8(offset);
          } else if (numBytes <= 2) {
            return this.getUint16(offset);
          } else if (numBytes <= 3) {
            return this.getUint32(offset) >>> 8;
          } else if (numBytes <= 4) {
            return this.getUint32(offset);
          } else {
            logID(8002);
          }
          return 0;
        }
        getBits(numBits, byteOffset, bitOffset) {
          bitOffset = bitOffset || 0;
          const extraBytes = Math.floor(bitOffset / 8);
          const newByteOffset = byteOffset + extraBytes;
          const totalBits = bitOffset + numBits;
          const shiftRight = 32 - numBits;
          let shiftLeft = 0;
          let rawBits = 0;
          if (totalBits <= 0) {
            logID(6023);
          } else if (totalBits <= 8) {
            shiftLeft = 24 + bitOffset;
            rawBits = this.getUint8(newByteOffset);
          } else if (totalBits <= 16) {
            shiftLeft = 16 + bitOffset;
            rawBits = this.getUint16(newByteOffset);
          } else if (totalBits <= 32) {
            shiftLeft = bitOffset;
            rawBits = this.getUint32(newByteOffset);
          } else {
            logID(6022);
          }
          return {
            bits: rawBits << shiftLeft >>> shiftRight,
            byteOffset: newByteOffset + Math.floor(totalBits / 8),
            bitOffset: totalBits % 8
          };
        }
        parseFileDirectory(offset) {
          const numDirEntries = this.getUint16(offset);
          const tiffFields = [];
          let i = 0;
          let entryCount = 0;
          for (i = offset + 2, entryCount = 0; entryCount < numDirEntries; i += 12, entryCount++) {
            const fieldTag = this.getUint16(i);
            const fieldType = this.getUint16(i + 2);
            const typeCount = this.getUint32(i + 4);
            const valueOffset = this.getUint32(i + 8);
            const fieldTagName = this.getFieldTagName(fieldTag);
            const fieldTypeName = this.getFieldTypeName(fieldType);
            const fieldValues = this.getFieldValues(fieldTagName, fieldTypeName, typeCount, valueOffset);
            tiffFields[fieldTagName] = {
              type: fieldTypeName,
              values: fieldValues
            };
          }
          this._fileDirectories.push(tiffFields);
          const nextIFDByteOffset = this.getUint32(i);
          if (nextIFDByteOffset !== 0x00000000) {
            this.parseFileDirectory(nextIFDByteOffset);
          }
        }
        clampColorSample(colorSample, bitsPerSample) {
          const multiplier = Math.pow(2, 8 - bitsPerSample);
          return Math.floor(colorSample * multiplier + (multiplier - 1));
        }
        parseTIFF(tiffData, canvas) {
          canvas = canvas || ccwindow$1.document.createElement('canvas');
          this._tiffData = tiffData;
          this._canvas = canvas;
          this.checkLittleEndian();
          if (!this.hasTowel()) {
            return;
          }
          const firstIFDByteOffset = this.getUint32(4);
          this._fileDirectories.length = 0;
          this.parseFileDirectory(firstIFDByteOffset);
          const fileDirectory = this._fileDirectories[0];
          const imageWidth = fileDirectory.ImageWidth.values[0];
          const imageLength = fileDirectory.ImageLength.values[0];
          this._canvas.width = imageWidth;
          this._canvas.height = imageLength;
          const strips = [];
          const compression = fileDirectory.Compression ? fileDirectory.Compression.values[0] : 1;
          const samplesPerPixel = fileDirectory.SamplesPerPixel.values[0];
          const sampleProperties = [];
          let bitsPerPixel = 0;
          let hasBytesPerPixel = false;
          fileDirectory.BitsPerSample.values.forEach((bitsPerSample, i, bitsPerSampleValues) => {
            sampleProperties[i] = {
              bitsPerSample,
              hasBytesPerSample: false,
              bytesPerSample: undefined
            };
            if (bitsPerSample % 8 === 0) {
              sampleProperties[i].hasBytesPerSample = true;
              sampleProperties[i].bytesPerSample = bitsPerSample / 8;
            }
            bitsPerPixel += bitsPerSample;
          }, this);
          let bytesPerPixel = 0;
          if (bitsPerPixel % 8 === 0) {
            hasBytesPerPixel = true;
            bytesPerPixel = bitsPerPixel / 8;
          }
          const stripOffsetValues = fileDirectory.StripOffsets.values;
          const numStripOffsetValues = stripOffsetValues.length;
          let stripByteCountValues;
          if (fileDirectory.StripByteCounts) {
            stripByteCountValues = fileDirectory.StripByteCounts.values;
          } else {
            logID(8003);
            if (numStripOffsetValues === 1) {
              stripByteCountValues = [Math.ceil(imageWidth * imageLength * bitsPerPixel / 8)];
            } else {
              throw Error(getError(6024));
            }
          }
          let blockLength = 1;
          let iterations = 1;
          for (let i = 0; i < numStripOffsetValues; i++) {
            const stripOffset = stripOffsetValues[i];
            strips[i] = [];
            const stripByteCount = stripByteCountValues[i];
            for (let byteOffset = 0, bitOffset = 0, jIncrement = 1, getHeader = true, pixel = [], numBytes = 0, sample = 0, currentSample = 0; byteOffset < stripByteCount; byteOffset += jIncrement) {
              switch (compression) {
                case 1:
                  pixel = [];
                  for (let m = 0; m < samplesPerPixel; m++) {
                    const s = sampleProperties[m];
                    if (s.hasBytesPerSample) {
                      const sampleOffset = s.bytesPerSample * m;
                      pixel.push(this.getBytes(s.bytesPerSample, stripOffset + byteOffset + sampleOffset));
                    } else {
                      const sampleInfo = this.getBits(s.bitsPerSample, stripOffset + byteOffset, bitOffset);
                      pixel.push(sampleInfo.bits);
                      byteOffset = sampleInfo.byteOffset - stripOffset;
                      bitOffset = sampleInfo.bitOffset;
                      throw RangeError(getError(6025));
                    }
                  }
                  strips[i].push(pixel);
                  if (hasBytesPerPixel) {
                    jIncrement = bytesPerPixel;
                  } else {
                    jIncrement = 0;
                    throw RangeError(getError(6026));
                  }
                  break;
                case 2:
                  break;
                case 3:
                  break;
                case 4:
                  break;
                case 5:
                  break;
                case 6:
                  break;
                case 7:
                  break;
                case 32773:
                  if (getHeader) {
                    getHeader = false;
                    const header = this.getUint8(stripOffset + byteOffset);
                    if (header >= 0 && header <= 127) {
                      blockLength = header + 1;
                    } else if (header >= -127 && header <= -1) {
                      iterations = -header + 1;
                    } else {
                        getHeader = true;
                      }
                  } else {
                    const currentByte = this.getUint8(stripOffset + byteOffset);
                    for (let m = 0; m < iterations; m++) {
                      const s = sampleProperties[sample];
                      if (s.hasBytesPerSample) {
                        currentSample = currentSample << 8 * numBytes | currentByte;
                        numBytes++;
                        if (numBytes === s.bytesPerSample) {
                          pixel.push(currentSample);
                          currentSample = numBytes = 0;
                          sample++;
                        }
                      } else {
                        throw RangeError(getError(6025));
                      }
                      if (sample === samplesPerPixel) {
                        strips[i].push(pixel);
                        pixel = [];
                        sample = 0;
                      }
                    }
                    blockLength--;
                    if (blockLength === 0) {
                      getHeader = true;
                    }
                  }
                  jIncrement = 1;
                  break;
              }
            }
          }
          if (canvas.getContext) {
            const ctx = this._canvas.getContext('2d');
            ctx.fillStyle = 'rgba(255, 255, 255, 0)';
            const rowsPerStrip = fileDirectory.RowsPerStrip ? fileDirectory.RowsPerStrip.values[0] : imageLength;
            const numStrips = strips.length;
            const imageLengthModRowsPerStrip = imageLength % rowsPerStrip;
            const rowsInLastStrip = imageLengthModRowsPerStrip === 0 ? rowsPerStrip : imageLengthModRowsPerStrip;
            let numRowsInStrip = rowsPerStrip;
            let numRowsInPreviousStrip = 0;
            const photometricInterpretation = fileDirectory.PhotometricInterpretation.values[0];
            let extraSamplesValues = [];
            let numExtraSamples = 0;
            if (fileDirectory.ExtraSamples) {
              extraSamplesValues = fileDirectory.ExtraSamples.values;
              numExtraSamples = extraSamplesValues.length;
            }
            let colorMapValues = [];
            let colorMapSampleSize = 0;
            if (fileDirectory.ColorMap) {
              colorMapValues = fileDirectory.ColorMap.values;
              colorMapSampleSize = Math.pow(2, sampleProperties[0].bitsPerSample);
            }
            for (let i = 0; i < numStrips; i++) {
              if (i + 1 === numStrips) {
                numRowsInStrip = rowsInLastStrip;
              }
              const numPixels = strips[i].length;
              const yPadding = numRowsInPreviousStrip * i;
              for (let y = 0, j = 0; y < numRowsInStrip && j < numPixels; y++) {
                for (let x = 0; x < imageWidth; x++, j++) {
                  const pixelSamples = strips[i][j];
                  let red = 0;
                  let green = 0;
                  let blue = 0;
                  let opacity = 1.0;
                  if (numExtraSamples > 0) {
                    for (let k = 0; k < numExtraSamples; k++) {
                      if (extraSamplesValues[k] === 1 || extraSamplesValues[k] === 2) {
                        opacity = pixelSamples[3 + k] / 256;
                        break;
                      }
                    }
                  }
                  switch (photometricInterpretation) {
                    case 0:
                      let invertValue = 0;
                      if (sampleProperties[0].hasBytesPerSample) {
                        invertValue = Math.pow(0x10, sampleProperties[0].bytesPerSample * 2);
                      }
                      pixelSamples.forEach((sample, index, samples) => {
                        samples[index] = invertValue - sample;
                      });
                    case 1:
                      red = green = blue = this.clampColorSample(pixelSamples[0], sampleProperties[0].bitsPerSample);
                      break;
                    case 2:
                      red = this.clampColorSample(pixelSamples[0], sampleProperties[0].bitsPerSample);
                      green = this.clampColorSample(pixelSamples[1], sampleProperties[1].bitsPerSample);
                      blue = this.clampColorSample(pixelSamples[2], sampleProperties[2].bitsPerSample);
                      break;
                    case 3:
                      if (colorMapValues === undefined) {
                        throw Error(getError(6027));
                      }
                      const colorMapIndex = pixelSamples[0];
                      red = this.clampColorSample(colorMapValues[colorMapIndex], 16);
                      green = this.clampColorSample(colorMapValues[colorMapSampleSize + colorMapIndex], 16);
                      blue = this.clampColorSample(colorMapValues[2 * colorMapSampleSize + colorMapIndex], 16);
                      break;
                    default:
                      throw RangeError(getError(6028, photometricInterpretation));
                  }
                  ctx.fillStyle = `rgba(${red}, ${green}, ${blue}, ${opacity})`;
                  ctx.fillRect(x, yPadding + y, 1, 1);
                }
              }
              numRowsInPreviousStrip = numRowsInStrip;
            }
          }
          return this._canvas;
        }
      }
      const fieldTagNames = {
        0x013B: 'Artist',
        0x0102: 'BitsPerSample',
        0x0109: 'CellLength',
        0x0108: 'CellWidth',
        0x0140: 'ColorMap',
        0x0103: 'Compression',
        0x8298: 'Copyright',
        0x0132: 'DateTime',
        0x0152: 'ExtraSamples',
        0x010A: 'FillOrder',
        0x0121: 'FreeByteCounts',
        0x0120: 'FreeOffsets',
        0x0123: 'GrayResponseCurve',
        0x0122: 'GrayResponseUnit',
        0x013C: 'HostComputer',
        0x010E: 'ImageDescription',
        0x0101: 'ImageLength',
        0x0100: 'ImageWidth',
        0x010F: 'Make',
        0x0119: 'MaxSampleValue',
        0x0118: 'MinSampleValue',
        0x0110: 'Model',
        0x00FE: 'NewSubfileType',
        0x0112: 'Orientation',
        0x0106: 'PhotometricInterpretation',
        0x011C: 'PlanarConfiguration',
        0x0128: 'ResolutionUnit',
        0x0116: 'RowsPerStrip',
        0x0115: 'SamplesPerPixel',
        0x0131: 'Software',
        0x0117: 'StripByteCounts',
        0x0111: 'StripOffsets',
        0x00FF: 'SubfileType',
        0x0107: 'Threshholding',
        0x011A: 'XResolution',
        0x011B: 'YResolution',
        0x0146: 'BadFaxLines',
        0x0147: 'CleanFaxData',
        0x0157: 'ClipPath',
        0x0148: 'ConsecutiveBadFaxLines',
        0x01B1: 'Decode',
        0x01B2: 'DefaultImageColor',
        0x010D: 'DocumentName',
        0x0150: 'DotRange',
        0x0141: 'HalftoneHints',
        0x015A: 'Indexed',
        0x015B: 'JPEGTables',
        0x011D: 'PageName',
        0x0129: 'PageNumber',
        0x013D: 'Predictor',
        0x013F: 'PrimaryChromaticities',
        0x0214: 'ReferenceBlackWhite',
        0x0153: 'SampleFormat',
        0x022F: 'StripRowCounts',
        0x014A: 'SubIFDs',
        0x0124: 'T4Options',
        0x0125: 'T6Options',
        0x0145: 'TileByteCounts',
        0x0143: 'TileLength',
        0x0144: 'TileOffsets',
        0x0142: 'TileWidth',
        0x012D: 'TransferFunction',
        0x013E: 'WhitePoint',
        0x0158: 'XClipPathUnits',
        0x011E: 'XPosition',
        0x0211: 'YCbCrCoefficients',
        0x0213: 'YCbCrPositioning',
        0x0212: 'YCbCrSubSampling',
        0x0159: 'YClipPathUnits',
        0x011F: 'YPosition',
        0x9202: 'ApertureValue',
        0xA001: 'ColorSpace',
        0x9004: 'DateTimeDigitized',
        0x9003: 'DateTimeOriginal',
        0x8769: 'Exif IFD',
        0x9000: 'ExifVersion',
        0x829A: 'ExposureTime',
        0xA300: 'FileSource',
        0x9209: 'Flash',
        0xA000: 'FlashpixVersion',
        0x829D: 'FNumber',
        0xA420: 'ImageUniqueID',
        0x9208: 'LightSource',
        0x927C: 'MakerNote',
        0x9201: 'ShutterSpeedValue',
        0x9286: 'UserComment',
        0x83BB: 'IPTC',
        0x8773: 'ICC Profile',
        0x02BC: 'XMP',
        0xA480: 'GDAL_METADATA',
        0xA481: 'GDAL_NODATA',
        0x8649: 'Photoshop'
      };
      const fieldTypeNames = {
        0x0001: 'BYTE',
        0x0002: 'ASCII',
        0x0003: 'SHORT',
        0x0004: 'LONG',
        0x0005: 'RATIONAL',
        0x0006: 'SBYTE',
        0x0007: 'UNDEFINED',
        0x0008: 'SSHORT',
        0x0009: 'SLONG',
        0x000A: 'SRATIONAL',
        0x000B: 'FLOAT',
        0x000C: 'DOUBLE'
      };

      const BASE64_KEYS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
      const BASE64_VALUES = new Array(123);
      for (let i = 0; i < 123; ++i) {
        BASE64_VALUES[i] = 64;
      }
      for (let i = 0; i < 64; ++i) {
        BASE64_VALUES[BASE64_KEYS.charCodeAt(i)] = i;
      }

      var Base64 = {
        name: 'Jacob__Codec__Base64'
      };
      Base64.decode = function Jacob__Codec__Base64__decode(input) {
        var output = [],
          chr1,
          chr2,
          chr3,
          enc1,
          enc2,
          enc3,
          enc4,
          i = 0;
        input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
        while (i < input.length) {
          enc1 = BASE64_VALUES[input.charCodeAt(i++)];
          enc2 = BASE64_VALUES[input.charCodeAt(i++)];
          enc3 = BASE64_VALUES[input.charCodeAt(i++)];
          enc4 = BASE64_VALUES[input.charCodeAt(i++)];
          chr1 = enc1 << 2 | enc2 >> 4;
          chr2 = (enc2 & 15) << 4 | enc3 >> 2;
          chr3 = (enc3 & 3) << 6 | enc4;
          output.push(String.fromCharCode(chr1));
          if (enc3 !== 64) {
            output.push(String.fromCharCode(chr2));
          }
          if (enc4 !== 64) {
            output.push(String.fromCharCode(chr3));
          }
        }
        output = output.join('');
        return output;
      };
      Base64.decodeAsArray = function Jacob__Codec__Base64___decodeAsArray(input, bytes) {
        var dec = this.decode(input),
          ar = [],
          i,
          j,
          len;
        for (i = 0, len = dec.length / bytes; i < len; i++) {
          ar[i] = 0;
          for (j = bytes - 1; j >= 0; --j) {
            ar[i] += dec.charCodeAt(i * bytes + j) << j * 8;
          }
        }
        return ar;
      };

      var GZip = function Jacob__GZip(data) {
        this.data = data;
        this.debug = false;
        this.gpflags = undefined;
        this.files = 0;
        this.unzipped = [];
        this.buf32k = new Array(32768);
        this.bIdx = 0;
        this.modeZIP = false;
        this.bytepos = 0;
        this.bb = 1;
        this.bits = 0;
        this.nameBuf = [];
        this.fileout = undefined;
        this.literalTree = new Array(GZip.LITERALS);
        this.distanceTree = new Array(32);
        this.treepos = 0;
        this.Places = null;
        this.len = 0;
        this.fpos = new Array(17);
        this.fpos[0] = 0;
        this.flens = undefined;
        this.fmax = undefined;
      };
      GZip.gunzip = function (string) {
        if (string.constructor === Array) ; else if (string.constructor === String) ;
        var gzip = new GZip(string);
        return gzip.gunzip()[0][0];
      };
      GZip.HufNode = function () {
        this.b0 = 0;
        this.b1 = 0;
        this.jump = null;
        this.jumppos = -1;
      };
      GZip.LITERALS = 288;
      GZip.NAMEMAX = 256;
      GZip.bitReverse = [0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0, 0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0, 0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8, 0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8, 0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4, 0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4, 0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec, 0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc, 0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2, 0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2, 0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea, 0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa, 0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6, 0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6, 0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee, 0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe, 0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1, 0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1, 0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9, 0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9, 0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5, 0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5, 0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed, 0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd, 0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3, 0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3, 0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb, 0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb, 0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7, 0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7, 0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef, 0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff];
      GZip.cplens = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0];
      GZip.cplext = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 99, 99];
      GZip.cpdist = [0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0007, 0x0009, 0x000d, 0x0011, 0x0019, 0x0021, 0x0031, 0x0041, 0x0061, 0x0081, 0x00c1, 0x0101, 0x0181, 0x0201, 0x0301, 0x0401, 0x0601, 0x0801, 0x0c01, 0x1001, 0x1801, 0x2001, 0x3001, 0x4001, 0x6001];
      GZip.cpdext = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
      GZip.border = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
      GZip.prototype.gunzip = function () {
        this.outputArr = [];
        this.nextFile();
        return this.unzipped;
      };
      GZip.prototype.readByte = function () {
        this.bits += 8;
        if (this.bytepos < this.data.length) {
          return this.data.charCodeAt(this.bytepos++);
        } else {
          return -1;
        }
      };
      GZip.prototype.byteAlign = function () {
        this.bb = 1;
      };
      GZip.prototype.readBit = function () {
        var carry;
        this.bits++;
        carry = this.bb & 1;
        this.bb >>= 1;
        if (this.bb === 0) {
          this.bb = this.readByte();
          carry = this.bb & 1;
          this.bb = this.bb >> 1 | 0x80;
        }
        return carry;
      };
      GZip.prototype.readBits = function (a) {
        var res = 0,
          i = a;
        while (i--) res = res << 1 | this.readBit();
        if (a) res = GZip.bitReverse[res] >> 8 - a;
        return res;
      };
      GZip.prototype.flushBuffer = function () {
        this.bIdx = 0;
      };
      GZip.prototype.addBuffer = function (a) {
        this.buf32k[this.bIdx++] = a;
        this.outputArr.push(String.fromCharCode(a));
        if (this.bIdx === 0x8000) this.bIdx = 0;
      };
      GZip.prototype.IsPat = function () {
        while (1) {
          if (this.fpos[this.len] >= this.fmax) return -1;
          if (this.flens[this.fpos[this.len]] === this.len) return this.fpos[this.len]++;
          this.fpos[this.len]++;
        }
      };
      GZip.prototype.Rec = function () {
        var curplace = this.Places[this.treepos];
        var tmp;
        if (this.len === 17) {
          return -1;
        }
        this.treepos++;
        this.len++;
        tmp = this.IsPat();
        if (tmp >= 0) {
          curplace.b0 = tmp;
        } else {
          curplace.b0 = 0x8000;
          if (this.Rec()) return -1;
        }
        tmp = this.IsPat();
        if (tmp >= 0) {
          curplace.b1 = tmp;
          curplace.jump = null;
        } else {
          curplace.b1 = 0x8000;
          curplace.jump = this.Places[this.treepos];
          curplace.jumppos = this.treepos;
          if (this.Rec()) return -1;
        }
        this.len--;
        return 0;
      };
      GZip.prototype.CreateTree = function (currentTree, numval, lengths, show) {
        var i;
        this.Places = currentTree;
        this.treepos = 0;
        this.flens = lengths;
        this.fmax = numval;
        for (i = 0; i < 17; i++) this.fpos[i] = 0;
        this.len = 0;
        if (this.Rec()) {
          return -1;
        }
        return 0;
      };
      GZip.prototype.DecodeValue = function (currentTree) {
        var len,
          i,
          xtreepos = 0,
          X = currentTree[xtreepos],
          b;
        while (1) {
          b = this.readBit();
          if (b) {
            if (!(X.b1 & 0x8000)) {
              return X.b1;
            }
            X = X.jump;
            len = currentTree.length;
            for (i = 0; i < len; i++) {
              if (currentTree[i] === X) {
                xtreepos = i;
                break;
              }
            }
          } else {
            if (!(X.b0 & 0x8000)) {
              return X.b0;
            }
            xtreepos++;
            X = currentTree[xtreepos];
          }
        }
        return -1;
      };
      GZip.prototype.DeflateLoop = function () {
        var last, c, type, i, len;
        do {
          last = this.readBit();
          type = this.readBits(2);
          if (type === 0) {
            var blockLen, cSum;
            this.byteAlign();
            blockLen = this.readByte();
            blockLen |= this.readByte() << 8;
            cSum = this.readByte();
            cSum |= this.readByte() << 8;
            if ((blockLen ^ ~cSum) & 0xffff) {
              document.write("BlockLen checksum mismatch\n");
            }
            while (blockLen--) {
              c = this.readByte();
              this.addBuffer(c);
            }
          } else if (type === 1) {
            var j;
            while (1) {
              j = GZip.bitReverse[this.readBits(7)] >> 1;
              if (j > 23) {
                j = j << 1 | this.readBit();
                if (j > 199) {
                  j -= 128;
                  j = j << 1 | this.readBit();
                } else {
                  j -= 48;
                  if (j > 143) {
                    j = j + 136;
                  }
                }
              } else {
                j += 256;
              }
              if (j < 256) {
                this.addBuffer(j);
              } else if (j === 256) {
                break;
              } else {
                var len, dist;
                j -= 256 + 1;
                len = this.readBits(GZip.cplext[j]) + GZip.cplens[j];
                j = GZip.bitReverse[this.readBits(5)] >> 3;
                if (GZip.cpdext[j] > 8) {
                  dist = this.readBits(8);
                  dist |= this.readBits(GZip.cpdext[j] - 8) << 8;
                } else {
                  dist = this.readBits(GZip.cpdext[j]);
                }
                dist += GZip.cpdist[j];
                for (j = 0; j < len; j++) {
                  var c = this.buf32k[this.bIdx - dist & 0x7fff];
                  this.addBuffer(c);
                }
              }
            }
          } else if (type === 2) {
            var j, n, literalCodes, distCodes, lenCodes;
            var ll = new Array(288 + 32);
            literalCodes = 257 + this.readBits(5);
            distCodes = 1 + this.readBits(5);
            lenCodes = 4 + this.readBits(4);
            for (j = 0; j < 19; j++) {
              ll[j] = 0;
            }
            for (j = 0; j < lenCodes; j++) {
              ll[GZip.border[j]] = this.readBits(3);
            }
            len = this.distanceTree.length;
            for (i = 0; i < len; i++) this.distanceTree[i] = new GZip.HufNode();
            if (this.CreateTree(this.distanceTree, 19, ll, 0)) {
              this.flushBuffer();
              return 1;
            }
            n = literalCodes + distCodes;
            i = 0;
            while (i < n) {
              j = this.DecodeValue(this.distanceTree);
              if (j < 16) {
                ll[i++] = j;
              } else if (j === 16) {
                var l;
                j = 3 + this.readBits(2);
                if (i + j > n) {
                  this.flushBuffer();
                  return 1;
                }
                l = i ? ll[i - 1] : 0;
                while (j--) {
                  ll[i++] = l;
                }
              } else {
                if (j === 17) {
                  j = 3 + this.readBits(3);
                } else {
                  j = 11 + this.readBits(7);
                }
                if (i + j > n) {
                  this.flushBuffer();
                  return 1;
                }
                while (j--) {
                  ll[i++] = 0;
                }
              }
            }
            len = this.literalTree.length;
            for (i = 0; i < len; i++) this.literalTree[i] = new GZip.HufNode();
            if (this.CreateTree(this.literalTree, literalCodes, ll, 0)) {
              this.flushBuffer();
              return 1;
            }
            len = this.literalTree.length;
            for (i = 0; i < len; i++) this.distanceTree[i] = new GZip.HufNode();
            var ll2 = new Array();
            for (i = literalCodes; i < ll.length; i++) ll2[i - literalCodes] = ll[i];
            if (this.CreateTree(this.distanceTree, distCodes, ll2, 0)) {
              this.flushBuffer();
              return 1;
            }
            while (1) {
              j = this.DecodeValue(this.literalTree);
              if (j >= 256) {
                var len, dist;
                j -= 256;
                if (j === 0) {
                  break;
                }
                j--;
                len = this.readBits(GZip.cplext[j]) + GZip.cplens[j];
                j = this.DecodeValue(this.distanceTree);
                if (GZip.cpdext[j] > 8) {
                  dist = this.readBits(8);
                  dist |= this.readBits(GZip.cpdext[j] - 8) << 8;
                } else {
                  dist = this.readBits(GZip.cpdext[j]);
                }
                dist += GZip.cpdist[j];
                while (len--) {
                  var c = this.buf32k[this.bIdx - dist & 0x7fff];
                  this.addBuffer(c);
                }
              } else {
                this.addBuffer(j);
              }
            }
          }
        } while (!last);
        this.flushBuffer();
        this.byteAlign();
        return 0;
      };
      GZip.prototype.unzipFile = function (name) {
        var i;
        this.gunzip();
        for (i = 0; i < this.unzipped.length; i++) {
          if (this.unzipped[i][1] === name) {
            return this.unzipped[i][0];
          }
        }
      };
      GZip.prototype.nextFile = function () {
        this.outputArr = [];
        this.modeZIP = false;
        var tmp = [];
        tmp[0] = this.readByte();
        tmp[1] = this.readByte();
        if (tmp[0] === 0x78 && tmp[1] === 0xda) {
          this.DeflateLoop();
          this.unzipped[this.files] = [this.outputArr.join(''), "geonext.gxt"];
          this.files++;
        }
        if (tmp[0] === 0x1f && tmp[1] === 0x8b) {
          this.skipdir();
          this.unzipped[this.files] = [this.outputArr.join(''), "file"];
          this.files++;
        }
        if (tmp[0] === 0x50 && tmp[1] === 0x4b) {
          this.modeZIP = true;
          tmp[2] = this.readByte();
          tmp[3] = this.readByte();
          if (tmp[2] === 0x03 && tmp[3] === 0x04) {
            tmp[0] = this.readByte();
            tmp[1] = this.readByte();
            this.gpflags = this.readByte();
            this.gpflags |= this.readByte() << 8;
            var method = this.readByte();
            method |= this.readByte() << 8;
            this.readByte();
            this.readByte();
            this.readByte();
            this.readByte();
            var compSize = this.readByte();
            compSize |= this.readByte() << 8;
            compSize |= this.readByte() << 16;
            compSize |= this.readByte() << 24;
            var size = this.readByte();
            size |= this.readByte() << 8;
            size |= this.readByte() << 16;
            size |= this.readByte() << 24;
            var filelen = this.readByte();
            filelen |= this.readByte() << 8;
            var extralen = this.readByte();
            extralen |= this.readByte() << 8;
            i = 0;
            this.nameBuf = [];
            while (filelen--) {
              var c = this.readByte();
              if (c === "/" | c === ":") {
                i = 0;
              } else if (i < GZip.NAMEMAX - 1) {
                this.nameBuf[i++] = String.fromCharCode(c);
              }
            }
            if (!this.fileout) this.fileout = this.nameBuf;
            var i = 0;
            while (i < extralen) {
              c = this.readByte();
              i++;
            }
            if (method === 8) {
              this.DeflateLoop();
              this.unzipped[this.files] = [this.outputArr.join(''), this.nameBuf.join('')];
              this.files++;
            }
            this.skipdir();
          }
        }
      };
      GZip.prototype.skipdir = function () {
        var tmp = [];
        var compSize, size, i, c;
        if (this.gpflags & 8) {
          tmp[0] = this.readByte();
          tmp[1] = this.readByte();
          tmp[2] = this.readByte();
          tmp[3] = this.readByte();
          compSize = this.readByte();
          compSize |= this.readByte() << 8;
          compSize |= this.readByte() << 16;
          compSize |= this.readByte() << 24;
          size = this.readByte();
          size |= this.readByte() << 8;
          size |= this.readByte() << 16;
          size |= this.readByte() << 24;
        }
        if (this.modeZIP) this.nextFile();
        tmp[0] = this.readByte();
        if (tmp[0] !== 8) {
          return 0;
        }
        this.gpflags = this.readByte();
        this.readByte();
        this.readByte();
        this.readByte();
        this.readByte();
        this.readByte();
        this.readByte();
        if (this.gpflags & 4) {
          tmp[0] = this.readByte();
          tmp[2] = this.readByte();
          this.len = tmp[0] + 256 * tmp[1];
          for (i = 0; i < this.len; i++) this.readByte();
        }
        if (this.gpflags & 8) {
          i = 0;
          this.nameBuf = [];
          while (c = this.readByte()) {
            if (c === "7" || c === ":") i = 0;
            if (i < GZip.NAMEMAX - 1) this.nameBuf[i++] = c;
          }
        }
        if (this.gpflags & 16) {
          while (c = this.readByte()) {}
        }
        if (this.gpflags & 2) {
          this.readByte();
          this.readByte();
        }
        this.DeflateLoop();
        size = this.readByte();
        size |= this.readByte() << 8;
        size |= this.readByte() << 16;
        size |= this.readByte() << 24;
        if (this.modeZIP) this.nextFile();
      };

      var codec = {
        name: 'Jacob__Codec'
      };
      codec.Base64 = Base64;
      codec.GZip = GZip;
      codec.unzip = function () {
        return codec.GZip.gunzip.apply(codec.GZip, arguments);
      };
      codec.unzipBase64 = function () {
        var buffer = codec.Base64.decode.apply(codec.Base64, arguments);
        try {
          return codec.GZip.gunzip.call(codec.GZip, buffer);
        } catch (e) {
          return buffer.slice(7);
        }
      };
      codec.unzipBase64AsArray = function (input, bytes) {
        bytes = bytes || 1;
        var dec = this.unzipBase64(input),
          ar = [],
          i,
          j,
          len;
        for (i = 0, len = dec.length / bytes; i < len; i++) {
          ar[i] = 0;
          for (j = bytes - 1; j >= 0; --j) {
            ar[i] += dec.charCodeAt(i * bytes + j) << j * 8;
          }
        }
        return ar;
      };
      codec.unzipAsArray = function (input, bytes) {
        bytes = bytes || 1;
        var dec = this.unzip(input),
          ar = [],
          i,
          j,
          len;
        for (i = 0, len = dec.length / bytes; i < len; i++) {
          ar[i] = 0;
          for (j = bytes - 1; j >= 0; --j) {
            ar[i] += dec.charCodeAt(i * bytes + j) << j * 8;
          }
        }
        return ar;
      };

      var _dec$j, _dec2$h, _dec3$f, _dec4$c, _dec5$c, _dec6$6, _class$i, _class2$g, _initializer$f, _initializer2$f, _initializer3$d, _initializer4$c, _initializer5$a, _initializer6$7, _initializer7$6, _initializer8$6, _initializer9$6, _initializer10$6, _initializer11$6, _initializer12$5, _initializer13$4, _initializer14$3, _initializer15$2, _initializer16$2, _initializer17$1, _initializer18$1, _initializer19, _initializer20, _initializer21, _initializer22, _initializer23, _initializer24, _initializer25, _initializer26, _initializer27, _initializer28, _initializer29, _initializer30, _initializer31, _initializer32, _initializer33, _initializer34, _initializer35, _initializer36, _initializer37, _initializer38, _initializer39, _initializer40, _initializer41, _initializer42, _initializer43, _class3$c;
      let ImageFormat;
      (function (ImageFormat) {
        ImageFormat[ImageFormat["JPG"] = 0] = "JPG";
        ImageFormat[ImageFormat["PNG"] = 1] = "PNG";
        ImageFormat[ImageFormat["TIFF"] = 2] = "TIFF";
        ImageFormat[ImageFormat["WEBP"] = 3] = "WEBP";
        ImageFormat[ImageFormat["PVR"] = 4] = "PVR";
        ImageFormat[ImageFormat["ETC"] = 5] = "ETC";
        ImageFormat[ImageFormat["S3TC"] = 6] = "S3TC";
        ImageFormat[ImageFormat["ATITC"] = 7] = "ATITC";
        ImageFormat[ImageFormat["TGA"] = 8] = "TGA";
        ImageFormat[ImageFormat["RAWDATA"] = 9] = "RAWDATA";
        ImageFormat[ImageFormat["UNKNOWN"] = 10] = "UNKNOWN";
      })(ImageFormat || (ImageFormat = {}));
      function getImageFormatByData(imgData) {
        if (imgData.length > 8 && imgData[0] === 0x89 && imgData[1] === 0x50 && imgData[2] === 0x4E && imgData[3] === 0x47 && imgData[4] === 0x0D && imgData[5] === 0x0A && imgData[6] === 0x1A && imgData[7] === 0x0A) {
          return ImageFormat.PNG;
        }
        if (imgData.length > 2 && (imgData[0] === 0x49 && imgData[1] === 0x49 || imgData[0] === 0x4d && imgData[1] === 0x4d || imgData[0] === 0xff && imgData[1] === 0xd8)) {
          return ImageFormat.TIFF;
        }
        return ImageFormat.UNKNOWN;
      }
      function getParticleComponents(node) {
        const parent = node.parent;
        const comp = node.getComponent(ParticleSystem2D);
        if (!parent || !comp) {
          return node.getComponentsInChildren(ParticleSystem2D);
        }
        return getParticleComponents(parent);
      }
      let ParticleSystem2D = exports('ParticleSystem2D', (_dec$j = ccclass$3('cc.ParticleSystem2D'), _dec2$h = type$2(ParticleAsset), _dec3$f = type$2(SpriteFrame), _dec4$c = type$2(PositionType), _dec5$c = type$2(EmitterMode), _dec6$6 = formerlySerializedAs('preview'), _dec$j(_class$i = (_class2$g = (_class3$c = class ParticleSystem2D extends UIRenderer {
        get custom() {
          return this._custom;
        }
        set custom(value) {
          if (this._custom !== value) {
            this._custom = value;
            this._applyFile();
            this._updateMaterial();
          }
        }
        get file() {
          return this._file;
        }
        set file(value) {
          if (this._file !== value) {
            this._file = value;
            if (value) {
              this._applyFile();
            } else {
              this.custom = true;
            }
          }
        }
        get spriteFrame() {
          return this._spriteFrame;
        }
        set spriteFrame(value) {
          const lastSprite = this._renderSpriteFrame;
          if (lastSprite === value) {
            return;
          }
          this._renderSpriteFrame = value;
          if (!value || value._uuid) {
            this._spriteFrame = value;
          }
          this._applySpriteFrame();
        }
        get particleCount() {
          return this._simulator.particles.length;
        }
        get totalParticles() {
          return this._totalParticles;
        }
        set totalParticles(value) {
          if (this._totalParticles === value) return;
          this._totalParticles = value;
        }
        get startColor() {
          return this._startColor;
        }
        set startColor(val) {
          this._startColor.r = val.r;
          this._startColor.g = val.g;
          this._startColor.b = val.b;
          this._startColor.a = val.a;
        }
        get startColorVar() {
          return this._startColorVar;
        }
        set startColorVar(val) {
          this._startColorVar.r = val.r;
          this._startColorVar.g = val.g;
          this._startColorVar.b = val.b;
          this._startColorVar.a = val.a;
        }
        set color(value) {}
        get color() {
          return this._color;
        }
        get endColor() {
          return this._endColor;
        }
        set endColor(val) {
          this._endColor.r = val.r;
          this._endColor.g = val.g;
          this._endColor.b = val.b;
          this._endColor.a = val.a;
        }
        get endColorVar() {
          return this._endColorVar;
        }
        set endColorVar(val) {
          this._endColorVar.r = val.r;
          this._endColorVar.g = val.g;
          this._endColorVar.b = val.b;
          this._endColorVar.a = val.a;
        }
        get positionType() {
          return this._positionType;
        }
        set positionType(val) {
          this._positionType = val;
          this._updateMaterial();
          this._updatePositionType();
        }
        get preview() {
          return this._preview;
        }
        set preview(val) {
          if (val) {
            this._startPreview();
          } else {
            this._stopPreview();
          }
          this._preview = val;
        }
        get stopped() {
          return this._stopped;
        }
        get active() {
          return this._simulator.active;
        }
        get assembler() {
          return this._assembler;
        }
        constructor() {
          super();
          this.duration = _initializer$f && _initializer$f();
          this.emissionRate = _initializer2$f && _initializer2$f();
          this.life = _initializer3$d && _initializer3$d();
          this.lifeVar = _initializer4$c && _initializer4$c();
          this.angle = _initializer5$a && _initializer5$a();
          this.angleVar = _initializer6$7 && _initializer6$7();
          this.startSize = _initializer7$6 && _initializer7$6();
          this.startSizeVar = _initializer8$6 && _initializer8$6();
          this.endSize = _initializer9$6 && _initializer9$6();
          this.endSizeVar = _initializer10$6 && _initializer10$6();
          this.startSpin = _initializer11$6 && _initializer11$6();
          this.startSpinVar = _initializer12$5 && _initializer12$5();
          this.endSpin = _initializer13$4 && _initializer13$4();
          this.endSpinVar = _initializer14$3 && _initializer14$3();
          this.sourcePos = _initializer15$2 && _initializer15$2();
          this.posVar = _initializer16$2 && _initializer16$2();
          this.emitterMode = _initializer17$1 && _initializer17$1();
          this.gravity = _initializer18$1 && _initializer18$1();
          this.speed = _initializer19 && _initializer19();
          this.speedVar = _initializer20 && _initializer20();
          this.tangentialAccel = _initializer21 && _initializer21();
          this.tangentialAccelVar = _initializer22 && _initializer22();
          this.radialAccel = _initializer23 && _initializer23();
          this.radialAccelVar = _initializer24 && _initializer24();
          this.rotationIsDir = _initializer25 && _initializer25();
          this.startRadius = _initializer26 && _initializer26();
          this.startRadiusVar = _initializer27 && _initializer27();
          this.endRadius = _initializer28 && _initializer28();
          this.endRadiusVar = _initializer29 && _initializer29();
          this.rotatePerS = _initializer30 && _initializer30();
          this.rotatePerSVar = _initializer31 && _initializer31();
          this.aspectRatio = 1;
          this.playOnLoad = _initializer32 && _initializer32();
          this.autoRemoveOnFinish = _initializer33 && _initializer33();
          this._preview = _initializer34 && _initializer34();
          this._custom = _initializer35 && _initializer35();
          this._file = _initializer36 && _initializer36();
          this._spriteFrame = _initializer37 && _initializer37();
          this._totalParticles = _initializer38 && _initializer38();
          this._startColor = _initializer39 && _initializer39();
          this._startColorVar = _initializer40 && _initializer40();
          this._endColor = _initializer41 && _initializer41();
          this._endColorVar = _initializer42 && _initializer42();
          this._positionType = _initializer43 && _initializer43();
          this._stopped = true;
          this._useFile = void 0;
          this.initProperties();
          this._useFile = false;
        }
        onEnable() {
          super.onEnable();
          this._updateMaterial();
          this._updatePositionType();
        }
        onDestroy() {
          super.onDestroy();
          if (this.autoRemoveOnFinish) {
            this.autoRemoveOnFinish = false;
          }
          this._simulator.uvFilled = 0;
          if (this._simulator.renderData && this._assembler) {
            this._assembler.removeData(this._simulator.renderData);
          }
        }
        initProperties() {
          this._previewTimer = null;
          this._focused = false;
          this.aspectRatio = 1;
          this._simulator = new Simulator(this);
        }
        onFocusInEditor() {
          this._focused = true;
          const components = getParticleComponents(this.node);
          for (let i = 0; i < components.length; ++i) {
            components[i]._startPreview();
          }
        }
        onLostFocusInEditor() {
          this._focused = false;
          const components = getParticleComponents(this.node);
          for (let i = 0; i < components.length; ++i) {
            components[i]._stopPreview();
          }
        }
        _startPreview() {
          if (this._preview) {
            this.resetSystem();
          }
        }
        _stopPreview() {
          if (this._preview) {
            this.resetSystem();
            this.stopSystem();
          }
          if (this._previewTimer) {
            clearInterval(this._previewTimer);
          }
        }
        __preload() {
          super.__preload();
          if (this._custom && this.spriteFrame && !this._renderSpriteFrame) {
            this._applySpriteFrame();
          } else if (this._file) {
            if (this._custom) {
              const missCustomTexture = !this._getTexture();
              if (missCustomTexture) {
                this._applyFile();
              }
            } else {
              this._applyFile();
            }
          }
          {
            if (this.playOnLoad) {
              this.resetSystem();
            }
          }
        }
        _flushAssembler() {
          const assembler = ParticleSystem2D.Assembler.getAssembler(this);
          if (this._assembler !== assembler) {
            this._assembler = assembler;
          }
          if (this._assembler && this._assembler.createData) {
            this._simulator.renderData = this._assembler.createData(this);
            this._simulator.renderData.particleInitRenderDrawInfo(this.renderEntity);
            this._simulator.initDrawInfo();
          }
        }
        lateUpdate(dt) {
          if (!this._simulator.finished) {
            this._simulator.step(dt);
          }
        }
        addParticle() {}
        stopSystem() {
          this._stopped = true;
          this._simulator.stop();
        }
        resetSystem() {
          this._stopped = false;
          this._simulator.reset();
          this.markForUpdateRenderData();
        }
        isFull() {
          return this.particleCount >= this.totalParticles;
        }
        _applyFile() {
          const file = this._file;
          if (file) {
            if (!file) {
              errorID(6029);
              return;
            }
            if (!this.isValid) {
              return;
            }
            this._plistFile = file.nativeUrl;
            if (!this._custom) {
              const isDiffFrame = this._spriteFrame !== file.spriteFrame;
              if (isDiffFrame) this.spriteFrame = file.spriteFrame;
              this._initWithDictionary(file._nativeAsset);
            }
            if (!this._spriteFrame) {
              if (file.spriteFrame) {
                this.spriteFrame = file.spriteFrame;
              } else if (this._custom) {
                this._initTextureWithDictionary(file._nativeAsset);
              }
            } else if (!this._renderSpriteFrame && this._spriteFrame) {
              this._applySpriteFrame();
            }
          }
        }
        _initTextureWithDictionary(dict) {
          if (dict.spriteFrameUuid) {
            const spriteFrameUuid = dict.spriteFrameUuid;
            assetManager.loadAny(spriteFrameUuid, (err, spriteFrame) => {
              if (err) {
                dict.spriteFrameUuid = undefined;
                this._initTextureWithDictionary(dict);
                error(err);
              } else {
                this.spriteFrame = spriteFrame;
              }
            });
          } else {
            const imgPath = changeBasename(this._plistFile, dict.textureFileName || '');
            if (dict.textureFileName) {
              assetManager.loadRemote(imgPath, (err, imageAsset) => {
                if (err) {
                  dict.textureFileName = undefined;
                  this._initTextureWithDictionary(dict);
                  error(err);
                } else {
                  if (imageAsset) {
                    this.spriteFrame = SpriteFrame.createWithImage(imageAsset);
                  } else {
                    this.spriteFrame = SpriteFrame.createWithImage(builtinResMgr.get('white-texture'));
                  }
                }
              });
            } else if (dict.textureImageData) {
              const textureData = dict.textureImageData;
              if (textureData && textureData.length > 0) {
                let imgPathName = imgPath;
                if (this.file) {
                  imgPathName += `-${this.file.uuid}`;
                }
                let imageAsset = assetManager.assets.get(imgPathName);
                if (!imageAsset) {
                  const buffer = codec.unzipBase64AsArray(textureData, 1);
                  if (!buffer) {
                    warnID(6030, this._file.name);
                    return false;
                  }
                  const imageFormat = getImageFormatByData(buffer);
                  if (imageFormat !== ImageFormat.TIFF && imageFormat !== ImageFormat.PNG) {
                    warnID(6031, this._file.name);
                    return false;
                  }
                  const canvasObj = ccwindow$1.document.createElement('canvas');
                  if (imageFormat === ImageFormat.PNG) {
                    const myPngObj = new PNGReader(buffer);
                    myPngObj.render(canvasObj);
                  } else {
                    if (!this._tiffReader) {
                      this._tiffReader = new TiffReader();
                    }
                    this._tiffReader.parseTIFF(buffer, canvasObj);
                  }
                  imageAsset = new ImageAsset$1(canvasObj);
                  assetManager.assets.add(imgPathName, imageAsset);
                }
                if (!imageAsset) {
                  warnID(6032, this._file.name);
                }
                if (imageAsset) {
                  this.spriteFrame = SpriteFrame.createWithImage(imageAsset);
                } else {
                  this.spriteFrame = SpriteFrame.createWithImage(builtinResMgr.get('white-texture'));
                }
              } else {
                return false;
              }
            }
          }
          return true;
        }
        _initWithDictionary(dict) {
          this._useFile = true;
          this.totalParticles = parseInt(dict.maxParticles || 0);
          this.life = parseFloat(dict.particleLifespan || 0);
          this.lifeVar = parseFloat(dict.particleLifespanVariance || 0);
          const _tempEmissionRate = dict.emissionRate;
          if (_tempEmissionRate) {
            this.emissionRate = _tempEmissionRate;
          } else {
            this.emissionRate = Math.min(this.totalParticles / this.life, Number.MAX_VALUE);
          }
          this.duration = parseFloat(dict.duration || 0);
          this._srcBlendFactor = parseInt(dict.blendFuncSource || BlendFactor.SRC_ALPHA);
          this._dstBlendFactor = parseInt(dict.blendFuncDestination || BlendFactor.ONE_MINUS_SRC_ALPHA);
          const locStartColor = this._startColor;
          locStartColor.r = parseFloat(dict.startColorRed || 0) * 255;
          locStartColor.g = parseFloat(dict.startColorGreen || 0) * 255;
          locStartColor.b = parseFloat(dict.startColorBlue || 0) * 255;
          locStartColor.a = parseFloat(dict.startColorAlpha || 0) * 255;
          const locStartColorVar = this._startColorVar;
          locStartColorVar.r = parseFloat(dict.startColorVarianceRed || 0) * 255;
          locStartColorVar.g = parseFloat(dict.startColorVarianceGreen || 0) * 255;
          locStartColorVar.b = parseFloat(dict.startColorVarianceBlue || 0) * 255;
          locStartColorVar.a = parseFloat(dict.startColorVarianceAlpha || 0) * 255;
          const locEndColor = this._endColor;
          locEndColor.r = parseFloat(dict.finishColorRed || 0) * 255;
          locEndColor.g = parseFloat(dict.finishColorGreen || 0) * 255;
          locEndColor.b = parseFloat(dict.finishColorBlue || 0) * 255;
          locEndColor.a = parseFloat(dict.finishColorAlpha || 0) * 255;
          const locEndColorVar = this._endColorVar;
          locEndColorVar.r = parseFloat(dict.finishColorVarianceRed || 0) * 255;
          locEndColorVar.g = parseFloat(dict.finishColorVarianceGreen || 0) * 255;
          locEndColorVar.b = parseFloat(dict.finishColorVarianceBlue || 0) * 255;
          locEndColorVar.a = parseFloat(dict.finishColorVarianceAlpha || 0) * 255;
          this.startSize = parseFloat(dict.startParticleSize || 0);
          this.startSizeVar = parseFloat(dict.startParticleSizeVariance || 0);
          this.endSize = parseFloat(dict.finishParticleSize || 0);
          this.endSizeVar = parseFloat(dict.finishParticleSizeVariance || 0);
          this.positionType = parseFloat(dict.positionType !== undefined ? dict.positionType : PositionType.FREE);
          this.sourcePos.set(0, 0);
          this.posVar.set(parseFloat(dict.sourcePositionVariancex || 0), parseFloat(dict.sourcePositionVariancey || 0));
          this.angle = parseFloat(dict.angle || 0);
          this.angleVar = parseFloat(dict.angleVariance || 0);
          this.startSpin = parseFloat(dict.rotationStart || 0);
          this.startSpinVar = parseFloat(dict.rotationStartVariance || 0);
          this.endSpin = parseFloat(dict.rotationEnd || 0);
          this.endSpinVar = parseFloat(dict.rotationEndVariance || 0);
          this.emitterMode = parseInt(dict.emitterType || EmitterMode.GRAVITY);
          if (this.emitterMode === EmitterMode.GRAVITY) {
            this.gravity.set(parseFloat(dict.gravityx || 0), parseFloat(dict.gravityy || 0));
            this.speed = parseFloat(dict.speed || 0);
            this.speedVar = parseFloat(dict.speedVariance || 0);
            this.radialAccel = parseFloat(dict.radialAcceleration || 0);
            this.radialAccelVar = parseFloat(dict.radialAccelVariance || 0);
            this.tangentialAccel = parseFloat(dict.tangentialAcceleration || 0);
            this.tangentialAccelVar = parseFloat(dict.tangentialAccelVariance || 0);
            let locRotationIsDir = dict.rotationIsDir || '';
            if (locRotationIsDir !== null) {
              locRotationIsDir = locRotationIsDir.toString().toLowerCase();
              this.rotationIsDir = locRotationIsDir === 'true' || locRotationIsDir === '1';
            } else {
              this.rotationIsDir = false;
            }
          } else if (this.emitterMode === EmitterMode.RADIUS) {
            this.startRadius = parseFloat(dict.maxRadius || 0);
            this.startRadiusVar = parseFloat(dict.maxRadiusVariance || 0);
            this.endRadius = parseFloat(dict.minRadius || 0);
            this.endRadiusVar = parseFloat(dict.minRadiusVariance || 0);
            this.rotatePerS = parseFloat(dict.rotatePerSecond || 0);
            this.rotatePerSVar = parseFloat(dict.rotatePerSecondVariance || 0);
          } else {
            warnID(6009);
            return false;
          }
          this._initTextureWithDictionary(dict);
          return true;
        }
        _syncAspect() {
          if (this._renderSpriteFrame) {
            const frameRect = this._renderSpriteFrame.rect;
            this.aspectRatio = frameRect.width / frameRect.height;
          }
        }
        _applySpriteFrame() {
          this._renderSpriteFrame = this._renderSpriteFrame || this._spriteFrame;
          if (this._renderSpriteFrame) {
            if (this._renderSpriteFrame.texture) {
              if (this._simulator) {
                this._simulator.updateUVs(true);
              }
              this._syncAspect();
              this._updateMaterial();
              this._stopped = false;
              this.markForUpdateRenderData();
            }
          } else {
            this.resetSystem();
          }
        }
        _getTexture() {
          return this._renderSpriteFrame && this._renderSpriteFrame.texture;
        }
        _updateMaterial() {
          if (this._customMaterial) {
            this.setSharedMaterial(this._customMaterial, 0);
            const target = this.getRenderMaterial(0).passes[0].blendState.targets[0];
            this._dstBlendFactor = target.blendDst;
            this._srcBlendFactor = target.blendSrc;
          }
          const mat = this.getMaterialInstance(0);
          if (mat) mat.recompileShaders({
            USE_LOCAL: this._positionType !== PositionType.FREE
          });
          if (mat && mat.passes.length > 0) {
            this._updateBlendFunc();
          }
        }
        _finishedSimulation() {
          this.resetSystem();
          this.stopSystem();
          this.markForUpdateRenderData();
          if (this.autoRemoveOnFinish && this._stopped) {
            this.node.destroy();
          }
        }
        _canRender() {
          return super._canRender() && !this._stopped && this._renderSpriteFrame !== null && this._renderSpriteFrame !== undefined;
        }
        _render(render) {
          if (this._positionType === PositionType.RELATIVE) {
            render.commitComp(this, this._simulator.renderData, this._renderSpriteFrame, this._assembler, this.node.parent);
          } else if (this.positionType === PositionType.GROUPED) {
            render.commitComp(this, this._simulator.renderData, this._renderSpriteFrame, this._assembler, this.node);
          } else {
            render.commitComp(this, this._simulator.renderData, this._renderSpriteFrame, this._assembler, null);
          }
        }
        _updatePositionType() {
          if (this._positionType === PositionType.RELATIVE) {
            this._renderEntity.setRenderTransform(this.node.parent);
            this._renderEntity.setUseLocal(true);
          } else if (this.positionType === PositionType.GROUPED) {
            this._renderEntity.setRenderTransform(this.node);
            this._renderEntity.setUseLocal(true);
          } else {
            this._renderEntity.setRenderTransform(null);
            this._renderEntity.setUseLocal(false);
          }
        }
      }, _class3$c.EmitterMode = EmitterMode, _class3$c.PositionType = PositionType, _class3$c.DURATION_INFINITY = DURATION_INFINITY, _class3$c.START_SIZE_EQUAL_TO_END_SIZE = START_SIZE_EQUAL_TO_END_SIZE, _class3$c.START_RADIUS_EQUAL_TO_END_RADIUS = START_RADIUS_EQUAL_TO_END_RADIUS, _class3$c), (_applyDecoratedDescriptor(_class2$g.prototype, "file", [_dec2$h], Object.getOwnPropertyDescriptor(_class2$g.prototype, "file"), _class2$g.prototype), _applyDecoratedDescriptor(_class2$g.prototype, "spriteFrame", [_dec3$f], Object.getOwnPropertyDescriptor(_class2$g.prototype, "spriteFrame"), _class2$g.prototype), _initializer$f = applyDecoratedInitializer(_class2$g.prototype, "duration", [serializable$3], function () {
        return -1;
      }), _initializer2$f = applyDecoratedInitializer(_class2$g.prototype, "emissionRate", [serializable$3], function () {
        return 10;
      }), _initializer3$d = applyDecoratedInitializer(_class2$g.prototype, "life", [serializable$3], function () {
        return 1;
      }), _initializer4$c = applyDecoratedInitializer(_class2$g.prototype, "lifeVar", [serializable$3], function () {
        return 0;
      }), _applyDecoratedDescriptor(_class2$g.prototype, "color", [override], Object.getOwnPropertyDescriptor(_class2$g.prototype, "color"), _class2$g.prototype), _initializer5$a = applyDecoratedInitializer(_class2$g.prototype, "angle", [serializable$3], function () {
        return 90;
      }), _initializer6$7 = applyDecoratedInitializer(_class2$g.prototype, "angleVar", [serializable$3], function () {
        return 20;
      }), _initializer7$6 = applyDecoratedInitializer(_class2$g.prototype, "startSize", [serializable$3], function () {
        return 50;
      }), _initializer8$6 = applyDecoratedInitializer(_class2$g.prototype, "startSizeVar", [serializable$3], function () {
        return 0;
      }), _initializer9$6 = applyDecoratedInitializer(_class2$g.prototype, "endSize", [serializable$3], function () {
        return 0;
      }), _initializer10$6 = applyDecoratedInitializer(_class2$g.prototype, "endSizeVar", [serializable$3], function () {
        return 0;
      }), _initializer11$6 = applyDecoratedInitializer(_class2$g.prototype, "startSpin", [serializable$3], function () {
        return 0;
      }), _initializer12$5 = applyDecoratedInitializer(_class2$g.prototype, "startSpinVar", [serializable$3], function () {
        return 0;
      }), _initializer13$4 = applyDecoratedInitializer(_class2$g.prototype, "endSpin", [serializable$3], function () {
        return 0;
      }), _initializer14$3 = applyDecoratedInitializer(_class2$g.prototype, "endSpinVar", [serializable$3], function () {
        return 0;
      }), _initializer15$2 = applyDecoratedInitializer(_class2$g.prototype, "sourcePos", [serializable$3], function () {
        return Vec2.ZERO.clone();
      }), _initializer16$2 = applyDecoratedInitializer(_class2$g.prototype, "posVar", [serializable$3], function () {
        return Vec2.ZERO.clone();
      }), _applyDecoratedDescriptor(_class2$g.prototype, "positionType", [_dec4$c], Object.getOwnPropertyDescriptor(_class2$g.prototype, "positionType"), _class2$g.prototype), _initializer17$1 = applyDecoratedInitializer(_class2$g.prototype, "emitterMode", [serializable$3, _dec5$c], function () {
        return EmitterMode.GRAVITY;
      }), _initializer18$1 = applyDecoratedInitializer(_class2$g.prototype, "gravity", [serializable$3], function () {
        return Vec2.ZERO.clone();
      }), _initializer19 = applyDecoratedInitializer(_class2$g.prototype, "speed", [serializable$3], function () {
        return 180;
      }), _initializer20 = applyDecoratedInitializer(_class2$g.prototype, "speedVar", [serializable$3], function () {
        return 50;
      }), _initializer21 = applyDecoratedInitializer(_class2$g.prototype, "tangentialAccel", [serializable$3], function () {
        return 80;
      }), _initializer22 = applyDecoratedInitializer(_class2$g.prototype, "tangentialAccelVar", [serializable$3], function () {
        return 0;
      }), _initializer23 = applyDecoratedInitializer(_class2$g.prototype, "radialAccel", [serializable$3], function () {
        return 0;
      }), _initializer24 = applyDecoratedInitializer(_class2$g.prototype, "radialAccelVar", [serializable$3], function () {
        return 0;
      }), _initializer25 = applyDecoratedInitializer(_class2$g.prototype, "rotationIsDir", [serializable$3], function () {
        return false;
      }), _initializer26 = applyDecoratedInitializer(_class2$g.prototype, "startRadius", [serializable$3], function () {
        return 0;
      }), _initializer27 = applyDecoratedInitializer(_class2$g.prototype, "startRadiusVar", [serializable$3], function () {
        return 0;
      }), _initializer28 = applyDecoratedInitializer(_class2$g.prototype, "endRadius", [serializable$3], function () {
        return 0;
      }), _initializer29 = applyDecoratedInitializer(_class2$g.prototype, "endRadiusVar", [serializable$3], function () {
        return 0;
      }), _initializer30 = applyDecoratedInitializer(_class2$g.prototype, "rotatePerS", [serializable$3], function () {
        return 0;
      }), _initializer31 = applyDecoratedInitializer(_class2$g.prototype, "rotatePerSVar", [serializable$3], function () {
        return 0;
      }), _initializer32 = applyDecoratedInitializer(_class2$g.prototype, "playOnLoad", [serializable$3], function () {
        return true;
      }), _initializer33 = applyDecoratedInitializer(_class2$g.prototype, "autoRemoveOnFinish", [serializable$3], function () {
        return false;
      }), _initializer34 = applyDecoratedInitializer(_class2$g.prototype, "_preview", [_dec6$6], function () {
        return true;
      }), _initializer35 = applyDecoratedInitializer(_class2$g.prototype, "_custom", [serializable$3], function () {
        return false;
      }), _initializer36 = applyDecoratedInitializer(_class2$g.prototype, "_file", [serializable$3], function () {
        return null;
      }), _initializer37 = applyDecoratedInitializer(_class2$g.prototype, "_spriteFrame", [serializable$3], function () {
        return null;
      }), _initializer38 = applyDecoratedInitializer(_class2$g.prototype, "_totalParticles", [serializable$3], function () {
        return 150;
      }), _initializer39 = applyDecoratedInitializer(_class2$g.prototype, "_startColor", [serializable$3], function () {
        return new Color$1(255, 255, 255, 255);
      }), _initializer40 = applyDecoratedInitializer(_class2$g.prototype, "_startColorVar", [serializable$3], function () {
        return new Color$1(0, 0, 0, 0);
      }), _initializer41 = applyDecoratedInitializer(_class2$g.prototype, "_endColor", [serializable$3], function () {
        return new Color$1(255, 255, 255, 0);
      }), _initializer42 = applyDecoratedInitializer(_class2$g.prototype, "_endColorVar", [serializable$3], function () {
        return new Color$1(0, 0, 0, 0);
      }), _initializer43 = applyDecoratedInitializer(_class2$g.prototype, "_positionType", [serializable$3], function () {
        return PositionType.FREE;
      })), _class2$g)) || _class$i));

      var _dec$i, _dec2$g, _class2$f, _class3$b, _initializer$e, _initializer2$e, _initializer3$c, _initializer4$b, _initializer5$9, _initializer6$6, _class4;
      class Point {
        constructor(point, dir) {
          this.point = new Vec2();
          this.dir = new Vec2();
          this.distance = 0;
          this.time = 0;
          if (point) this.point.set(point);
          if (dir) this.dir.set(dir);
        }
        setPoint(x, y) {
          this.point.x = x;
          this.point.y = y;
        }
        setDir(x, y) {
          this.dir.x = x;
          this.dir.y = y;
        }
      }
      let MotionStreak = exports('MotionStreak', (_dec$i = ccclass$3('cc.MotionStreak'), _dec2$g = type$2(Texture2D$1), _dec$i(_class2$f = (_class3$b = (_class4 = class MotionStreak extends UIRenderer {
        constructor(...args) {
          super(...args);
          this._preview = _initializer$e && _initializer$e();
          this._fadeTime = _initializer2$e && _initializer2$e();
          this._minSeg = _initializer3$c && _initializer3$c();
          this._stroke = _initializer4$b && _initializer4$b();
          this._texture = _initializer5$9 && _initializer5$9();
          this._fastMode = _initializer6$6 && _initializer6$6();
          this._points = [];
        }
        get preview() {
          return this._preview;
        }
        set preview(val) {
          this._preview = val;
          this.reset();
        }
        get fadeTime() {
          return this._fadeTime;
        }
        set fadeTime(val) {
          this._fadeTime = val;
          this.reset();
        }
        get minSeg() {
          return this._minSeg;
        }
        set minSeg(val) {
          this._minSeg = val;
        }
        get stroke() {
          return this._stroke;
        }
        set stroke(val) {
          this._stroke = val;
        }
        get texture() {
          return this._texture;
        }
        set texture(val) {
          if (this._texture === val) return;
          this._texture = val;
        }
        get fastMode() {
          return this._fastMode;
        }
        set fastMode(val) {
          this._fastMode = val;
        }
        get points() {
          return this._points;
        }
        onEnable() {
          super.onEnable();
          this.reset();
        }
        _flushAssembler() {
          const assembler = MotionStreak.Assembler.getAssembler(this);
          if (this._assembler !== assembler) {
            this._assembler = assembler;
          }
          if (!this._renderData) {
            if (this._assembler && this._assembler.createData) {
              this._renderData = this._assembler.createData(this);
              this._renderData.material = this.material;
              this._updateColor();
            }
          }
        }
        onFocusInEditor() {
          if (this._preview) {
            this.reset();
          }
        }
        onLostFocusInEditor() {
          if (this._preview) {
            this.reset();
          }
        }
        reset() {
          this._points.length = 0;
          if (this._renderData) this._renderData.clear();
        }
        lateUpdate(dt) {
          if (this._assembler) this._assembler.update(this, dt);
        }
        _render(render) {
          render.commitComp(this, this._renderData, this._texture, this._assembler, null);
        }
      }, _class4.Point = Point, _class4), (_applyDecoratedDescriptor(_class3$b.prototype, "texture", [_dec2$g], Object.getOwnPropertyDescriptor(_class3$b.prototype, "texture"), _class3$b.prototype), _initializer$e = applyDecoratedInitializer(_class3$b.prototype, "_preview", [serializable$3], function () {
        return false;
      }), _initializer2$e = applyDecoratedInitializer(_class3$b.prototype, "_fadeTime", [serializable$3], function () {
        return 1;
      }), _initializer3$c = applyDecoratedInitializer(_class3$b.prototype, "_minSeg", [serializable$3], function () {
        return 1;
      }), _initializer4$b = applyDecoratedInitializer(_class3$b.prototype, "_stroke", [serializable$3], function () {
        return 64;
      }), _initializer5$9 = applyDecoratedInitializer(_class3$b.prototype, "_texture", [serializable$3], function () {
        return null;
      }), _initializer6$6 = applyDecoratedInitializer(_class3$b.prototype, "_fastMode", [serializable$3], function () {
        return false;
      })), _class3$b)) || _class2$f));

      new Vec2();
      const _normal = new Vec2();
      const _vec2 = new Vec2();
      let QUAD_INDICES;
      function normal(out, dir) {
        out.x = -dir.y;
        out.y = dir.x;
        return out;
      }
      const MotionStreakAssembler = {
        createData(comp) {
          const renderData = comp.requestRenderData();
          renderData.dataLength = 4;
          renderData.resize(16, (16 - 2) * 3);
          return renderData;
        },
        update(comp, dt) {
          const stroke = comp.stroke / 2;
          const node = comp.node;
          const matrix = node.worldMatrix;
          const tx = matrix.m12;
          const ty = matrix.m13;
          const points = comp.points;
          let cur;
          if (points.length > 1) {
            const point = points[0];
            const difx = point.point.x - tx;
            const dify = point.point.y - ty;
            if (difx * difx + dify * dify < comp.minSeg) {
              cur = point;
            }
          }
          if (!cur) {
            cur = new MotionStreak.Point();
            points.unshift(cur);
          }
          cur.setPoint(tx, ty);
          cur.time = comp.fadeTime + dt;
          let vertexCount = 0;
          let indexCount = 0;
          if (points.length < 2) {
            return;
          }
          const renderData = comp.renderData;
          this.updateRenderDataCache(comp, renderData);
          const color = comp.color;
          const cr = color.r;
          const cg = color.g;
          const cb = color.b;
          const ca = color.a;
          const prev = points[1];
          prev.distance = Vec2.subtract(_vec2, cur.point, prev.point).length();
          _vec2.normalize();
          prev.setDir(_vec2.x, _vec2.y);
          cur.setDir(_vec2.x, _vec2.y);
          renderData.dataLength = points.length * 2;
          const data = renderData.data;
          const fadeTime = comp.fadeTime;
          let findLast = false;
          for (let i = points.length - 1; i >= 0; i--) {
            const p = points[i];
            const point = p.point;
            const dir = p.dir;
            p.time -= dt;
            if (p.time < 0) {
              points.splice(i, 1);
              continue;
            }
            const progress = p.time / fadeTime;
            const next = points[i - 1];
            if (!findLast) {
              if (!next) {
                points.splice(i, 1);
                continue;
              }
              point.x = next.point.x - dir.x * progress;
              point.y = next.point.y - dir.y * progress;
            }
            findLast = true;
            normal(_normal, dir);
            const da = progress * ca;
            const c = (da << 24 >>> 0) + (cb << 16) + (cg << 8) + cr;
            let offset = vertexCount;
            data[offset].x = point.x + _normal.x * stroke;
            data[offset].y = point.y + _normal.y * stroke;
            data[offset].u = 1;
            data[offset].v = progress;
            data[offset].color._val = c;
            offset += 1;
            data[offset].x = point.x - _normal.x * stroke;
            data[offset].y = point.y - _normal.y * stroke;
            data[offset].u = 0;
            data[offset].v = progress;
            data[offset].color._val = c;
            vertexCount += 2;
          }
          indexCount = vertexCount <= 2 ? 0 : (vertexCount - 2) * 3;
          renderData.resize(vertexCount, indexCount);
          {
            const indexCount = renderData.indexCount;
            this.createQuadIndices(comp, indexCount);
            renderData.chunk.setIndexBuffer(QUAD_INDICES);
            this.updateWorldVertexAllData(comp);
            renderData.updateRenderData(comp, comp.texture);
            comp.markForUpdateRenderData();
          }
        },
        updateWorldVertexAllData(comp) {
          const renderData = comp.renderData;
          const stride = renderData.floatStride;
          const dataList = renderData.data;
          const vData = renderData.chunk.vb;
          for (let i = 0; i < dataList.length; i++) {
            const offset = i * stride;
            vData[offset + 0] = dataList[i].x;
            vData[offset + 1] = dataList[i].y;
            vData[offset + 2] = dataList[i].z;
            vData[offset + 3] = dataList[i].u;
            vData[offset + 4] = dataList[i].v;
            Color$1.toArray(vData, dataList[i].color, offset + 5);
          }
        },
        createQuadIndices(comp, indexCount) {
          const renderData = comp.renderData;
          const chunk = renderData.chunk;
          const vid = 0;
          const meshBuffer = chunk.meshBuffer;
          let indexOffset = meshBuffer.indexOffset;
          QUAD_INDICES = null;
          QUAD_INDICES = new Uint16Array(indexCount);
          for (let i = 0, l = indexCount; i < l; i += 2) {
            const start = vid + i;
            QUAD_INDICES[indexOffset++] = start;
            QUAD_INDICES[indexOffset++] = start + 2;
            QUAD_INDICES[indexOffset++] = start + 1;
            QUAD_INDICES[indexOffset++] = start + 1;
            QUAD_INDICES[indexOffset++] = start + 2;
            QUAD_INDICES[indexOffset++] = start + 3;
          }
        },
        updateRenderDataCache(comp, renderData) {
          if (renderData.passDirty) {
            renderData.updatePass(comp);
          }
          if (renderData.nodeDirty) {
            renderData.updateNode(comp);
          }
          if (renderData.textureDirty && comp.texture) {
            renderData.updateTexture(comp.texture);
            renderData.material = comp.getRenderMaterial(0);
          }
          if (renderData.hashDirty) {
            renderData.updateHash();
          }
        },
        updateRenderData(comp) {
          {
            comp.renderData.renderDrawInfo.setVertDirty(false);
            comp.node.hasChangedFlags = 0;
          }
        },
        updateColor(comp) {},
        fillBuffers(comp, renderer) {
          const renderData = comp.renderData;
          const chunk = renderData.chunk;
          const dataList = renderData.data;
          const vertexCount = renderData.vertexCount;
          const indexCount = renderData.indexCount;
          const vData = chunk.vb;
          let vertexOffset = 0;
          for (let i = 0; i < vertexCount; i++) {
            const vert = dataList[i];
            vData[vertexOffset++] = vert.x;
            vData[vertexOffset++] = vert.y;
            vData[vertexOffset++] = vert.z;
            vData[vertexOffset++] = vert.u;
            vData[vertexOffset++] = vert.v;
            Color$1.toArray(vData, vert.color, vertexOffset);
            vertexOffset += 4;
          }
          chunk.bufferId;
          const vid = chunk.vertexOffset;
          const meshBuffer = chunk.meshBuffer;
          const ib = chunk.meshBuffer.iData;
          let indexOffset = meshBuffer.indexOffset;
          for (let i = 0, l = indexCount; i < l; i += 2) {
            const start = vid + i;
            ib[indexOffset++] = start;
            ib[indexOffset++] = start + 2;
            ib[indexOffset++] = start + 1;
            ib[indexOffset++] = start + 1;
            ib[indexOffset++] = start + 2;
            ib[indexOffset++] = start + 3;
          }
          meshBuffer.indexOffset += renderData.indexCount;
          meshBuffer.setDirty();
        }
      };
      const MotionStreakAssemblerManager = exports('MotionStreakAssemblerManager', {
        getAssembler(comp) {
          return MotionStreakAssembler;
        }
      });
      MotionStreak.Assembler = MotionStreakAssemblerManager;

      const ParticleAssembler = {
        maxParticleDeltaTime: 0,
        createData(comp) {
          return MeshRenderData.add();
        },
        removeData(data) {
          MeshRenderData.remove(data);
        },
        updateRenderData() {},
        fillBuffers(comp, renderer) {}
      };
      const ParticleSystem2DAssembler = exports('ParticleSystem2DAssembler', {
        getAssembler(comp) {
          if (!ParticleAssembler.maxParticleDeltaTime) {
            ParticleAssembler.maxParticleDeltaTime = legacyCC.game.frameTime / 1000 * 2;
          }
          return ParticleAssembler;
        }
      });
      ParticleSystem2D.Assembler = ParticleSystem2DAssembler;

      class Action {
        constructor() {
          this.originalTarget = null;
          this.target = null;
          this.tag = Action.TAG_INVALID;
        }
        clone() {
          const action = new Action();
          action.originalTarget = null;
          action.target = null;
          action.tag = this.tag;
          return action;
        }
        isDone() {
          return true;
        }
        startWithTarget(target) {
          this.originalTarget = target;
          this.target = target;
        }
        stop() {
          this.target = null;
        }
        step(dt) {
          logID(1006);
        }
        update(dt) {
          logID(1007);
        }
        getTarget() {
          return this.target;
        }
        setTarget(target) {
          this.target = target;
        }
        getOriginalTarget() {
          return this.originalTarget;
        }
        setOriginalTarget(originalTarget) {
          this.originalTarget = originalTarget;
        }
        getTag() {
          return this.tag;
        }
        setTag(tag) {
          this.tag = tag;
        }
        reverse() {
          logID(1008);
          return null;
        }
        retain() {}
        release() {}
      }
      Action.TAG_INVALID = -1;
      class FiniteTimeAction extends Action {
        constructor(...args) {
          super(...args);
          this._duration = 0;
          this._timesForRepeat = 1;
        }
        getDuration() {
          return this._duration * (this._timesForRepeat || 1);
        }
        setDuration(duration) {
          this._duration = duration;
        }
        clone() {
          return new FiniteTimeAction();
        }
      }

      let ID_COUNTER = 0;
      class HashElement {
        constructor() {
          this.actions = [];
          this.target = null;
          this.actionIndex = 0;
          this.currentAction = null;
          this.paused = false;
          this.lock = false;
        }
      }
      class ActionManager {
        constructor() {
          this._hashTargets = new Map();
          this._arrayTargets = [];
          this._currentTarget = void 0;
          this._elementPool = [];
        }
        _searchElementByTarget(arr, target) {
          for (let k = 0; k < arr.length; k++) {
            if (target === arr[k].target) return arr[k];
          }
          return null;
        }
        _getElement(target, paused) {
          let element = this._elementPool.pop();
          if (!element) {
            element = new HashElement();
          }
          element.target = target;
          element.paused = !!paused;
          return element;
        }
        _putElement(element) {
          element.actions.length = 0;
          element.actionIndex = 0;
          element.currentAction = null;
          element.paused = false;
          element.target = null;
          element.lock = false;
          this._elementPool.push(element);
        }
        addAction(action, target, paused) {
          if (!action || !target) {
            errorID(1000);
            return;
          }
          if (target.uuid == null) {
            target.uuid = `_TWEEN_UUID_${ID_COUNTER++}`;
          }
          let element = this._hashTargets.get(target);
          if (!element) {
            element = this._getElement(target, paused);
            this._hashTargets.set(target, element);
            this._arrayTargets.push(element);
          } else if (!element.actions) {
            element.actions = [];
          }
          element.target = target;
          element.actions.push(action);
          action.startWithTarget(target);
        }
        removeAllActions() {
          const locTargets = this._arrayTargets;
          for (let i = 0; i < locTargets.length; i++) {
            const element = locTargets[i];
            if (element) this._putElement(element);
          }
          this._arrayTargets.length = 0;
          this._hashTargets = new Map();
        }
        removeAllActionsFromTarget(target) {
          if (target == null) return;
          const element = this._hashTargets.get(target);
          if (element) {
            element.actions.length = 0;
            this._deleteHashElement(element);
          }
        }
        removeAction(action) {
          if (action == null) return;
          const target = action.getOriginalTarget();
          const element = this._hashTargets.get(target);
          if (element) {
            for (let i = 0; i < element.actions.length; i++) {
              if (element.actions[i] === action) {
                element.actions.splice(i, 1);
                if (element.actionIndex >= i) element.actionIndex--;
                break;
              }
            }
          }
        }
        _removeActionByTag(tag, element, target) {
          for (let i = 0, l = element.actions.length; i < l; ++i) {
            const action = element.actions[i];
            if (action && action.getTag() === tag) {
              if (target && action.getOriginalTarget() !== target) {
                continue;
              }
              this._removeActionAtIndex(i, element);
              break;
            }
          }
        }
        _removeAllActionsByTag(tag, element, target) {
          for (let i = element.actions.length - 1; i >= 0; --i) {
            const action = element.actions[i];
            if (action && action.getTag() === tag) {
              if (target && action.getOriginalTarget() !== target) {
                continue;
              }
              this._removeActionAtIndex(i, element);
            }
          }
        }
        removeActionByTag(tag, target) {
          if (tag === Action.TAG_INVALID) logID(1002);
          const hashTargets = this._hashTargets;
          if (target) {
            const element = hashTargets.get(target);
            if (element) {
              this._removeActionByTag(tag, element, target);
            }
          } else {
            hashTargets.forEach(element => {
              this._removeActionByTag(tag, element);
            });
          }
        }
        removeAllActionsByTag(tag, target) {
          if (tag === Action.TAG_INVALID) logID(1002);
          const hashTargets = this._hashTargets;
          if (target) {
            const element = hashTargets.get(target);
            if (element) {
              this._removeAllActionsByTag(tag, element, target);
            }
          } else {
            hashTargets.forEach(element => {
              this._removeAllActionsByTag(tag, element);
            });
          }
        }
        getActionByTag(tag, target) {
          if (tag === Action.TAG_INVALID) logID(1004);
          const element = this._hashTargets.get(target);
          if (element) {
            if (element.actions != null) {
              for (let i = 0; i < element.actions.length; ++i) {
                const action = element.actions[i];
                if (action && action.getTag() === tag) {
                  return action;
                }
              }
            }
            logID(1005, tag);
          }
          return null;
        }
        getNumberOfRunningActionsInTarget(target) {
          const element = this._hashTargets.get(target);
          if (element) {
            return element.actions ? element.actions.length : 0;
          }
          return 0;
        }
        pauseTarget(target) {
          const element = this._hashTargets.get(target);
          if (element) element.paused = true;
        }
        resumeTarget(target) {
          const element = this._hashTargets.get(target);
          if (element) element.paused = false;
        }
        pauseAllRunningActions() {
          const idsWithActions = [];
          const locTargets = this._arrayTargets;
          for (let i = 0; i < locTargets.length; i++) {
            const element = locTargets[i];
            if (element && !element.paused) {
              element.paused = true;
              idsWithActions.push(element.target);
            }
          }
          return idsWithActions;
        }
        resumeTargets(targetsToResume) {
          if (!targetsToResume) return;
          for (let i = 0; i < targetsToResume.length; i++) {
            if (targetsToResume[i]) this.resumeTarget(targetsToResume[i]);
          }
        }
        pauseTargets(targetsToPause) {
          if (!targetsToPause) return;
          for (let i = 0; i < targetsToPause.length; i++) {
            if (targetsToPause[i]) this.pauseTarget(targetsToPause[i]);
          }
        }
        purgeSharedManager() {
          legacyCC.director.getScheduler().unscheduleUpdate(this);
        }
        _removeActionAtIndex(index, element) {
          element.actions[index];
          element.actions.splice(index, 1);
          if (element.actionIndex >= index) element.actionIndex--;
          if (element.actions.length === 0) {
            this._deleteHashElement(element);
          }
        }
        _deleteHashElement(element) {
          let ret = false;
          if (element && !element.lock) {
            if (this._hashTargets.get(element.target)) {
              this._hashTargets.delete(element.target);
              const targets = this._arrayTargets;
              for (let i = 0, l = targets.length; i < l; i++) {
                if (targets[i] === element) {
                  targets.splice(i, 1);
                  break;
                }
              }
              this._putElement(element);
              ret = true;
            }
          }
          return ret;
        }
        update(dt) {
          const locTargets = this._arrayTargets;
          let locCurrTarget;
          for (let elt = 0; elt < locTargets.length; elt++) {
            this._currentTarget = locTargets[elt];
            locCurrTarget = this._currentTarget;
            const target = locCurrTarget.target;
            if (isCCObject(target) && !target.isValid) {
              this.removeAllActionsFromTarget(target);
              elt--;
              continue;
            }
            if (!locCurrTarget.paused && locCurrTarget.actions) {
              locCurrTarget.lock = true;
              for (locCurrTarget.actionIndex = 0; locCurrTarget.actionIndex < locCurrTarget.actions.length; locCurrTarget.actionIndex++) {
                locCurrTarget.currentAction = locCurrTarget.actions[locCurrTarget.actionIndex];
                if (!locCurrTarget.currentAction) continue;
                locCurrTarget.currentAction.step(dt * (this._isActionInternal(locCurrTarget.currentAction) ? locCurrTarget.currentAction.getSpeed() : 1));
                if (locCurrTarget.currentAction && locCurrTarget.currentAction.isDone()) {
                  locCurrTarget.currentAction.stop();
                  const action = locCurrTarget.currentAction;
                  locCurrTarget.currentAction = null;
                  this.removeAction(action);
                }
                locCurrTarget.currentAction = null;
              }
              locCurrTarget.lock = false;
            }
            if (locCurrTarget.actions.length === 0) {
              if (this._deleteHashElement(locCurrTarget)) {
                elt--;
              }
            }
          }
        }
        _isActionInternal(action) {
          return typeof action._speedMethod !== 'undefined';
        }
      }

      class TweenSystem extends System {
        constructor(...args) {
          super(...args);
          this.actionMgr = new ActionManager();
        }
        get ActionManager() {
          return this.actionMgr;
        }
        update(dt) {
          {
            this.actionMgr.update(dt);
          }
        }
      } exports('TweenSystem', TweenSystem);
      TweenSystem.ID = 'TWEEN';
      TweenSystem.instance = void 0;
      director.on(Director.EVENT_INIT, () => {
        const sys = new TweenSystem();
        TweenSystem.instance = sys;
        director.registerSystem(TweenSystem.ID, sys, System.Priority.MEDIUM);
      });

      class ActionInstant extends FiniteTimeAction {
        isDone() {
          return true;
        }
        step(dt) {
          this.update(1);
        }
        update(dt) {}
        reverse() {
          return this.clone();
        }
        clone() {
          return new ActionInstant();
        }
      }
      class Show extends ActionInstant {
        update(dt) {
          const _renderComps = this.target.getComponentsInChildren(Renderer);
          for (let i = 0; i < _renderComps.length; ++i) {
            const render = _renderComps[i];
            render.enabled = true;
          }
        }
        reverse() {
          return new Hide();
        }
        clone() {
          return new Show();
        }
      }
      function show() {
        return new Show();
      }
      class Hide extends ActionInstant {
        update(dt) {
          const _renderComps = this.target.getComponentsInChildren(Renderer);
          for (let i = 0; i < _renderComps.length; ++i) {
            const render = _renderComps[i];
            render.enabled = false;
          }
        }
        reverse() {
          return new Show();
        }
        clone() {
          return new Hide();
        }
      }
      function hide() {
        return new Hide();
      }
      class RemoveSelf extends ActionInstant {
        constructor(isNeedCleanUp) {
          super();
          this._isNeedCleanUp = true;
          isNeedCleanUp !== undefined && this.init(isNeedCleanUp);
        }
        update(dt) {
          this.target.removeFromParent();
          if (this._isNeedCleanUp) {
            this.target.destroy();
          }
        }
        init(isNeedCleanUp) {
          this._isNeedCleanUp = isNeedCleanUp;
          return true;
        }
        reverse() {
          return new RemoveSelf(this._isNeedCleanUp);
        }
        clone() {
          return new RemoveSelf(this._isNeedCleanUp);
        }
      }
      function removeSelf(isNeedCleanUp) {
        return new RemoveSelf(isNeedCleanUp);
      }
      class CallFunc extends ActionInstant {
        constructor(selector, selectorTarget, data) {
          super();
          this._selectorTarget = null;
          this._function = null;
          this._data = null;
          this.initWithFunction(selector, selectorTarget, data);
        }
        initWithFunction(selector, selectorTarget, data) {
          if (selector) {
            this._function = selector;
          }
          if (selectorTarget) {
            this._selectorTarget = selectorTarget;
          }
          if (data !== undefined) {
            this._data = data;
          }
          return true;
        }
        execute() {
          if (this._function) {
            this._function.call(this._selectorTarget, this.target, this._data);
          }
        }
        update(dt) {
          this.execute();
        }
        getTargetCallback() {
          return this._selectorTarget;
        }
        setTargetCallback(sel) {
          if (sel !== this._selectorTarget) {
            if (this._selectorTarget) {
              this._selectorTarget = null;
            }
            this._selectorTarget = sel;
          }
        }
        clone() {
          const action = new CallFunc();
          action.initWithFunction(this._function, this._selectorTarget, this._data);
          return action;
        }
      }
      function callFunc(selector, selectorTarget, data) {
        return new CallFunc(selector, selectorTarget, data);
      }

      var _class2$e, _class5;
      class ActionInterval extends FiniteTimeAction {
        constructor(d) {
          super();
          this.MAX_VALUE = 2;
          this._elapsed = 0;
          this._firstTick = false;
          this._easeList = [];
          this._speed = 1;
          this._repeatForever = false;
          this._repeatMethod = false;
          this._speedMethod = false;
          if (d !== undefined && !isNaN(d)) {
            this.initWithDuration(d);
          }
        }
        getElapsed() {
          return this._elapsed;
        }
        initWithDuration(d) {
          this._duration = d === 0 ? macro.FLT_EPSILON : d;
          this._elapsed = 0;
          this._firstTick = true;
          return true;
        }
        isDone() {
          return this._elapsed >= this._duration;
        }
        _cloneDecoration(action) {
          action._repeatForever = this._repeatForever;
          action._speed = this._speed;
          action._timesForRepeat = this._timesForRepeat;
          action._easeList = this._easeList;
          action._speedMethod = this._speedMethod;
          action._repeatMethod = this._repeatMethod;
        }
        _reverseEaseList(action) {
          if (this._easeList) {
            action._easeList = [];
            for (let i = 0; i < this._easeList.length; i++) {
              action._easeList.push(this._easeList[i]);
            }
          }
        }
        clone() {
          const action = new ActionInterval(this._duration);
          this._cloneDecoration(action);
          return action;
        }
        easing(easeObj) {
          if (this._easeList) this._easeList.length = 0;else this._easeList = [];
          for (let i = 0; i < arguments.length; i++) this._easeList.push(arguments[i]);
          return this;
        }
        _computeEaseTime(dt) {
          return dt;
        }
        step(dt) {
          if (this._firstTick) {
            this._firstTick = false;
            this._elapsed = 0;
          } else this._elapsed += dt;
          let t = this._elapsed / (this._duration > 0.0000001192092896 ? this._duration : 0.0000001192092896);
          t = t < 1 ? t : 1;
          this.update(t > 0 ? t : 0);
          if (this._repeatMethod && this._timesForRepeat > 1 && this.isDone()) {
            if (!this._repeatForever) {
              this._timesForRepeat--;
            }
            this.startWithTarget(this.target);
            this.step(this._elapsed - this._duration);
          }
        }
        startWithTarget(target) {
          Action.prototype.startWithTarget.call(this, target);
          this._elapsed = 0;
          this._firstTick = true;
        }
        reverse() {
          logID(1010);
          return this;
        }
        setAmplitudeRate(amp) {
          logID(1011);
        }
        getAmplitudeRate() {
          logID(1012);
          return 0;
        }
        speed(speed) {
          if (speed <= 0) {
            logID(1013);
            return this;
          }
          this._speedMethod = true;
          this._speed *= speed;
          return this;
        }
        getSpeed() {
          return this._speed;
        }
        setSpeed(speed) {
          this._speed = speed;
          return this;
        }
        repeat(times) {
          times = Math.round(times);
          if (isNaN(times) || times < 1) {
            logID(1014);
            return this;
          }
          this._repeatMethod = true;
          this._timesForRepeat *= times;
          return this;
        }
        repeatForever() {
          this._repeatMethod = true;
          this._timesForRepeat = this.MAX_VALUE;
          this._repeatForever = true;
          return this;
        }
      }
      class Sequence extends ActionInterval {
        constructor(tempArray) {
          super();
          this._actions = [];
          this._split = 0;
          this._last = 0;
          this._reversed = false;
          const paramArray = tempArray instanceof Array ? tempArray : arguments;
          if (paramArray.length === 1) {
            errorID(1019);
            return;
          }
          const last = paramArray.length - 1;
          if (last >= 0 && paramArray[last] == null) logID(1015);
          if (last >= 0) {
            let prev = paramArray[0];
            let action1;
            for (let i = 1; i < last; i++) {
              if (paramArray[i]) {
                action1 = prev;
                prev = Sequence._actionOneTwo(action1, paramArray[i]);
              }
            }
            this.initWithTwoActions(prev, paramArray[last]);
          }
        }
        initWithTwoActions(actionOne, actionTwo) {
          if (!actionOne || !actionTwo) {
            errorID(1025);
            return false;
          }
          let durationOne = actionOne._duration;
          let durationTwo = actionTwo._duration;
          durationOne *= actionOne._repeatMethod ? actionOne._timesForRepeat : 1;
          durationTwo *= actionTwo._repeatMethod ? actionTwo._timesForRepeat : 1;
          const d = durationOne + durationTwo;
          this.initWithDuration(d);
          this._actions[0] = actionOne;
          this._actions[1] = actionTwo;
          return true;
        }
        clone() {
          const action = new Sequence();
          this._cloneDecoration(action);
          action.initWithTwoActions(this._actions[0].clone(), this._actions[1].clone());
          return action;
        }
        startWithTarget(target) {
          ActionInterval.prototype.startWithTarget.call(this, target);
          this._split = this._actions[0]._duration / this._duration;
          this._split *= this._actions[0]._repeatMethod ? this._actions[0]._timesForRepeat : 1;
          this._last = -1;
        }
        stop() {
          if (this._last !== -1) this._actions[this._last].stop();
          Action.prototype.stop.call(this);
        }
        update(dt) {
          let new_t;
          let found = 0;
          const locSplit = this._split;
          const locActions = this._actions;
          const locLast = this._last;
          let actionFound;
          dt = this._computeEaseTime(dt);
          if (dt < locSplit) {
            new_t = locSplit !== 0 ? dt / locSplit : 1;
            if (found === 0 && locLast === 1 && this._reversed) {
              locActions[1].update(0);
              locActions[1].stop();
            }
          } else {
            found = 1;
            new_t = locSplit === 1 ? 1 : (dt - locSplit) / (1 - locSplit);
            if (locLast === -1) {
              locActions[0].startWithTarget(this.target);
              locActions[0].update(1);
              locActions[0].stop();
            }
            if (locLast === 0) {
              locActions[0].update(1);
              locActions[0].stop();
            }
          }
          actionFound = locActions[found];
          if (locLast === found && actionFound.isDone()) return;
          if (locLast !== found) actionFound.startWithTarget(this.target);
          new_t *= actionFound._timesForRepeat;
          actionFound.update(new_t > 1 ? new_t % 1 : new_t);
          this._last = found;
        }
        reverse() {
          const action = Sequence._actionOneTwo(this._actions[1].reverse(), this._actions[0].reverse());
          this._cloneDecoration(action);
          this._reverseEaseList(action);
          action._reversed = true;
          return action;
        }
      }
      _class2$e = Sequence;
      Sequence._actionOneTwo = function (actionOne, actionTwo) {
        const sequence = new _class2$e();
        sequence.initWithTwoActions(actionOne, actionTwo);
        return sequence;
      };
      function sequence(tempArray) {
        const paramArray = tempArray instanceof Array ? tempArray : arguments;
        if (paramArray.length === 1) {
          errorID(1019);
          return null;
        }
        const last = paramArray.length - 1;
        if (last >= 0 && paramArray[last] == null) logID(1015);
        let result = null;
        if (last >= 0) {
          result = paramArray[0];
          for (let i = 1; i <= last; i++) {
            if (paramArray[i]) {
              result = Sequence._actionOneTwo(result, paramArray[i]);
            }
          }
        }
        return result;
      }
      class Repeat extends ActionInterval {
        constructor(action, times) {
          super();
          this._times = 0;
          this._total = 0;
          this._nextDt = 0;
          this._actionInstant = false;
          this._innerAction = null;
          times !== undefined && this.initWithAction(action, times);
        }
        initWithAction(action, times) {
          const duration = action._duration * times;
          if (this.initWithDuration(duration)) {
            this._times = times;
            this._innerAction = action;
            if (action instanceof ActionInstant) {
              this._actionInstant = true;
              this._times -= 1;
            }
            this._total = 0;
            return true;
          }
          return false;
        }
        clone() {
          const action = new Repeat();
          this._cloneDecoration(action);
          action.initWithAction(this._innerAction.clone(), this._times);
          return action;
        }
        startWithTarget(target) {
          this._total = 0;
          this._nextDt = this._innerAction._duration / this._duration;
          ActionInterval.prototype.startWithTarget.call(this, target);
          this._innerAction.startWithTarget(target);
        }
        stop() {
          this._innerAction.stop();
          Action.prototype.stop.call(this);
        }
        update(dt) {
          dt = this._computeEaseTime(dt);
          const locInnerAction = this._innerAction;
          const locDuration = this._duration;
          const locTimes = this._times;
          let locNextDt = this._nextDt;
          if (dt >= locNextDt) {
            while (dt > locNextDt && this._total < locTimes) {
              locInnerAction.update(1);
              this._total++;
              locInnerAction.stop();
              locInnerAction.startWithTarget(this.target);
              locNextDt += locInnerAction._duration / locDuration;
              this._nextDt = locNextDt > 1 ? 1 : locNextDt;
            }
            if (dt >= 1.0 && this._total < locTimes) {
              locInnerAction.update(1);
              this._total++;
            }
            if (!this._actionInstant) {
              if (this._total === locTimes) {
                locInnerAction.stop();
              } else {
                locInnerAction.update(dt - (locNextDt - locInnerAction._duration / locDuration));
              }
            }
          } else {
            locInnerAction.update(dt * locTimes % 1.0);
          }
        }
        isDone() {
          return this._total === this._times;
        }
        reverse() {
          const action = new Repeat(this._innerAction.reverse(), this._times);
          this._cloneDecoration(action);
          this._reverseEaseList(action);
          return action;
        }
        setInnerAction(action) {
          if (this._innerAction !== action) {
            this._innerAction = action;
          }
        }
        getInnerAction() {
          return this._innerAction;
        }
      }
      function repeat(action, times) {
        return new Repeat(action, times);
      }
      class RepeatForever extends ActionInterval {
        constructor(action) {
          super();
          this._innerAction = null;
          action && this.initWithAction(action);
        }
        initWithAction(action) {
          if (!action) {
            errorID(1026);
            return false;
          }
          this._innerAction = action;
          return true;
        }
        clone() {
          const action = new RepeatForever();
          this._cloneDecoration(action);
          action.initWithAction(this._innerAction.clone());
          return action;
        }
        startWithTarget(target) {
          ActionInterval.prototype.startWithTarget.call(this, target);
          this._innerAction.startWithTarget(target);
        }
        step(dt) {
          const locInnerAction = this._innerAction;
          locInnerAction.step(dt);
          if (locInnerAction.isDone()) {
            locInnerAction.startWithTarget(this.target);
            locInnerAction.step(locInnerAction.getElapsed() - locInnerAction._duration);
          }
        }
        isDone() {
          return false;
        }
        reverse() {
          const action = new RepeatForever(this._innerAction.reverse());
          this._cloneDecoration(action);
          this._reverseEaseList(action);
          return action;
        }
        setInnerAction(action) {
          if (this._innerAction !== action) {
            this._innerAction = action;
          }
        }
        getInnerAction() {
          return this._innerAction;
        }
      }
      function repeatForever(action) {
        return new RepeatForever(action);
      }
      class Spawn extends ActionInterval {
        constructor(tempArray) {
          super();
          this._one = null;
          this._two = null;
          const paramArray = tempArray instanceof Array ? tempArray : arguments;
          if (paramArray.length === 1) {
            errorID(1020);
            return;
          }
          const last = paramArray.length - 1;
          if (last >= 0 && paramArray[last] == null) logID(1015);
          if (last >= 0) {
            let prev = paramArray[0];
            let action1;
            for (let i = 1; i < last; i++) {
              if (paramArray[i]) {
                action1 = prev;
                prev = Spawn._actionOneTwo(action1, paramArray[i]);
              }
            }
            this.initWithTwoActions(prev, paramArray[last]);
          }
        }
        initWithTwoActions(action1, action2) {
          if (!action1 || !action2) {
            errorID(1027);
            return false;
          }
          let ret = false;
          const d1 = action1._duration;
          const d2 = action2._duration;
          if (this.initWithDuration(Math.max(d1, d2))) {
            this._one = action1;
            this._two = action2;
            if (d1 > d2) {
              this._two = Sequence._actionOneTwo(action2, delayTime(d1 - d2));
            } else if (d1 < d2) {
              this._one = Sequence._actionOneTwo(action1, delayTime(d2 - d1));
            }
            ret = true;
          }
          return ret;
        }
        clone() {
          const action = new Spawn();
          this._cloneDecoration(action);
          action.initWithTwoActions(this._one.clone(), this._two.clone());
          return action;
        }
        startWithTarget(target) {
          ActionInterval.prototype.startWithTarget.call(this, target);
          this._one.startWithTarget(target);
          this._two.startWithTarget(target);
        }
        stop() {
          this._one.stop();
          this._two.stop();
          Action.prototype.stop.call(this);
        }
        update(dt) {
          dt = this._computeEaseTime(dt);
          if (this._one) this._one.update(dt);
          if (this._two) this._two.update(dt);
        }
        reverse() {
          const action = Spawn._actionOneTwo(this._one.reverse(), this._two.reverse());
          this._cloneDecoration(action);
          this._reverseEaseList(action);
          return action;
        }
      }
      _class5 = Spawn;
      Spawn._actionOneTwo = function (action1, action2) {
        const pSpawn = new _class5();
        pSpawn.initWithTwoActions(action1, action2);
        return pSpawn;
      };
      function spawn(tempArray) {
        const paramArray = tempArray instanceof Array ? tempArray : arguments;
        if (paramArray.length === 1) {
          errorID(1020);
          return null;
        }
        if (paramArray.length > 0 && paramArray[paramArray.length - 1] == null) logID(1015);
        let prev = paramArray[0];
        for (let i = 1; i < paramArray.length; i++) {
          if (paramArray[i] != null) prev = Spawn._actionOneTwo(prev, paramArray[i]);
        }
        return prev;
      }
      class DelayTime extends ActionInterval {
        update(dt) {}
        reverse() {
          const action = new DelayTime(this._duration);
          this._cloneDecoration(action);
          this._reverseEaseList(action);
          return action;
        }
        clone() {
          const action = new DelayTime();
          this._cloneDecoration(action);
          action.initWithDuration(this._duration);
          return action;
        }
      }
      function delayTime(d) {
        return new DelayTime(d);
      }
      class ReverseTime extends ActionInterval {
        constructor(action) {
          super();
          this._other = null;
          action && this.initWithAction(action);
        }
        initWithAction(action) {
          if (!action) {
            errorID(1028);
            return false;
          }
          if (action === this._other) {
            errorID(1029);
            return false;
          }
          if (ActionInterval.prototype.initWithDuration.call(this, action._duration)) {
            this._other = action;
            return true;
          }
          return false;
        }
        clone() {
          const action = new ReverseTime();
          this._cloneDecoration(action);
          action.initWithAction(this._other.clone());
          return action;
        }
        startWithTarget(target) {
          ActionInterval.prototype.startWithTarget.call(this, target);
          this._other.startWithTarget(target);
        }
        update(dt) {
          dt = this._computeEaseTime(dt);
          if (this._other) this._other.update(1 - dt);
        }
        reverse() {
          return this._other.clone();
        }
        stop() {
          this._other.stop();
          Action.prototype.stop.call(this);
        }
      }
      function reverseTime(action) {
        return new ReverseTime(action);
      }

      function TweenEasingAdapter(easingName) {
        const initialChar = easingName.charAt(0);
        if (/[A-Z]/.test(initialChar)) {
          easingName = easingName.replace(initialChar, initialChar.toLowerCase());
          const arr = easingName.split('-');
          if (arr.length === 2) {
            const str0 = arr[0];
            if (str0 === 'linear') {
              easingName = 'linear';
            } else {
              const str1 = arr[1];
              switch (str0) {
                case 'quadratic':
                  easingName = `quad${str1}`;
                  break;
                case 'quartic':
                  easingName = `quart${str1}`;
                  break;
                case 'quintic':
                  easingName = `quint${str1}`;
                  break;
                case 'sinusoidal':
                  easingName = `sine${str1}`;
                  break;
                case 'exponential':
                  easingName = `expo${str1}`;
                  break;
                case 'circular':
                  easingName = `circ${str1}`;
                  break;
                default:
                  easingName = str0 + str1;
                  break;
              }
            }
          }
        }
        return easingName;
      }
      function TweenOptionChecker(opts) {
        const header = ' [Tween:] ';
        const message = ` option is not support in v + ${engineVersion}`;
        const _opts = opts;
        if (_opts.delay) {
          warn(`${header}delay${message}`);
        }
        if (_opts.repeat) {
          warn(`${header}repeat${message}`);
        }
        if (_opts.repeatDelay) {
          warn(`${header}repeatDelay${message}`);
        }
        if (_opts.interpolation) {
          warn(`${header}interpolation${message}`);
        }
        if (_opts.onStop) {
          warn(`${header}onStop${message}`);
        }
      }
      class TweenAction extends ActionInterval {
        constructor(duration, props, opts) {
          super();
          this._opts = void 0;
          this._props = void 0;
          this._originProps = void 0;
          if (opts == null) {
            opts = Object.create(null);
          } else {
            TweenOptionChecker(opts);
            if (opts.easing && typeof opts.easing === 'string') {
              opts.easing = TweenEasingAdapter(opts.easing);
            }
            if (!opts.progress) {
              opts.progress = this.progress;
            }
            if (opts.easing && typeof opts.easing === 'string') {
              const easingName = opts.easing;
              opts.easing = easing[easingName];
              if (!opts.easing) {
                warnID(1031, easingName);
              }
            }
          }
          this._opts = opts;
          this._props = Object.create(null);
          for (const name in props) {
            if (!props.hasOwnProperty(name)) continue;
            let value = props[name];
            if (typeof value === 'function') {
              value = value();
            }
            if (value == null || typeof value === 'string') continue;
            let customEasing;
            let progress;
            if (value.value !== undefined && (value.easing || value.progress)) {
              if (typeof value.easing === 'string') {
                customEasing = easing[value.easing];
                if (!customEasing) warnID(1031, value.easing);
              } else {
                customEasing = value.easing;
              }
              progress = value.progress;
              value = value.value;
            }
            const prop = Object.create(null);
            prop.value = value;
            prop.easing = customEasing;
            prop.progress = progress;
            this._props[name] = prop;
          }
          this._originProps = props;
          this.initWithDuration(duration);
        }
        clone() {
          const action = new TweenAction(this._duration, this._originProps, this._opts);
          this._cloneDecoration(action);
          return action;
        }
        startWithTarget(target) {
          ActionInterval.prototype.startWithTarget.call(this, target);
          const relative = !!this._opts.relative;
          const props = this._props;
          for (const property in props) {
            const _t = target[property];
            if (_t === undefined) {
              continue;
            }
            const prop = props[property];
            const value = prop.value;
            if (typeof _t === 'number') {
              prop.start = _t;
              prop.current = _t;
              prop.end = relative ? _t + value : value;
            } else if (typeof _t === 'object') {
              if (prop.start == null) {
                prop.start = {};
                prop.current = {};
                prop.end = {};
              }
              for (const k in value) {
                if (isNaN(_t[k])) continue;
                prop.start[k] = _t[k];
                prop.current[k] = _t[k];
                prop.end[k] = relative ? _t[k] + value[k] : value[k];
              }
            }
          }
          if (this._opts.onStart) {
            this._opts.onStart(this.target);
          }
        }
        update(t) {
          const target = this.target;
          if (!target) return;
          const props = this._props;
          const opts = this._opts;
          let easingTime = t;
          if (opts.easing) easingTime = opts.easing(t);
          const progress = opts.progress;
          for (const name in props) {
            const prop = props[name];
            const time = prop.easing ? prop.easing(t) : easingTime;
            const interpolation = prop.progress ? prop.progress : progress;
            const start = prop.start;
            const end = prop.end;
            if (typeof start === 'number') {
              prop.current = interpolation(start, end, prop.current, time);
            } else if (typeof start === 'object') {
              for (const k in start) {
                prop.current[k] = interpolation(start[k], end[k], prop.current[k], time);
              }
            }
            target[name] = prop.current;
          }
          if (opts.onUpdate) {
            opts.onUpdate(this.target, t);
          }
          if (t === 1 && opts.onComplete) {
            opts.onComplete(this.target);
          }
        }
        progress(start, end, current, t) {
          return start + (end - start) * t;
        }
      } exports('TweenAction', TweenAction);

      class SetAction extends ActionInstant {
        constructor(props) {
          super();
          this._props = void 0;
          this._props = {};
          props !== undefined && this.init(props);
        }
        init(props) {
          for (const name in props) {
            this._props[name] = props[name];
          }
          return true;
        }
        update() {
          const props = this._props;
          const target = this.target;
          for (const name in props) {
            target[name] = props[name];
          }
        }
        clone() {
          const action = new SetAction();
          action.init(this._props);
          return action;
        }
      }

      class Tween {
        constructor(target) {
          this._actions = [];
          this._finalAction = null;
          this._target = null;
          this._tag = Action.TAG_INVALID;
          this._target = target === undefined ? null : target;
        }
        tag(tag) {
          this._tag = tag;
          return this;
        }
        then(other) {
          if (other instanceof Action) {
            this._actions.push(other.clone());
          } else {
            this._actions.push(other._union());
          }
          return this;
        }
        target(target) {
          this._target = target;
          return this;
        }
        start() {
          if (!this._target) {
            warn('Please set target to tween first');
            return this;
          }
          if (this._finalAction) {
            TweenSystem.instance.ActionManager.removeAction(this._finalAction);
          }
          this._finalAction = this._union();
          this._finalAction.setTag(this._tag);
          TweenSystem.instance.ActionManager.addAction(this._finalAction, this._target, false);
          return this;
        }
        stop() {
          if (this._finalAction) {
            TweenSystem.instance.ActionManager.removeAction(this._finalAction);
          }
          return this;
        }
        clone(target) {
          const action = this._union();
          return tween(target).then(action.clone());
        }
        union() {
          const action = this._union();
          this._actions.length = 0;
          this._actions.push(action);
          return this;
        }
        to(duration, props, opts) {
          opts = opts || Object.create(null);
          opts.relative = false;
          const action = new TweenAction(duration, props, opts);
          this._actions.push(action);
          return this;
        }
        by(duration, props, opts) {
          opts = opts || Object.create(null);
          opts.relative = true;
          const action = new TweenAction(duration, props, opts);
          this._actions.push(action);
          return this;
        }
        set(props) {
          const action = new SetAction(props);
          this._actions.push(action);
          return this;
        }
        delay(duration) {
          const action = delayTime(duration);
          this._actions.push(action);
          return this;
        }
        call(callback) {
          const action = callFunc(callback);
          this._actions.push(action);
          return this;
        }
        sequence(...args) {
          const action = Tween._wrappedSequence(...args);
          this._actions.push(action);
          return this;
        }
        parallel(...args) {
          const action = Tween._wrappedParallel(...args);
          this._actions.push(action);
          return this;
        }
        repeat(repeatTimes, embedTween) {
          if (repeatTimes === Infinity) {
            return this.repeatForever(embedTween);
          }
          const actions = this._actions;
          let action;
          if (embedTween instanceof Tween) {
            action = embedTween._union();
          } else {
            action = actions.pop();
          }
          actions.push(repeat(action, repeatTimes));
          return this;
        }
        repeatForever(embedTween) {
          const actions = this._actions;
          let action;
          if (embedTween instanceof Tween) {
            action = embedTween._union();
          } else {
            action = actions.pop();
          }
          actions.push(repeatForever(action));
          return this;
        }
        reverseTime(embedTween) {
          const actions = this._actions;
          let action;
          if (embedTween instanceof Tween) {
            action = embedTween._union();
          } else {
            action = actions.pop();
          }
          actions.push(reverseTime(action));
          return this;
        }
        hide() {
          const action = hide();
          this._actions.push(action);
          return this;
        }
        show() {
          const action = show();
          this._actions.push(action);
          return this;
        }
        removeSelf() {
          const action = removeSelf(false);
          this._actions.push(action);
          return this;
        }
        destroySelf() {
          const action = removeSelf(true);
          this._actions.push(action);
          return this;
        }
        static stopAll() {
          TweenSystem.instance.ActionManager.removeAllActions();
        }
        static stopAllByTag(tag, target) {
          TweenSystem.instance.ActionManager.removeAllActionsByTag(tag, target);
        }
        static stopAllByTarget(target) {
          TweenSystem.instance.ActionManager.removeAllActionsFromTarget(target);
        }
        _union() {
          const actions = this._actions;
          let action;
          if (actions.length === 1) {
            action = actions[0];
          } else {
            action = sequence(actions);
          }
          return action;
        }
        _destroy() {
          this.stop();
        }
        static _wrappedSequence(...args) {
          const tmp_args = Tween._tmp_args;
          tmp_args.length = 0;
          for (let l = args.length, i = 0; i < l; i++) {
            const arg = tmp_args[i] = args[i];
            if (arg instanceof Tween) {
              tmp_args[i] = arg._union();
            }
          }
          return sequence.apply(sequence, tmp_args);
        }
        static _wrappedParallel(...args) {
          const tmp_args = Tween._tmp_args;
          tmp_args.length = 0;
          for (let l = args.length, i = 0; i < l; i++) {
            const arg = tmp_args[i] = args[i];
            if (arg instanceof Tween) {
              tmp_args[i] = arg._union();
            }
          }
          return spawn.apply(spawn, tmp_args);
        }
      } exports('Tween', Tween);
      Tween._tmp_args = [];
      legacyCC.Tween = Tween;
      function tween(target) {
        return new Tween(target);
      }
      legacyCC.tween = tween;
      function tweenUtil(target) {
        warn('tweenUtil\' is deprecated, please use \'tween\' instead ');
        return new Tween(target);
      }
      legacyCC.tweenUtil = tweenUtil;

      let DeviceType;
      (function (DeviceType) {
        DeviceType[DeviceType["Other"] = 0] = "Other";
        DeviceType[DeviceType["Left"] = 1] = "Left";
        DeviceType[DeviceType["Right"] = 2] = "Right";
      })(DeviceType || (DeviceType = {}));
      let XrUIPressEventType;
      (function (XrUIPressEventType) {
        XrUIPressEventType["XRUI_HOVER_ENTERED"] = "xrui-hover-entered";
        XrUIPressEventType["XRUI_HOVER_EXITED"] = "xrui-hover-exited";
        XrUIPressEventType["XRUI_HOVER_STAY"] = "xrui-hover-stay";
        XrUIPressEventType["XRUI_CLICK"] = "xrui-click";
        XrUIPressEventType["XRUI_UNCLICK"] = "xrui-unclick";
      })(XrUIPressEventType || (XrUIPressEventType = {}));
      let XrKeyboardEventType;
      (function (XrKeyboardEventType) {
        XrKeyboardEventType["XR_CAPS_LOCK"] = "xr-caps-lock";
        XrKeyboardEventType["XR_KEYBOARD_INIT"] = "xr-keyboard-init";
        XrKeyboardEventType["XR_KEYBOARD_INPUT"] = "xr-keyboard-input";
        XrKeyboardEventType["TO_LATIN"] = "to-latin";
        XrKeyboardEventType["TO_SYMBOL"] = "to-symbol";
        XrKeyboardEventType["TO_MATH_SYMBOL"] = "to-math-symbol";
      })(XrKeyboardEventType || (XrKeyboardEventType = {}));

      var _dec$h, _dec2$f, _dec3$e, _dec4$b, _dec5$b, _dec6$5, _dec7$4, _dec8$3, _dec9$3, _dec10$1, _class$h, _class2$d, _initializer$d, _initializer2$d, _initializer3$b, _initializer4$a, _initializer5$8, _initializer6$5, _initializer7$5, _initializer8$5, _initializer9$5, _initializer10$5, _initializer11$5, _initializer12$4, _initializer13$3, _initializer14$2, _class3$a;
      const _tempColor$1 = new Color$1();
      var Transition;
      (function (Transition) {
        Transition[Transition["NONE"] = 0] = "NONE";
        Transition[Transition["COLOR"] = 1] = "COLOR";
        Transition[Transition["SPRITE"] = 2] = "SPRITE";
        Transition[Transition["SCALE"] = 3] = "SCALE";
      })(Transition || (Transition = {}));
      ccenum(Transition);
      var State;
      (function (State) {
        State["NORMAL"] = "normal";
        State["HOVER"] = "hover";
        State["PRESSED"] = "pressed";
        State["DISABLED"] = "disabled";
      })(State || (State = {}));
      let EventType$4;
      (function (EventType) {
        EventType["CLICK"] = "click";
      })(EventType$4 || (EventType$4 = {}));
      let Button = (_dec$h = ccclass$3('cc.Button'), _dec2$f = executionOrder(110), _dec3$e = requireComponent(UITransform), _dec4$b = type$2(Node$1), _dec5$b = type$2(Transition), _dec6$5 = type$2(SpriteFrame), _dec7$4 = type$2(SpriteFrame), _dec8$3 = type$2(SpriteFrame), _dec9$3 = type$2(SpriteFrame), _dec10$1 = type$2([EventHandler]), _dec$h(_class$h = _dec2$f(_class$h = _dec3$e(_class$h = (_class2$d = (_class3$a = class Button extends Component {
        constructor(...args) {
          super(...args);
          this.clickEvents = _initializer$d && _initializer$d();
          this._interactable = _initializer2$d && _initializer2$d();
          this._transition = _initializer3$b && _initializer3$b();
          this._normalColor = _initializer4$a && _initializer4$a();
          this._hoverColor = _initializer5$8 && _initializer5$8();
          this._pressedColor = _initializer6$5 && _initializer6$5();
          this._disabledColor = _initializer7$5 && _initializer7$5();
          this._normalSprite = _initializer8$5 && _initializer8$5();
          this._hoverSprite = _initializer9$5 && _initializer9$5();
          this._pressedSprite = _initializer10$5 && _initializer10$5();
          this._disabledSprite = _initializer11$5 && _initializer11$5();
          this._duration = _initializer12$4 && _initializer12$4();
          this._zoomScale = _initializer13$3 && _initializer13$3();
          this._target = _initializer14$2 && _initializer14$2();
          this._pressed = false;
          this._hovered = false;
          this._fromColor = new Color$1();
          this._toColor = new Color$1();
          this._time = 0;
          this._transitionFinished = true;
          this._fromScale = new Vec3();
          this._toScale = new Vec3();
          this._originalScale = null;
          this._sprite = null;
          this._targetScale = new Vec3();
        }
        get target() {
          return this._target || this.node;
        }
        set target(value) {
          if (this._target === value) {
            return;
          }
          if (this._target) {
            this._unregisterTargetEvent(this._target);
          }
          this._target = value;
          this._applyTarget();
        }
        get interactable() {
          return this._interactable;
        }
        set interactable(value) {
          if (this._interactable === value) {
            return;
          }
          this._interactable = value;
          this._updateState();
          if (!this._interactable) {
            this._resetState();
          }
        }
        set _resizeToTarget(value) {
          if (value) {
            this._resizeNodeToTargetNode();
          }
        }
        get transition() {
          return this._transition;
        }
        set transition(value) {
          if (this._transition === value) {
            return;
          }
          if (this._transition === Transition.COLOR) {
            this._updateColorTransition(State.NORMAL);
          } else if (this._transition === Transition.SPRITE) {
            this._updateSpriteTransition(State.NORMAL);
          }
          this._transition = value;
          this._updateState();
        }
        get normalColor() {
          return this._normalColor;
        }
        set normalColor(value) {
          if (this._normalColor === value) {
            return;
          }
          this._normalColor.set(value);
          this._updateState();
        }
        get pressedColor() {
          return this._pressedColor;
        }
        set pressedColor(value) {
          if (this._pressedColor === value) {
            return;
          }
          this._pressedColor.set(value);
        }
        get hoverColor() {
          return this._hoverColor;
        }
        set hoverColor(value) {
          if (this._hoverColor === value) {
            return;
          }
          this._hoverColor.set(value);
        }
        get disabledColor() {
          return this._disabledColor;
        }
        set disabledColor(value) {
          if (this._disabledColor === value) {
            return;
          }
          this._disabledColor.set(value);
          this._updateState();
        }
        get duration() {
          return this._duration;
        }
        set duration(value) {
          if (this._duration === value) {
            return;
          }
          this._duration = value;
        }
        get zoomScale() {
          return this._zoomScale;
        }
        set zoomScale(value) {
          if (this._zoomScale === value) {
            return;
          }
          this._zoomScale = value;
        }
        get normalSprite() {
          return this._normalSprite;
        }
        set normalSprite(value) {
          if (this._normalSprite === value) {
            return;
          }
          this._normalSprite = value;
          const sprite = this.node.getComponent(Sprite);
          if (sprite) {
            sprite.spriteFrame = value;
          }
          this._updateState();
        }
        get pressedSprite() {
          return this._pressedSprite;
        }
        set pressedSprite(value) {
          if (this._pressedSprite === value) {
            return;
          }
          this._pressedSprite = value;
          this._updateState();
        }
        get hoverSprite() {
          return this._hoverSprite;
        }
        set hoverSprite(value) {
          if (this._hoverSprite === value) {
            return;
          }
          this._hoverSprite = value;
          this._updateState();
        }
        get disabledSprite() {
          return this._disabledSprite;
        }
        set disabledSprite(value) {
          if (this._disabledSprite === value) {
            return;
          }
          this._disabledSprite = value;
          this._updateState();
        }
        __preload() {
          if (!this.target) {
            this.target = this.node;
          }
          this._applyTarget();
          this._resetState();
        }
        onEnable() {
          {
            this._registerNodeEvent();
          }
        }
        onDisable() {
          this._resetState();
          {
            this._unregisterNodeEvent();
          }
        }
        onDestroy() {
          if (this.target.isValid) {
            this._unregisterTargetEvent(this.target);
          }
        }
        update(dt) {
          const target = this.target;
          if (this._transitionFinished || !target) {
            return;
          }
          if (this._transition !== Transition.COLOR && this._transition !== Transition.SCALE) {
            return;
          }
          this._time += dt;
          let ratio = 1.0;
          if (this._duration > 0) {
            ratio = this._time / this._duration;
          }
          if (ratio >= 1) {
            ratio = 1;
          }
          if (this._transition === Transition.COLOR) {
            const renderComp = target._uiProps.uiComp;
            Color$1.lerp(_tempColor$1, this._fromColor, this._toColor, ratio);
            if (renderComp) {
              renderComp.color = _tempColor$1;
            }
          } else if (this.transition === Transition.SCALE) {
            target.getScale(this._targetScale);
            this._targetScale.x = lerp(this._fromScale.x, this._toScale.x, ratio);
            this._targetScale.y = lerp(this._fromScale.y, this._toScale.y, ratio);
            target.setScale(this._targetScale);
          }
          if (ratio === 1) {
            this._transitionFinished = true;
          }
        }
        _resizeNodeToTargetNode() {
          if (!this.target) {
            return;
          }
          this.target._uiProps.uiTransformComp;
        }
        _resetState() {
          this._pressed = false;
          this._hovered = false;
          const target = this.target;
          if (!target) {
            return;
          }
          const transition = this._transition;
          if (transition === Transition.COLOR && this._interactable) {
            const renderComp = target.getComponent(UIRenderer);
            if (renderComp) {
              renderComp.color = this._normalColor;
            }
          } else if (transition === Transition.SCALE && this._originalScale) {
            target.setScale(this._originalScale);
          }
          this._transitionFinished = true;
        }
        _registerNodeEvent() {
          this.node.on(NodeEventType.TOUCH_START, this._onTouchBegan, this);
          this.node.on(NodeEventType.TOUCH_MOVE, this._onTouchMove, this);
          this.node.on(NodeEventType.TOUCH_END, this._onTouchEnded, this);
          this.node.on(NodeEventType.TOUCH_CANCEL, this._onTouchCancel, this);
          this.node.on(NodeEventType.MOUSE_ENTER, this._onMouseMoveIn, this);
          this.node.on(NodeEventType.MOUSE_LEAVE, this._onMouseMoveOut, this);
          this.node.on(XrUIPressEventType.XRUI_HOVER_ENTERED, this._xrHoverEnter, this);
          this.node.on(XrUIPressEventType.XRUI_HOVER_EXITED, this._xrHoverExit, this);
          this.node.on(XrUIPressEventType.XRUI_CLICK, this._xrClick, this);
          this.node.on(XrUIPressEventType.XRUI_UNCLICK, this._xrUnClick, this);
        }
        _registerTargetEvent(target) {
          target.on(NodeEventType.TRANSFORM_CHANGED, this._onTargetTransformChanged, this);
        }
        _unregisterNodeEvent() {
          this.node.off(NodeEventType.TOUCH_START, this._onTouchBegan, this);
          this.node.off(NodeEventType.TOUCH_MOVE, this._onTouchMove, this);
          this.node.off(NodeEventType.TOUCH_END, this._onTouchEnded, this);
          this.node.off(NodeEventType.TOUCH_CANCEL, this._onTouchCancel, this);
          this.node.off(NodeEventType.MOUSE_ENTER, this._onMouseMoveIn, this);
          this.node.off(NodeEventType.MOUSE_LEAVE, this._onMouseMoveOut, this);
          this.node.off(XrUIPressEventType.XRUI_HOVER_ENTERED, this._xrHoverEnter, this);
          this.node.off(XrUIPressEventType.XRUI_HOVER_EXITED, this._xrHoverExit, this);
          this.node.off(XrUIPressEventType.XRUI_CLICK, this._xrClick, this);
          this.node.off(XrUIPressEventType.XRUI_UNCLICK, this._xrUnClick, this);
        }
        _unregisterTargetEvent(target) {
          target.off(NodeEventType.TRANSFORM_CHANGED);
        }
        _getTargetSprite(target) {
          let sprite = null;
          if (target) {
            sprite = target.getComponent(Sprite);
          }
          return sprite;
        }
        _applyTarget() {
          if (this.target) {
            this._sprite = this._getTargetSprite(this.target);
            if (!this._originalScale) {
              this._originalScale = new Vec3();
            }
            Vec3.copy(this._originalScale, this.target.getScale());
            this._registerTargetEvent(this.target);
          }
        }
        _onTargetSpriteFrameChanged(comp) {
          if (this._transition === Transition.SPRITE) {
            this._setCurrentStateSpriteFrame(comp.spriteFrame);
          }
        }
        _setCurrentStateSpriteFrame(spriteFrame) {
          if (!spriteFrame) {
            return;
          }
          switch (this._getButtonState()) {
            case State.NORMAL:
              this._normalSprite = spriteFrame;
              break;
            case State.HOVER:
              this._hoverSprite = spriteFrame;
              break;
            case State.PRESSED:
              this._pressedSprite = spriteFrame;
              break;
            case State.DISABLED:
              this._disabledSprite = spriteFrame;
              break;
          }
        }
        _onTargetColorChanged(color) {
          if (this._transition === Transition.COLOR) {
            this._setCurrentStateColor(color);
          }
        }
        _setCurrentStateColor(color) {
          switch (this._getButtonState()) {
            case State.NORMAL:
              this._normalColor = color;
              break;
            case State.HOVER:
              this._hoverColor = color;
              break;
            case State.PRESSED:
              this._pressedColor = color;
              break;
            case State.DISABLED:
              this._disabledColor = color;
              break;
          }
        }
        _onTargetTransformChanged(transformBit) {
          if (transformBit & TransformBit.SCALE && this._originalScale && this._transition === Transition.SCALE && this._transitionFinished) {
            Vec3.copy(this._originalScale, this.target.getScale());
          }
        }
        _onTouchBegan(event) {
          if (!this._interactable || !this.enabledInHierarchy) {
            return;
          }
          this._pressed = true;
          this._updateState();
          if (event) {
            event.propagationStopped = true;
          }
        }
        _onTouchMove(event) {
          if (!this._interactable || !this.enabledInHierarchy || !this._pressed) {
            return;
          }
          if (!event) {
            return;
          }
          const touch = event.touch;
          if (!touch) {
            return;
          }
          const hit = this.node._uiProps.uiTransformComp.hitTest(touch.getLocation(), event.windowId);
          if (this._transition === Transition.SCALE && this.target && this._originalScale) {
            if (hit) {
              Vec3.copy(this._fromScale, this._originalScale);
              Vec3.multiplyScalar(this._toScale, this._originalScale, this._zoomScale);
              this._transitionFinished = false;
            } else {
              this._time = 0;
              this._transitionFinished = true;
              this.target.setScale(this._originalScale);
            }
          } else {
            let state;
            if (hit) {
              state = State.PRESSED;
            } else {
              state = State.NORMAL;
            }
            this._applyTransition(state);
          }
          if (event) {
            event.propagationStopped = true;
          }
        }
        _onTouchEnded(event) {
          if (!this._interactable || !this.enabledInHierarchy) {
            return;
          }
          if (this._pressed) {
            EventHandler.emitEvents(this.clickEvents, event);
            this.node.emit(EventType$4.CLICK, this);
          }
          this._pressed = false;
          this._updateState();
          if (event) {
            event.propagationStopped = true;
          }
        }
        _onTouchCancel(event) {
          if (!this._interactable || !this.enabledInHierarchy) {
            return;
          }
          this._pressed = false;
          this._updateState();
        }
        _onMouseMoveIn(event) {
          if (this._pressed || !this.interactable || !this.enabledInHierarchy) {
            return;
          }
          if (this._transition === Transition.SPRITE && !this._hoverSprite) {
            return;
          }
          if (!this._hovered) {
            this._hovered = true;
            this._updateState();
          }
        }
        _onMouseMoveOut(event) {
          if (this._hovered) {
            this._hovered = false;
            this._updateState();
          }
        }
        _updateState() {
          const state = this._getButtonState();
          this._applyTransition(state);
        }
        _getButtonState() {
          let state = State.NORMAL;
          if (!this._interactable) {
            state = State.DISABLED;
          } else if (this._pressed) {
            state = State.PRESSED;
          } else if (this._hovered) {
            state = State.HOVER;
          }
          return state.toString();
        }
        _updateColorTransition(state) {
          var _this$target;
          const color = this[`${state}Color`];
          const renderComp = (_this$target = this.target) === null || _this$target === void 0 ? void 0 : _this$target.getComponent(UIRenderer);
          if (!renderComp) {
            return;
          }
          if (state === State.DISABLED.toString()) {
            renderComp.color = color;
          } else {
            this._fromColor = renderComp.color.clone();
            this._toColor = color;
            this._time = 0;
            this._transitionFinished = false;
          }
        }
        _updateSpriteTransition(state) {
          const sprite = this[`${state}Sprite`];
          if (this._sprite && sprite) {
            this._sprite.spriteFrame = sprite;
          }
        }
        _updateScaleTransition(state) {
          if (!this._interactable) {
            return;
          }
          if (state === State.PRESSED.toString()) {
            this._zoomUp();
          } else {
            this._zoomBack();
          }
        }
        _zoomUp() {
          if (!this._originalScale) {
            return;
          }
          Vec3.copy(this._fromScale, this._originalScale);
          Vec3.multiplyScalar(this._toScale, this._originalScale, this._zoomScale);
          this._time = 0;
          this._transitionFinished = false;
        }
        _zoomBack() {
          if (!this.target || !this._originalScale) {
            return;
          }
          Vec3.copy(this._fromScale, this.target.getScale());
          Vec3.copy(this._toScale, this._originalScale);
          this._time = 0;
          this._transitionFinished = false;
        }
        _applyTransition(state) {
          const transition = this._transition;
          if (transition === Transition.COLOR) {
            this._updateColorTransition(state);
          } else if (transition === Transition.SPRITE) {
            this._updateSpriteTransition(state);
          } else if (transition === Transition.SCALE) {
            this._updateScaleTransition(state);
          }
        }
        _xrHoverEnter() {
          this._onMouseMoveIn();
          this._updateState();
        }
        _xrHoverExit() {
          this._onMouseMoveOut();
          if (this._pressed) {
            this._pressed = false;
            this._updateState();
          }
        }
        _xrClick() {
          if (!this._interactable || !this.enabledInHierarchy) {
            return;
          }
          this._pressed = true;
          this._updateState();
        }
        _xrUnClick() {
          if (!this._interactable || !this.enabledInHierarchy) {
            return;
          }
          if (this._pressed) {
            EventHandler.emitEvents(this.clickEvents, this);
            this.node.emit(EventType$4.CLICK, this);
          }
          this._pressed = false;
          this._updateState();
        }
      }, _class3$a.Transition = Transition, _class3$a.EventType = EventType$4, _class3$a), (_applyDecoratedDescriptor(_class2$d.prototype, "target", [_dec4$b], Object.getOwnPropertyDescriptor(_class2$d.prototype, "target"), _class2$d.prototype), _applyDecoratedDescriptor(_class2$d.prototype, "transition", [_dec5$b], Object.getOwnPropertyDescriptor(_class2$d.prototype, "transition"), _class2$d.prototype), _applyDecoratedDescriptor(_class2$d.prototype, "normalSprite", [_dec6$5], Object.getOwnPropertyDescriptor(_class2$d.prototype, "normalSprite"), _class2$d.prototype), _applyDecoratedDescriptor(_class2$d.prototype, "pressedSprite", [_dec7$4], Object.getOwnPropertyDescriptor(_class2$d.prototype, "pressedSprite"), _class2$d.prototype), _applyDecoratedDescriptor(_class2$d.prototype, "hoverSprite", [_dec8$3], Object.getOwnPropertyDescriptor(_class2$d.prototype, "hoverSprite"), _class2$d.prototype), _applyDecoratedDescriptor(_class2$d.prototype, "disabledSprite", [_dec9$3], Object.getOwnPropertyDescriptor(_class2$d.prototype, "disabledSprite"), _class2$d.prototype), _initializer$d = applyDecoratedInitializer(_class2$d.prototype, "clickEvents", [_dec10$1, serializable$3], function () {
        return [];
      }), _initializer2$d = applyDecoratedInitializer(_class2$d.prototype, "_interactable", [serializable$3], function () {
        return true;
      }), _initializer3$b = applyDecoratedInitializer(_class2$d.prototype, "_transition", [serializable$3], function () {
        return Transition.NONE;
      }), _initializer4$a = applyDecoratedInitializer(_class2$d.prototype, "_normalColor", [serializable$3], function () {
        return Color$1.WHITE.clone();
      }), _initializer5$8 = applyDecoratedInitializer(_class2$d.prototype, "_hoverColor", [serializable$3], function () {
        return new Color$1(211, 211, 211, 255);
      }), _initializer6$5 = applyDecoratedInitializer(_class2$d.prototype, "_pressedColor", [serializable$3], function () {
        return Color$1.WHITE.clone();
      }), _initializer7$5 = applyDecoratedInitializer(_class2$d.prototype, "_disabledColor", [serializable$3], function () {
        return new Color$1(124, 124, 124, 255);
      }), _initializer8$5 = applyDecoratedInitializer(_class2$d.prototype, "_normalSprite", [serializable$3], function () {
        return null;
      }), _initializer9$5 = applyDecoratedInitializer(_class2$d.prototype, "_hoverSprite", [serializable$3], function () {
        return null;
      }), _initializer10$5 = applyDecoratedInitializer(_class2$d.prototype, "_pressedSprite", [serializable$3], function () {
        return null;
      }), _initializer11$5 = applyDecoratedInitializer(_class2$d.prototype, "_disabledSprite", [serializable$3], function () {
        return null;
      }), _initializer12$4 = applyDecoratedInitializer(_class2$d.prototype, "_duration", [serializable$3], function () {
        return 0.1;
      }), _initializer13$3 = applyDecoratedInitializer(_class2$d.prototype, "_zoomScale", [serializable$3], function () {
        return 1.2;
      }), _initializer14$2 = applyDecoratedInitializer(_class2$d.prototype, "_target", [serializable$3], function () {
        return null;
      })), _class2$d)) || _class$h) || _class$h) || _class$h); exports({ Button: Button, ButtonComponent: Button });
      legacyCC.Button = Button;

      class tabIndexUtil {
        static add(editBoxImpl) {
          const list = this._tabIndexList;
          const index = list.indexOf(editBoxImpl);
          if (index === -1) {
            list.push(editBoxImpl);
          }
        }
        static remove(editBoxImpl) {
          const list = this._tabIndexList;
          const index = list.indexOf(editBoxImpl);
          if (index !== -1) {
            list.splice(index, 1);
          }
        }
        static resort() {
          this._tabIndexList.sort((a, b) => a._delegate.tabIndex - b._delegate.tabIndex);
        }
        static next(editBoxImpl) {
          const list = this._tabIndexList;
          const index = list.indexOf(editBoxImpl);
          editBoxImpl.setFocus(false);
          if (index !== -1) {
            const nextImpl = list[index + 1];
            if (nextImpl && nextImpl._delegate.tabIndex >= 0) {
              nextImpl.setFocus(true);
            }
          }
        }
      }
      tabIndexUtil._tabIndexList = [];

      let KeyboardReturnType;
      (function (KeyboardReturnType) {
        KeyboardReturnType[KeyboardReturnType["DEFAULT"] = 0] = "DEFAULT";
        KeyboardReturnType[KeyboardReturnType["DONE"] = 1] = "DONE";
        KeyboardReturnType[KeyboardReturnType["SEND"] = 2] = "SEND";
        KeyboardReturnType[KeyboardReturnType["SEARCH"] = 3] = "SEARCH";
        KeyboardReturnType[KeyboardReturnType["GO"] = 4] = "GO";
        KeyboardReturnType[KeyboardReturnType["NEXT"] = 5] = "NEXT";
      })(KeyboardReturnType || (KeyboardReturnType = {}));
      Enum(KeyboardReturnType);
      let InputMode;
      (function (InputMode) {
        InputMode[InputMode["ANY"] = 0] = "ANY";
        InputMode[InputMode["EMAIL_ADDR"] = 1] = "EMAIL_ADDR";
        InputMode[InputMode["NUMERIC"] = 2] = "NUMERIC";
        InputMode[InputMode["PHONE_NUMBER"] = 3] = "PHONE_NUMBER";
        InputMode[InputMode["URL"] = 4] = "URL";
        InputMode[InputMode["DECIMAL"] = 5] = "DECIMAL";
        InputMode[InputMode["SINGLE_LINE"] = 6] = "SINGLE_LINE";
      })(InputMode || (InputMode = {}));
      Enum(InputMode);
      let InputFlag;
      (function (InputFlag) {
        InputFlag[InputFlag["PASSWORD"] = 0] = "PASSWORD";
        InputFlag[InputFlag["SENSITIVE"] = 1] = "SENSITIVE";
        InputFlag[InputFlag["INITIAL_CAPS_WORD"] = 2] = "INITIAL_CAPS_WORD";
        InputFlag[InputFlag["INITIAL_CAPS_SENTENCE"] = 3] = "INITIAL_CAPS_SENTENCE";
        InputFlag[InputFlag["INITIAL_CAPS_ALL_CHARACTERS"] = 4] = "INITIAL_CAPS_ALL_CHARACTERS";
        InputFlag[InputFlag["DEFAULT"] = 5] = "DEFAULT";
      })(InputFlag || (InputFlag = {}));
      Enum(InputFlag);

      class EditBoxImplBase {
        constructor() {
          this._editing = false;
          this._delegate = null;
          this._dirtyFlag = false;
        }
        init(delegate) {}
        onEnable() {}
        update() {}
        onDisable() {
          if (this._editing) {
            this.endEditing();
          }
        }
        clear() {
          this._delegate = null;
        }
        setTabIndex(index) {}
        setSize(width, height) {}
        setFocus(value) {
          if (value) {
            this.beginEditing();
          } else {
            this.endEditing();
          }
        }
        isFocused() {
          return this._editing;
        }
        beginEditing() {}
        endEditing() {}
      }

      const ccdocument = ccwindow$1.document;
      const SCROLLY = 40;
      const LEFT_PADDING$1 = 2;
      const DELAY_TIME = 400;
      const _matrix = new Mat4();
      const _matrix_temp = new Mat4();
      const _vec3 = new Vec3();
      let _currentEditBoxImpl = null;
      let _domCount = 0;
      class EditBoxImpl extends EditBoxImplBase {
        constructor(...args) {
          super(...args);
          this._delegate = null;
          this._inputMode = -1;
          this._inputFlag = -1;
          this._returnType = -1;
          this.__eventListeners = {};
          this.__autoResize = false;
          this.__orientationChanged = void 0;
          this._edTxt = null;
          this._isTextArea = false;
          this._textLabelFont = null;
          this._textLabelFontSize = null;
          this._textLabelFontColor = null;
          this._textLabelAlign = null;
          this._placeholderLabelFont = null;
          this._placeholderLabelFontSize = null;
          this._placeholderLabelFontColor = null;
          this._placeholderLabelAlign = null;
          this._placeholderLineHeight = null;
          this._placeholderStyleSheet = null;
          this._domId = `EditBoxId_${++_domCount}`;
        }
        init(delegate) {
          if (!delegate) {
            return;
          }
          this._delegate = delegate;
          if (delegate.inputMode === InputMode.ANY) {
            this._createTextArea();
          } else {
            this._createInput();
          }
          tabIndexUtil.add(this);
          this.setTabIndex(delegate.tabIndex);
          this._initStyleSheet();
          this._registerEventListeners();
          this._addDomToGameContainer();
        }
        clear() {
          this._removeEventListeners();
          this._removeDomFromGameContainer();
          tabIndexUtil.remove(this);
          if (_currentEditBoxImpl === this) {
            _currentEditBoxImpl = null;
          }
          this._delegate = null;
        }
        update() {
          if (!this._dirtyFlag) return;
          this._updateMatrix();
        }
        setTabIndex(index) {
          this._edTxt.tabIndex = index;
          tabIndexUtil.resort();
        }
        setSize(width, height) {
          const elem = this._edTxt;
          if (elem) {
            elem.style.width = `${width}px`;
            elem.style.height = `${height}px`;
          }
        }
        beginEditing() {
          if (_currentEditBoxImpl && _currentEditBoxImpl !== this) {
            _currentEditBoxImpl.setFocus(false);
          }
          this._editing = true;
          _currentEditBoxImpl = this;
          this._delegate._editBoxEditingDidBegan();
          this._showDom();
          this._edTxt.focus();
        }
        endEditing() {
          this._edTxt.blur();
        }
        _createInput() {
          this._isTextArea = false;
          this._edTxt = ccdocument.createElement('input');
        }
        _createTextArea() {
          this._isTextArea = true;
          this._edTxt = ccdocument.createElement('textarea');
        }
        _addDomToGameContainer() {
          if (game.container && this._edTxt) {
            game.container.appendChild(this._edTxt);
            ccdocument.head.appendChild(this._placeholderStyleSheet);
          }
        }
        _removeDomFromGameContainer() {
          const hasElem = contains$1(game.container, this._edTxt);
          if (hasElem && this._edTxt) {
            game.container.removeChild(this._edTxt);
          }
          const hasStyleSheet = contains$1(ccdocument.head, this._placeholderStyleSheet);
          if (hasStyleSheet) {
            ccdocument.head.removeChild(this._placeholderStyleSheet);
          }
          this._edTxt = null;
          this._placeholderStyleSheet = null;
        }
        _showDom() {
          this._updateMaxLength();
          this._updateInputType();
          this._updateStyleSheet();
          if (this._edTxt && this._delegate) {
            this._edTxt.style.display = '';
            this._delegate._hideLabels();
          }
          if (sys.isMobile) {
            this._showDomOnMobile();
          }
        }
        _hideDom() {
          const elem = this._edTxt;
          if (elem && this._delegate) {
            elem.style.display = 'none';
            this._delegate._showLabels();
          }
          if (sys.isMobile) {
            this._hideDomOnMobile();
          }
        }
        _showDomOnMobile() {
          if (sys.os !== OS.ANDROID && sys.os !== OS.OHOS) {
            return;
          }
          screenAdapter.handleResizeEvent = false;
          this._adjustWindowScroll();
        }
        _hideDomOnMobile() {
          if (sys.os === OS.ANDROID || sys.os === OS.OHOS) {
            screenAdapter.handleResizeEvent = true;
          }
          this._scrollBackWindow();
        }
        _adjustWindowScroll() {
          setTimeout(() => {
            if (ccwindow$1.scrollY < SCROLLY) {
              this._edTxt.scrollIntoView({
                block: 'start',
                inline: 'nearest',
                behavior: 'smooth'
              });
            }
          }, DELAY_TIME);
        }
        _scrollBackWindow() {
          setTimeout(() => {
            if (sys.browserType === BrowserType.WECHAT && sys.os === OS.IOS) {
              if (ccwindow$1.top) {
                ccwindow$1.top.scrollTo(0, 0);
              }
              return;
            }
            ccwindow$1.scrollTo(0, 0);
          }, DELAY_TIME);
        }
        _updateMatrix() {
          if (!this._edTxt) {
            return;
          }
          const node = this._delegate.node;
          let scaleX = view.getScaleX();
          let scaleY = view.getScaleY();
          const viewport = view.getViewportRect();
          const dpr = screenAdapter.devicePixelRatio;
          node.getWorldMatrix(_matrix);
          const transform = node._uiProps.uiTransformComp;
          if (transform) {
            Vec3.set(_vec3, -transform.anchorX * transform.width, -transform.anchorY * transform.height, _vec3.z);
            Mat4.transform(_matrix, _matrix, _vec3);
          }
          if (!node._uiProps.uiTransformComp) {
            return;
          }
          const camera = director.root.batcher2D.getFirstRenderCamera(node);
          if (!camera) return;
          camera.node.getWorldRT(_matrix_temp);
          const m12 = _matrix_temp.m12;
          const m13 = _matrix_temp.m13;
          const center = visibleRect.center;
          _matrix_temp.m12 = center.x - (_matrix_temp.m00 * m12 + _matrix_temp.m04 * m13);
          _matrix_temp.m13 = center.y - (_matrix_temp.m01 * m12 + _matrix_temp.m05 * m13);
          scaleX /= dpr;
          scaleY /= dpr;
          Vec3.set(_vec3, scaleX, scaleY, 1);
          Mat4.scale(_matrix_temp, _matrix_temp, _vec3);
          const container = game.container;
          let offsetX = parseInt(container && container.style.paddingLeft || '0');
          offsetX += viewport.x / dpr;
          let offsetY = parseInt(container && container.style.paddingBottom || '0');
          offsetY += viewport.y / dpr;
          _matrix_temp.m12 += offsetX;
          _matrix_temp.m13 += offsetY;
          Mat4.multiply(_matrix_temp, _matrix_temp, _matrix);
          const a = _matrix_temp.m00;
          const b = _matrix_temp.m01;
          const c = _matrix_temp.m04;
          const d = _matrix_temp.m05;
          const tx = _matrix_temp.m12;
          const ty = _matrix_temp.m13;
          const matrix = `matrix(${a},${-b},${-c},${d},${tx},${-ty})`;
          this._edTxt.style.transform = matrix;
          this._edTxt.style['-webkit-transform'] = matrix;
          this._edTxt.style['transform-origin'] = '0px 100% 0px';
          this._edTxt.style['-webkit-transform-origin'] = '0px 100% 0px';
        }
        _updateInputType() {
          const delegate = this._delegate;
          const inputMode = delegate.inputMode;
          const inputFlag = delegate.inputFlag;
          const returnType = delegate.returnType;
          let elem = this._edTxt;
          if (this._inputMode === inputMode && this._inputFlag === inputFlag && this._returnType === returnType) {
            return;
          }
          this._inputMode = inputMode;
          this._inputFlag = inputFlag;
          this._returnType = returnType;
          if (this._isTextArea) {
            let transform = 'none';
            if (inputFlag === InputFlag.INITIAL_CAPS_ALL_CHARACTERS) {
              transform = 'uppercase';
            } else if (inputFlag === InputFlag.INITIAL_CAPS_WORD) {
              transform = 'capitalize';
            }
            elem.style.textTransform = transform;
            return;
          }
          elem = elem;
          if (inputFlag === InputFlag.PASSWORD) {
            elem.type = 'password';
            elem.style.textTransform = 'none';
            return;
          }
          let type = elem.type;
          if (inputMode === InputMode.EMAIL_ADDR) {
            type = 'email';
          } else if (inputMode === InputMode.NUMERIC || inputMode === InputMode.DECIMAL) {
            type = 'number';
          } else if (inputMode === InputMode.PHONE_NUMBER) {
            type = 'number';
            elem.pattern = '[0-9]*';
            elem.addEventListener('wheel', () => false);
          } else if (inputMode === InputMode.URL) {
            type = 'url';
          } else {
            type = 'text';
            if (returnType === KeyboardReturnType.SEARCH) {
              type = 'search';
            }
          }
          elem.type = type;
          let textTransform = 'none';
          if (inputFlag === InputFlag.INITIAL_CAPS_ALL_CHARACTERS) {
            textTransform = 'uppercase';
          } else if (inputFlag === InputFlag.INITIAL_CAPS_WORD) {
            textTransform = 'capitalize';
          }
          elem.style.textTransform = textTransform;
        }
        _updateMaxLength() {
          let maxLength = this._delegate.maxLength;
          if (maxLength < 0) {
            maxLength = 65535;
          }
          this._edTxt.maxLength = maxLength;
        }
        _initStyleSheet() {
          if (!this._edTxt) {
            return;
          }
          let elem = this._edTxt;
          elem.style.color = '#000000';
          elem.style.border = '0px';
          elem.style.background = 'transparent';
          elem.style.width = '100%';
          elem.style.height = '100%';
          elem.style.outline = 'medium';
          elem.style.padding = '0';
          elem.style.textTransform = 'none';
          elem.style.display = 'none';
          elem.style.position = 'absolute';
          elem.style.bottom = '0px';
          elem.style.left = `${LEFT_PADDING$1}px`;
          elem.className = 'cocosEditBox';
          elem.style.fontFamily = 'Arial';
          elem.id = this._domId;
          if (!this._isTextArea) {
            elem = elem;
            elem.type = 'text';
            elem.style['-moz-appearance'] = 'textfield';
          } else {
            elem.style.resize = 'none';
            elem.style.overflowY = 'scroll';
          }
          this._placeholderStyleSheet = ccdocument.createElement('style');
        }
        _updateStyleSheet() {
          const delegate = this._delegate;
          const elem = this._edTxt;
          if (elem && delegate) {
            elem.value = delegate.string;
            this._updateTextLabel(delegate.textLabel);
          }
        }
        _updateTextLabel(textLabel) {
          if (!textLabel) {
            return;
          }
          let font = textLabel.font;
          if (font && !(font instanceof BitmapFont)) {
            font = font._fontFamily;
          } else {
            font = textLabel.fontFamily;
          }
          const fontSize = textLabel.fontSize * textLabel.node.scale.y;
          if (this._textLabelFont === font && this._textLabelFontSize === fontSize && this._textLabelFontColor === textLabel.fontColor && this._textLabelAlign === textLabel.horizontalAlign) {
            return;
          }
          this._textLabelFont = font;
          this._textLabelFontSize = fontSize;
          this._textLabelFontColor = textLabel.fontColor;
          this._textLabelAlign = textLabel.horizontalAlign;
          if (!this._edTxt) {
            return;
          }
          const elem = this._edTxt;
          elem.style.fontSize = `${fontSize}px`;
          elem.style.color = textLabel.color.toCSS();
          elem.style.fontFamily = font;
          switch (textLabel.horizontalAlign) {
            case Label.HorizontalAlign.LEFT:
              elem.style.textAlign = 'left';
              break;
            case Label.HorizontalAlign.CENTER:
              elem.style.textAlign = 'center';
              break;
            case Label.HorizontalAlign.RIGHT:
              elem.style.textAlign = 'right';
              break;
          }
        }
        _updatePlaceholderLabel(placeholderLabel) {
          if (!placeholderLabel) {
            return;
          }
          let font = placeholderLabel.font;
          if (font && !(font instanceof BitmapFont)) {
            font = placeholderLabel.font._fontFamily;
          } else {
            font = placeholderLabel.fontFamily;
          }
          const fontSize = placeholderLabel.fontSize * placeholderLabel.node.scale.y;
          if (this._placeholderLabelFont === font && this._placeholderLabelFontSize === fontSize && this._placeholderLabelFontColor === placeholderLabel.fontColor && this._placeholderLabelAlign === placeholderLabel.horizontalAlign && this._placeholderLineHeight === placeholderLabel.fontSize) {
            return;
          }
          this._placeholderLabelFont = font;
          this._placeholderLabelFontSize = fontSize;
          this._placeholderLabelFontColor = placeholderLabel.fontColor;
          this._placeholderLabelAlign = placeholderLabel.horizontalAlign;
          this._placeholderLineHeight = placeholderLabel.fontSize;
          const styleEl = this._placeholderStyleSheet;
          const fontColor = placeholderLabel.color.toCSS();
          const lineHeight = placeholderLabel.fontSize;
          let horizontalAlign = '';
          switch (placeholderLabel.horizontalAlign) {
            case Label.HorizontalAlign.LEFT:
              horizontalAlign = 'left';
              break;
            case Label.HorizontalAlign.CENTER:
              horizontalAlign = 'center';
              break;
            case Label.HorizontalAlign.RIGHT:
              horizontalAlign = 'right';
              break;
          }
          styleEl.innerHTML = `#${this._domId}::-webkit-input-placeholder{text-transform: initial;-family: ${font};font-size: ${fontSize}px;color: ${fontColor};line-height: ${lineHeight}px;text-align: ${horizontalAlign};}` + `#${this._domId}::-moz-placeholder{text-transform: initial;-family: ${font};font-size: ${fontSize}px;color: ${fontColor};line-height: ${lineHeight}px;text-align: ${horizontalAlign};}` + `#${this._domId}::-ms-input-placeholder{text-transform: initial;-family: ${font};font-size: ${fontSize}px;color: ${fontColor};line-height: ${lineHeight}px;text-align: ${horizontalAlign};}`;
          if (sys.browserType === BrowserType.EDGE) {
            styleEl.innerHTML += `#${this._domId}::-ms-clear{display: none;}`;
          }
        }
        _registerEventListeners() {
          if (!this._edTxt) {
            return;
          }
          const elem = this._edTxt;
          let inputLock = false;
          const cbs = this.__eventListeners;
          cbs.compositionStart = () => {
            inputLock = true;
          };
          cbs.compositionEnd = () => {
            inputLock = false;
            this._delegate._editBoxTextChanged(elem.value);
          };
          cbs.onInput = () => {
            if (inputLock) {
              return;
            }
            const delegate = this._delegate;
            const maxLength = delegate.maxLength;
            if (maxLength >= 0) {
              elem.value = elem.value.slice(0, maxLength);
            }
            delegate._editBoxTextChanged(elem.value);
          };
          cbs.onClick = () => {
            if (this._editing) {
              if (sys.isMobile) {
                this._adjustWindowScroll();
              }
            }
          };
          cbs.onKeydown = e => {
            if (e.keyCode === KeyCode.ENTER) {
              e.propagationStopped = true;
              this._delegate._editBoxEditingReturn();
              if (!this._isTextArea) {
                elem.blur();
              }
            } else if (e.keyCode === KeyCode.TAB) {
              e.propagationStopped = true;
              e.preventDefault();
              tabIndexUtil.next(this);
            }
          };
          cbs.onBlur = () => {
            if (sys.isMobile && inputLock) {
              cbs.compositionEnd();
            }
            this._editing = false;
            _currentEditBoxImpl = null;
            this._hideDom();
            this._delegate._editBoxEditingDidEnded();
          };
          elem.addEventListener('compositionstart', cbs.compositionStart);
          elem.addEventListener('compositionend', cbs.compositionEnd);
          elem.addEventListener('input', cbs.onInput);
          elem.addEventListener('keydown', cbs.onKeydown);
          elem.addEventListener('blur', cbs.onBlur);
          elem.addEventListener('touchstart', cbs.onClick);
        }
        _removeEventListeners() {
          if (!this._edTxt) {
            return;
          }
          const elem = this._edTxt;
          const cbs = this.__eventListeners;
          elem.removeEventListener('compositionstart', cbs.compositionStart);
          elem.removeEventListener('compositionend', cbs.compositionEnd);
          elem.removeEventListener('input', cbs.onInput);
          elem.removeEventListener('keydown', cbs.onKeydown);
          elem.removeEventListener('blur', cbs.onBlur);
          elem.removeEventListener('touchstart', cbs.onClick);
          cbs.compositionStart = null;
          cbs.compositionEnd = null;
          cbs.onInput = null;
          cbs.onKeydown = null;
          cbs.onBlur = null;
          cbs.onClick = null;
        }
      }

      var _dec$g, _dec2$e, _dec3$d, _dec4$a, _dec5$a, _dec6$4, _dec7$3, _dec8$2, _dec9$2, _dec10, _dec11, _dec12, _dec13, _class$g, _class2$c, _initializer$c, _initializer2$c, _initializer3$a, _initializer4$9, _initializer5$7, _initializer6$4, _initializer7$4, _initializer8$4, _initializer9$4, _initializer10$4, _initializer11$4, _initializer12$3, _initializer13$2, _class3$9;
      const LEFT_PADDING = 2;
      function capitalize(str) {
        return str.replace(/(?:^|\s)\S/g, a => a.toUpperCase());
      }
      function capitalizeFirstLetter(str) {
        return str.charAt(0).toUpperCase() + str.slice(1);
      }
      var EventType$3;
      (function (EventType) {
        EventType["EDITING_DID_BEGAN"] = "editing-did-began";
        EventType["EDITING_DID_ENDED"] = "editing-did-ended";
        EventType["TEXT_CHANGED"] = "text-changed";
        EventType["EDITING_RETURN"] = "editing-return";
        EventType["XR_EDITING_DID_BEGAN"] = "xr-editing-did-began";
        EventType["XR_EDITING_DID_ENDED"] = "xr-editing-did-ended";
      })(EventType$3 || (EventType$3 = {}));
      let EditBox = (_dec$g = ccclass$3('cc.EditBox'), _dec2$e = executionOrder(110), _dec3$d = requireComponent(UITransform), _dec4$a = type$2(Label), _dec5$a = type$2(Label), _dec6$4 = type$2(SpriteFrame), _dec7$3 = type$2(InputFlag), _dec8$2 = type$2(InputMode), _dec9$2 = type$2(KeyboardReturnType), _dec10 = type$2([EventHandler]), _dec11 = type$2([EventHandler]), _dec12 = type$2([EventHandler]), _dec13 = type$2([EventHandler]), _dec$g(_class$g = _dec2$e(_class$g = _dec3$d(_class$g = (_class2$c = (_class3$9 = class EditBox extends Component {
        constructor(...args) {
          super(...args);
          this.editingDidBegan = _initializer$c && _initializer$c();
          this.textChanged = _initializer2$c && _initializer2$c();
          this.editingDidEnded = _initializer3$a && _initializer3$a();
          this.editingReturn = _initializer4$9 && _initializer4$9();
          this._impl = null;
          this._background = null;
          this._textLabel = _initializer5$7 && _initializer5$7();
          this._placeholderLabel = _initializer6$4 && _initializer6$4();
          this._returnType = _initializer7$4 && _initializer7$4();
          this._string = _initializer8$4 && _initializer8$4();
          this._tabIndex = _initializer9$4 && _initializer9$4();
          this._backgroundImage = _initializer10$4 && _initializer10$4();
          this._inputFlag = _initializer11$4 && _initializer11$4();
          this._inputMode = _initializer12$3 && _initializer12$3();
          this._maxLength = _initializer13$2 && _initializer13$2();
          this._isLabelVisible = false;
        }
        get string() {
          return this._string;
        }
        set string(value) {
          if (this._maxLength >= 0 && value.length >= this._maxLength) {
            value = value.slice(0, this._maxLength);
          }
          if (this._string === value) {
            return;
          }
          this._string = value;
          this._updateString(value);
        }
        get placeholder() {
          if (!this._placeholderLabel) {
            return '';
          }
          return this._placeholderLabel.string;
        }
        set placeholder(value) {
          if (this._placeholderLabel) {
            this._placeholderLabel.string = value;
          }
        }
        get textLabel() {
          return this._textLabel;
        }
        set textLabel(oldValue) {
          if (this._textLabel !== oldValue) {
            this._textLabel = oldValue;
            if (this._textLabel) {
              this._updateTextLabel();
              this._updateLabels();
            }
          }
        }
        get placeholderLabel() {
          return this._placeholderLabel;
        }
        set placeholderLabel(oldValue) {
          if (this._placeholderLabel !== oldValue) {
            this._placeholderLabel = oldValue;
            if (this._placeholderLabel) {
              this._updatePlaceholderLabel();
              this._updateLabels();
            }
          }
        }
        get backgroundImage() {
          return this._backgroundImage;
        }
        set backgroundImage(value) {
          if (this._backgroundImage === value) {
            return;
          }
          this._backgroundImage = value;
          this._ensureBackgroundSprite();
          this._background.spriteFrame = value;
        }
        get inputFlag() {
          return this._inputFlag;
        }
        set inputFlag(value) {
          if (this._inputFlag === value) {
            return;
          }
          this._inputFlag = value;
          this._updateString(this._string);
        }
        get inputMode() {
          return this._inputMode;
        }
        set inputMode(oldValue) {
          if (this._inputMode !== oldValue) {
            this._inputMode = oldValue;
            this._updateTextLabel();
            this._updatePlaceholderLabel();
          }
        }
        get returnType() {
          return this._returnType;
        }
        set returnType(value) {
          this._returnType = value;
        }
        get maxLength() {
          return this._maxLength;
        }
        set maxLength(value) {
          this._maxLength = value;
        }
        get tabIndex() {
          return this._tabIndex;
        }
        set tabIndex(value) {
          if (this._tabIndex !== value) {
            this._tabIndex = value;
            if (this._impl) {
              this._impl.setTabIndex(value);
            }
          }
        }
        __preload() {
          this._init();
        }
        onEnable() {
          {
            this._registerEvent();
          }
          this._ensureBackgroundSprite();
          if (this._impl) {
            this._impl.onEnable();
          }
        }
        update() {
          if (this._impl) {
            this._impl.update();
          }
        }
        onDisable() {
          {
            this._unregisterEvent();
          }
          this._unregisterBackgroundEvent();
          if (this._impl) {
            this._impl.onDisable();
          }
        }
        onDestroy() {
          if (this._impl) {
            this._impl.clear();
          }
        }
        setFocus() {
          if (this._impl) {
            this._impl.setFocus(true);
          }
        }
        focus() {
          if (this._impl) {
            this._impl.setFocus(true);
          }
        }
        blur() {
          if (this._impl) {
            this._impl.setFocus(false);
          }
        }
        isFocused() {
          if (this._impl) {
            return this._impl.isFocused();
          }
          return false;
        }
        _editBoxEditingDidBegan() {
          EventHandler.emitEvents(this.editingDidBegan, this);
          this.node.emit(EventType$3.EDITING_DID_BEGAN, this);
          if (this._impl) {
            this._impl._dirtyFlag = true;
          }
        }
        _editBoxEditingDidEnded(text) {
          EventHandler.emitEvents(this.editingDidEnded, this);
          this.node.emit(EventType$3.EDITING_DID_ENDED, this, text);
          if (this._impl) {
            this._impl._dirtyFlag = false;
          }
        }
        _editBoxTextChanged(text) {
          text = this._updateLabelStringStyle(text, true);
          this.string = text;
          EventHandler.emitEvents(this.textChanged, text, this);
          this.node.emit(EventType$3.TEXT_CHANGED, this);
        }
        _editBoxEditingReturn(text) {
          EventHandler.emitEvents(this.editingReturn, this);
          this.node.emit(EventType$3.EDITING_RETURN, this, text);
        }
        _showLabels() {
          this._isLabelVisible = true;
          this._updateLabels();
        }
        _hideLabels() {
          this._isLabelVisible = false;
          if (this._textLabel) {
            this._textLabel.node.active = false;
          }
          if (this._placeholderLabel) {
            this._placeholderLabel.node.active = false;
          }
        }
        _onTouchBegan(event) {
          event.propagationStopped = true;
        }
        _onTouchCancel(event) {
          event.propagationStopped = true;
        }
        _onTouchEnded(event) {
          if (this._impl) {
            this._impl.beginEditing();
          }
          event.propagationStopped = true;
        }
        _init() {
          this._updatePlaceholderLabel();
          this._updateTextLabel();
          this._isLabelVisible = true;
          this.node.on(NodeEventType.SIZE_CHANGED, this._resizeChildNodes, this);
          const impl = this._impl = new EditBox._EditBoxImpl();
          impl.init(this);
          this._updateString(this._string);
          this._syncSize();
        }
        _ensureBackgroundSprite() {
          if (!this._background) {
            let background = this.node.getComponent(Sprite);
            if (!background) {
              background = this.node.addComponent(Sprite);
            }
            if (background !== this._background) {
              background.type = Sprite.Type.SLICED;
              background.spriteFrame = this._backgroundImage;
              this._background = background;
              this._registerBackgroundEvent();
            }
          }
        }
        _updateTextLabel() {
          let textLabel = this._textLabel;
          if (!textLabel) {
            let node = this.node.getChildByName('TEXT_LABEL');
            if (!node) {
              node = new Node$1('TEXT_LABEL');
              node.layer = this.node.layer;
            }
            textLabel = node.getComponent(Label);
            if (!textLabel) {
              textLabel = node.addComponent(Label);
            }
            node.parent = this.node;
            this._textLabel = textLabel;
          }
          if (this._inputMode === InputMode.ANY) {
            textLabel.verticalAlign = VerticalTextAlignment.TOP;
            textLabel.enableWrapText = true;
          } else {
            textLabel.enableWrapText = false;
          }
          textLabel.string = this._updateLabelStringStyle(this._string);
        }
        _updatePlaceholderLabel() {
          let placeholderLabel = this._placeholderLabel;
          if (!placeholderLabel) {
            let node = this.node.getChildByName('PLACEHOLDER_LABEL');
            if (!node) {
              node = new Node$1('PLACEHOLDER_LABEL');
              node.layer = this.node.layer;
            }
            placeholderLabel = node.getComponent(Label);
            if (!placeholderLabel) {
              placeholderLabel = node.addComponent(Label);
            }
            node.parent = this.node;
            this._placeholderLabel = placeholderLabel;
          }
          if (this._inputMode === InputMode.ANY) {
            placeholderLabel.enableWrapText = true;
          } else {
            placeholderLabel.enableWrapText = false;
          }
          placeholderLabel.string = this.placeholder;
        }
        _syncSize() {
          const trans = this.node._uiProps.uiTransformComp;
          const size = trans.contentSize;
          if (this._background) {
            const bgTrans = this._background.node._uiProps.uiTransformComp;
            bgTrans.anchorPoint = trans.anchorPoint;
            bgTrans.setContentSize(size);
          }
          this._updateLabelPosition(size);
          if (this._impl) {
            this._impl.setSize(size.width, size.height);
          }
        }
        _updateLabels() {
          if (this._isLabelVisible) {
            const content = this._string;
            if (this._textLabel) {
              this._textLabel.node.active = content !== '';
            }
            if (this._placeholderLabel) {
              this._placeholderLabel.node.active = content === '';
            }
          }
        }
        _updateString(text) {
          const textLabel = this._textLabel;
          if (!textLabel) {
            return;
          }
          let displayText = text;
          if (displayText) {
            displayText = this._updateLabelStringStyle(displayText);
          }
          textLabel.string = displayText;
          this._updateLabels();
        }
        _updateLabelStringStyle(text, ignorePassword = false) {
          const inputFlag = this._inputFlag;
          if (!ignorePassword && inputFlag === InputFlag.PASSWORD) {
            let passwordString = '';
            const len = text.length;
            for (let i = 0; i < len; ++i) {
              passwordString += '\u25CF';
            }
            text = passwordString;
          } else if (inputFlag === InputFlag.INITIAL_CAPS_ALL_CHARACTERS) {
            text = text.toUpperCase();
          } else if (inputFlag === InputFlag.INITIAL_CAPS_WORD) {
            text = capitalize(text);
          } else if (inputFlag === InputFlag.INITIAL_CAPS_SENTENCE) {
            text = capitalizeFirstLetter(text);
          }
          return text;
        }
        _registerEvent() {
          this.node.on(NodeEventType.TOUCH_START, this._onTouchBegan, this);
          this.node.on(NodeEventType.TOUCH_END, this._onTouchEnded, this);
          this.node.on(XrUIPressEventType.XRUI_UNCLICK, this._xrUnClick, this);
          this.node.on(XrKeyboardEventType.XR_KEYBOARD_INPUT, this._xrKeyBoardInput, this);
        }
        _unregisterEvent() {
          this.node.off(NodeEventType.TOUCH_START, this._onTouchBegan, this);
          this.node.off(NodeEventType.TOUCH_END, this._onTouchEnded, this);
          this.node.off(XrUIPressEventType.XRUI_UNCLICK, this._xrUnClick, this);
          this.node.off(XrKeyboardEventType.XR_KEYBOARD_INPUT, this._xrKeyBoardInput, this);
        }
        _onBackgroundSpriteFrameChanged() {
          if (!this._background) {
            return;
          }
          this.backgroundImage = this._background.spriteFrame;
        }
        _registerBackgroundEvent() {
          const node = this._background && this._background.node;
          node === null || node === void 0 ? void 0 : node.on(Sprite.EventType.SPRITE_FRAME_CHANGED, this._onBackgroundSpriteFrameChanged, this);
        }
        _unregisterBackgroundEvent() {
          const node = this._background && this._background.node;
          node === null || node === void 0 ? void 0 : node.off(Sprite.EventType.SPRITE_FRAME_CHANGED, this._onBackgroundSpriteFrameChanged, this);
        }
        _updateLabelPosition(size) {
          const trans = this.node._uiProps.uiTransformComp;
          const offX = -trans.anchorX * trans.width;
          const offY = -trans.anchorY * trans.height;
          const placeholderLabel = this._placeholderLabel;
          const textLabel = this._textLabel;
          if (textLabel) {
            textLabel.node._uiProps.uiTransformComp.setContentSize(size.width - LEFT_PADDING, size.height);
            textLabel.node.setPosition(offX + LEFT_PADDING, offY + size.height, textLabel.node.position.z);
            if (this._inputMode === InputMode.ANY) {
              textLabel.verticalAlign = VerticalTextAlignment.TOP;
            }
            textLabel.enableWrapText = this._inputMode === InputMode.ANY;
          }
          if (placeholderLabel) {
            placeholderLabel.node._uiProps.uiTransformComp.setContentSize(size.width - LEFT_PADDING, size.height);
            placeholderLabel.lineHeight = size.height;
            placeholderLabel.node.setPosition(offX + LEFT_PADDING, offY + size.height, placeholderLabel.node.position.z);
            placeholderLabel.enableWrapText = this._inputMode === InputMode.ANY;
          }
        }
        _resizeChildNodes() {
          const trans = this.node._uiProps.uiTransformComp;
          const textLabelNode = this._textLabel && this._textLabel.node;
          if (textLabelNode) {
            textLabelNode.setPosition(-trans.width / 2, trans.height / 2, textLabelNode.position.z);
            textLabelNode._uiProps.uiTransformComp.setContentSize(trans.contentSize);
          }
          const placeholderLabelNode = this._placeholderLabel && this._placeholderLabel.node;
          if (placeholderLabelNode) {
            placeholderLabelNode.setPosition(-trans.width / 2, trans.height / 2, placeholderLabelNode.position.z);
            placeholderLabelNode._uiProps.uiTransformComp.setContentSize(trans.contentSize);
          }
          const backgroundNode = this._background && this._background.node;
          if (backgroundNode) {
            backgroundNode._uiProps.uiTransformComp.setContentSize(trans.contentSize);
          }
          this._syncSize();
        }
        _xrUnClick() {
          this.node.emit(EventType$3.XR_EDITING_DID_BEGAN, this._maxLength, this.string);
        }
        _xrKeyBoardInput(str) {
          this.string = str;
        }
      }, _class3$9._EditBoxImpl = EditBoxImplBase, _class3$9.KeyboardReturnType = KeyboardReturnType, _class3$9.InputFlag = InputFlag, _class3$9.InputMode = InputMode, _class3$9.EventType = EventType$3, _class3$9), (_applyDecoratedDescriptor(_class2$c.prototype, "textLabel", [_dec4$a], Object.getOwnPropertyDescriptor(_class2$c.prototype, "textLabel"), _class2$c.prototype), _applyDecoratedDescriptor(_class2$c.prototype, "placeholderLabel", [_dec5$a], Object.getOwnPropertyDescriptor(_class2$c.prototype, "placeholderLabel"), _class2$c.prototype), _applyDecoratedDescriptor(_class2$c.prototype, "backgroundImage", [_dec6$4], Object.getOwnPropertyDescriptor(_class2$c.prototype, "backgroundImage"), _class2$c.prototype), _applyDecoratedDescriptor(_class2$c.prototype, "inputFlag", [_dec7$3], Object.getOwnPropertyDescriptor(_class2$c.prototype, "inputFlag"), _class2$c.prototype), _applyDecoratedDescriptor(_class2$c.prototype, "inputMode", [_dec8$2], Object.getOwnPropertyDescriptor(_class2$c.prototype, "inputMode"), _class2$c.prototype), _applyDecoratedDescriptor(_class2$c.prototype, "returnType", [_dec9$2], Object.getOwnPropertyDescriptor(_class2$c.prototype, "returnType"), _class2$c.prototype), _initializer$c = applyDecoratedInitializer(_class2$c.prototype, "editingDidBegan", [_dec10, serializable$3], function () {
        return [];
      }), _initializer2$c = applyDecoratedInitializer(_class2$c.prototype, "textChanged", [_dec11, serializable$3], function () {
        return [];
      }), _initializer3$a = applyDecoratedInitializer(_class2$c.prototype, "editingDidEnded", [_dec12, serializable$3], function () {
        return [];
      }), _initializer4$9 = applyDecoratedInitializer(_class2$c.prototype, "editingReturn", [_dec13, serializable$3], function () {
        return [];
      }), _initializer5$7 = applyDecoratedInitializer(_class2$c.prototype, "_textLabel", [serializable$3], function () {
        return null;
      }), _initializer6$4 = applyDecoratedInitializer(_class2$c.prototype, "_placeholderLabel", [serializable$3], function () {
        return null;
      }), _initializer7$4 = applyDecoratedInitializer(_class2$c.prototype, "_returnType", [serializable$3], function () {
        return KeyboardReturnType.DEFAULT;
      }), _initializer8$4 = applyDecoratedInitializer(_class2$c.prototype, "_string", [serializable$3], function () {
        return '';
      }), _initializer9$4 = applyDecoratedInitializer(_class2$c.prototype, "_tabIndex", [serializable$3], function () {
        return 0;
      }), _initializer10$4 = applyDecoratedInitializer(_class2$c.prototype, "_backgroundImage", [serializable$3], function () {
        return null;
      }), _initializer11$4 = applyDecoratedInitializer(_class2$c.prototype, "_inputFlag", [serializable$3], function () {
        return InputFlag.DEFAULT;
      }), _initializer12$3 = applyDecoratedInitializer(_class2$c.prototype, "_inputMode", [serializable$3], function () {
        return InputMode.ANY;
      }), _initializer13$2 = applyDecoratedInitializer(_class2$c.prototype, "_maxLength", [serializable$3], function () {
        return 20;
      })), _class2$c)) || _class$g) || _class$g) || _class$g); exports({ EditBox: EditBox, EditBoxComponent: EditBox });
      if (typeof window === 'object' && typeof document === 'object' && !MINIGAME && !JSB && !RUNTIME_BASED) {
        EditBox._EditBoxImpl = EditBoxImpl;
      }
      legacyCC.internal.EditBox = EditBox;

      var _dec$f, _dec2$d, _dec3$c, _dec4$9, _dec5$9, _dec6$3, _dec7$2, _dec8$1, _dec9$1, _class$f, _class2$b, _initializer$b, _initializer2$b, _initializer3$9, _initializer4$8, _initializer5$6, _initializer6$3, _initializer7$3, _initializer8$3, _initializer9$3, _initializer10$3, _initializer11$3, _initializer12$2, _initializer13$1, _initializer14$1, _initializer15$1, _initializer16$1, _class3$8;
      var Type;
      (function (Type) {
        Type[Type["NONE"] = 0] = "NONE";
        Type[Type["HORIZONTAL"] = 1] = "HORIZONTAL";
        Type[Type["VERTICAL"] = 2] = "VERTICAL";
        Type[Type["GRID"] = 3] = "GRID";
      })(Type || (Type = {}));
      ccenum(Type);
      var ResizeMode;
      (function (ResizeMode) {
        ResizeMode[ResizeMode["NONE"] = 0] = "NONE";
        ResizeMode[ResizeMode["CONTAINER"] = 1] = "CONTAINER";
        ResizeMode[ResizeMode["CHILDREN"] = 2] = "CHILDREN";
      })(ResizeMode || (ResizeMode = {}));
      ccenum(ResizeMode);
      var AxisDirection;
      (function (AxisDirection) {
        AxisDirection[AxisDirection["HORIZONTAL"] = 0] = "HORIZONTAL";
        AxisDirection[AxisDirection["VERTICAL"] = 1] = "VERTICAL";
      })(AxisDirection || (AxisDirection = {}));
      ccenum(AxisDirection);
      var VerticalDirection;
      (function (VerticalDirection) {
        VerticalDirection[VerticalDirection["BOTTOM_TO_TOP"] = 0] = "BOTTOM_TO_TOP";
        VerticalDirection[VerticalDirection["TOP_TO_BOTTOM"] = 1] = "TOP_TO_BOTTOM";
      })(VerticalDirection || (VerticalDirection = {}));
      ccenum(VerticalDirection);
      var HorizontalDirection;
      (function (HorizontalDirection) {
        HorizontalDirection[HorizontalDirection["LEFT_TO_RIGHT"] = 0] = "LEFT_TO_RIGHT";
        HorizontalDirection[HorizontalDirection["RIGHT_TO_LEFT"] = 1] = "RIGHT_TO_LEFT";
      })(HorizontalDirection || (HorizontalDirection = {}));
      ccenum(HorizontalDirection);
      var Constraint;
      (function (Constraint) {
        Constraint[Constraint["NONE"] = 0] = "NONE";
        Constraint[Constraint["FIXED_ROW"] = 1] = "FIXED_ROW";
        Constraint[Constraint["FIXED_COL"] = 2] = "FIXED_COL";
      })(Constraint || (Constraint = {}));
      ccenum(Constraint);
      const _tempVec3$2 = new Vec3();
      let Layout = (_dec$f = ccclass$3('cc.Layout'), _dec2$d = executionOrder(110), _dec3$c = requireComponent(UITransform), _dec4$9 = type$2(Type), _dec5$9 = type$2(ResizeMode), _dec6$3 = type$2(AxisDirection), _dec7$2 = type$2(VerticalDirection), _dec8$1 = type$2(HorizontalDirection), _dec9$1 = type$2(Constraint), _dec$f(_class$f = _dec2$d(_class$f = _dec3$c(_class$f = (_class2$b = (_class3$8 = class Layout extends Component {
        constructor(...args) {
          super(...args);
          this._resizeMode = _initializer$b && _initializer$b();
          this._layoutType = _initializer2$b && _initializer2$b();
          this._cellSize = _initializer3$9 && _initializer3$9();
          this._startAxis = _initializer4$8 && _initializer4$8();
          this._paddingLeft = _initializer5$6 && _initializer5$6();
          this._paddingRight = _initializer6$3 && _initializer6$3();
          this._paddingTop = _initializer7$3 && _initializer7$3();
          this._paddingBottom = _initializer8$3 && _initializer8$3();
          this._spacingX = _initializer9$3 && _initializer9$3();
          this._spacingY = _initializer10$3 && _initializer10$3();
          this._verticalDirection = _initializer11$3 && _initializer11$3();
          this._horizontalDirection = _initializer12$2 && _initializer12$2();
          this._constraint = _initializer13$1 && _initializer13$1();
          this._constraintNum = _initializer14$1 && _initializer14$1();
          this._affectedByScale = _initializer15$1 && _initializer15$1();
          this._isAlign = _initializer16$1 && _initializer16$1();
          this._layoutSize = new Size$1(300, 200);
          this._layoutDirty = true;
          this._childrenDirty = false;
          this._usefulLayoutObj = [];
          this._init = false;
        }
        get alignHorizontal() {
          return this._isAlign;
        }
        set alignHorizontal(value) {
          if (this._layoutType !== Type.HORIZONTAL) {
            return;
          }
          this._isAlign = value;
          this._doLayoutDirty();
        }
        get alignVertical() {
          return this._isAlign;
        }
        set alignVertical(value) {
          if (this._layoutType !== Type.VERTICAL) {
            return;
          }
          this._isAlign = value;
          this._doLayoutDirty();
        }
        get type() {
          return this._layoutType;
        }
        set type(value) {
          this._layoutType = value;
          this._doLayoutDirty();
        }
        get resizeMode() {
          return this._resizeMode;
        }
        set resizeMode(value) {
          if (this._layoutType === Type.NONE) {
            return;
          }
          this._resizeMode = value;
          this._doLayoutDirty();
        }
        get cellSize() {
          return this._cellSize;
        }
        set cellSize(value) {
          if (this._cellSize === value) {
            return;
          }
          this._cellSize.set(value);
          this._doLayoutDirty();
        }
        get startAxis() {
          return this._startAxis;
        }
        set startAxis(value) {
          if (this._startAxis === value) {
            return;
          }
          this._startAxis = value;
          this._doLayoutDirty();
        }
        get paddingLeft() {
          return this._paddingLeft;
        }
        set paddingLeft(value) {
          if (this._paddingLeft === value) {
            return;
          }
          this._paddingLeft = value;
          this._doLayoutDirty();
        }
        get paddingRight() {
          return this._paddingRight;
        }
        set paddingRight(value) {
          if (this._paddingRight === value) {
            return;
          }
          this._paddingRight = value;
          this._doLayoutDirty();
        }
        get paddingTop() {
          return this._paddingTop;
        }
        set paddingTop(value) {
          if (this._paddingTop === value) {
            return;
          }
          this._paddingTop = value;
          this._doLayoutDirty();
        }
        get paddingBottom() {
          return this._paddingBottom;
        }
        set paddingBottom(value) {
          if (this._paddingBottom === value) {
            return;
          }
          this._paddingBottom = value;
          this._doLayoutDirty();
        }
        get spacingX() {
          return this._spacingX;
        }
        set spacingX(value) {
          if (this._spacingX === value) {
            return;
          }
          this._spacingX = value;
          this._doLayoutDirty();
        }
        get spacingY() {
          return this._spacingY;
        }
        set spacingY(value) {
          if (this._spacingY === value) {
            return;
          }
          this._spacingY = value;
          this._doLayoutDirty();
        }
        get verticalDirection() {
          return this._verticalDirection;
        }
        set verticalDirection(value) {
          if (this._verticalDirection === value) {
            return;
          }
          this._verticalDirection = value;
          this._doLayoutDirty();
        }
        get horizontalDirection() {
          return this._horizontalDirection;
        }
        set horizontalDirection(value) {
          if (this._horizontalDirection === value) {
            return;
          }
          this._horizontalDirection = value;
          this._doLayoutDirty();
        }
        get padding() {
          return this._paddingLeft;
        }
        set padding(value) {
          if (this.paddingLeft !== value || this._paddingRight !== value || this._paddingTop !== value || this._paddingBottom !== value) {
            this._paddingLeft = this._paddingRight = this._paddingTop = this._paddingBottom = value;
            this._doLayoutDirty();
          }
        }
        get constraint() {
          return this._constraint;
        }
        set constraint(value) {
          if (this._layoutType === Type.NONE || this._constraint === value) {
            return;
          }
          this._constraint = value;
          this._doLayoutDirty();
        }
        get constraintNum() {
          return this._constraintNum;
        }
        set constraintNum(value) {
          if (this._constraint === Constraint.NONE || this._constraintNum === value) {
            return;
          }
          if (value <= 0) {
            warn('Limit values to be greater than 0');
          }
          this._constraintNum = value;
          this._doLayoutDirty();
        }
        get affectedByScale() {
          return this._affectedByScale;
        }
        set affectedByScale(value) {
          this._affectedByScale = value;
          this._doLayoutDirty();
        }
        updateLayout(force = false) {
          if (this._layoutDirty || force) {
            this._doLayout();
            this._layoutDirty = false;
          }
        }
        onEnable() {
          this._addEventListeners();
          const trans = this.node._uiProps.uiTransformComp;
          if (trans.contentSize.equals(Size$1.ZERO)) {
            trans.setContentSize(this._layoutSize);
          }
          this._childrenChanged();
        }
        onDisable() {
          this._usefulLayoutObj.length = 0;
          this._removeEventListeners();
        }
        _checkUsefulObj() {
          this._usefulLayoutObj.length = 0;
          const children = this.node.children;
          for (let i = 0; i < children.length; ++i) {
            const child = children[i];
            const uiTrans = child._uiProps.uiTransformComp;
            if (child.activeInHierarchy && uiTrans) {
              this._usefulLayoutObj.push(uiTrans);
            }
          }
        }
        _addEventListeners() {
          director.on(Director.EVENT_AFTER_UPDATE, this.updateLayout, this);
          this.node.on(NodeEventType.SIZE_CHANGED, this._resized, this);
          this.node.on(NodeEventType.ANCHOR_CHANGED, this._doLayoutDirty, this);
          this.node.on(NodeEventType.CHILD_ADDED, this._childAdded, this);
          this.node.on(NodeEventType.CHILD_REMOVED, this._childRemoved, this);
          this.node.on(NodeEventType.SIBLING_ORDER_CHANGED, this._childrenChanged, this);
          this.node.on('childrenSiblingOrderChanged', this.updateLayout, this);
          this._addChildrenEventListeners();
        }
        _removeEventListeners() {
          director.off(Director.EVENT_AFTER_UPDATE, this.updateLayout, this);
          this.node.off(NodeEventType.SIZE_CHANGED, this._resized, this);
          this.node.off(NodeEventType.ANCHOR_CHANGED, this._doLayoutDirty, this);
          this.node.off(NodeEventType.CHILD_ADDED, this._childAdded, this);
          this.node.off(NodeEventType.CHILD_REMOVED, this._childRemoved, this);
          this.node.off(NodeEventType.SIBLING_ORDER_CHANGED, this._childrenChanged, this);
          this.node.off('childrenSiblingOrderChanged', this.updateLayout, this);
          this._removeChildrenEventListeners();
        }
        _addChildrenEventListeners() {
          const children = this.node.children;
          for (let i = 0; i < children.length; ++i) {
            const child = children[i];
            child.on(NodeEventType.SIZE_CHANGED, this._doLayoutDirty, this);
            child.on(NodeEventType.TRANSFORM_CHANGED, this._transformDirty, this);
            child.on(NodeEventType.ANCHOR_CHANGED, this._doLayoutDirty, this);
            child.on(NodeEventType.ACTIVE_IN_HIERARCHY_CHANGED, this._childrenChanged, this);
          }
        }
        _removeChildrenEventListeners() {
          const children = this.node.children;
          for (let i = 0; i < children.length; ++i) {
            const child = children[i];
            child.off(NodeEventType.SIZE_CHANGED, this._doLayoutDirty, this);
            child.off(NodeEventType.TRANSFORM_CHANGED, this._transformDirty, this);
            child.off(NodeEventType.ANCHOR_CHANGED, this._doLayoutDirty, this);
            child.off(NodeEventType.ACTIVE_IN_HIERARCHY_CHANGED, this._childrenChanged, this);
          }
        }
        _childAdded(child) {
          child.on(NodeEventType.SIZE_CHANGED, this._doLayoutDirty, this);
          child.on(NodeEventType.TRANSFORM_CHANGED, this._transformDirty, this);
          child.on(NodeEventType.ANCHOR_CHANGED, this._doLayoutDirty, this);
          child.on(NodeEventType.ACTIVE_IN_HIERARCHY_CHANGED, this._childrenChanged, this);
          this._childrenChanged();
        }
        _childRemoved(child) {
          child.off(NodeEventType.SIZE_CHANGED, this._doLayoutDirty, this);
          child.off(NodeEventType.TRANSFORM_CHANGED, this._transformDirty, this);
          child.off(NodeEventType.ANCHOR_CHANGED, this._doLayoutDirty, this);
          child.off(NodeEventType.ACTIVE_IN_HIERARCHY_CHANGED, this._childrenChanged, this);
          this._childrenChanged();
        }
        _resized() {
          this._layoutSize.set(this.node._uiProps.uiTransformComp.contentSize);
          this._doLayoutDirty();
        }
        _doLayoutHorizontally(baseWidth, rowBreak, fnPositionY, applyChildren) {
          const trans = this.node._uiProps.uiTransformComp;
          const layoutAnchor = trans.anchorPoint;
          const limit = this._getFixedBreakingNum();
          let sign = 1;
          let paddingX = this._paddingLeft;
          if (this._horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT) {
            sign = -1;
            paddingX = this._paddingRight;
          }
          const startPos = (this._horizontalDirection - layoutAnchor.x) * baseWidth + sign * paddingX;
          let nextX = startPos - sign * this._spacingX;
          let totalHeight = 0;
          let rowMaxHeight = 0;
          let tempMaxHeight = 0;
          let maxHeight = 0;
          let isBreak = false;
          const activeChildCount = this._usefulLayoutObj.length;
          let newChildWidth = this._cellSize.width;
          const paddingH = this._getPaddingH();
          if (this._layoutType !== Type.GRID && this._resizeMode === ResizeMode.CHILDREN) {
            newChildWidth = (baseWidth - paddingH - (activeChildCount - 1) * this._spacingX) / activeChildCount;
          }
          const children = this._usefulLayoutObj;
          for (let i = 0; i < children.length; ++i) {
            const childTrans = children[i];
            const child = childTrans.node;
            const scale = child.scale;
            const childScaleX = this._getUsedScaleValue(scale.x);
            const childScaleY = this._getUsedScaleValue(scale.y);
            if (this._resizeMode === ResizeMode.CHILDREN) {
              childTrans.width = newChildWidth / childScaleX;
              if (this._layoutType === Type.GRID) {
                childTrans.height = this._cellSize.height / childScaleY;
              }
            }
            const anchorX = Math.abs(this._horizontalDirection - childTrans.anchorX);
            const childBoundingBoxWidth = childTrans.width * childScaleX;
            const childBoundingBoxHeight = childTrans.height * childScaleY;
            if (childBoundingBoxHeight > tempMaxHeight) {
              maxHeight = Math.max(tempMaxHeight, maxHeight);
              rowMaxHeight = tempMaxHeight || childBoundingBoxHeight;
              tempMaxHeight = childBoundingBoxHeight;
            }
            nextX += sign * (anchorX * childBoundingBoxWidth + this._spacingX);
            const rightBoundaryOfChild = sign * (1 - anchorX) * childBoundingBoxWidth;
            if (rowBreak) {
              if (limit > 0) {
                isBreak = i / limit > 0 && i % limit === 0;
                if (isBreak) {
                  rowMaxHeight = tempMaxHeight > childBoundingBoxHeight ? tempMaxHeight : rowMaxHeight;
                }
              } else if (childBoundingBoxWidth > baseWidth - paddingH) {
                if (nextX > startPos + sign * (anchorX * childBoundingBoxWidth)) {
                  isBreak = true;
                }
              } else {
                const boundary = (1 - this._horizontalDirection - layoutAnchor.x) * baseWidth;
                const rowBreakBoundary = nextX + rightBoundaryOfChild + sign * (sign > 0 ? this._paddingRight : this._paddingLeft);
                isBreak = Math.abs(rowBreakBoundary) > Math.abs(boundary);
              }
              if (isBreak) {
                nextX = startPos + sign * (anchorX * childBoundingBoxWidth);
                if (childBoundingBoxHeight !== tempMaxHeight) {
                  rowMaxHeight = tempMaxHeight;
                }
                totalHeight += rowMaxHeight + this._spacingY;
                rowMaxHeight = tempMaxHeight = childBoundingBoxHeight;
              }
            }
            const finalPositionY = fnPositionY(child, childTrans, totalHeight);
            if (applyChildren) {
              child.setPosition(nextX, finalPositionY);
            }
            nextX += rightBoundaryOfChild;
          }
          rowMaxHeight = Math.max(rowMaxHeight, tempMaxHeight);
          const containerResizeBoundary = Math.max(maxHeight, totalHeight + rowMaxHeight) + this._getPaddingV();
          return containerResizeBoundary;
        }
        _doLayoutVertically(baseHeight, columnBreak, fnPositionX, applyChildren) {
          const trans = this.node._uiProps.uiTransformComp;
          const layoutAnchor = trans.anchorPoint;
          const limit = this._getFixedBreakingNum();
          let sign = 1;
          let paddingY = this._paddingBottom;
          if (this._verticalDirection === VerticalDirection.TOP_TO_BOTTOM) {
            sign = -1;
            paddingY = this._paddingTop;
          }
          const startPos = (this._verticalDirection - layoutAnchor.y) * baseHeight + sign * paddingY;
          let nextY = startPos - sign * this._spacingY;
          let tempMaxWidth = 0;
          let maxWidth = 0;
          let colMaxWidth = 0;
          let totalWidth = 0;
          let isBreak = false;
          const activeChildCount = this._usefulLayoutObj.length;
          let newChildHeight = this._cellSize.height;
          const paddingV = this._getPaddingV();
          if (this._layoutType !== Type.GRID && this._resizeMode === ResizeMode.CHILDREN) {
            newChildHeight = (baseHeight - paddingV - (activeChildCount - 1) * this._spacingY) / activeChildCount;
          }
          const children = this._usefulLayoutObj;
          for (let i = 0; i < children.length; ++i) {
            const childTrans = children[i];
            const child = childTrans.node;
            const scale = child.scale;
            const childScaleX = this._getUsedScaleValue(scale.x);
            const childScaleY = this._getUsedScaleValue(scale.y);
            if (this._resizeMode === ResizeMode.CHILDREN) {
              childTrans.height = newChildHeight / childScaleY;
              if (this._layoutType === Type.GRID) {
                childTrans.width = this._cellSize.width / childScaleX;
              }
            }
            const anchorY = Math.abs(this._verticalDirection - childTrans.anchorY);
            const childBoundingBoxWidth = childTrans.width * childScaleX;
            const childBoundingBoxHeight = childTrans.height * childScaleY;
            if (childBoundingBoxWidth > tempMaxWidth) {
              maxWidth = Math.max(tempMaxWidth, maxWidth);
              colMaxWidth = tempMaxWidth || childBoundingBoxWidth;
              tempMaxWidth = childBoundingBoxWidth;
            }
            nextY += sign * (anchorY * childBoundingBoxHeight + this._spacingY);
            const topBoundaryOfChild = sign * (1 - anchorY) * childBoundingBoxHeight;
            if (columnBreak) {
              if (limit > 0) {
                isBreak = i / limit > 0 && i % limit === 0;
                if (isBreak) {
                  colMaxWidth = tempMaxWidth > childBoundingBoxHeight ? tempMaxWidth : colMaxWidth;
                }
              } else if (childBoundingBoxHeight > baseHeight - paddingV) {
                if (nextY > startPos + sign * (anchorY * childBoundingBoxHeight)) {
                  isBreak = true;
                }
              } else {
                const boundary = (1 - this._verticalDirection - layoutAnchor.y) * baseHeight;
                const columnBreakBoundary = nextY + topBoundaryOfChild + sign * (sign > 0 ? this._paddingTop : this._paddingBottom);
                isBreak = Math.abs(columnBreakBoundary) > Math.abs(boundary);
              }
              if (isBreak) {
                nextY = startPos + sign * (anchorY * childBoundingBoxHeight);
                if (childBoundingBoxWidth !== tempMaxWidth) {
                  colMaxWidth = tempMaxWidth;
                }
                totalWidth += colMaxWidth + this._spacingX;
                colMaxWidth = tempMaxWidth = childBoundingBoxWidth;
              }
            }
            const finalPositionX = fnPositionX(child, childTrans, totalWidth);
            if (applyChildren) {
              child.getPosition(_tempVec3$2);
              child.setPosition(finalPositionX, nextY, _tempVec3$2.z);
            }
            nextY += topBoundaryOfChild;
          }
          colMaxWidth = Math.max(colMaxWidth, tempMaxWidth);
          const containerResizeBoundary = Math.max(maxWidth, totalWidth + colMaxWidth) + this._getPaddingH();
          return containerResizeBoundary;
        }
        _doLayoutGridAxisHorizontal(layoutAnchor, layoutSize) {
          const baseWidth = layoutSize.width;
          let sign = 1;
          let bottomBoundaryOfLayout = -layoutAnchor.y * layoutSize.height;
          let paddingY = this._paddingBottom;
          if (this._verticalDirection === VerticalDirection.TOP_TO_BOTTOM) {
            sign = -1;
            bottomBoundaryOfLayout = (1 - layoutAnchor.y) * layoutSize.height;
            paddingY = this._paddingTop;
          }
          const fnPositionY = (child, childTrans, topOffset) => bottomBoundaryOfLayout + sign * (topOffset + (1 - childTrans.anchorY) * childTrans.height * this._getUsedScaleValue(child.scale.y) + paddingY);
          let newHeight = 0;
          if (this._resizeMode === ResizeMode.CONTAINER) {
            newHeight = this._doLayoutHorizontally(baseWidth, true, fnPositionY, false);
            bottomBoundaryOfLayout = -layoutAnchor.y * newHeight;
            if (this._verticalDirection === VerticalDirection.TOP_TO_BOTTOM) {
              sign = -1;
              bottomBoundaryOfLayout = (1 - layoutAnchor.y) * newHeight;
            }
          }
          this._doLayoutHorizontally(baseWidth, true, fnPositionY, true);
          if (this._resizeMode === ResizeMode.CONTAINER) {
            this.node._uiProps.uiTransformComp.setContentSize(baseWidth, newHeight);
          }
        }
        _doLayoutGridAxisVertical(layoutAnchor, layoutSize) {
          const baseHeight = layoutSize.height;
          let sign = 1;
          let leftBoundaryOfLayout = -layoutAnchor.x * layoutSize.width;
          let paddingX = this._paddingLeft;
          if (this._horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT) {
            sign = -1;
            leftBoundaryOfLayout = (1 - layoutAnchor.x) * layoutSize.width;
            paddingX = this._paddingRight;
          }
          const fnPositionX = (child, childTrans, leftOffset) => leftBoundaryOfLayout + sign * (leftOffset + (1 - childTrans.anchorX) * childTrans.width * this._getUsedScaleValue(child.scale.x) + paddingX);
          let newWidth = 0;
          if (this._resizeMode === ResizeMode.CONTAINER) {
            newWidth = this._doLayoutVertically(baseHeight, true, fnPositionX, false);
            leftBoundaryOfLayout = -layoutAnchor.x * newWidth;
            if (this._horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT) {
              sign = -1;
              leftBoundaryOfLayout = (1 - layoutAnchor.x) * newWidth;
            }
          }
          this._doLayoutVertically(baseHeight, true, fnPositionX, true);
          if (this._resizeMode === ResizeMode.CONTAINER) {
            this.node._uiProps.uiTransformComp.setContentSize(newWidth, baseHeight);
          }
        }
        _doLayoutGrid() {
          const trans = this.node._uiProps.uiTransformComp;
          const layoutAnchor = trans.anchorPoint;
          const layoutSize = trans.contentSize;
          if (this.startAxis === AxisDirection.HORIZONTAL) {
            this._doLayoutGridAxisHorizontal(layoutAnchor, layoutSize);
          } else if (this.startAxis === AxisDirection.VERTICAL) {
            this._doLayoutGridAxisVertical(layoutAnchor, layoutSize);
          }
        }
        _getHorizontalBaseWidth(horizontal = true) {
          const children = this._usefulLayoutObj;
          let baseSize = 0;
          const activeChildCount = children.length;
          if (this._resizeMode === ResizeMode.CONTAINER) {
            for (let i = 0; i < children.length; ++i) {
              const childTrans = children[i];
              const child = childTrans.node;
              const scale = child.scale;
              baseSize += childTrans.width * this._getUsedScaleValue(scale.x);
            }
            baseSize += (activeChildCount - 1) * this._spacingX + this._getPaddingH();
          } else {
            baseSize = this.node._uiProps.uiTransformComp.width;
          }
          return baseSize;
        }
        _getVerticalBaseHeight() {
          const children = this._usefulLayoutObj;
          let baseSize = 0;
          const activeChildCount = children.length;
          if (this._resizeMode === ResizeMode.CONTAINER) {
            for (let i = 0; i < children.length; ++i) {
              const childTrans = children[i];
              const child = childTrans.node;
              const scale = child.scale;
              baseSize += childTrans.height * this._getUsedScaleValue(scale.y);
            }
            baseSize += (activeChildCount - 1) * this._spacingY + this._getPaddingV();
          } else {
            baseSize = this.node._uiProps.uiTransformComp.height;
          }
          return baseSize;
        }
        _doLayout() {
          if (!this._init || this._childrenDirty) {
            this._checkUsefulObj();
            this._init = true;
            this._childrenDirty = false;
          }
          if (this._layoutType === Type.HORIZONTAL) {
            const newWidth = this._getHorizontalBaseWidth();
            const fnPositionY = child => {
              const pos = this._isAlign ? Vec3.ZERO : child.position;
              return pos.y;
            };
            this._doLayoutHorizontally(newWidth, false, fnPositionY, true);
            this.node._uiProps.uiTransformComp.width = newWidth;
          } else if (this._layoutType === Type.VERTICAL) {
            const newHeight = this._getVerticalBaseHeight();
            const fnPositionX = child => {
              const pos = this._isAlign ? Vec3.ZERO : child.position;
              return pos.x;
            };
            this._doLayoutVertically(newHeight, false, fnPositionX, true);
            this.node._uiProps.uiTransformComp.height = newHeight;
          } else if (this._layoutType === Type.GRID) {
            this._doLayoutGrid();
          }
        }
        _getUsedScaleValue(value) {
          return this._affectedByScale ? Math.abs(value) : 1;
        }
        _transformDirty(type) {
          if (!(type & TransformBit.SCALE) || !(type & TransformBit.POSITION) || !this._affectedByScale) {
            return;
          }
          this._doLayoutDirty();
        }
        _doLayoutDirty() {
          this._layoutDirty = true;
        }
        _childrenChanged() {
          this._childrenDirty = true;
          this._doLayoutDirty();
        }
        _getPaddingH() {
          return this._paddingLeft + this._paddingRight;
        }
        _getPaddingV() {
          return this._paddingTop + this._paddingBottom;
        }
        _getFixedBreakingNum() {
          if (this._layoutType !== Type.GRID || this._constraint === Constraint.NONE || this._constraintNum <= 0) {
            return 0;
          }
          let num = this._constraint === Constraint.FIXED_ROW ? Math.ceil(this._usefulLayoutObj.length / this._constraintNum) : this._constraintNum;
          if (this._startAxis === AxisDirection.VERTICAL) {
            num = this._constraint === Constraint.FIXED_COL ? Math.ceil(this._usefulLayoutObj.length / this._constraintNum) : this._constraintNum;
          }
          return num;
        }
      }, _class3$8.Type = Type, _class3$8.VerticalDirection = VerticalDirection, _class3$8.HorizontalDirection = HorizontalDirection, _class3$8.ResizeMode = ResizeMode, _class3$8.AxisDirection = AxisDirection, _class3$8.Constraint = Constraint, _class3$8), (_applyDecoratedDescriptor(_class2$b.prototype, "type", [_dec4$9], Object.getOwnPropertyDescriptor(_class2$b.prototype, "type"), _class2$b.prototype), _applyDecoratedDescriptor(_class2$b.prototype, "resizeMode", [_dec5$9], Object.getOwnPropertyDescriptor(_class2$b.prototype, "resizeMode"), _class2$b.prototype), _applyDecoratedDescriptor(_class2$b.prototype, "startAxis", [_dec6$3], Object.getOwnPropertyDescriptor(_class2$b.prototype, "startAxis"), _class2$b.prototype), _applyDecoratedDescriptor(_class2$b.prototype, "verticalDirection", [_dec7$2], Object.getOwnPropertyDescriptor(_class2$b.prototype, "verticalDirection"), _class2$b.prototype), _applyDecoratedDescriptor(_class2$b.prototype, "horizontalDirection", [_dec8$1], Object.getOwnPropertyDescriptor(_class2$b.prototype, "horizontalDirection"), _class2$b.prototype), _applyDecoratedDescriptor(_class2$b.prototype, "constraint", [_dec9$1], Object.getOwnPropertyDescriptor(_class2$b.prototype, "constraint"), _class2$b.prototype), _initializer$b = applyDecoratedInitializer(_class2$b.prototype, "_resizeMode", [serializable$3], function () {
        return ResizeMode.NONE;
      }), _initializer2$b = applyDecoratedInitializer(_class2$b.prototype, "_layoutType", [serializable$3], function () {
        return Type.NONE;
      }), _initializer3$9 = applyDecoratedInitializer(_class2$b.prototype, "_cellSize", [serializable$3], function () {
        return new Size$1(40, 40);
      }), _initializer4$8 = applyDecoratedInitializer(_class2$b.prototype, "_startAxis", [serializable$3], function () {
        return AxisDirection.HORIZONTAL;
      }), _initializer5$6 = applyDecoratedInitializer(_class2$b.prototype, "_paddingLeft", [serializable$3], function () {
        return 0;
      }), _initializer6$3 = applyDecoratedInitializer(_class2$b.prototype, "_paddingRight", [serializable$3], function () {
        return 0;
      }), _initializer7$3 = applyDecoratedInitializer(_class2$b.prototype, "_paddingTop", [serializable$3], function () {
        return 0;
      }), _initializer8$3 = applyDecoratedInitializer(_class2$b.prototype, "_paddingBottom", [serializable$3], function () {
        return 0;
      }), _initializer9$3 = applyDecoratedInitializer(_class2$b.prototype, "_spacingX", [serializable$3], function () {
        return 0;
      }), _initializer10$3 = applyDecoratedInitializer(_class2$b.prototype, "_spacingY", [serializable$3], function () {
        return 0;
      }), _initializer11$3 = applyDecoratedInitializer(_class2$b.prototype, "_verticalDirection", [serializable$3], function () {
        return VerticalDirection.TOP_TO_BOTTOM;
      }), _initializer12$2 = applyDecoratedInitializer(_class2$b.prototype, "_horizontalDirection", [serializable$3], function () {
        return HorizontalDirection.LEFT_TO_RIGHT;
      }), _initializer13$1 = applyDecoratedInitializer(_class2$b.prototype, "_constraint", [serializable$3], function () {
        return Constraint.NONE;
      }), _initializer14$1 = applyDecoratedInitializer(_class2$b.prototype, "_constraintNum", [serializable$3], function () {
        return 2;
      }), _initializer15$1 = applyDecoratedInitializer(_class2$b.prototype, "_affectedByScale", [serializable$3], function () {
        return false;
      }), _initializer16$1 = applyDecoratedInitializer(_class2$b.prototype, "_isAlign", [serializable$3], function () {
        return false;
      })), _class2$b)) || _class$f) || _class$f) || _class$f); exports({ Layout: Layout, LayoutComponent: Layout });
      legacyCC.Layout = Layout;

      var _dec$e, _dec2$c, _dec3$b, _dec4$8, _dec5$8, _class$e, _class2$a, _initializer$a, _initializer2$a, _initializer3$8, _initializer4$7, _initializer5$5, _class3$7;
      var Mode;
      (function (Mode) {
        Mode[Mode["HORIZONTAL"] = 0] = "HORIZONTAL";
        Mode[Mode["VERTICAL"] = 1] = "VERTICAL";
        Mode[Mode["FILLED"] = 2] = "FILLED";
      })(Mode || (Mode = {}));
      Enum(Mode);
      let ProgressBar = (_dec$e = ccclass$3('cc.ProgressBar'), _dec2$c = executionOrder(110), _dec3$b = requireComponent(UITransform), _dec4$8 = type$2(Sprite), _dec5$8 = type$2(Mode), _dec$e(_class$e = _dec2$c(_class$e = _dec3$b(_class$e = (_class2$a = (_class3$7 = class ProgressBar extends Component {
        constructor(...args) {
          super(...args);
          this._barSprite = _initializer$a && _initializer$a();
          this._mode = _initializer2$a && _initializer2$a();
          this._totalLength = _initializer3$8 && _initializer3$8();
          this._progress = _initializer4$7 && _initializer4$7();
          this._reverse = _initializer5$5 && _initializer5$5();
        }
        get barSprite() {
          return this._barSprite;
        }
        set barSprite(value) {
          if (this._barSprite === value) {
            return;
          }
          this._barSprite = value;
          this._initBarSprite();
        }
        get mode() {
          return this._mode;
        }
        set mode(value) {
          if (this._mode === value) {
            return;
          }
          this._mode = value;
          if (this._barSprite) {
            const entity = this._barSprite.node;
            if (!entity) {
              return;
            }
            const entitySize = entity._uiProps.uiTransformComp.contentSize;
            if (this._mode === Mode.HORIZONTAL) {
              this.totalLength = entitySize.width;
            } else if (this._mode === Mode.VERTICAL) {
              this.totalLength = entitySize.height;
            } else if (this._mode === Mode.FILLED) {
              this.totalLength = this._barSprite.fillRange;
            }
          }
        }
        get totalLength() {
          return this._totalLength;
        }
        set totalLength(value) {
          if (this._mode === Mode.FILLED) {
            value = clamp01(value);
          }
          if (this._totalLength === value) {
            return;
          }
          this._totalLength = value;
          this._updateBarStatus();
        }
        get progress() {
          return this._progress;
        }
        set progress(value) {
          if (this._progress === value) {
            return;
          }
          this._progress = value;
          this._updateBarStatus();
        }
        get reverse() {
          return this._reverse;
        }
        set reverse(value) {
          if (this._reverse === value) {
            return;
          }
          this._reverse = value;
          if (this._barSprite) {
            this._barSprite.fillStart = 1 - this._barSprite.fillStart;
          }
          this._updateBarStatus();
        }
        _initBarSprite() {
          if (this._barSprite) {
            const entity = this._barSprite.node;
            if (!entity) {
              return;
            }
            const trans = this.node._uiProps.uiTransformComp;
            const nodeSize = trans.contentSize;
            const nodeAnchor = trans.anchorPoint;
            const barSpriteSize = entity._uiProps.uiTransformComp.contentSize;
            if (this._barSprite.fillType === Sprite.FillType.RADIAL) {
              this._mode = Mode.FILLED;
            }
            if (this._mode === Mode.HORIZONTAL) {
              this.totalLength = barSpriteSize.width;
            } else if (this._mode === Mode.VERTICAL) {
              this.totalLength = barSpriteSize.height;
            } else {
              this.totalLength = this._barSprite.fillRange;
            }
            if (entity.parent === this.node) {
              const x = -nodeSize.width * nodeAnchor.x;
              entity.setPosition(x, 0, 0);
            }
          }
        }
        _updateBarStatus() {
          if (this._barSprite) {
            const entity = this._barSprite.node;
            if (!entity) {
              return;
            }
            const entTrans = entity._uiProps.uiTransformComp;
            const entityAnchorPoint = entTrans.anchorPoint;
            const entitySize = entTrans.contentSize;
            const entityPosition = entity.getPosition();
            let anchorPoint = new Vec2(0, 0.5);
            const progress = clamp01(this._progress);
            let actualLenth = this._totalLength * progress;
            let finalContentSize = entitySize;
            let totalWidth = 0;
            let totalHeight = 0;
            switch (this._mode) {
              case Mode.HORIZONTAL:
                if (this._reverse) {
                  anchorPoint = new Vec2(1, 0.5);
                }
                finalContentSize = new Size$1(actualLenth, entitySize.height);
                totalWidth = this._totalLength;
                totalHeight = entitySize.height;
                break;
              case Mode.VERTICAL:
                if (this._reverse) {
                  anchorPoint = new Vec2(0.5, 1);
                } else {
                  anchorPoint = new Vec2(0.5, 0);
                }
                finalContentSize = new Size$1(entitySize.width, actualLenth);
                totalWidth = entitySize.width;
                totalHeight = this._totalLength;
                break;
            }
            if (this._mode === Mode.FILLED) {
              if (this._barSprite.type !== Sprite.Type.FILLED) {
                warn('ProgressBar FILLED mode only works when barSprite\'s Type is FILLED!');
              } else {
                if (this._reverse) {
                  actualLenth *= -1;
                }
                this._barSprite.fillRange = actualLenth;
              }
            } else if (this._barSprite.type !== Sprite.Type.FILLED) {
              const anchorOffsetX = anchorPoint.x - entityAnchorPoint.x;
              const anchorOffsetY = anchorPoint.y - entityAnchorPoint.y;
              const finalPosition = new Vec3(totalWidth * anchorOffsetX, totalHeight * anchorOffsetY, 0);
              entity.setPosition(entityPosition.x + finalPosition.x, entityPosition.y + finalPosition.y, entityPosition.z);
              entTrans.setAnchorPoint(anchorPoint);
              entTrans.setContentSize(finalContentSize);
            } else {
              warn('ProgressBar non-FILLED mode only works when barSprite\'s Type is non-FILLED!');
            }
          }
        }
      }, _class3$7.Mode = Mode, _class3$7), (_applyDecoratedDescriptor(_class2$a.prototype, "barSprite", [_dec4$8], Object.getOwnPropertyDescriptor(_class2$a.prototype, "barSprite"), _class2$a.prototype), _applyDecoratedDescriptor(_class2$a.prototype, "mode", [_dec5$8], Object.getOwnPropertyDescriptor(_class2$a.prototype, "mode"), _class2$a.prototype), _initializer$a = applyDecoratedInitializer(_class2$a.prototype, "_barSprite", [serializable$3], function () {
        return null;
      }), _initializer2$a = applyDecoratedInitializer(_class2$a.prototype, "_mode", [serializable$3], function () {
        return Mode.HORIZONTAL;
      }), _initializer3$8 = applyDecoratedInitializer(_class2$a.prototype, "_totalLength", [serializable$3], function () {
        return 1;
      }), _initializer4$7 = applyDecoratedInitializer(_class2$a.prototype, "_progress", [serializable$3], function () {
        return 0.1;
      }), _initializer5$5 = applyDecoratedInitializer(_class2$a.prototype, "_reverse", [serializable$3], function () {
        return false;
      })), _class2$a)) || _class$e) || _class$e) || _class$e); exports({ ProgressBar: ProgressBar, ProgressBarComponent: ProgressBar });
      legacyCC.ProgressBar = ProgressBar;

      var _dec$d, _dec2$b, _dec3$a, _dec4$7, _dec5$7, _class$d, _class2$9, _initializer$9, _initializer2$9, _initializer3$7, _initializer4$6, _initializer5$4, _class3$6;
      const GETTING_SHORTER_FACTOR = 20;
      const _tempPos_1 = new Vec3();
      const _tempPos_2 = new Vec3();
      const _tempVec3$1 = new Vec3();
      const defaultAnchor = new Vec2();
      const _tempColor = new Color$1();
      const _tempVec2$2 = new Vec2();
      var Direction$3;
      (function (Direction) {
        Direction[Direction["HORIZONTAL"] = 0] = "HORIZONTAL";
        Direction[Direction["VERTICAL"] = 1] = "VERTICAL";
      })(Direction$3 || (Direction$3 = {}));
      ccenum(Direction$3);
      let ScrollBar = (_dec$d = ccclass$3('cc.ScrollBar'), _dec2$b = executionOrder(110), _dec3$a = requireComponent(UITransform), _dec4$7 = type$2(Sprite), _dec5$7 = type$2(Direction$3), _dec$d(_class$d = _dec2$b(_class$d = _dec3$a(_class$d = (_class2$9 = (_class3$6 = class ScrollBar extends Component {
        constructor(...args) {
          super(...args);
          this._scrollView = _initializer$9 && _initializer$9();
          this._handle = _initializer2$9 && _initializer2$9();
          this._direction = _initializer3$7 && _initializer3$7();
          this._enableAutoHide = _initializer4$6 && _initializer4$6();
          this._autoHideTime = _initializer5$4 && _initializer5$4();
          this._touching = false;
          this._opacity = 255;
          this._autoHideRemainingTime = 0;
        }
        get handle() {
          return this._handle;
        }
        set handle(value) {
          if (this._handle === value) {
            return;
          }
          this._handle = value;
          this.onScroll(Vec2.ZERO);
        }
        get direction() {
          return this._direction;
        }
        set direction(value) {
          if (this._direction === value) {
            return;
          }
          this._direction = value;
          this.onScroll(Vec2.ZERO);
        }
        get enableAutoHide() {
          return this._enableAutoHide;
        }
        set enableAutoHide(value) {
          if (this._enableAutoHide === value) {
            return;
          }
          this._enableAutoHide = value;
          if (this._enableAutoHide) {
            this._setOpacity(0);
          }
        }
        get autoHideTime() {
          return this._autoHideTime;
        }
        set autoHideTime(value) {
          if (this._autoHideTime === value) {
            return;
          }
          this._autoHideTime = value;
        }
        hide() {
          this._autoHideRemainingTime = 0;
          this._setOpacity(0);
        }
        show() {
          this._autoHideRemainingTime = this._autoHideTime;
          this._opacity = 255;
          this._setOpacity(this._opacity);
        }
        onScroll(outOfBoundary) {
          if (!this._scrollView) {
            return;
          }
          const content = this._scrollView.content;
          if (!content) {
            return;
          }
          const contentSize = content._uiProps.uiTransformComp.contentSize;
          const scrollViewSize = this._scrollView.node._uiProps.uiTransformComp.contentSize;
          const barSize = this.node._uiProps.uiTransformComp.contentSize;
          if (this._conditionalDisableScrollBar(contentSize, scrollViewSize)) {
            return;
          }
          if (this._enableAutoHide) {
            this._autoHideRemainingTime = this._autoHideTime;
            this._setOpacity(this._opacity);
          }
          let contentMeasure = 0;
          let scrollViewMeasure = 0;
          let outOfBoundaryValue = 0;
          let contentPosition = 0;
          let handleNodeMeasure = 0;
          const outOfContentPosition = _tempVec2$2;
          outOfContentPosition.set(0, 0);
          if (this._direction === Direction$3.HORIZONTAL) {
            contentMeasure = contentSize.width;
            scrollViewMeasure = scrollViewSize.width;
            handleNodeMeasure = barSize.width;
            outOfBoundaryValue = outOfBoundary.x;
            this._convertToScrollViewSpace(outOfContentPosition, content);
            contentPosition = -outOfContentPosition.x;
          } else if (this._direction === Direction$3.VERTICAL) {
            contentMeasure = contentSize.height;
            scrollViewMeasure = scrollViewSize.height;
            handleNodeMeasure = barSize.height;
            outOfBoundaryValue = outOfBoundary.y;
            this._convertToScrollViewSpace(outOfContentPosition, content);
            contentPosition = -outOfContentPosition.y;
          }
          const length = this._calculateLength(contentMeasure, scrollViewMeasure, handleNodeMeasure, outOfBoundaryValue);
          const position = _tempVec2$2;
          this._calculatePosition(position, contentMeasure, scrollViewMeasure, handleNodeMeasure, contentPosition, outOfBoundaryValue, length);
          this._updateLength(length);
          this._updateHandlerPosition(position);
        }
        setScrollView(scrollView) {
          this._scrollView = scrollView;
        }
        onTouchBegan() {
          if (!this._enableAutoHide) {
            return;
          }
          this._touching = true;
        }
        onTouchEnded() {
          if (!this._enableAutoHide) {
            return;
          }
          this._touching = false;
          if (this._autoHideTime <= 0) {
            return;
          }
          if (this._scrollView) {
            const content = this._scrollView.content;
            if (content) {
              const contentSize = content._uiProps.uiTransformComp.contentSize;
              const scrollViewSize = this._scrollView.node._uiProps.uiTransformComp.contentSize;
              if (this._conditionalDisableScrollBar(contentSize, scrollViewSize)) {
                return;
              }
            }
          }
          this._autoHideRemainingTime = this._autoHideTime;
        }
        onEnable() {
          const renderComp = this.node.getComponent(Sprite);
          if (renderComp) {
            this._opacity = renderComp.color.a;
          }
        }
        start() {
          if (this._enableAutoHide) {
            this._setOpacity(0);
          }
        }
        update(dt) {
          this._processAutoHide(dt);
        }
        _convertToScrollViewSpace(out, content) {
          const scrollTrans = this._scrollView && this._scrollView.node._uiProps.uiTransformComp;
          const contentTrans = content._uiProps.uiTransformComp;
          if (!scrollTrans || !contentTrans) {
            out.set(Vec2.ZERO);
          } else {
            _tempPos_1.set(-contentTrans.anchorX * contentTrans.width, -contentTrans.anchorY * contentTrans.height, 0);
            contentTrans.convertToWorldSpaceAR(_tempPos_1, _tempPos_2);
            const scrollViewSpacePos = scrollTrans.convertToNodeSpaceAR(_tempPos_2);
            scrollViewSpacePos.x += scrollTrans.anchorX * scrollTrans.width;
            scrollViewSpacePos.y += scrollTrans.anchorY * scrollTrans.height;
            out.set(scrollViewSpacePos.x, scrollViewSpacePos.y);
          }
        }
        _setOpacity(opacity) {
          if (this._handle) {
            let renderComp = this.node.getComponent(Sprite);
            if (renderComp) {
              _tempColor.set(renderComp.color);
              _tempColor.a = opacity;
              renderComp.color = _tempColor;
            }
            renderComp = this._handle.getComponent(Sprite);
            if (renderComp) {
              _tempColor.set(renderComp.color);
              _tempColor.a = opacity;
              renderComp.color = _tempColor;
            }
          }
        }
        _updateHandlerPosition(position) {
          if (this._handle) {
            const oldPosition = _tempVec3$1;
            this._fixupHandlerPosition(oldPosition);
            this._handle.node.setPosition(position.x + oldPosition.x, position.y + oldPosition.y, oldPosition.z);
          }
        }
        _fixupHandlerPosition(out) {
          const uiTrans = this.node._uiProps.uiTransformComp;
          const barSize = uiTrans.contentSize;
          const barAnchor = uiTrans.anchorPoint;
          const handleSize = this.handle.node._uiProps.uiTransformComp.contentSize;
          const handleParent = this.handle.node.parent;
          Vec3.set(_tempPos_1, -barSize.width * barAnchor.x, -barSize.height * barAnchor.y, 0);
          const leftBottomWorldPosition = this.node._uiProps.uiTransformComp.convertToWorldSpaceAR(_tempPos_1, _tempPos_2);
          const fixupPosition = out;
          fixupPosition.set(0, 0, 0);
          handleParent._uiProps.uiTransformComp.convertToNodeSpaceAR(leftBottomWorldPosition, fixupPosition);
          if (this.direction === Direction$3.HORIZONTAL) {
            fixupPosition.set(fixupPosition.x, fixupPosition.y + (barSize.height - handleSize.height) / 2, fixupPosition.z);
          } else if (this.direction === Direction$3.VERTICAL) {
            fixupPosition.set(fixupPosition.x + (barSize.width - handleSize.width) / 2, fixupPosition.y, fixupPosition.z);
          }
          this.handle.node.setPosition(fixupPosition);
        }
        _conditionalDisableScrollBar(contentSize, scrollViewSize) {
          if (contentSize.width <= scrollViewSize.width && this._direction === Direction$3.HORIZONTAL) {
            return true;
          }
          if (contentSize.height <= scrollViewSize.height && this._direction === Direction$3.VERTICAL) {
            return true;
          }
          return false;
        }
        _calculateLength(contentMeasure, scrollViewMeasure, handleNodeMeasure, outOfBoundary) {
          let denominatorValue = contentMeasure;
          if (outOfBoundary) {
            denominatorValue += (outOfBoundary > 0 ? outOfBoundary : -outOfBoundary) * GETTING_SHORTER_FACTOR;
          }
          const lengthRation = scrollViewMeasure / denominatorValue;
          return handleNodeMeasure * lengthRation;
        }
        _calculatePosition(out, contentMeasure, scrollViewMeasure, handleNodeMeasure, contentPosition, outOfBoundary, actualLenth) {
          let denominatorValue = contentMeasure - scrollViewMeasure;
          if (outOfBoundary) {
            denominatorValue += Math.abs(outOfBoundary);
          }
          let positionRatio = 0;
          if (denominatorValue) {
            positionRatio = contentPosition / denominatorValue;
            positionRatio = clamp01(positionRatio);
          }
          const position = (handleNodeMeasure - actualLenth) * positionRatio;
          if (this._direction === Direction$3.VERTICAL) {
            out.set(0, position);
          } else {
            out.set(position, 0);
          }
        }
        _updateLength(length) {
          if (this._handle) {
            const handleNode = this._handle.node;
            const handleTrans = handleNode._uiProps.uiTransformComp;
            const handleNodeSize = handleTrans.contentSize;
            const anchor = handleTrans.anchorPoint;
            if (anchor.x !== defaultAnchor.x || anchor.y !== defaultAnchor.y) {
              handleTrans.setAnchorPoint(defaultAnchor);
            }
            if (this._direction === Direction$3.HORIZONTAL) {
              handleTrans.setContentSize(length, handleNodeSize.height);
            } else {
              handleTrans.setContentSize(handleNodeSize.width, length);
            }
          }
        }
        _processAutoHide(deltaTime) {
          if (!this._enableAutoHide || this._autoHideRemainingTime <= 0) {
            return;
          } else if (this._touching) {
            return;
          }
          this._autoHideRemainingTime -= deltaTime;
          if (this._autoHideRemainingTime <= this._autoHideTime) {
            this._autoHideRemainingTime = Math.max(0, this._autoHideRemainingTime);
            const opacity = this._opacity * (this._autoHideRemainingTime / this._autoHideTime);
            this._setOpacity(opacity);
          }
        }
      }, _class3$6.Direction = Direction$3, _class3$6), (_applyDecoratedDescriptor(_class2$9.prototype, "handle", [_dec4$7], Object.getOwnPropertyDescriptor(_class2$9.prototype, "handle"), _class2$9.prototype), _applyDecoratedDescriptor(_class2$9.prototype, "direction", [_dec5$7], Object.getOwnPropertyDescriptor(_class2$9.prototype, "direction"), _class2$9.prototype), _initializer$9 = applyDecoratedInitializer(_class2$9.prototype, "_scrollView", [serializable$3], function () {
        return null;
      }), _initializer2$9 = applyDecoratedInitializer(_class2$9.prototype, "_handle", [serializable$3], function () {
        return null;
      }), _initializer3$7 = applyDecoratedInitializer(_class2$9.prototype, "_direction", [serializable$3], function () {
        return Direction$3.HORIZONTAL;
      }), _initializer4$6 = applyDecoratedInitializer(_class2$9.prototype, "_enableAutoHide", [serializable$3], function () {
        return false;
      }), _initializer5$4 = applyDecoratedInitializer(_class2$9.prototype, "_autoHideTime", [serializable$3], function () {
        return 1.0;
      })), _class2$9)) || _class$d) || _class$d) || _class$d); exports({ ScrollBar: ScrollBar, ScrollBarComponent: ScrollBar });
      legacyCC.ScrollBar = ScrollBar;

      var _dec$c, _dec2$a, _class$c;
      let ViewGroup = exports('ViewGroup', (_dec$c = ccclass$3('cc.ViewGroup'), _dec2$a = executionOrder(110), _dec$c(_class$c = _dec2$a(_class$c = class ViewGroup extends Component {}) || _class$c) || _class$c));
      legacyCC.ViewGroup = ViewGroup;

      var _dec$b, _dec2$9, _dec3$9, _dec4$6, _dec5$6, _dec6$2, _dec7$1, _class$b, _class2$8, _initializer$8, _initializer2$8, _initializer3$6, _initializer4$5, _initializer5$3, _initializer6$2, _initializer7$2, _initializer8$2, _initializer9$2, _initializer10$2, _initializer11$2, _class3$5;
      const NUMBER_OF_GATHERED_TOUCHES_FOR_MOVE_SPEED = 5;
      const OUT_OF_BOUNDARY_BREAKING_FACTOR = 0.05;
      const EPSILON = 1e-4;
      const TOLERANCE = 1e4;
      const MOVEMENT_FACTOR = 0.7;
      const _tempVec3 = new Vec3();
      const _tempVec3_1 = new Vec3();
      const _tempVec2$1 = new Vec2();
      const _tempVec2_1$1 = new Vec2();
      const quintEaseOut = time => {
        time -= 1;
        return time * time * time * time * time + 1;
      };
      const getTimeInMilliseconds = () => {
        const currentTime = new Date();
        return currentTime.getMilliseconds();
      };
      const eventMap = {
        'scroll-to-top': 0,
        'scroll-to-bottom': 1,
        'scroll-to-left': 2,
        'scroll-to-right': 3,
        scrolling: 4,
        'bounce-bottom': 6,
        'bounce-left': 7,
        'bounce-right': 8,
        'bounce-top': 5,
        'scroll-ended': 9,
        'touch-up': 10,
        'scroll-ended-with-threshold': 11,
        'scroll-began': 12
      };
      let EventType$2;
      (function (EventType) {
        EventType["SCROLL_TO_TOP"] = "scroll-to-top";
        EventType["SCROLL_TO_BOTTOM"] = "scroll-to-bottom";
        EventType["SCROLL_TO_LEFT"] = "scroll-to-left";
        EventType["SCROLL_TO_RIGHT"] = "scroll-to-right";
        EventType["SCROLL_BEGAN"] = "scroll-began";
        EventType["SCROLL_ENDED"] = "scroll-ended";
        EventType["BOUNCE_TOP"] = "bounce-top";
        EventType["BOUNCE_BOTTOM"] = "bounce-bottom";
        EventType["BOUNCE_LEFT"] = "bounce-left";
        EventType["BOUNCE_RIGHT"] = "bounce-right";
        EventType["SCROLLING"] = "scrolling";
        EventType["SCROLL_ENG_WITH_THRESHOLD"] = "scroll-ended-with-threshold";
        EventType["TOUCH_UP"] = "touch-up";
      })(EventType$2 || (EventType$2 = {}));
      var XrhoverType;
      (function (XrhoverType) {
        XrhoverType[XrhoverType["NONE"] = 0] = "NONE";
        XrhoverType[XrhoverType["LEFT"] = 1] = "LEFT";
        XrhoverType[XrhoverType["RIGHT"] = 2] = "RIGHT";
      })(XrhoverType || (XrhoverType = {}));
      let ScrollView = (_dec$b = ccclass$3('cc.ScrollView'), _dec2$9 = executionOrder(110), _dec3$9 = requireComponent(UITransform), _dec4$6 = type$2(Node$1), _dec5$6 = type$2(ScrollBar), _dec6$2 = type$2(ScrollBar), _dec7$1 = type$2([EventHandler]), _dec$b(_class$b = _dec2$9(_class$b = _dec3$9(_class$b = (_class2$8 = (_class3$5 = class ScrollView extends ViewGroup {
        constructor(...args) {
          super(...args);
          this.bounceDuration = _initializer$8 && _initializer$8();
          this.brake = _initializer2$8 && _initializer2$8();
          this.elastic = _initializer3$6 && _initializer3$6();
          this.inertia = _initializer4$5 && _initializer4$5();
          this.horizontal = _initializer5$3 && _initializer5$3();
          this.vertical = _initializer6$2 && _initializer6$2();
          this.cancelInnerEvents = _initializer7$2 && _initializer7$2();
          this.scrollEvents = _initializer8$2 && _initializer8$2();
          this._autoScrolling = false;
          this._scrolling = false;
          this._content = _initializer9$2 && _initializer9$2();
          this._horizontalScrollBar = _initializer10$2 && _initializer10$2();
          this._verticalScrollBar = _initializer11$2 && _initializer11$2();
          this._topBoundary = 0;
          this._bottomBoundary = 0;
          this._leftBoundary = 0;
          this._rightBoundary = 0;
          this._touchMoveDisplacements = [];
          this._touchMoveTimeDeltas = [];
          this._touchMovePreviousTimestamp = 0;
          this._touchMoved = false;
          this._autoScrollAttenuate = false;
          this._autoScrollStartPosition = new Vec3();
          this._autoScrollTargetDelta = new Vec3();
          this._autoScrollTotalTime = 0;
          this._autoScrollAccumulatedTime = 0;
          this._autoScrollCurrentlyOutOfBoundary = false;
          this._autoScrollBraking = false;
          this._autoScrollBrakingStartPosition = new Vec3();
          this._outOfBoundaryAmount = new Vec3();
          this._outOfBoundaryAmountDirty = true;
          this._stopMouseWheel = false;
          this._mouseWheelEventElapsedTime = 0.0;
          this._isScrollEndedWithThresholdEventFired = false;
          this._scrollEventEmitMask = 0;
          this._isBouncing = false;
          this._contentPos = new Vec3();
          this._deltaPos = new Vec3();
          this._hoverIn = XrhoverType.NONE;
        }
        get content() {
          return this._content;
        }
        set content(value) {
          if (this._content === value) {
            return;
          }
          const viewTrans = value && value.parent && value.parent._uiProps.uiTransformComp;
          if (value && (!value || !viewTrans)) {
            logID(4302);
            return;
          }
          this._content = value;
          this._calculateBoundary();
        }
        get horizontalScrollBar() {
          if (this._horizontalScrollBar && !this._horizontalScrollBar.isValid) {
            errorID(4303, 'horizontal', this.node.name);
          }
          return this._horizontalScrollBar;
        }
        set horizontalScrollBar(value) {
          if (this._horizontalScrollBar === value) {
            return;
          }
          this._horizontalScrollBar = value;
          if (this._horizontalScrollBar) {
            this._horizontalScrollBar.setScrollView(this);
            this._updateScrollBar(Vec2.ZERO);
          }
        }
        get verticalScrollBar() {
          if (this._verticalScrollBar && !this._verticalScrollBar.isValid) {
            errorID(4303, 'vertical', this.node.name);
          }
          return this._verticalScrollBar;
        }
        set verticalScrollBar(value) {
          if (this._verticalScrollBar === value) {
            return;
          }
          this._verticalScrollBar = value;
          if (this._verticalScrollBar) {
            this._verticalScrollBar.setScrollView(this);
            this._updateScrollBar(Vec2.ZERO);
          }
        }
        get view() {
          const parent = this._content && this._content.parent;
          if (!parent) {
            return null;
          }
          return parent._uiProps.uiTransformComp;
        }
        scrollToBottom(timeInSecond, attenuated = true) {
          const moveDelta = this._calculateMovePercentDelta({
            anchor: new Vec2(0, 0),
            applyToHorizontal: false,
            applyToVertical: true
          });
          if (timeInSecond) {
            this._startAutoScroll(moveDelta, timeInSecond, attenuated !== false);
          } else {
            this._moveContent(moveDelta, true);
          }
        }
        scrollToTop(timeInSecond, attenuated = true) {
          const moveDelta = this._calculateMovePercentDelta({
            anchor: new Vec2(0, 1),
            applyToHorizontal: false,
            applyToVertical: true
          });
          if (timeInSecond) {
            this._startAutoScroll(moveDelta, timeInSecond, attenuated !== false);
          } else {
            this._moveContent(moveDelta);
          }
        }
        scrollToLeft(timeInSecond, attenuated = true) {
          const moveDelta = this._calculateMovePercentDelta({
            anchor: new Vec2(0, 0),
            applyToHorizontal: true,
            applyToVertical: false
          });
          if (timeInSecond) {
            this._startAutoScroll(moveDelta, timeInSecond, attenuated !== false);
          } else {
            this._moveContent(moveDelta);
          }
        }
        scrollToRight(timeInSecond, attenuated = true) {
          const moveDelta = this._calculateMovePercentDelta({
            anchor: new Vec2(1, 0),
            applyToHorizontal: true,
            applyToVertical: false
          });
          if (timeInSecond) {
            this._startAutoScroll(moveDelta, timeInSecond, attenuated !== false);
          } else {
            this._moveContent(moveDelta);
          }
        }
        scrollToTopLeft(timeInSecond, attenuated = true) {
          const moveDelta = this._calculateMovePercentDelta({
            anchor: new Vec2(0, 1),
            applyToHorizontal: true,
            applyToVertical: true
          });
          if (timeInSecond) {
            this._startAutoScroll(moveDelta, timeInSecond, attenuated !== false);
          } else {
            this._moveContent(moveDelta);
          }
        }
        scrollToTopRight(timeInSecond, attenuated = true) {
          const moveDelta = this._calculateMovePercentDelta({
            anchor: new Vec2(1, 1),
            applyToHorizontal: true,
            applyToVertical: true
          });
          if (timeInSecond) {
            this._startAutoScroll(moveDelta, timeInSecond, attenuated !== false);
          } else {
            this._moveContent(moveDelta);
          }
        }
        scrollToBottomLeft(timeInSecond, attenuated = true) {
          const moveDelta = this._calculateMovePercentDelta({
            anchor: new Vec2(0, 0),
            applyToHorizontal: true,
            applyToVertical: true
          });
          if (timeInSecond) {
            this._startAutoScroll(moveDelta, timeInSecond, attenuated !== false);
          } else {
            this._moveContent(moveDelta);
          }
        }
        scrollToBottomRight(timeInSecond, attenuated = true) {
          const moveDelta = this._calculateMovePercentDelta({
            anchor: new Vec2(1, 0),
            applyToHorizontal: true,
            applyToVertical: true
          });
          if (timeInSecond) {
            this._startAutoScroll(moveDelta, timeInSecond, attenuated !== false);
          } else {
            this._moveContent(moveDelta);
          }
        }
        scrollToOffset(offset, timeInSecond, attenuated = true) {
          const maxScrollOffset = this.getMaxScrollOffset();
          const anchor = new Vec2(0, 0);
          if (maxScrollOffset.x === 0) {
            anchor.x = 0;
          } else {
            anchor.x = offset.x / maxScrollOffset.x;
          }
          if (maxScrollOffset.y === 0) {
            anchor.y = 1;
          } else {
            anchor.y = (maxScrollOffset.y - offset.y) / maxScrollOffset.y;
          }
          this.scrollTo(anchor, timeInSecond, attenuated);
        }
        getScrollOffset() {
          const topDelta = this._getContentTopBoundary() - this._topBoundary;
          const leftDelta = this._getContentLeftBoundary() - this._leftBoundary;
          return new Vec2(leftDelta, topDelta);
        }
        getMaxScrollOffset() {
          if (!this._content || !this.view) {
            return Vec2.ZERO;
          }
          const contentSize = this._content._uiProps.uiTransformComp.contentSize;
          let horizontalMaximizeOffset = contentSize.width - this.view.width;
          let verticalMaximizeOffset = contentSize.height - this.view.height;
          horizontalMaximizeOffset = horizontalMaximizeOffset >= 0 ? horizontalMaximizeOffset : 0;
          verticalMaximizeOffset = verticalMaximizeOffset >= 0 ? verticalMaximizeOffset : 0;
          return new Vec2(horizontalMaximizeOffset, verticalMaximizeOffset);
        }
        scrollToPercentHorizontal(percent, timeInSecond, attenuated) {
          const moveDelta = this._calculateMovePercentDelta({
            anchor: new Vec2(percent, 0),
            applyToHorizontal: true,
            applyToVertical: false
          });
          if (timeInSecond) {
            this._startAutoScroll(moveDelta, timeInSecond, attenuated !== false);
          } else {
            this._moveContent(moveDelta);
          }
        }
        scrollTo(anchor, timeInSecond, attenuated) {
          const moveDelta = this._calculateMovePercentDelta({
            anchor: new Vec2(anchor),
            applyToHorizontal: true,
            applyToVertical: true
          });
          if (timeInSecond) {
            this._startAutoScroll(moveDelta, timeInSecond, attenuated);
          } else {
            this._moveContent(moveDelta);
          }
        }
        scrollToPercentVertical(percent, timeInSecond, attenuated) {
          const moveDelta = this._calculateMovePercentDelta({
            anchor: new Vec2(0, percent),
            applyToHorizontal: false,
            applyToVertical: true
          });
          if (timeInSecond) {
            this._startAutoScroll(moveDelta, timeInSecond, attenuated);
          } else {
            this._moveContent(moveDelta);
          }
        }
        stopAutoScroll() {
          this._autoScrolling = false;
          this._autoScrollAccumulatedTime = this._autoScrollTotalTime;
        }
        setContentPosition(position) {
          this._setContentPosition(position);
        }
        _setContentPosition(position) {
          if (!this._content) {
            return;
          }
          const contentPos = this._getContentPosition();
          if (Math.abs(position.x - contentPos.x) < EPSILON && Math.abs(position.y - contentPos.y) < EPSILON) {
            return;
          }
          this._content.setPosition(position);
          this._outOfBoundaryAmountDirty = true;
        }
        getContentPosition() {
          return this._getContentPosition();
        }
        _getContentPosition() {
          if (!this._content) {
            return Vec3.ZERO.clone();
          }
          this._contentPos.set(this._content.position);
          return this._contentPos;
        }
        isScrolling() {
          return this._scrolling;
        }
        isAutoScrolling() {
          return this._autoScrolling;
        }
        getScrollEndedEventTiming() {
          return EPSILON;
        }
        start() {
          this._calculateBoundary();
          if (this._content) {
            director.once(Director.EVENT_BEFORE_DRAW, this._adjustContentOutOfBoundary, this);
          }
        }
        onEnable() {
          {
            this._registerEvent();
            if (this._content) {
              this._content.on(NodeEventType.SIZE_CHANGED, this._calculateBoundary, this);
              this._content.on(NodeEventType.TRANSFORM_CHANGED, this._scaleChanged, this);
              if (this.view) {
                this.view.node.on(NodeEventType.TRANSFORM_CHANGED, this._scaleChanged, this);
                this.view.node.on(NodeEventType.SIZE_CHANGED, this._calculateBoundary, this);
              }
            }
            this._calculateBoundary();
          }
          this._updateScrollBarState();
        }
        update(dt) {
          if (this._autoScrolling) {
            this._processAutoScrolling(dt);
          }
        }
        onDisable() {
          {
            this._unregisterEvent();
            if (this._content) {
              this._content.off(NodeEventType.SIZE_CHANGED, this._calculateBoundary, this);
              this._content.off(NodeEventType.TRANSFORM_CHANGED, this._scaleChanged, this);
              if (this.view) {
                this.view.node.off(NodeEventType.TRANSFORM_CHANGED, this._scaleChanged, this);
                this.view.node.off(NodeEventType.SIZE_CHANGED, this._calculateBoundary, this);
              }
            }
          }
          this._hideScrollBar();
          this.stopAutoScroll();
        }
        _registerEvent() {
          this.node.on(NodeEventType.TOUCH_START, this._onTouchBegan, this, true);
          this.node.on(NodeEventType.TOUCH_MOVE, this._onTouchMoved, this, true);
          this.node.on(NodeEventType.TOUCH_END, this._onTouchEnded, this, true);
          this.node.on(NodeEventType.TOUCH_CANCEL, this._onTouchCancelled, this, true);
          this.node.on(NodeEventType.MOUSE_WHEEL, this._onMouseWheel, this, true);
          this.node.on(XrUIPressEventType.XRUI_HOVER_ENTERED, this._xrHoverEnter, this);
          this.node.on(XrUIPressEventType.XRUI_HOVER_EXITED, this._xrHoverExit, this);
          input.on(Input.EventType.HANDLE_INPUT, this._dispatchEventHandleInput, this);
          input.on(Input.EventType.GAMEPAD_INPUT, this._dispatchEventHandleInput, this);
        }
        _unregisterEvent() {
          this.node.off(NodeEventType.TOUCH_START, this._onTouchBegan, this, true);
          this.node.off(NodeEventType.TOUCH_MOVE, this._onTouchMoved, this, true);
          this.node.off(NodeEventType.TOUCH_END, this._onTouchEnded, this, true);
          this.node.off(NodeEventType.TOUCH_CANCEL, this._onTouchCancelled, this, true);
          this.node.off(NodeEventType.MOUSE_WHEEL, this._onMouseWheel, this, true);
          this.node.off(XrUIPressEventType.XRUI_HOVER_ENTERED, this._xrHoverEnter, this);
          this.node.off(XrUIPressEventType.XRUI_HOVER_EXITED, this._xrHoverExit, this);
          input.off(Input.EventType.HANDLE_INPUT, this._dispatchEventHandleInput, this);
          input.off(Input.EventType.GAMEPAD_INPUT, this._dispatchEventHandleInput, this);
        }
        _onMouseWheel(event, captureListeners) {
          if (!this.enabledInHierarchy) {
            return;
          }
          if (this._hasNestedViewGroup(event, captureListeners)) {
            return;
          }
          const deltaMove = new Vec3();
          const wheelPrecision = -0.1;
          const scrollY = event.getScrollY();
          if (this.vertical) {
            deltaMove.set(0, scrollY * wheelPrecision, 0);
          } else if (this.horizontal) {
            deltaMove.set(scrollY * wheelPrecision, 0, 0);
          }
          this._mouseWheelEventElapsedTime = 0;
          this._processDeltaMove(deltaMove);
          if (!this._stopMouseWheel) {
            this._handlePressLogic();
            this.schedule(this._checkMouseWheel, 1.0 / 60);
            this._stopMouseWheel = true;
          }
          this._stopPropagationIfTargetIsMe(event);
        }
        _onTouchBegan(event, captureListeners) {
          if (!this.enabledInHierarchy || !this._content) {
            return;
          }
          if (this._hasNestedViewGroup(event, captureListeners)) {
            return;
          }
          this._handlePressLogic();
          this._touchMoved = false;
          this._stopPropagationIfTargetIsMe(event);
        }
        _onTouchMoved(event, captureListeners) {
          if (!this.enabledInHierarchy || !this._content) {
            return;
          }
          if (this._hasNestedViewGroup(event, captureListeners)) {
            return;
          }
          const touch = event.touch;
          this._handleMoveLogic(touch);
          if (!this.cancelInnerEvents) {
            return;
          }
          const deltaMove = touch.getUILocation(_tempVec2$1);
          deltaMove.subtract(touch.getUIStartLocation(_tempVec2_1$1));
          if (deltaMove.length() > 7) {
            if (!this._touchMoved && event.target !== this.node) {
              const cancelEvent = new EventTouch(event.getTouches(), event.bubbles, SystemEventType.TOUCH_CANCEL);
              cancelEvent.touch = event.touch;
              cancelEvent.simulate = true;
              event.target.dispatchEvent(cancelEvent);
              this._touchMoved = true;
            }
          }
          this._stopPropagationIfTargetIsMe(event);
        }
        _onTouchEnded(event, captureListeners) {
          if (!this.enabledInHierarchy || !this._content || !event) {
            return;
          }
          if (this._hasNestedViewGroup(event, captureListeners)) {
            return;
          }
          this._dispatchEvent(EventType$2.TOUCH_UP);
          const touch = event.touch;
          this._handleReleaseLogic(touch);
          if (this._touchMoved) {
            event.propagationStopped = true;
          } else {
            this._stopPropagationIfTargetIsMe(event);
          }
        }
        _onTouchCancelled(event, captureListeners) {
          if (!this.enabledInHierarchy || !this._content) {
            return;
          }
          if (this._hasNestedViewGroup(event, captureListeners)) {
            return;
          }
          if (event && !event.simulate) {
            const touch = event.touch;
            this._handleReleaseLogic(touch);
          }
          this._stopPropagationIfTargetIsMe(event);
        }
        _calculateBoundary() {
          if (this._content && this.view) {
            const layout = this._content.getComponent(Layout);
            if (layout && layout.enabledInHierarchy) {
              layout.updateLayout();
            }
            const viewTrans = this.view;
            const anchorX = viewTrans.width * viewTrans.anchorX;
            const anchorY = viewTrans.height * viewTrans.anchorY;
            this._leftBoundary = -anchorX;
            this._bottomBoundary = -anchorY;
            this._rightBoundary = this._leftBoundary + viewTrans.width;
            this._topBoundary = this._bottomBoundary + viewTrans.height;
            this._moveContentToTopLeft(viewTrans.contentSize);
          }
        }
        _hasNestedViewGroup(event, captureListeners) {
          if (!event || event.eventPhase !== Event.CAPTURING_PHASE) {
            return false;
          }
          if (captureListeners) {
            for (const listener of captureListeners) {
              const item = listener;
              if (this.node === item) {
                if (event.target && event.target.getComponent(ViewGroup)) {
                  return true;
                }
                return false;
              }
              if (item.getComponent(ViewGroup)) {
                return true;
              }
            }
          }
          return false;
        }
        _startInertiaScroll(touchMoveVelocity) {
          const inertiaTotalMovement = new Vec3(touchMoveVelocity);
          inertiaTotalMovement.multiplyScalar(MOVEMENT_FACTOR);
          this._startAttenuatingAutoScroll(inertiaTotalMovement, touchMoveVelocity);
        }
        _calculateAttenuatedFactor(distance) {
          if (this.brake <= 0) {
            return 1 - this.brake;
          }
          return (1 - this.brake) * (1 / (1 + distance * 0.000014 + distance * distance * 0.000000008));
        }
        _startAttenuatingAutoScroll(deltaMove, initialVelocity) {
          const targetDelta = deltaMove.clone();
          targetDelta.normalize();
          if (this._content && this.view) {
            const contentSize = this._content._uiProps.uiTransformComp.contentSize;
            const scrollViewSize = this.view.contentSize;
            const totalMoveWidth = contentSize.width - scrollViewSize.width;
            const totalMoveHeight = contentSize.height - scrollViewSize.height;
            const attenuatedFactorX = this._calculateAttenuatedFactor(totalMoveWidth);
            const attenuatedFactorY = this._calculateAttenuatedFactor(totalMoveHeight);
            targetDelta.x = targetDelta.x * totalMoveWidth * (1 - this.brake) * attenuatedFactorX;
            targetDelta.y = targetDelta.y * totalMoveHeight * attenuatedFactorY * (1 - this.brake);
            targetDelta.z = 0;
          }
          const originalMoveLength = deltaMove.length();
          let factor = targetDelta.length() / originalMoveLength;
          targetDelta.add(deltaMove);
          if (this.brake > 0 && factor > 7) {
            factor = Math.sqrt(factor);
            const clonedDeltaMove = deltaMove.clone();
            clonedDeltaMove.multiplyScalar(factor);
            targetDelta.set(clonedDeltaMove);
            targetDelta.add(deltaMove);
          }
          let time = this._calculateAutoScrollTimeByInitialSpeed(initialVelocity.length());
          if (this.brake > 0 && factor > 3) {
            factor = 3;
            time *= factor;
          }
          if (this.brake === 0 && factor > 1) {
            time *= factor;
          }
          this._startAutoScroll(targetDelta, time, true);
        }
        _calculateAutoScrollTimeByInitialSpeed(initialSpeed) {
          return Math.sqrt(Math.sqrt(initialSpeed / 5));
        }
        _startAutoScroll(deltaMove, timeInSecond, attenuated = false) {
          const adjustedDeltaMove = this._flattenVectorByDirection(deltaMove);
          this._autoScrolling = true;
          this._autoScrollTargetDelta = adjustedDeltaMove;
          this._autoScrollAttenuate = attenuated;
          Vec3.copy(this._autoScrollStartPosition, this._getContentPosition());
          this._autoScrollTotalTime = timeInSecond;
          this._autoScrollAccumulatedTime = 0;
          this._autoScrollBraking = false;
          this._isScrollEndedWithThresholdEventFired = false;
          this._autoScrollBrakingStartPosition.set(0, 0, 0);
          const currentOutOfBoundary = this._getHowMuchOutOfBoundary();
          if (!currentOutOfBoundary.equals(Vec3.ZERO, EPSILON)) {
            this._autoScrollCurrentlyOutOfBoundary = true;
          }
        }
        _calculateTouchMoveVelocity() {
          const out = new Vec3();
          let totalTime = 0;
          totalTime = this._touchMoveTimeDeltas.reduce((a, b) => a + b, totalTime);
          if (totalTime <= 0 || totalTime >= 0.5) {
            out.set(Vec3.ZERO);
          } else {
            let totalMovement = new Vec3();
            totalMovement = this._touchMoveDisplacements.reduce((a, b) => {
              a.add(b);
              return a;
            }, totalMovement);
            out.set(totalMovement.x * (1 - this.brake) / totalTime, totalMovement.y * (1 - this.brake) / totalTime, totalMovement.z);
          }
          return out;
        }
        _flattenVectorByDirection(vector) {
          const result = vector;
          result.x = this.horizontal ? result.x : 0;
          result.y = this.vertical ? result.y : 0;
          return result;
        }
        _moveContent(deltaMove, canStartBounceBack) {
          const adjustedMove = this._flattenVectorByDirection(deltaMove);
          _tempVec3.set(this._getContentPosition());
          _tempVec3.add(adjustedMove);
          _tempVec3.set(Math.round(_tempVec3.x * TOLERANCE) * EPSILON, Math.round(_tempVec3.y * TOLERANCE) * EPSILON, _tempVec3.z);
          this._setContentPosition(_tempVec3);
          const outOfBoundary = this._getHowMuchOutOfBoundary();
          _tempVec2$1.set(outOfBoundary.x, outOfBoundary.y);
          this._updateScrollBar(_tempVec2$1);
          if (this.elastic && canStartBounceBack) {
            this._startBounceBackIfNeeded();
          }
        }
        _getContentLeftBoundary() {
          if (!this._content) {
            return -1;
          }
          const contentPos = this._getContentPosition();
          const uiTrans = this._content._uiProps.uiTransformComp;
          return contentPos.x - uiTrans.anchorX * uiTrans.width;
        }
        _getContentRightBoundary() {
          if (!this._content) {
            return -1;
          }
          const uiTrans = this._content._uiProps.uiTransformComp;
          return this._getContentLeftBoundary() + uiTrans.width;
        }
        _getContentTopBoundary() {
          if (!this._content) {
            return -1;
          }
          const uiTrans = this._content._uiProps.uiTransformComp;
          return this._getContentBottomBoundary() + uiTrans.height;
        }
        _getContentBottomBoundary() {
          if (!this._content) {
            return -1;
          }
          const contentPos = this._getContentPosition();
          const uiTrans = this._content._uiProps.uiTransformComp;
          return contentPos.y - uiTrans.anchorY * uiTrans.height;
        }
        _getHowMuchOutOfBoundary(addition) {
          addition = addition || new Vec3();
          if (addition.equals(Vec3.ZERO, EPSILON) && !this._outOfBoundaryAmountDirty) {
            return this._outOfBoundaryAmount;
          }
          const outOfBoundaryAmount = new Vec3();
          const tempLeftBoundary = this._getContentLeftBoundary();
          const tempRightBoundary = this._getContentRightBoundary();
          if (tempLeftBoundary + addition.x > this._leftBoundary) {
            outOfBoundaryAmount.x = this._leftBoundary - (tempLeftBoundary + addition.x);
          } else if (tempRightBoundary + addition.x < this._rightBoundary) {
            outOfBoundaryAmount.x = this._rightBoundary - (tempRightBoundary + addition.x);
          }
          const tempTopBoundary = this._getContentTopBoundary();
          const tempBottomBoundary = this._getContentBottomBoundary();
          if (tempTopBoundary + addition.y < this._topBoundary) {
            outOfBoundaryAmount.y = this._topBoundary - (tempTopBoundary + addition.y);
          } else if (tempBottomBoundary + addition.y > this._bottomBoundary) {
            outOfBoundaryAmount.y = this._bottomBoundary - (tempBottomBoundary + addition.y);
          }
          if (addition.equals(Vec3.ZERO, EPSILON)) {
            this._outOfBoundaryAmount = outOfBoundaryAmount;
            this._outOfBoundaryAmountDirty = false;
          }
          this._clampDelta(outOfBoundaryAmount);
          return outOfBoundaryAmount;
        }
        _updateScrollBar(outOfBoundary) {
          if (this._horizontalScrollBar && this._horizontalScrollBar.isValid) {
            this._horizontalScrollBar.onScroll(outOfBoundary);
          }
          if (this._verticalScrollBar && this._verticalScrollBar.isValid) {
            this._verticalScrollBar.onScroll(outOfBoundary);
          }
        }
        _onScrollBarTouchBegan() {
          if (this._horizontalScrollBar && this._horizontalScrollBar.isValid) {
            this._horizontalScrollBar.onTouchBegan();
          }
          if (this._verticalScrollBar && this._verticalScrollBar.isValid) {
            this._verticalScrollBar.onTouchBegan();
          }
        }
        _onScrollBarTouchEnded() {
          if (this._horizontalScrollBar && this._horizontalScrollBar.isValid) {
            this._horizontalScrollBar.onTouchEnded();
          }
          if (this._verticalScrollBar && this._verticalScrollBar.isValid) {
            this._verticalScrollBar.onTouchEnded();
          }
        }
        _dispatchEvent(event) {
          if (event === EventType$2.SCROLL_ENDED) {
            this._scrollEventEmitMask = 0;
          } else if (event === EventType$2.SCROLL_TO_TOP || event === EventType$2.SCROLL_TO_BOTTOM || event === EventType$2.SCROLL_TO_LEFT || event === EventType$2.SCROLL_TO_RIGHT) {
            const flag = 1 << eventMap[event];
            if (this._scrollEventEmitMask & flag) {
              return;
            } else {
              this._scrollEventEmitMask |= flag;
            }
          }
          EventHandler.emitEvents(this.scrollEvents, this, eventMap[event]);
          this.node.emit(event, this);
        }
        _adjustContentOutOfBoundary() {
          if (!this._content) {
            return;
          }
          this._outOfBoundaryAmountDirty = true;
          const outOfBoundary = this._getHowMuchOutOfBoundary();
          const _isOutOfBoundary = !outOfBoundary.equals(Vec3.ZERO, EPSILON);
          if (_isOutOfBoundary) {
            _tempVec3.set(this._getContentPosition());
            _tempVec3.add(outOfBoundary);
            this._setContentPosition(_tempVec3);
            this._updateScrollBar(Vec2.ZERO);
          }
        }
        _hideScrollBar() {
          if (this._horizontalScrollBar && this._horizontalScrollBar.isValid) {
            this._horizontalScrollBar.hide();
          }
          if (this._verticalScrollBar && this._verticalScrollBar.isValid) {
            this._verticalScrollBar.hide();
          }
        }
        _updateScrollBarState() {
          if (!this._content || !this.view) {
            return;
          }
          const viewTrans = this.view;
          const uiTrans = this._content._uiProps.uiTransformComp;
          if (this._verticalScrollBar && this._verticalScrollBar.isValid) {
            if (uiTrans.height < viewTrans.height || approx(uiTrans.height, viewTrans.height)) {
              this._verticalScrollBar.hide();
            } else {
              this._verticalScrollBar.show();
            }
          }
          if (this._horizontalScrollBar && this._horizontalScrollBar.isValid) {
            if (uiTrans.width < viewTrans.width || approx(uiTrans.width, viewTrans.width)) {
              this._horizontalScrollBar.hide();
            } else {
              this._horizontalScrollBar.show();
            }
          }
        }
        _stopPropagationIfTargetIsMe(event) {
          if (event.eventPhase === Event.AT_TARGET && event.target === this.node) {
            event.propagationStopped = true;
          }
        }
        _processDeltaMove(deltaMove) {
          this._scrollChildren(deltaMove);
          this._gatherTouchMove(deltaMove);
        }
        _handleMoveLogic(touch) {
          this._getLocalAxisAlignDelta(this._deltaPos, touch);
          this._processDeltaMove(this._deltaPos);
        }
        _handleReleaseLogic(touch) {
          this._getLocalAxisAlignDelta(this._deltaPos, touch);
          this._gatherTouchMove(this._deltaPos);
          this._processInertiaScroll();
          if (this._scrolling) {
            this._scrolling = false;
            if (!this._autoScrolling) {
              this._dispatchEvent(EventType$2.SCROLL_ENDED);
            }
          }
        }
        _getLocalAxisAlignDelta(out, touch) {
          const uiTransformComp = this.node._uiProps.uiTransformComp;
          const vec = new Vec3();
          if (uiTransformComp) {
            touch.getUILocation(_tempVec2$1);
            touch.getUIPreviousLocation(_tempVec2_1$1);
            _tempVec3.set(_tempVec2$1.x, _tempVec2$1.y, 0);
            _tempVec3_1.set(_tempVec2_1$1.x, _tempVec2_1$1.y, 0);
            uiTransformComp.convertToNodeSpaceAR(_tempVec3, _tempVec3);
            uiTransformComp.convertToNodeSpaceAR(_tempVec3_1, _tempVec3_1);
            Vec3.subtract(vec, _tempVec3, _tempVec3_1);
          }
          out.set(vec);
        }
        _scrollChildren(deltaMove) {
          this._clampDelta(deltaMove);
          const realMove = deltaMove;
          let outOfBoundary;
          if (this.elastic) {
            outOfBoundary = this._getHowMuchOutOfBoundary();
            realMove.x *= outOfBoundary.x === 0 ? 1 : 0.5;
            realMove.y *= outOfBoundary.y === 0 ? 1 : 0.5;
          }
          if (!this.elastic) {
            outOfBoundary = this._getHowMuchOutOfBoundary(realMove);
            realMove.add(outOfBoundary);
          }
          let verticalScrollEventType = '';
          let horizontalScrollEventType = '';
          if (this._content) {
            const {
              anchorX,
              anchorY,
              width,
              height
            } = this._content._uiProps.uiTransformComp;
            const pos = this._content.position || Vec3.ZERO;
            if (this.vertical) {
              if (realMove.y > 0) {
                const icBottomPos = pos.y - anchorY * height;
                if (icBottomPos + realMove.y >= this._bottomBoundary) {
                  verticalScrollEventType = EventType$2.SCROLL_TO_BOTTOM;
                }
              } else if (realMove.y < 0) {
                const icTopPos = pos.y - anchorY * height + height;
                if (icTopPos + realMove.y <= this._topBoundary) {
                  verticalScrollEventType = EventType$2.SCROLL_TO_TOP;
                }
              }
            }
            if (this.horizontal) {
              if (realMove.x < 0) {
                const icRightPos = pos.x - anchorX * width + width;
                if (icRightPos + realMove.x <= this._rightBoundary) {
                  horizontalScrollEventType = EventType$2.SCROLL_TO_RIGHT;
                }
              } else if (realMove.x > 0) {
                const icLeftPos = pos.x - anchorX * width;
                if (icLeftPos + realMove.x >= this._leftBoundary) {
                  horizontalScrollEventType = EventType$2.SCROLL_TO_LEFT;
                }
              }
            }
          }
          this._moveContent(realMove, false);
          if (this.horizontal && realMove.x !== 0 || this.vertical && realMove.y !== 0) {
            if (!this._scrolling) {
              this._scrolling = true;
              this._dispatchEvent(EventType$2.SCROLL_BEGAN);
            }
            this._dispatchEvent(EventType$2.SCROLLING);
          }
          if (verticalScrollEventType !== '') {
            this._dispatchEvent(verticalScrollEventType);
          }
          if (horizontalScrollEventType !== '') {
            this._dispatchEvent(horizontalScrollEventType);
          }
        }
        _handlePressLogic() {
          if (this._autoScrolling) {
            this._dispatchEvent(EventType$2.SCROLL_ENDED);
          }
          this._autoScrolling = false;
          this._isBouncing = false;
          this._touchMovePreviousTimestamp = getTimeInMilliseconds();
          this._touchMoveDisplacements.length = 0;
          this._touchMoveTimeDeltas.length = 0;
          this._onScrollBarTouchBegan();
        }
        _clampDelta(out) {
          if (this._content && this.view) {
            const scrollViewSize = this.view.contentSize;
            const uiTrans = this._content._uiProps.uiTransformComp;
            if (uiTrans.width < scrollViewSize.width) {
              out.x = 0;
            }
            if (uiTrans.height < scrollViewSize.height) {
              out.y = 0;
            }
          }
        }
        _gatherTouchMove(delta) {
          const clampDt = delta.clone();
          this._clampDelta(clampDt);
          while (this._touchMoveDisplacements.length >= NUMBER_OF_GATHERED_TOUCHES_FOR_MOVE_SPEED) {
            this._touchMoveDisplacements.shift();
            this._touchMoveTimeDeltas.shift();
          }
          this._touchMoveDisplacements.push(clampDt);
          const timeStamp = getTimeInMilliseconds();
          this._touchMoveTimeDeltas.push((timeStamp - this._touchMovePreviousTimestamp) / 1000);
          this._touchMovePreviousTimestamp = timeStamp;
        }
        _startBounceBackIfNeeded() {
          if (!this.elastic) {
            return false;
          }
          const bounceBackAmount = this._getHowMuchOutOfBoundary();
          this._clampDelta(bounceBackAmount);
          if (bounceBackAmount.equals(Vec3.ZERO, EPSILON)) {
            return false;
          }
          const bounceBackTime = Math.max(this.bounceDuration, 0);
          this._startAutoScroll(bounceBackAmount, bounceBackTime, true);
          if (!this._isBouncing) {
            if (bounceBackAmount.y > 0) {
              this._dispatchEvent(EventType$2.BOUNCE_TOP);
            }
            if (bounceBackAmount.y < 0) {
              this._dispatchEvent(EventType$2.BOUNCE_BOTTOM);
            }
            if (bounceBackAmount.x > 0) {
              this._dispatchEvent(EventType$2.BOUNCE_RIGHT);
            }
            if (bounceBackAmount.x < 0) {
              this._dispatchEvent(EventType$2.BOUNCE_LEFT);
            }
            this._isBouncing = true;
          }
          return true;
        }
        _processInertiaScroll() {
          const bounceBackStarted = this._startBounceBackIfNeeded();
          if (!bounceBackStarted && this.inertia) {
            const touchMoveVelocity = this._calculateTouchMoveVelocity();
            if (!touchMoveVelocity.equals(_tempVec3, EPSILON) && this.brake < 1) {
              this._startInertiaScroll(touchMoveVelocity);
            }
          }
          this._onScrollBarTouchEnded();
        }
        _isOutOfBoundary() {
          const outOfBoundary = this._getHowMuchOutOfBoundary();
          return !outOfBoundary.equals(Vec3.ZERO, EPSILON);
        }
        _isNecessaryAutoScrollBrake() {
          if (this._autoScrollBraking) {
            return true;
          }
          if (this._isOutOfBoundary()) {
            if (!this._autoScrollCurrentlyOutOfBoundary) {
              this._autoScrollCurrentlyOutOfBoundary = true;
              this._autoScrollBraking = true;
              Vec3.copy(this._autoScrollBrakingStartPosition, this._getContentPosition());
              return true;
            }
          } else {
            this._autoScrollCurrentlyOutOfBoundary = false;
          }
          return false;
        }
        _processAutoScrolling(dt) {
          const isAutoScrollBrake = this._isNecessaryAutoScrollBrake();
          const brakingFactor = isAutoScrollBrake ? OUT_OF_BOUNDARY_BREAKING_FACTOR : 1;
          this._autoScrollAccumulatedTime += dt * (1 / brakingFactor);
          let percentage = Math.min(1, this._autoScrollAccumulatedTime / this._autoScrollTotalTime);
          if (this._autoScrollAttenuate) {
            percentage = quintEaseOut(percentage);
          }
          const clonedAutoScrollTargetDelta = this._autoScrollTargetDelta.clone();
          clonedAutoScrollTargetDelta.multiplyScalar(percentage);
          const clonedAutoScrollStartPosition = this._autoScrollStartPosition.clone();
          clonedAutoScrollStartPosition.add(clonedAutoScrollTargetDelta);
          let reachedEnd = Math.abs(percentage - 1) <= EPSILON;
          const fireEvent = Math.abs(percentage - 1) <= this.getScrollEndedEventTiming();
          if (fireEvent && !this._isScrollEndedWithThresholdEventFired) {
            this._dispatchEvent(EventType$2.SCROLL_ENG_WITH_THRESHOLD);
            this._isScrollEndedWithThresholdEventFired = true;
          }
          if (this.elastic) {
            const brakeOffsetPosition = clonedAutoScrollStartPosition.clone();
            brakeOffsetPosition.subtract(this._autoScrollBrakingStartPosition);
            if (isAutoScrollBrake) {
              brakeOffsetPosition.multiplyScalar(brakingFactor);
            }
            clonedAutoScrollStartPosition.set(this._autoScrollBrakingStartPosition);
            clonedAutoScrollStartPosition.add(brakeOffsetPosition);
          } else {
            const moveDelta = clonedAutoScrollStartPosition.clone();
            moveDelta.subtract(this.getContentPosition());
            const outOfBoundary = this._getHowMuchOutOfBoundary(moveDelta);
            if (!outOfBoundary.equals(Vec3.ZERO, EPSILON)) {
              clonedAutoScrollStartPosition.add(outOfBoundary);
              reachedEnd = true;
            }
          }
          if (reachedEnd) {
            this._autoScrolling = false;
          }
          const deltaMove = clonedAutoScrollStartPosition.clone();
          deltaMove.subtract(this._getContentPosition());
          this._clampDelta(deltaMove);
          this._moveContent(deltaMove, reachedEnd);
          this._dispatchEvent(EventType$2.SCROLLING);
          if (!this._autoScrolling) {
            this._isBouncing = false;
            this._scrolling = false;
            this._dispatchEvent(EventType$2.SCROLL_ENDED);
          }
        }
        _checkMouseWheel(dt) {
          const currentOutOfBoundary = this._getHowMuchOutOfBoundary();
          const maxElapsedTime = 0.1;
          if (!currentOutOfBoundary.equals(Vec3.ZERO, EPSILON)) {
            this._processInertiaScroll();
            if (this._scrolling) {
              this._scrolling = false;
              if (!this._autoScrolling) {
                this._dispatchEvent(EventType$2.SCROLL_ENDED);
              }
            }
            this.unschedule(this._checkMouseWheel);
            this._stopMouseWheel = false;
            return;
          }
          this._mouseWheelEventElapsedTime += dt;
          if (this._mouseWheelEventElapsedTime > maxElapsedTime) {
            this._onScrollBarTouchEnded();
            if (this._scrolling) {
              this._scrolling = false;
              if (!this._autoScrolling) {
                this._dispatchEvent(EventType$2.SCROLL_ENDED);
              }
            }
            this.unschedule(this._checkMouseWheel);
            this._stopMouseWheel = false;
          }
        }
        _calculateMovePercentDelta(options) {
          const anchor = options.anchor;
          const applyToHorizontal = options.applyToHorizontal;
          const applyToVertical = options.applyToVertical;
          this._calculateBoundary();
          anchor.clampf(Vec2.ZERO, Vec2.ONE);
          let bottomDelta = this._getContentBottomBoundary() - this._bottomBoundary;
          bottomDelta = -bottomDelta;
          let leftDelta = this._getContentLeftBoundary() - this._leftBoundary;
          leftDelta = -leftDelta;
          const moveDelta = new Vec3();
          if (this._content && this.view) {
            let totalScrollDelta = 0;
            const uiTrans = this._content._uiProps.uiTransformComp;
            const contentSize = uiTrans.contentSize;
            const scrollSize = this.view.contentSize;
            if (applyToHorizontal) {
              totalScrollDelta = contentSize.width - scrollSize.width;
              moveDelta.x = leftDelta - totalScrollDelta * anchor.x;
            }
            if (applyToVertical) {
              totalScrollDelta = contentSize.height - scrollSize.height;
              moveDelta.y = bottomDelta - totalScrollDelta * anchor.y;
            }
          }
          return moveDelta;
        }
        _moveContentToTopLeft(scrollViewSize) {
          let bottomDelta = this._getContentBottomBoundary() - this._bottomBoundary;
          bottomDelta = -bottomDelta;
          const moveDelta = new Vec3();
          let totalScrollDelta = 0;
          let leftDelta = this._getContentLeftBoundary() - this._leftBoundary;
          leftDelta = -leftDelta;
          if (this._content) {
            const uiTrans = this._content._uiProps.uiTransformComp;
            const contentSize = uiTrans.contentSize;
            if (contentSize.height < scrollViewSize.height) {
              totalScrollDelta = contentSize.height - scrollViewSize.height;
              moveDelta.y = bottomDelta - totalScrollDelta;
            }
            if (contentSize.width < scrollViewSize.width) {
              totalScrollDelta = contentSize.width - scrollViewSize.width;
              moveDelta.x = leftDelta;
            }
          }
          this._updateScrollBarState();
          this._moveContent(moveDelta);
          this._adjustContentOutOfBoundary();
        }
        _scaleChanged(value) {
          if (value === TransformBit.SCALE) {
            this._calculateBoundary();
          }
        }
        _xrHoverEnter(event) {
          if (event.deviceType === DeviceType.Left) {
            this._hoverIn = XrhoverType.LEFT;
          } else if (event.deviceType === DeviceType.Right) {
            this._hoverIn = XrhoverType.RIGHT;
          }
        }
        _xrHoverExit(event) {
          this._hoverIn = XrhoverType.NONE;
        }
        _dispatchEventHandleInput(event) {
          let handleInputDevice;
          if (event instanceof EventGamepad) {
            handleInputDevice = event.gamepad;
          } else if (event instanceof EventHandle) {
            handleInputDevice = event.handleInputDevice;
          }
          let value;
          if (!this.enabledInHierarchy || this._hoverIn === XrhoverType.NONE) {
            return;
          }
          if (this._hoverIn === XrhoverType.LEFT) {
            value = handleInputDevice.leftStick.getValue();
            if (!value.equals(Vec2.ZERO)) {
              this._xrThumbStickMove(value);
            }
          } else if (this._hoverIn === XrhoverType.RIGHT) {
            value = handleInputDevice.rightStick.getValue();
            if (!value.equals(Vec2.ZERO)) {
              this._xrThumbStickMove(value);
            }
          }
        }
        _xrThumbStickMove(event) {
          if (!this.enabledInHierarchy) {
            return;
          }
          const deltaMove = new Vec3();
          const wheelPrecision = -62.5;
          const scrollY = event.y;
          if (this.vertical) {
            deltaMove.set(0, scrollY * wheelPrecision, 0);
          } else if (this.horizontal) {
            deltaMove.set(scrollY * wheelPrecision, 0, 0);
          }
          this._mouseWheelEventElapsedTime = 0;
          this._processDeltaMove(deltaMove);
          if (!this._stopMouseWheel) {
            this._handlePressLogic();
            this.schedule(this._checkMouseWheel, 1.0 / 60, NaN, 0);
            this._stopMouseWheel = true;
          }
        }
      }, _class3$5.EventType = EventType$2, _class3$5), (_initializer$8 = applyDecoratedInitializer(_class2$8.prototype, "bounceDuration", [serializable$3], function () {
        return 1;
      }), _initializer2$8 = applyDecoratedInitializer(_class2$8.prototype, "brake", [serializable$3], function () {
        return 0.5;
      }), _initializer3$6 = applyDecoratedInitializer(_class2$8.prototype, "elastic", [serializable$3], function () {
        return true;
      }), _initializer4$5 = applyDecoratedInitializer(_class2$8.prototype, "inertia", [serializable$3], function () {
        return true;
      }), _applyDecoratedDescriptor(_class2$8.prototype, "content", [_dec4$6], Object.getOwnPropertyDescriptor(_class2$8.prototype, "content"), _class2$8.prototype), _initializer5$3 = applyDecoratedInitializer(_class2$8.prototype, "horizontal", [serializable$3], function () {
        return true;
      }), _applyDecoratedDescriptor(_class2$8.prototype, "horizontalScrollBar", [_dec5$6], Object.getOwnPropertyDescriptor(_class2$8.prototype, "horizontalScrollBar"), _class2$8.prototype), _initializer6$2 = applyDecoratedInitializer(_class2$8.prototype, "vertical", [serializable$3], function () {
        return true;
      }), _applyDecoratedDescriptor(_class2$8.prototype, "verticalScrollBar", [_dec6$2], Object.getOwnPropertyDescriptor(_class2$8.prototype, "verticalScrollBar"), _class2$8.prototype), _initializer7$2 = applyDecoratedInitializer(_class2$8.prototype, "cancelInnerEvents", [serializable$3], function () {
        return true;
      }), _initializer8$2 = applyDecoratedInitializer(_class2$8.prototype, "scrollEvents", [_dec7$1, serializable$3], function () {
        return [];
      }), _initializer9$2 = applyDecoratedInitializer(_class2$8.prototype, "_content", [serializable$3], function () {
        return null;
      }), _initializer10$2 = applyDecoratedInitializer(_class2$8.prototype, "_horizontalScrollBar", [serializable$3], function () {
        return null;
      }), _initializer11$2 = applyDecoratedInitializer(_class2$8.prototype, "_verticalScrollBar", [serializable$3], function () {
        return null;
      })), _class2$8)) || _class$b) || _class$b) || _class$b); exports({ ScrollView: ScrollView, ScrollViewComponent: ScrollView });
      legacyCC.ScrollView = ScrollView;

      var _dec$a, _dec2$8, _dec3$8, _dec4$5, _dec5$5, _dec6$1, _class$a, _class2$7, _initializer$7, _initializer2$7, _initializer3$5, _initializer4$4, _class3$4;
      const _tempPos$1 = new Vec3();
      var Direction$2;
      (function (Direction) {
        Direction[Direction["Horizontal"] = 0] = "Horizontal";
        Direction[Direction["Vertical"] = 1] = "Vertical";
      })(Direction$2 || (Direction$2 = {}));
      ccenum(Direction$2);
      let Slider = (_dec$a = ccclass$3('cc.Slider'), _dec2$8 = executionOrder(110), _dec3$8 = requireComponent(UITransform), _dec4$5 = type$2(Sprite), _dec5$5 = type$2(Direction$2), _dec6$1 = type$2([EventHandler]), _dec$a(_class$a = _dec2$8(_class$a = _dec3$8(_class$a = (_class2$7 = (_class3$4 = class Slider extends Component {
        constructor(...args) {
          super(...args);
          this.slideEvents = _initializer$7 && _initializer$7();
          this._handle = _initializer2$7 && _initializer2$7();
          this._direction = _initializer3$5 && _initializer3$5();
          this._progress = _initializer4$4 && _initializer4$4();
          this._offset = new Vec3();
          this._dragging = false;
          this._touchHandle = false;
          this._handleLocalPos = new Vec3();
          this._touchPos = new Vec3();
        }
        get handle() {
          return this._handle;
        }
        set handle(value) {
          if (this._handle === value) {
            return;
          }
          this._handle = value;
        }
        get direction() {
          return this._direction;
        }
        set direction(value) {
          if (this._direction === value) {
            return;
          }
          this._direction = value;
          this._changeLayout();
        }
        get progress() {
          return this._progress;
        }
        set progress(value) {
          if (this._progress === value) {
            return;
          }
          this._progress = value;
          this._updateHandlePosition();
        }
        __preload() {
          this._updateHandlePosition();
        }
        onEnable() {
          this._updateHandlePosition();
          this.node.on(NodeEventType.TOUCH_START, this._onTouchBegan, this);
          this.node.on(NodeEventType.TOUCH_MOVE, this._onTouchMoved, this);
          this.node.on(NodeEventType.TOUCH_END, this._onTouchEnded, this);
          this.node.on(NodeEventType.TOUCH_CANCEL, this._onTouchCancelled, this);
          this.node.on(XrUIPressEventType.XRUI_HOVER_STAY, this._xrHoverStay, this);
          this.node.on(XrUIPressEventType.XRUI_CLICK, this._xrClick, this);
          this.node.on(XrUIPressEventType.XRUI_UNCLICK, this._xrUnClick, this);
          if (this._handle && this._handle.isValid) {
            this._handle.node.on(NodeEventType.TOUCH_START, this._onHandleDragStart, this);
            this._handle.node.on(NodeEventType.TOUCH_MOVE, this._onTouchMoved, this);
            this._handle.node.on(NodeEventType.TOUCH_END, this._onTouchEnded, this);
          }
        }
        onDisable() {
          this.node.off(NodeEventType.TOUCH_START, this._onTouchBegan, this);
          this.node.off(NodeEventType.TOUCH_MOVE, this._onTouchMoved, this);
          this.node.off(NodeEventType.TOUCH_END, this._onTouchEnded, this);
          this.node.off(NodeEventType.TOUCH_CANCEL, this._onTouchCancelled, this);
          this.node.off(XrUIPressEventType.XRUI_HOVER_STAY, this._xrHoverStay, this);
          this.node.off(XrUIPressEventType.XRUI_CLICK, this._xrClick, this);
          this.node.off(XrUIPressEventType.XRUI_UNCLICK, this._xrUnClick, this);
          if (this._handle && this._handle.isValid) {
            this._handle.node.off(NodeEventType.TOUCH_START, this._onHandleDragStart, this);
            this._handle.node.off(NodeEventType.TOUCH_MOVE, this._onTouchMoved, this);
            this._handle.node.off(NodeEventType.TOUCH_END, this._onTouchEnded, this);
          }
        }
        _onHandleDragStart(event) {
          if (!event || !this._handle || !this._handle.node._uiProps.uiTransformComp) {
            return;
          }
          this._dragging = true;
          this._touchHandle = true;
          const touhPos = event.touch.getUILocation();
          Vec3.set(this._touchPos, touhPos.x, touhPos.y, 0);
          this._handle.node._uiProps.uiTransformComp.convertToNodeSpaceAR(this._touchPos, this._offset);
          event.propagationStopped = true;
        }
        _onTouchBegan(event) {
          if (!this._handle || !event) {
            return;
          }
          this._dragging = true;
          if (!this._touchHandle) {
            this._handleSliderLogic(event.touch);
          }
          event.propagationStopped = true;
        }
        _onTouchMoved(event) {
          if (!this._dragging || !event) {
            return;
          }
          this._handleSliderLogic(event.touch);
          event.propagationStopped = true;
        }
        _onTouchEnded(event) {
          this._dragging = false;
          this._touchHandle = false;
          this._offset = new Vec3();
          if (event) {
            event.propagationStopped = true;
          }
        }
        _onTouchCancelled(event) {
          this._dragging = false;
          if (event) {
            event.propagationStopped = true;
          }
        }
        _handleSliderLogic(touch) {
          this._updateProgress(touch);
          this._emitSlideEvent();
        }
        _emitSlideEvent() {
          EventHandler.emitEvents(this.slideEvents, this);
          this.node.emit('slide', this);
        }
        _updateProgress(touch) {
          if (!this._handle || !touch) {
            return;
          }
          const touchPos = touch.getUILocation();
          Vec3.set(this._touchPos, touchPos.x, touchPos.y, 0);
          const uiTrans = this.node._uiProps.uiTransformComp;
          const localTouchPos = uiTrans.convertToNodeSpaceAR(this._touchPos, _tempPos$1);
          if (this.direction === Direction$2.Horizontal) {
            this.progress = clamp01(0.5 + (localTouchPos.x - this._offset.x) / uiTrans.width);
          } else {
            this.progress = clamp01(0.5 + (localTouchPos.y - this._offset.y) / uiTrans.height);
          }
        }
        _updateHandlePosition() {
          if (!this._handle) {
            return;
          }
          this._handleLocalPos.set(this._handle.node.getPosition());
          const uiTrans = this.node._uiProps.uiTransformComp;
          if (this._direction === Direction$2.Horizontal) {
            this._handleLocalPos.x = -uiTrans.width * uiTrans.anchorX + this.progress * uiTrans.width;
          } else {
            this._handleLocalPos.y = -uiTrans.height * uiTrans.anchorY + this.progress * uiTrans.height;
          }
          this._handle.node.setPosition(this._handleLocalPos);
        }
        _changeLayout() {
          const uiTrans = this.node._uiProps.uiTransformComp;
          const contentSize = uiTrans.contentSize;
          uiTrans.setContentSize(contentSize.height, contentSize.width);
          if (this._handle) {
            const pos = this._handle.node.position;
            if (this._direction === Direction$2.Horizontal) {
              this._handle.node.setPosition(pos.x, 0, pos.z);
            } else {
              this._handle.node.setPosition(0, pos.y, pos.z);
            }
            this._updateHandlePosition();
          }
        }
        _xrHandleProgress(point) {
          if (!this._touchHandle) {
            const uiTrans = this.node._uiProps.uiTransformComp;
            uiTrans.convertToNodeSpaceAR(point, _tempPos$1);
            if (this.direction === Direction$2.Horizontal) {
              this.progress = clamp01(0.5 + (_tempPos$1.x - this.node.position.x) / uiTrans.width);
            } else {
              this.progress = clamp01(0.5 + (_tempPos$1.y - this.node.position.y) / uiTrans.height);
            }
          }
        }
        _xrClick(event) {
          if (!this._handle) {
            return;
          }
          this._dragging = true;
          this._xrHandleProgress(event.hitPoint);
          this._emitSlideEvent();
        }
        _xrUnClick() {
          this._dragging = false;
          this._touchHandle = false;
        }
        _xrHoverStay(event) {
          if (!this._dragging) {
            return;
          }
          this._xrHandleProgress(event.hitPoint);
          this._emitSlideEvent();
        }
      }, _class3$4.Direction = Direction$2, _class3$4), (_applyDecoratedDescriptor(_class2$7.prototype, "handle", [_dec4$5], Object.getOwnPropertyDescriptor(_class2$7.prototype, "handle"), _class2$7.prototype), _applyDecoratedDescriptor(_class2$7.prototype, "direction", [_dec5$5], Object.getOwnPropertyDescriptor(_class2$7.prototype, "direction"), _class2$7.prototype), _initializer$7 = applyDecoratedInitializer(_class2$7.prototype, "slideEvents", [_dec6$1, serializable$3], function () {
        return [];
      }), _initializer2$7 = applyDecoratedInitializer(_class2$7.prototype, "_handle", [serializable$3], function () {
        return null;
      }), _initializer3$5 = applyDecoratedInitializer(_class2$7.prototype, "_direction", [serializable$3], function () {
        return Direction$2.Horizontal;
      }), _initializer4$4 = applyDecoratedInitializer(_class2$7.prototype, "_progress", [serializable$3], function () {
        return 0.1;
      })), _class2$7)) || _class$a) || _class$a) || _class$a); exports({ Slider: Slider, SliderComponent: Slider });
      legacyCC.Slider = Slider;

      function extendsEnum(...enums) {
        return Object.assign({}, ...enums);
      }

      var _dec$9, _dec2$7, _dec3$7, _dec4$4, _dec5$4, _class$9, _class2$6, _initializer$6, _initializer2$6, _initializer3$4, _class3$3;
      var EventType$1;
      (function (EventType) {
        EventType["TOGGLE"] = "toggle";
      })(EventType$1 || (EventType$1 = {}));
      let Toggle = (_dec$9 = ccclass$3('cc.Toggle'), _dec2$7 = executionOrder(110), _dec3$7 = requireComponent(UITransform), _dec4$4 = type$2(Sprite), _dec5$4 = type$2([EventHandler]), _dec$9(_class$9 = _dec2$7(_class$9 = _dec3$7(_class$9 = (_class2$6 = (_class3$3 = class Toggle extends Button {
        constructor(...args) {
          super(...args);
          this.checkEvents = _initializer$6 && _initializer$6();
          this._isChecked = _initializer2$6 && _initializer2$6();
          this._checkMark = _initializer3$4 && _initializer3$4();
        }
        get isChecked() {
          return this._isChecked;
        }
        set isChecked(value) {
          this._set(value);
        }
        get checkMark() {
          return this._checkMark;
        }
        set checkMark(value) {
          if (this._checkMark === value) {
            return;
          }
          this._checkMark = value;
        }
        set _resizeToTarget(value) {
          if (value) {
            this._resizeNodeToTargetNode();
          }
        }
        get _toggleContainer() {
          const parent = this.node.parent;
          if (legacyCC.Node.isNode(parent)) {
            return parent.getComponent('cc.ToggleContainer');
          }
          return null;
        }
        _internalToggle() {
          this.isChecked = !this.isChecked;
        }
        _set(value, emitEvent = true) {
          if (this._isChecked == value) return;
          this._isChecked = value;
          const group = this._toggleContainer;
          if (group && group.enabled && this.enabled) {
            if (value || !group.anyTogglesChecked() && !group.allowSwitchOff) {
              this._isChecked = true;
              group.notifyToggleCheck(this, emitEvent);
            }
          }
          this.playEffect();
          if (emitEvent) {
            this._emitToggleEvents();
          }
        }
        playEffect() {
          if (this._checkMark) {
            this._checkMark.node.active = this._isChecked;
          }
        }
        setIsCheckedWithoutNotify(value) {
          this._set(value, false);
        }
        onEnable() {
          super.onEnable();
          this.playEffect();
          {
            this.node.on(Toggle.EventType.CLICK, this._internalToggle, this);
          }
        }
        onDisable() {
          super.onDisable();
          {
            this.node.off(Toggle.EventType.CLICK, this._internalToggle, this);
          }
        }
        _emitToggleEvents() {
          this.node.emit(Toggle.EventType.TOGGLE, this);
          if (this.checkEvents) {
            EventHandler.emitEvents(this.checkEvents, this);
          }
        }
      }, _class3$3.EventType = extendsEnum(EventType$1, EventType$4), _class3$3), (_applyDecoratedDescriptor(_class2$6.prototype, "checkMark", [_dec4$4], Object.getOwnPropertyDescriptor(_class2$6.prototype, "checkMark"), _class2$6.prototype), _initializer$6 = applyDecoratedInitializer(_class2$6.prototype, "checkEvents", [_dec5$4, serializable$3], function () {
        return [];
      }), _initializer2$6 = applyDecoratedInitializer(_class2$6.prototype, "_isChecked", [serializable$3], function () {
        return true;
      }), _initializer3$4 = applyDecoratedInitializer(_class2$6.prototype, "_checkMark", [serializable$3], function () {
        return null;
      })), _class2$6)) || _class$9) || _class$9) || _class$9); exports({ Toggle: Toggle, ToggleComponent: Toggle });
      legacyCC.Toggle = Toggle;

      var _dec$8, _dec2$6, _dec3$6, _class$8, _class2$5, _initializer$5, _initializer2$5;
      let ToggleContainer = (_dec$8 = ccclass$3('cc.ToggleContainer'), _dec2$6 = executionOrder(110), _dec3$6 = type$2([EventHandler]), _dec$8(_class$8 = _dec2$6(_class$8 = (_class2$5 = class ToggleContainer extends Component {
        constructor(...args) {
          super(...args);
          this._allowSwitchOff = _initializer$5 && _initializer$5();
          this.checkEvents = _initializer2$5 && _initializer2$5();
        }
        get allowSwitchOff() {
          return this._allowSwitchOff;
        }
        set allowSwitchOff(value) {
          this._allowSwitchOff = value;
        }
        get toggleItems() {
          return this.node.children.map(item => {
            const toggle = item.getComponent('cc.Toggle');
            if (toggle && toggle.enabled) {
              return toggle;
            }
            return null;
          }).filter(Boolean);
        }
        onEnable() {
          this.ensureValidState();
          this.node.on(NodeEventType.CHILD_ADDED, this.ensureValidState, this);
          this.node.on(NodeEventType.CHILD_REMOVED, this.ensureValidState, this);
        }
        onDisable() {
          this.node.off(NodeEventType.CHILD_ADDED, this.ensureValidState, this);
          this.node.off(NodeEventType.CHILD_REMOVED, this.ensureValidState, this);
        }
        activeToggles() {
          return this.toggleItems.filter(x => x.isChecked);
        }
        anyTogglesChecked() {
          return !!this.toggleItems.find(x => x.isChecked);
        }
        notifyToggleCheck(toggle, emitEvent = true) {
          if (!this.enabledInHierarchy) {
            return;
          }
          for (let i = 0; i < this.toggleItems.length; i++) {
            const item = this.toggleItems[i];
            if (item === toggle) {
              continue;
            }
            if (emitEvent) {
              item.isChecked = false;
            } else {
              item.setIsCheckedWithoutNotify(false);
            }
          }
          if (this.checkEvents) {
            legacyCC.Component.EventHandler.emitEvents(this.checkEvents, toggle);
          }
        }
        ensureValidState() {
          const toggles = this.toggleItems;
          if (!this._allowSwitchOff && !this.anyTogglesChecked() && toggles.length !== 0) {
            const toggle = toggles[0];
            toggle.isChecked = true;
            this.notifyToggleCheck(toggle);
          }
          const activeToggles = this.activeToggles();
          if (activeToggles.length > 1) {
            const firstToggle = activeToggles[0];
            for (let i = 0; i < activeToggles.length; ++i) {
              const toggle = activeToggles[i];
              if (toggle === firstToggle) {
                continue;
              }
              toggle.isChecked = false;
            }
          }
        }
      }, (_initializer$5 = applyDecoratedInitializer(_class2$5.prototype, "_allowSwitchOff", [serializable$3], function () {
        return false;
      }), _initializer2$5 = applyDecoratedInitializer(_class2$5.prototype, "checkEvents", [_dec3$6, serializable$3], function () {
        return [];
      })), _class2$5)) || _class$8) || _class$8); exports({ ToggleContainer: ToggleContainer, ToggleContainerComponent: ToggleContainer });
      legacyCC.ToggleContainer = ToggleContainer;

      var _dec$7, _dec2$5, _dec3$5, _dec4$3, _dec5$3, _class$7, _class2$4, _initializer$4, _initializer2$4, _initializer3$3, _initializer4$3, _initializer5$2, _initializer6$1, _initializer7$1, _initializer8$1, _initializer9$1, _initializer10$1, _initializer11$1, _initializer12$1, _initializer13, _initializer14, _initializer15, _initializer16, _initializer17, _initializer18, _class3$2;
      const _tempScale = new Vec2();
      function getReadonlyNodeSize(parent) {
        if (parent instanceof Scene) {
          return visibleRect;
        } else if (parent._uiProps.uiTransformComp) {
          return parent._uiProps.uiTransformComp.contentSize;
        } else {
          return Size$1.ZERO;
        }
      }
      function computeInverseTransForTarget(widgetNode, target, out_inverseTranslate, out_inverseScale) {
        if (widgetNode.parent) {
          _tempScale.set(widgetNode.parent.getScale().x, widgetNode.parent.getScale().y);
        } else {
          _tempScale.set(0, 0);
        }
        let scaleX = _tempScale.x;
        let scaleY = _tempScale.y;
        let translateX = 0;
        let translateY = 0;
        for (let node = widgetNode.parent;;) {
          if (!node) {
            out_inverseTranslate.x = out_inverseTranslate.y = 0;
            out_inverseScale.x = out_inverseScale.y = 1;
            return;
          }
          const pos = node.getPosition();
          translateX += pos.x;
          translateY += pos.y;
          node = node.parent;
          if (node !== target) {
            if (node) {
              _tempScale.set(node.getScale().x, node.getScale().y);
            } else {
              _tempScale.set(0, 0);
            }
            const sx = _tempScale.x;
            const sy = _tempScale.y;
            translateX *= sx;
            translateY *= sy;
            scaleX *= sx;
            scaleY *= sy;
          } else {
            break;
          }
        }
        out_inverseScale.x = scaleX !== 0 ? 1 / scaleX : 1;
        out_inverseScale.y = scaleY !== 0 ? 1 / scaleY : 1;
        out_inverseTranslate.x = -translateX;
        out_inverseTranslate.y = -translateY;
      }
      let AlignMode;
      (function (AlignMode) {
        AlignMode[AlignMode["ONCE"] = 0] = "ONCE";
        AlignMode[AlignMode["ALWAYS"] = 1] = "ALWAYS";
        AlignMode[AlignMode["ON_WINDOW_RESIZE"] = 2] = "ON_WINDOW_RESIZE";
      })(AlignMode || (AlignMode = {}));
      ccenum(AlignMode);
      let AlignFlags;
      (function (AlignFlags) {
        AlignFlags[AlignFlags["TOP"] = 1] = "TOP";
        AlignFlags[AlignFlags["MID"] = 2] = "MID";
        AlignFlags[AlignFlags["BOT"] = 4] = "BOT";
        AlignFlags[AlignFlags["LEFT"] = 8] = "LEFT";
        AlignFlags[AlignFlags["CENTER"] = 16] = "CENTER";
        AlignFlags[AlignFlags["RIGHT"] = 32] = "RIGHT";
        AlignFlags[AlignFlags["HORIZONTAL"] = 56] = "HORIZONTAL";
        AlignFlags[AlignFlags["VERTICAL"] = 7] = "VERTICAL";
      })(AlignFlags || (AlignFlags = {}));
      const TOP_BOT = AlignFlags.TOP | AlignFlags.BOT;
      const LEFT_RIGHT = AlignFlags.LEFT | AlignFlags.RIGHT;
      let Widget = (_dec$7 = ccclass$3('cc.Widget'), _dec2$5 = executionOrder(110), _dec3$5 = requireComponent(UITransform), _dec4$3 = type$2(Node$1), _dec5$3 = type$2(AlignMode), _dec$7(_class$7 = _dec2$5(_class$7 = _dec3$5(_class$7 = (_class2$4 = (_class3$2 = class Widget extends Component {
        constructor(...args) {
          super(...args);
          this._lastPos = new Vec3();
          this._lastSize = new Size$1();
          this._dirty = true;
          this._hadAlignOnce = false;
          this._alignFlags = _initializer$4 && _initializer$4();
          this._target = _initializer2$4 && _initializer2$4();
          this._left = _initializer3$3 && _initializer3$3();
          this._right = _initializer4$3 && _initializer4$3();
          this._top = _initializer5$2 && _initializer5$2();
          this._bottom = _initializer6$1 && _initializer6$1();
          this._horizontalCenter = _initializer7$1 && _initializer7$1();
          this._verticalCenter = _initializer8$1 && _initializer8$1();
          this._isAbsLeft = _initializer9$1 && _initializer9$1();
          this._isAbsRight = _initializer10$1 && _initializer10$1();
          this._isAbsTop = _initializer11$1 && _initializer11$1();
          this._isAbsBottom = _initializer12$1 && _initializer12$1();
          this._isAbsHorizontalCenter = _initializer13 && _initializer13();
          this._isAbsVerticalCenter = _initializer14 && _initializer14();
          this._originalWidth = _initializer15 && _initializer15();
          this._originalHeight = _initializer16 && _initializer16();
          this._alignMode = _initializer17 && _initializer17();
          this._lockFlags = _initializer18 && _initializer18();
        }
        get target() {
          return this._target;
        }
        set target(value) {
          if (this._target === value) {
            return;
          }
          this._unregisterTargetEvents();
          this._target = value;
          this._registerTargetEvents();
          this._validateTargetInDEV();
          this._recursiveDirty();
        }
        get isAlignTop() {
          return (this._alignFlags & AlignFlags.TOP) > 0;
        }
        set isAlignTop(value) {
          this._setAlign(AlignFlags.TOP, value);
          this._recursiveDirty();
        }
        get isAlignBottom() {
          return (this._alignFlags & AlignFlags.BOT) > 0;
        }
        set isAlignBottom(value) {
          this._setAlign(AlignFlags.BOT, value);
          this._recursiveDirty();
        }
        get isAlignLeft() {
          return (this._alignFlags & AlignFlags.LEFT) > 0;
        }
        set isAlignLeft(value) {
          this._setAlign(AlignFlags.LEFT, value);
          this._recursiveDirty();
        }
        get isAlignRight() {
          return (this._alignFlags & AlignFlags.RIGHT) > 0;
        }
        set isAlignRight(value) {
          this._setAlign(AlignFlags.RIGHT, value);
          this._recursiveDirty();
        }
        get isAlignVerticalCenter() {
          return (this._alignFlags & AlignFlags.MID) > 0;
        }
        set isAlignVerticalCenter(value) {
          if (value) {
            this.isAlignTop = false;
            this.isAlignBottom = false;
            this._alignFlags |= AlignFlags.MID;
          } else {
            this._alignFlags &= ~AlignFlags.MID;
          }
          this._recursiveDirty();
        }
        get isAlignHorizontalCenter() {
          return (this._alignFlags & AlignFlags.CENTER) > 0;
        }
        set isAlignHorizontalCenter(value) {
          if (value) {
            this.isAlignLeft = false;
            this.isAlignRight = false;
            this._alignFlags |= AlignFlags.CENTER;
          } else {
            this._alignFlags &= ~AlignFlags.CENTER;
          }
          this._recursiveDirty();
        }
        get isStretchWidth() {
          return (this._alignFlags & LEFT_RIGHT) === LEFT_RIGHT;
        }
        get isStretchHeight() {
          return (this._alignFlags & TOP_BOT) === TOP_BOT;
        }
        get top() {
          return this._top;
        }
        set top(value) {
          this._top = value;
          this._recursiveDirty();
        }
        get editorTop() {
          return this._isAbsTop ? this._top : this._top * 100;
        }
        set editorTop(value) {
          this._top = this._isAbsTop ? value : value / 100;
          this._recursiveDirty();
        }
        get bottom() {
          return this._bottom;
        }
        set bottom(value) {
          this._bottom = value;
          this._recursiveDirty();
        }
        get editorBottom() {
          return this._isAbsBottom ? this._bottom : this._bottom * 100;
        }
        set editorBottom(value) {
          this._bottom = this._isAbsBottom ? value : value / 100;
          this._recursiveDirty();
        }
        get left() {
          return this._left;
        }
        set left(value) {
          this._left = value;
          this._recursiveDirty();
        }
        get editorLeft() {
          return this._isAbsLeft ? this._left : this._left * 100;
        }
        set editorLeft(value) {
          this._left = this._isAbsLeft ? value : value / 100;
          this._recursiveDirty();
        }
        get right() {
          return this._right;
        }
        set right(value) {
          this._right = value;
          this._recursiveDirty();
        }
        get editorRight() {
          return this._isAbsRight ? this._right : this._right * 100;
        }
        set editorRight(value) {
          this._right = this._isAbsRight ? value : value / 100;
          this._recursiveDirty();
        }
        get horizontalCenter() {
          return this._horizontalCenter;
        }
        set horizontalCenter(value) {
          this._horizontalCenter = value;
          this._recursiveDirty();
        }
        get editorHorizontalCenter() {
          return this._isAbsHorizontalCenter ? this._horizontalCenter : this._horizontalCenter * 100;
        }
        set editorHorizontalCenter(value) {
          this._horizontalCenter = this._isAbsHorizontalCenter ? value : value / 100;
          this._recursiveDirty();
        }
        get verticalCenter() {
          return this._verticalCenter;
        }
        set verticalCenter(value) {
          this._verticalCenter = value;
          this._recursiveDirty();
        }
        get editorVerticalCenter() {
          return this._isAbsVerticalCenter ? this._verticalCenter : this._verticalCenter * 100;
        }
        set editorVerticalCenter(value) {
          this._verticalCenter = this._isAbsVerticalCenter ? value : value / 100;
          this._recursiveDirty();
        }
        get isAbsoluteTop() {
          return this._isAbsTop;
        }
        set isAbsoluteTop(value) {
          if (this._isAbsTop === value) {
            return;
          }
          this._isAbsTop = value;
          this._autoChangedValue(AlignFlags.TOP, this._isAbsTop);
        }
        get isAbsoluteBottom() {
          return this._isAbsBottom;
        }
        set isAbsoluteBottom(value) {
          if (this._isAbsBottom === value) {
            return;
          }
          this._isAbsBottom = value;
          this._autoChangedValue(AlignFlags.BOT, this._isAbsBottom);
        }
        get isAbsoluteLeft() {
          return this._isAbsLeft;
        }
        set isAbsoluteLeft(value) {
          if (this._isAbsLeft === value) {
            return;
          }
          this._isAbsLeft = value;
          this._autoChangedValue(AlignFlags.LEFT, this._isAbsLeft);
        }
        get isAbsoluteRight() {
          return this._isAbsRight;
        }
        set isAbsoluteRight(value) {
          if (this._isAbsRight === value) {
            return;
          }
          this._isAbsRight = value;
          this._autoChangedValue(AlignFlags.RIGHT, this._isAbsRight);
        }
        get isAbsoluteHorizontalCenter() {
          return this._isAbsHorizontalCenter;
        }
        set isAbsoluteHorizontalCenter(value) {
          if (this._isAbsHorizontalCenter === value) {
            return;
          }
          this._isAbsHorizontalCenter = value;
          this._autoChangedValue(AlignFlags.CENTER, this._isAbsHorizontalCenter);
        }
        get isAbsoluteVerticalCenter() {
          return this._isAbsVerticalCenter;
        }
        set isAbsoluteVerticalCenter(value) {
          if (this._isAbsVerticalCenter === value) {
            return;
          }
          this._isAbsVerticalCenter = value;
          this._autoChangedValue(AlignFlags.MID, this._isAbsVerticalCenter);
        }
        get alignMode() {
          return this._alignMode;
        }
        set alignMode(value) {
          this._alignMode = value;
          this._recursiveDirty();
        }
        get alignFlags() {
          return this._alignFlags;
        }
        set alignFlags(value) {
          if (this._alignFlags === value) {
            return;
          }
          this._alignFlags = value;
          this._recursiveDirty();
        }
        updateAlignment() {
          legacyCC._widgetManager.updateAlignment(this.node);
        }
        _validateTargetInDEV() {
          {
            return;
          }
        }
        setDirty() {
          this._recursiveDirty();
        }
        onEnable() {
          this.node.getPosition(this._lastPos);
          this._lastSize.set(this.node._uiProps.uiTransformComp.contentSize);
          legacyCC._widgetManager.add(this);
          this._hadAlignOnce = false;
          this._registerEvent();
          this._registerTargetEvents();
        }
        onDisable() {
          legacyCC._widgetManager.remove(this);
          this._unregisterEvent();
          this._unregisterTargetEvents();
        }
        onDestroy() {
          this._removeParentEvent();
        }
        _adjustWidgetToAllowMovingInEditor(eventType) {}
        _adjustWidgetToAllowResizingInEditor() {}
        _adjustWidgetToAnchorChanged() {
          this.setDirty();
        }
        _adjustTargetToParentChanged(oldParent) {
          if (oldParent) {
            this._unregisterOldParentEvents(oldParent);
          }
          if (this.node.getParent()) {
            this._registerTargetEvents();
          }
          this._setDirtyByMode();
        }
        _registerEvent() {
          {
            this.node.on(NodeEventType.TRANSFORM_CHANGED, this._setDirtyByMode, this);
            this.node.on(NodeEventType.SIZE_CHANGED, this._setDirtyByMode, this);
          }
          this.node.on(NodeEventType.ANCHOR_CHANGED, this._adjustWidgetToAnchorChanged, this);
          this.node.on(NodeEventType.PARENT_CHANGED, this._adjustTargetToParentChanged, this);
        }
        _unregisterEvent() {
          {
            this.node.off(NodeEventType.TRANSFORM_CHANGED, this._setDirtyByMode, this);
            this.node.off(NodeEventType.SIZE_CHANGED, this._setDirtyByMode, this);
          }
          this.node.off(NodeEventType.ANCHOR_CHANGED, this._adjustWidgetToAnchorChanged, this);
        }
        _removeParentEvent() {
          this.node.off(NodeEventType.PARENT_CHANGED, this._adjustTargetToParentChanged, this);
        }
        _autoChangedValue(flag, isAbs) {
          const current = (this._alignFlags & flag) > 0;
          if (!current) {
            return;
          }
          const parentUiProps = this.node.parent && this.node.parent._uiProps;
          const parentTrans = parentUiProps && parentUiProps.uiTransformComp;
          const size = parentTrans ? parentTrans.contentSize : visibleRect;
          if (this.isAlignLeft && flag === AlignFlags.LEFT) {
            this._left = isAbs ? this._left * size.width : this._left / size.width;
          } else if (this.isAlignRight && flag === AlignFlags.RIGHT) {
            this._right = isAbs ? this._right * size.width : this._right / size.width;
          } else if (this.isAlignHorizontalCenter && flag === AlignFlags.CENTER) {
            this._horizontalCenter = isAbs ? this._horizontalCenter * size.width : this._horizontalCenter / size.width;
          } else if (this.isAlignTop && flag === AlignFlags.TOP) {
            this._top = isAbs ? this._top * size.height : this._top / size.height;
          } else if (this.isAlignBottom && flag === AlignFlags.BOT) {
            this._bottom = isAbs ? this._bottom * size.height : this._bottom / size.height;
          } else if (this.isAbsoluteVerticalCenter && flag === AlignFlags.MID) {
            this._verticalCenter = isAbs ? this._verticalCenter / size.height : this._verticalCenter / size.height;
          }
          this._recursiveDirty();
        }
        _registerTargetEvents() {
          const target = this._target || this.node.parent;
          if (target) {
            if (target.getComponent(UITransform)) {
              target.on(NodeEventType.TRANSFORM_CHANGED, this._setDirtyByMode, this);
              target.on(NodeEventType.SIZE_CHANGED, this._setDirtyByMode, this);
              target.on(NodeEventType.ANCHOR_CHANGED, this._setDirtyByMode, this);
            }
          }
        }
        _unregisterTargetEvents() {
          const target = this._target || this.node.parent;
          if (target) {
            target.off(NodeEventType.TRANSFORM_CHANGED, this._setDirtyByMode, this);
            target.off(NodeEventType.SIZE_CHANGED, this._setDirtyByMode, this);
            target.off(NodeEventType.ANCHOR_CHANGED, this._setDirtyByMode, this);
          }
        }
        _unregisterOldParentEvents(oldParent) {
          const target = this._target || oldParent;
          if (target) {
            target.off(NodeEventType.TRANSFORM_CHANGED, this._setDirtyByMode, this);
            target.off(NodeEventType.SIZE_CHANGED, this._setDirtyByMode, this);
          }
        }
        _setDirtyByMode() {
          if (this.alignMode === AlignMode.ALWAYS || EDITOR_NOT_IN_PREVIEW) {
            this._recursiveDirty();
          }
        }
        _setAlign(flag, isAlign) {
          const current = (this._alignFlags & flag) > 0;
          if (isAlign === current) {
            return;
          }
          const isHorizontal = (flag & LEFT_RIGHT) > 0;
          const trans = this.node._uiProps.uiTransformComp;
          if (isAlign) {
            this._alignFlags |= flag;
            if (isHorizontal) {
              this.isAlignHorizontalCenter = false;
              if (this.isStretchWidth) {
                this._originalWidth = trans.width;
              }
            } else {
              this.isAlignVerticalCenter = false;
              if (this.isStretchHeight) {
                this._originalHeight = trans.height;
              }
            }
          } else {
            if (isHorizontal) {
              if (this.isStretchWidth) {
                trans.width = this._originalWidth;
              }
            } else if (this.isStretchHeight) {
              trans.height = this._originalHeight;
            }
            this._alignFlags &= ~flag;
          }
        }
        _recursiveDirty() {
          if (this._dirty) {
            return;
          }
          this._dirty = true;
        }
      }, _class3$2.AlignMode = AlignMode, _class3$2), (_applyDecoratedDescriptor(_class2$4.prototype, "target", [_dec4$3], Object.getOwnPropertyDescriptor(_class2$4.prototype, "target"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "alignMode", [_dec5$3], Object.getOwnPropertyDescriptor(_class2$4.prototype, "alignMode"), _class2$4.prototype), _initializer$4 = applyDecoratedInitializer(_class2$4.prototype, "_alignFlags", [serializable$3], function () {
        return 0;
      }), _initializer2$4 = applyDecoratedInitializer(_class2$4.prototype, "_target", [serializable$3], function () {
        return null;
      }), _initializer3$3 = applyDecoratedInitializer(_class2$4.prototype, "_left", [serializable$3], function () {
        return 0;
      }), _initializer4$3 = applyDecoratedInitializer(_class2$4.prototype, "_right", [serializable$3], function () {
        return 0;
      }), _initializer5$2 = applyDecoratedInitializer(_class2$4.prototype, "_top", [serializable$3], function () {
        return 0;
      }), _initializer6$1 = applyDecoratedInitializer(_class2$4.prototype, "_bottom", [serializable$3], function () {
        return 0;
      }), _initializer7$1 = applyDecoratedInitializer(_class2$4.prototype, "_horizontalCenter", [serializable$3], function () {
        return 0;
      }), _initializer8$1 = applyDecoratedInitializer(_class2$4.prototype, "_verticalCenter", [serializable$3], function () {
        return 0;
      }), _initializer9$1 = applyDecoratedInitializer(_class2$4.prototype, "_isAbsLeft", [serializable$3], function () {
        return true;
      }), _initializer10$1 = applyDecoratedInitializer(_class2$4.prototype, "_isAbsRight", [serializable$3], function () {
        return true;
      }), _initializer11$1 = applyDecoratedInitializer(_class2$4.prototype, "_isAbsTop", [serializable$3], function () {
        return true;
      }), _initializer12$1 = applyDecoratedInitializer(_class2$4.prototype, "_isAbsBottom", [serializable$3], function () {
        return true;
      }), _initializer13 = applyDecoratedInitializer(_class2$4.prototype, "_isAbsHorizontalCenter", [serializable$3], function () {
        return true;
      }), _initializer14 = applyDecoratedInitializer(_class2$4.prototype, "_isAbsVerticalCenter", [serializable$3], function () {
        return true;
      }), _initializer15 = applyDecoratedInitializer(_class2$4.prototype, "_originalWidth", [serializable$3], function () {
        return 0;
      }), _initializer16 = applyDecoratedInitializer(_class2$4.prototype, "_originalHeight", [serializable$3], function () {
        return 0;
      }), _initializer17 = applyDecoratedInitializer(_class2$4.prototype, "_alignMode", [serializable$3], function () {
        return AlignMode.ON_WINDOW_RESIZE;
      }), _initializer18 = applyDecoratedInitializer(_class2$4.prototype, "_lockFlags", [serializable$3, editorOnly], function () {
        return 0;
      })), _class2$4)) || _class$7) || _class$7) || _class$7); exports({ Widget: Widget, WidgetComponent: Widget });
      legacyCC.internal.computeInverseTransForTarget = computeInverseTransForTarget;
      legacyCC.internal.getReadonlyNodeSize = getReadonlyNodeSize;
      legacyCC.Widget = Widget;

      var _dec$6, _dec2$4, _dec3$4, _dec4$2, _dec5$2, _class$6, _class2$3, _initializer$3, _initializer2$3, _initializer3$2, _initializer4$2, _class3$1;
      const _color = new Color$1();
      var Direction$1;
      (function (Direction) {
        Direction[Direction["HORIZONTAL"] = 0] = "HORIZONTAL";
        Direction[Direction["VERTICAL"] = 1] = "VERTICAL";
      })(Direction$1 || (Direction$1 = {}));
      ccenum(Direction$1);
      let PageViewIndicator = (_dec$6 = ccclass$3('cc.PageViewIndicator'), _dec2$4 = executionOrder(110), _dec3$4 = type$2(SpriteFrame), _dec4$2 = type$2(Direction$1), _dec5$2 = type$2(Size$1), _dec$6(_class$6 = _dec2$4(_class$6 = (_class2$3 = (_class3$1 = class PageViewIndicator extends Component {
        constructor(...args) {
          super(...args);
          this.spacing = _initializer$3 && _initializer$3();
          this._spriteFrame = _initializer2$3 && _initializer2$3();
          this._direction = _initializer3$2 && _initializer3$2();
          this._cellSize = _initializer4$2 && _initializer4$2();
          this._layout = null;
          this._pageView = null;
          this._indicators = [];
        }
        get spriteFrame() {
          return this._spriteFrame;
        }
        set spriteFrame(value) {
          if (this._spriteFrame === value) {
            return;
          }
          this._spriteFrame = value;
        }
        get direction() {
          return this._direction;
        }
        set direction(value) {
          if (this._direction === value) {
            return;
          }
          this._direction = value;
        }
        get cellSize() {
          return this._cellSize;
        }
        set cellSize(value) {
          if (this._cellSize === value) {
            return;
          }
          this._cellSize = value;
        }
        onLoad() {
          this._updateLayout();
        }
        setPageView(target) {
          this._pageView = target;
          this._refresh();
        }
        _updateLayout() {
          this._layout = this.getComponent(Layout);
          if (!this._layout) {
            this._layout = this.addComponent(Layout);
          }
          const layout = this._layout;
          if (this.direction === Direction$1.HORIZONTAL) {
            layout.type = Layout.Type.HORIZONTAL;
            layout.spacingX = this.spacing;
          } else if (this.direction === Direction$1.VERTICAL) {
            layout.type = Layout.Type.VERTICAL;
            layout.spacingY = this.spacing;
          }
          layout.resizeMode = Layout.ResizeMode.CONTAINER;
        }
        _createIndicator() {
          const node = new Node$1();
          node.layer = this.node.layer;
          const sprite = node.addComponent(Sprite);
          sprite.spriteFrame = this.spriteFrame;
          sprite.sizeMode = Sprite.SizeMode.CUSTOM;
          node.parent = this.node;
          node._uiProps.uiTransformComp.setContentSize(this._cellSize);
          return node;
        }
        _changedState() {
          const indicators = this._indicators;
          if (indicators.length === 0 || !this._pageView) {
            return;
          }
          const idx = this._pageView.curPageIdx;
          if (idx >= indicators.length) {
            return;
          }
          for (let i = 0; i < indicators.length; ++i) {
            const node = indicators[i];
            if (!node._uiProps.uiComp) {
              continue;
            }
            const uiComp = node._uiProps.uiComp;
            _color.set(uiComp.color);
            _color.a = 255 / 2;
            uiComp.color = _color;
          }
          if (indicators[idx]._uiProps.uiComp) {
            const comp = indicators[idx]._uiProps.uiComp;
            _color.set(comp.color);
            _color.a = 255;
            comp.color = _color;
          }
        }
        _refresh() {
          if (!this._pageView) {
            return;
          }
          const indicators = this._indicators;
          const pages = this._pageView.getPages();
          if (pages.length === indicators.length) {
            return;
          }
          let i = 0;
          if (pages.length > indicators.length) {
            for (i = 0; i < pages.length; ++i) {
              if (!indicators[i]) {
                indicators[i] = this._createIndicator();
              }
            }
          } else {
            const count = indicators.length - pages.length;
            for (i = count; i > 0; --i) {
              const node = indicators[i - 1];
              this.node.removeChild(node);
              indicators.splice(i - 1, 1);
            }
          }
          if (this._layout && this._layout.enabledInHierarchy) {
            this._layout.updateLayout();
          }
          this._changedState();
        }
      }, _class3$1.Direction = Direction$1, _class3$1), (_applyDecoratedDescriptor(_class2$3.prototype, "spriteFrame", [_dec3$4], Object.getOwnPropertyDescriptor(_class2$3.prototype, "spriteFrame"), _class2$3.prototype), _applyDecoratedDescriptor(_class2$3.prototype, "direction", [_dec4$2], Object.getOwnPropertyDescriptor(_class2$3.prototype, "direction"), _class2$3.prototype), _applyDecoratedDescriptor(_class2$3.prototype, "cellSize", [_dec5$2], Object.getOwnPropertyDescriptor(_class2$3.prototype, "cellSize"), _class2$3.prototype), _initializer$3 = applyDecoratedInitializer(_class2$3.prototype, "spacing", [serializable$3], function () {
        return 0;
      }), _initializer2$3 = applyDecoratedInitializer(_class2$3.prototype, "_spriteFrame", [serializable$3], function () {
        return null;
      }), _initializer3$2 = applyDecoratedInitializer(_class2$3.prototype, "_direction", [serializable$3], function () {
        return Direction$1.HORIZONTAL;
      }), _initializer4$2 = applyDecoratedInitializer(_class2$3.prototype, "_cellSize", [serializable$3], function () {
        return new Size$1(20, 20);
      })), _class2$3)) || _class$6) || _class$6); exports({ PageViewIndicator: PageViewIndicator, PageViewIndicatorComponent: PageViewIndicator });
      legacyCC.PageViewIndicator = PageViewIndicator;

      var _dec$5, _dec2$3, _dec3$3, _dec4$1, _dec5$1, _dec6, _dec7, _dec8, _dec9, _class$5, _class2$2, _initializer$2, _initializer2$2, _initializer3$1, _initializer4$1, _initializer5$1, _initializer6, _initializer7, _initializer8, _initializer9, _initializer10, _initializer11, _initializer12, _class3;
      const _tempVec2 = new Vec2();
      var SizeMode;
      (function (SizeMode) {
        SizeMode[SizeMode["Unified"] = 0] = "Unified";
        SizeMode[SizeMode["Free"] = 1] = "Free";
      })(SizeMode || (SizeMode = {}));
      ccenum(SizeMode);
      var Direction;
      (function (Direction) {
        Direction[Direction["Horizontal"] = 0] = "Horizontal";
        Direction[Direction["Vertical"] = 1] = "Vertical";
      })(Direction || (Direction = {}));
      ccenum(Direction);
      var EventType;
      (function (EventType) {
        EventType["PAGE_TURNING"] = "page-turning";
      })(EventType || (EventType = {}));
      let PageView = (_dec$5 = ccclass$3('cc.PageView'), _dec2$3 = executionOrder(110), _dec3$3 = type$2(SizeMode), _dec4$1 = type$2(Direction), _dec5$1 = type$2(PageViewIndicator), _dec6 = type$2(ScrollBar), _dec7 = type$2(ScrollBar), _dec8 = type$2([EventHandler]), _dec9 = type$2([EventHandler]), _dec$5(_class$5 = _dec2$3(_class$5 = (_class2$2 = (_class3 = class PageView extends ScrollView {
        constructor(...args) {
          super(...args);
          this.autoPageTurningThreshold = _initializer$2 && _initializer$2();
          this.horizontal = _initializer2$2 && _initializer2$2();
          this.vertical = _initializer3$1 && _initializer3$1();
          this.cancelInnerEvents = _initializer4$1 && _initializer4$1();
          this.scrollEvents = _initializer5$1 && _initializer5$1();
          this.pageTurningSpeed = _initializer6 && _initializer6();
          this.pageEvents = _initializer7 && _initializer7();
          this._sizeMode = _initializer8 && _initializer8();
          this._direction = _initializer9 && _initializer9();
          this._scrollThreshold = _initializer10 && _initializer10();
          this._pageTurningEventTiming = _initializer11 && _initializer11();
          this._indicator = _initializer12 && _initializer12();
          this._curPageIdx = 0;
          this._lastPageIdx = 0;
          this._pages = [];
          this._initContentPos = new Vec3();
          this._scrollCenterOffsetX = [];
          this._scrollCenterOffsetY = [];
          this._touchBeganPosition = new Vec2();
          this._touchEndPosition = new Vec2();
        }
        get sizeMode() {
          return this._sizeMode;
        }
        set sizeMode(value) {
          if (this._sizeMode === value) {
            return;
          }
          this._sizeMode = value;
          this._syncSizeMode();
        }
        get direction() {
          return this._direction;
        }
        set direction(value) {
          if (this._direction === value) {
            return;
          }
          this._direction = value;
          this._syncScrollDirection();
        }
        get scrollThreshold() {
          return this._scrollThreshold;
        }
        set scrollThreshold(value) {
          if (this._scrollThreshold === value) {
            return;
          }
          this._scrollThreshold = value;
        }
        get pageTurningEventTiming() {
          return this._pageTurningEventTiming;
        }
        set pageTurningEventTiming(value) {
          if (this._pageTurningEventTiming === value) {
            return;
          }
          this._pageTurningEventTiming = value;
        }
        get indicator() {
          return this._indicator;
        }
        set indicator(value) {
          if (this._indicator === value) {
            return;
          }
          this._indicator = value;
          if (this.indicator) {
            this.indicator.setPageView(this);
          }
        }
        get curPageIdx() {
          return this._curPageIdx;
        }
        get verticalScrollBar() {
          return super.verticalScrollBar;
        }
        set verticalScrollBar(value) {
          super.verticalScrollBar = value;
        }
        get horizontalScrollBar() {
          return super.horizontalScrollBar;
        }
        set horizontalScrollBar(value) {
          super.horizontalScrollBar = value;
        }
        onEnable() {
          super.onEnable();
          this.node.on(NodeEventType.SIZE_CHANGED, this._updateAllPagesSize, this);
          {
            this.node.on(PageView.EventType.SCROLL_ENG_WITH_THRESHOLD, this._dispatchPageTurningEvent, this);
          }
        }
        onDisable() {
          super.onDisable();
          this.node.off(NodeEventType.SIZE_CHANGED, this._updateAllPagesSize, this);
          {
            this.node.off(PageView.EventType.SCROLL_ENG_WITH_THRESHOLD, this._dispatchPageTurningEvent, this);
          }
        }
        onLoad() {
          this._initPages();
          if (this.indicator) {
            this.indicator.setPageView(this);
          }
        }
        getCurrentPageIndex() {
          return this._curPageIdx;
        }
        setCurrentPageIndex(index) {
          this.scrollToPage(index, 1);
        }
        getPages() {
          return this._pages;
        }
        addPage(page) {
          if (!page || this._pages.indexOf(page) !== -1 || !this.content) {
            return;
          }
          if (!page._uiProps.uiTransformComp) {
            logID(4301);
            return;
          }
          this.content.addChild(page);
          this._pages.push(page);
          this._updatePageView();
        }
        insertPage(page, index) {
          if (index < 0 || !page || this._pages.indexOf(page) !== -1 || !this.content) {
            return;
          }
          const pageCount = this._pages.length;
          if (index >= pageCount) {
            this.addPage(page);
          } else {
            if (!page._uiProps.uiTransformComp) {
              logID(4301);
              return;
            }
            this._pages.splice(index, 0, page);
            this.content.insertChild(page, index);
            this._updatePageView();
          }
        }
        removePage(page) {
          if (!page || !this.content) {
            return;
          }
          const index = this._pages.indexOf(page);
          if (index === -1) {
            warnID(4300, page.name);
            return;
          }
          this.removePageAtIndex(index);
        }
        removePageAtIndex(index) {
          const pageList = this._pages;
          if (index < 0 || index >= pageList.length) {
            return;
          }
          const page = pageList[index];
          if (!page || !this.content) {
            return;
          }
          this.content.removeChild(page);
          pageList.splice(index, 1);
          this._updatePageView();
        }
        removeAllPages() {
          if (!this.content) {
            return;
          }
          const locPages = this._pages;
          for (let i = 0, len = locPages.length; i < len; i++) {
            this.content.removeChild(locPages[i]);
          }
          this._pages.length = 0;
          this._updatePageView();
        }
        scrollToPage(idx, timeInSecond = 0.3) {
          if (idx < 0 || idx >= this._pages.length) {
            return;
          }
          this._curPageIdx = idx;
          this.scrollToOffset(this._moveOffsetValue(idx), timeInSecond, true);
          if (this.indicator) {
            this.indicator._changedState();
          }
        }
        getScrollEndedEventTiming() {
          return this.pageTurningEventTiming;
        }
        _updatePageView() {
          if (!this.content) {
            return;
          }
          const layout = this.content.getComponent(Layout);
          if (layout && layout.enabled) {
            layout.updateLayout();
          }
          const pageCount = this._pages.length;
          if (this._curPageIdx >= pageCount) {
            this._curPageIdx = pageCount === 0 ? 0 : pageCount - 1;
            this._lastPageIdx = this._curPageIdx;
          }
          const contentPos = this._initContentPos;
          for (let i = 0; i < pageCount; ++i) {
            const page = this._pages[i];
            const pos = page.position;
            if (this.direction === Direction.Horizontal) {
              this._scrollCenterOffsetX[i] = Math.abs(contentPos.x + pos.x);
            } else {
              this._scrollCenterOffsetY[i] = Math.abs(contentPos.y + pos.y);
            }
          }
          if (this.indicator) {
            this.indicator._refresh();
          }
        }
        _updateAllPagesSize() {
          const viewTrans = this.view;
          if (!this.content || !viewTrans) {
            return;
          }
          if (this._sizeMode !== SizeMode.Unified) {
            return;
          }
          const locPages = this._pages;
          const selfSize = viewTrans.contentSize;
          for (let i = 0, len = locPages.length; i < len; i++) {
            locPages[i]._uiProps.uiTransformComp.setContentSize(selfSize);
          }
        }
        _handleReleaseLogic() {
          this._autoScrollToPage();
          if (this._scrolling) {
            this._scrolling = false;
            if (!this._autoScrolling) {
              this._dispatchEvent(PageView.EventType.SCROLL_ENDED);
            }
          }
        }
        _onTouchBegan(event, captureListeners) {
          event.touch.getUILocation(_tempVec2);
          Vec2.set(this._touchBeganPosition, _tempVec2.x, _tempVec2.y);
          super._onTouchBegan(event, captureListeners);
        }
        _onTouchMoved(event, captureListeners) {
          super._onTouchMoved(event, captureListeners);
        }
        _onTouchEnded(event, captureListeners) {
          event.touch.getUILocation(_tempVec2);
          Vec2.set(this._touchEndPosition, _tempVec2.x, _tempVec2.y);
          super._onTouchEnded(event, captureListeners);
        }
        _onTouchCancelled(event, captureListeners) {
          event.touch.getUILocation(_tempVec2);
          Vec2.set(this._touchEndPosition, _tempVec2.x, _tempVec2.y);
          super._onTouchCancelled(event, captureListeners);
        }
        _onMouseWheel() {}
        _syncScrollDirection() {
          this.horizontal = this.direction === Direction.Horizontal;
          this.vertical = this.direction === Direction.Vertical;
        }
        _syncSizeMode() {
          const viewTrans = this.view;
          if (!this.content || !viewTrans) {
            return;
          }
          const layout = this.content.getComponent(Layout);
          if (layout) {
            if (this._sizeMode === SizeMode.Free && this._pages.length > 0) {
              const firstPageTrans = this._pages[0]._uiProps.uiTransformComp;
              const lastPageTrans = this._pages[this._pages.length - 1]._uiProps.uiTransformComp;
              if (this.direction === Direction.Horizontal) {
                layout.paddingLeft = (viewTrans.width - firstPageTrans.width) / 2;
                layout.paddingRight = (viewTrans.width - lastPageTrans.width) / 2;
              } else if (this.direction === Direction.Vertical) {
                layout.paddingTop = (viewTrans.height - firstPageTrans.height) / 2;
                layout.paddingBottom = (viewTrans.height - lastPageTrans.height) / 2;
              }
            }
            layout.updateLayout();
          }
        }
        _initPages() {
          if (!this.content) {
            return;
          }
          this._initContentPos = this.content.position;
          const children = this.content.children;
          for (let i = 0; i < children.length; ++i) {
            const page = children[i];
            if (this._pages.indexOf(page) >= 0) {
              continue;
            }
            this._pages.push(page);
          }
          this._syncScrollDirection();
          this._syncSizeMode();
          this._updatePageView();
        }
        _dispatchPageTurningEvent() {
          if (this._lastPageIdx === this._curPageIdx) {
            return;
          }
          this._lastPageIdx = this._curPageIdx;
          EventHandler.emitEvents(this.pageEvents, this, EventType.PAGE_TURNING);
          this.node.emit(EventType.PAGE_TURNING, this);
        }
        _isQuicklyScrollable(touchMoveVelocity) {
          if (this.direction === Direction.Horizontal) {
            if (Math.abs(touchMoveVelocity.x) > this.autoPageTurningThreshold) {
              return true;
            }
          } else if (this.direction === Direction.Vertical) {
            if (Math.abs(touchMoveVelocity.y) > this.autoPageTurningThreshold) {
              return true;
            }
          }
          return false;
        }
        _moveOffsetValue(idx) {
          const offset = new Vec2();
          if (this._sizeMode === SizeMode.Free) {
            if (this.direction === Direction.Horizontal) {
              offset.x = this._scrollCenterOffsetX[idx];
            } else if (this.direction === Direction.Vertical) {
              offset.y = this._scrollCenterOffsetY[idx];
            }
          } else {
            const viewTrans = this.view;
            if (!viewTrans) {
              return offset;
            }
            if (this.direction === Direction.Horizontal) {
              offset.x = idx * viewTrans.width;
            } else if (this.direction === Direction.Vertical) {
              offset.y = idx * viewTrans.height;
            }
          }
          return offset;
        }
        _getDragDirection(moveOffset) {
          if (this._direction === Direction.Horizontal) {
            if (moveOffset.x === 0) {
              return 0;
            }
            return moveOffset.x > 0 ? 1 : -1;
          } else {
            if (moveOffset.y === 0) {
              return 0;
            }
            return moveOffset.y < 0 ? 1 : -1;
          }
        }
        _isScrollable(offset, index, nextIndex) {
          if (this._sizeMode === SizeMode.Free) {
            let curPageCenter = 0;
            let nextPageCenter = 0;
            if (this.direction === Direction.Horizontal) {
              curPageCenter = this._scrollCenterOffsetX[index];
              nextPageCenter = this._scrollCenterOffsetX[nextIndex];
              return Math.abs(offset.x) >= Math.abs(curPageCenter - nextPageCenter) * this.scrollThreshold;
            } else if (this.direction === Direction.Vertical) {
              curPageCenter = this._scrollCenterOffsetY[index];
              nextPageCenter = this._scrollCenterOffsetY[nextIndex];
              return Math.abs(offset.y) >= Math.abs(curPageCenter - nextPageCenter) * this.scrollThreshold;
            }
          } else {
            const viewTrans = this.view;
            if (!viewTrans) {
              return false;
            }
            if (this.direction === Direction.Horizontal) {
              return Math.abs(offset.x) >= viewTrans.width * this.scrollThreshold;
            } else if (this.direction === Direction.Vertical) {
              return Math.abs(offset.y) >= viewTrans.height * this.scrollThreshold;
            }
          }
          return false;
        }
        _autoScrollToPage() {
          const bounceBackStarted = this._startBounceBackIfNeeded();
          if (bounceBackStarted) {
            const bounceBackAmount = this._getHowMuchOutOfBoundary();
            this._clampDelta(bounceBackAmount);
            if (bounceBackAmount.x > 0 || bounceBackAmount.y < 0) {
              this._curPageIdx = this._pages.length === 0 ? 0 : this._pages.length - 1;
            }
            if (bounceBackAmount.x < 0 || bounceBackAmount.y > 0) {
              this._curPageIdx = 0;
            }
            if (this.indicator) {
              this.indicator._changedState();
            }
          } else {
            const moveOffset = new Vec2();
            Vec2.subtract(moveOffset, this._touchBeganPosition, this._touchEndPosition);
            const index = this._curPageIdx;
            const nextIndex = index + this._getDragDirection(moveOffset);
            const timeInSecond = this.pageTurningSpeed * Math.abs(index - nextIndex);
            if (nextIndex < this._pages.length) {
              if (this._isScrollable(moveOffset, index, nextIndex)) {
                this.scrollToPage(nextIndex, timeInSecond);
                return;
              } else {
                const touchMoveVelocity = this._calculateTouchMoveVelocity();
                if (this._isQuicklyScrollable(touchMoveVelocity)) {
                  this.scrollToPage(nextIndex, timeInSecond);
                  return;
                }
              }
            }
            this.scrollToPage(index, timeInSecond);
          }
        }
      }, _class3.SizeMode = SizeMode, _class3.Direction = Direction, _class3.EventType = extendsEnum(EventType, EventType$2), _class3), (_applyDecoratedDescriptor(_class2$2.prototype, "sizeMode", [_dec3$3], Object.getOwnPropertyDescriptor(_class2$2.prototype, "sizeMode"), _class2$2.prototype), _applyDecoratedDescriptor(_class2$2.prototype, "direction", [_dec4$1], Object.getOwnPropertyDescriptor(_class2$2.prototype, "direction"), _class2$2.prototype), _applyDecoratedDescriptor(_class2$2.prototype, "indicator", [_dec5$1], Object.getOwnPropertyDescriptor(_class2$2.prototype, "indicator"), _class2$2.prototype), _initializer$2 = applyDecoratedInitializer(_class2$2.prototype, "autoPageTurningThreshold", [serializable$3], function () {
        return 100;
      }), _applyDecoratedDescriptor(_class2$2.prototype, "verticalScrollBar", [_dec6, override], Object.getOwnPropertyDescriptor(_class2$2.prototype, "verticalScrollBar"), _class2$2.prototype), _applyDecoratedDescriptor(_class2$2.prototype, "horizontalScrollBar", [_dec7, override], Object.getOwnPropertyDescriptor(_class2$2.prototype, "horizontalScrollBar"), _class2$2.prototype), _initializer2$2 = applyDecoratedInitializer(_class2$2.prototype, "horizontal", [override, serializable$3], function () {
        return true;
      }), _initializer3$1 = applyDecoratedInitializer(_class2$2.prototype, "vertical", [override, serializable$3], function () {
        return true;
      }), _initializer4$1 = applyDecoratedInitializer(_class2$2.prototype, "cancelInnerEvents", [override, serializable$3], function () {
        return true;
      }), _initializer5$1 = applyDecoratedInitializer(_class2$2.prototype, "scrollEvents", [_dec8, serializable$3, override], function () {
        return [];
      }), _initializer6 = applyDecoratedInitializer(_class2$2.prototype, "pageTurningSpeed", [serializable$3], function () {
        return 0.3;
      }), _initializer7 = applyDecoratedInitializer(_class2$2.prototype, "pageEvents", [_dec9, serializable$3], function () {
        return [];
      }), _initializer8 = applyDecoratedInitializer(_class2$2.prototype, "_sizeMode", [serializable$3], function () {
        return SizeMode.Unified;
      }), _initializer9 = applyDecoratedInitializer(_class2$2.prototype, "_direction", [serializable$3], function () {
        return Direction.Horizontal;
      }), _initializer10 = applyDecoratedInitializer(_class2$2.prototype, "_scrollThreshold", [serializable$3], function () {
        return 0.5;
      }), _initializer11 = applyDecoratedInitializer(_class2$2.prototype, "_pageTurningEventTiming", [serializable$3], function () {
        return 0.1;
      }), _initializer12 = applyDecoratedInitializer(_class2$2.prototype, "_indicator", [serializable$3], function () {
        return null;
      })), _class2$2)) || _class$5) || _class$5); exports({ PageView: PageView, PageViewComponent: PageView });
      legacyCC.PageView = PageView;

      const _tempPos = new Vec3();
      const _defaultAnchor = new Vec2();
      const tInverseTranslate = new Vec2();
      const tInverseScale = new Vec2(1, 1);
      const _tempVec2_1 = new Vec2();
      const _tempVec2_2 = new Vec2();
      function align(node, widget) {
        if (widget._hadAlignOnce) return;
        if (widget.alignMode === AlignMode.ONCE) {
          widget._hadAlignOnce = true;
        }
        const hasTarget = widget.target;
        let target;
        const inverseTranslate = tInverseTranslate;
        const inverseScale = tInverseScale;
        if (hasTarget) {
          target = hasTarget;
          computeInverseTransForTarget(node, target, inverseTranslate, inverseScale);
        } else {
          target = node.parent;
        }
        const targetSize = getReadonlyNodeSize(target);
        const useGlobal = target instanceof Scene || !target.getComponent(UITransform);
        const targetAnchor = useGlobal ? _defaultAnchor : target.getComponent(UITransform).anchorPoint;
        const isRoot = useGlobal;
        node.getPosition(_tempPos);
        const uiTrans = node._uiProps.uiTransformComp;
        let x = _tempPos.x;
        let y = _tempPos.y;
        const anchor = uiTrans.anchorPoint;
        const scale = node.getScale();
        if (widget.alignFlags & AlignFlags.HORIZONTAL) {
          let localLeft = 0;
          let localRight = 0;
          const targetWidth = targetSize.width;
          if (isRoot) {
            localLeft = visibleRect.left.x;
            localRight = visibleRect.right.x;
          } else {
            localLeft = -targetAnchor.x * targetWidth;
            localRight = localLeft + targetWidth;
          }
          localLeft += widget.isAbsoluteLeft ? widget.left : widget.left * targetWidth;
          localRight -= widget.isAbsoluteRight ? widget.right : widget.right * targetWidth;
          if (hasTarget) {
            localLeft += inverseTranslate.x;
            localLeft *= inverseScale.x;
            localRight += inverseTranslate.x;
            localRight *= inverseScale.x;
          }
          let width = 0;
          let anchorX = anchor.x;
          let scaleX = scale.x;
          if (scaleX < 0) {
            anchorX = 1.0 - anchorX;
            scaleX = -scaleX;
          }
          if (widget.isStretchWidth) {
            width = localRight - localLeft;
            if (scaleX !== 0) {
              uiTrans.width = width / scaleX;
            }
            x = localLeft + anchorX * width;
          } else {
            width = uiTrans.width * scaleX;
            if (widget.isAlignHorizontalCenter) {
              let localHorizontalCenter = widget.isAbsoluteHorizontalCenter ? widget.horizontalCenter : widget.horizontalCenter * targetWidth;
              let targetCenter = (0.5 - targetAnchor.x) * targetSize.width;
              if (hasTarget) {
                localHorizontalCenter *= inverseScale.x;
                targetCenter += inverseTranslate.x;
                targetCenter *= inverseScale.x;
              }
              x = targetCenter + (anchorX - 0.5) * width + localHorizontalCenter;
            } else if (widget.isAlignLeft) {
              x = localLeft + anchorX * width;
            } else {
              x = localRight + (anchorX - 1) * width;
            }
            if (!approx(scaleX, 0, EPSILON$2)) {
              width /= scaleX;
            } else {
              width = uiTrans.width;
            }
          }
          widget._lastSize.width = width;
        }
        if (widget.alignFlags & AlignFlags.VERTICAL) {
          let localTop = 0;
          let localBottom = 0;
          const targetHeight = targetSize.height;
          if (isRoot) {
            localBottom = visibleRect.bottom.y;
            localTop = visibleRect.top.y;
          } else {
            localBottom = -targetAnchor.y * targetHeight;
            localTop = localBottom + targetHeight;
          }
          localBottom += widget.isAbsoluteBottom ? widget.bottom : widget.bottom * targetHeight;
          localTop -= widget.isAbsoluteTop ? widget.top : widget.top * targetHeight;
          if (hasTarget) {
            localBottom += inverseTranslate.y;
            localBottom *= inverseScale.y;
            localTop += inverseTranslate.y;
            localTop *= inverseScale.y;
          }
          let height = 0;
          let anchorY = anchor.y;
          let scaleY = scale.y;
          if (scaleY < 0) {
            anchorY = 1.0 - anchorY;
            scaleY = -scaleY;
          }
          if (widget.isStretchHeight) {
            height = localTop - localBottom;
            if (scaleY !== 0) {
              uiTrans.height = height / scaleY;
            }
            y = localBottom + anchorY * height;
          } else {
            height = uiTrans.height * scaleY;
            if (widget.isAlignVerticalCenter) {
              let localVerticalCenter = widget.isAbsoluteVerticalCenter ? widget.verticalCenter : widget.verticalCenter * targetHeight;
              let targetMiddle = (0.5 - targetAnchor.y) * targetSize.height;
              if (hasTarget) {
                localVerticalCenter *= inverseScale.y;
                targetMiddle += inverseTranslate.y;
                targetMiddle *= inverseScale.y;
              }
              y = targetMiddle + (anchorY - 0.5) * height + localVerticalCenter;
            } else if (widget.isAlignBottom) {
              y = localBottom + anchorY * height;
            } else {
              y = localTop + (anchorY - 1) * height;
            }
            if (!approx(scaleY, 0, EPSILON$2)) {
              height /= scaleY;
            } else {
              height = uiTrans.height;
            }
          }
          widget._lastSize.height = height;
        }
        node.setPosition(x, y, _tempPos.z);
        Vec3.set(widget._lastPos, x, y, _tempPos.z);
      }
      function visitNode(node) {
        const widget = node.getComponent(Widget);
        if (widget && widget.enabled) {
          if (!legacyCC.isValid(node, true)) {
            return;
          }
          activeWidgets.push(widget);
        }
        const children = node.children;
        for (const child of children) {
          if (child.active) {
            visitNode(child);
          }
        }
      }
      function refreshScene() {
        const scene = director.getScene();
        if (scene) {
          widgetManager.isAligning = true;
          if (widgetManager._nodesOrderDirty) {
            activeWidgets.length = 0;
            visitNode(scene);
            widgetManager._nodesOrderDirty = false;
          }
          let widget = null;
          const iterator = widgetManager._activeWidgetsIterator;
          for (iterator.i = 0; iterator.i < activeWidgets.length; ++iterator.i) {
            widget = activeWidgets[iterator.i];
            if (widget._dirty) {
              align(widget.node, widget);
              widget._dirty = false;
            }
          }
          widgetManager.isAligning = false;
        }
      }
      const activeWidgets = [];
      function updateAlignment(node) {
        const parent = node.parent;
        if (parent && Node$1.isNode(parent)) {
          updateAlignment(parent);
        }
        const widget = node.getComponent(Widget);
        if (widget && parent) {
          align(node, widget);
        }
      }
      const widgetManager = exports('widgetManager', legacyCC._widgetManager = {
        isAligning: false,
        _nodesOrderDirty: false,
        _activeWidgetsIterator: new MutableForwardIterator(activeWidgets),
        animationState: null,
        init() {
          director.on(Director.EVENT_AFTER_SCENE_LAUNCH, refreshScene);
          director.on(Director.EVENT_AFTER_UPDATE, refreshScene);
          View.instance.on('design-resolution-changed', this.onResized, this);
          {
            const thisOnResized = this.onResized.bind(this);
            View.instance.on('canvas-resize', thisOnResized);
            screenAdapter.on('window-resize', thisOnResized);
          }
        },
        add(widget) {
          this._nodesOrderDirty = true;
        },
        remove(widget) {
          this._activeWidgetsIterator.remove(widget);
        },
        onResized() {
          const scene = director.getScene();
          if (scene) {
            this.refreshWidgetOnResized(scene);
          }
        },
        refreshWidgetOnResized(node) {
          const widget = Node$1.isNode(node) && node.getComponent(Widget);
          if (widget && widget.enabled && (widget.alignMode === AlignMode.ON_WINDOW_RESIZE || widget.alignMode === AlignMode.ALWAYS)) {
            widget.setDirty();
          }
          const children = node.children;
          for (const child of children) {
            this.refreshWidgetOnResized(child);
          }
        },
        updateOffsetsToStayPut(widget, e) {
          function i(t, c) {
            return Math.abs(t - c) > 1e-10 ? c : t;
          }
          const widgetNode = widget.node;
          let widgetParent = widgetNode.parent;
          if (widgetParent) {
            const zero = _tempVec2_1;
            zero.set(0, 0);
            const one = _tempVec2_2;
            one.set(1, 1);
            if (widget.target) {
              widgetParent = widget.target;
              computeInverseTransForTarget(widgetNode, widgetParent, zero, one);
            }
            if (!e) {
              return;
            }
            const parentTrans = widgetParent._uiProps && widgetParent._uiProps.uiTransformComp;
            const parentAP = parentTrans ? parentTrans.anchorPoint : _defaultAnchor;
            const trans = widgetNode._uiProps.uiTransformComp;
            const matchSize = getReadonlyNodeSize(widgetParent);
            const myAP = trans.anchorPoint;
            const pos = widgetNode.getPosition();
            const alignFlags = AlignFlags;
            const widgetNodeScale = widgetNode.getScale();
            let temp = 0;
            if (e & alignFlags.LEFT) {
              let l = -parentAP.x * matchSize.width;
              l += zero.x;
              l *= one.x;
              temp = pos.x - myAP.x * trans.width * Math.abs(widgetNodeScale.x) - l;
              if (!widget.isAbsoluteLeft) {
                temp /= matchSize.width;
              }
              temp /= one.x;
              widget.left = i(widget.left, temp);
            }
            if (e & alignFlags.RIGHT) {
              let r = (1 - parentAP.x) * matchSize.width;
              r += zero.x;
              temp = (r *= one.x) - (pos.x + (1 - myAP.x) * trans.width * Math.abs(widgetNodeScale.x));
              if (!widget.isAbsoluteRight) {
                temp /= matchSize.width;
              }
              temp /= one.x;
              widget.right = i(widget.right, temp);
            }
            if (e & alignFlags.TOP) {
              let t = (1 - parentAP.y) * matchSize.height;
              t += zero.y;
              temp = (t *= one.y) - (pos.y + (1 - myAP.y) * trans.height * Math.abs(widgetNodeScale.y));
              if (!widget.isAbsoluteTop) {
                temp /= matchSize.height;
              }
              temp /= one.y;
              widget.top = i(widget.top, temp);
            }
            if (e & alignFlags.BOT) {
              let b = -parentAP.y * matchSize.height;
              b += zero.y;
              b *= one.y;
              temp = pos.y - myAP.y * trans.height * Math.abs(widgetNodeScale.y) - b;
              if (!widget.isAbsoluteBottom) {
                temp /= matchSize.height;
              }
              temp /= one.y;
              widget.bottom = i(widget.bottom, temp);
            }
          }
        },
        updateAlignment,
        AlignMode,
        AlignFlags
      });
      director.on(Director.EVENT_INIT, () => {
        widgetManager.init();
      });

      var _dec$4, _dec2$2, _dec3$2, _class$4;
      let SafeArea = (_dec$4 = ccclass$3('cc.SafeArea'), _dec2$2 = executionOrder(110), _dec3$2 = requireComponent(Widget), _dec$4(_class$4 = _dec2$2(_class$4 = _dec3$2(_class$4 = class SafeArea extends Component {
        onEnable() {
          this.updateArea();
          screenAdapter.on('window-resize', this.updateArea, this);
          screenAdapter.on('orientation-change', this.updateArea, this);
        }
        onDisable() {
          screenAdapter.off('window-resize', this.updateArea, this);
          screenAdapter.off('orientation-change', this.updateArea, this);
        }
        updateArea() {
          const widget = this.node.getComponent(Widget);
          const uiTransComp = this.node.getComponent(UITransform);
          if (!widget || !uiTransComp) {
            return;
          }
          widget.updateAlignment();
          const lastPos = this.node.position.clone();
          const lastAnchorPoint = uiTransComp.anchorPoint.clone();
          widget.isAlignTop = widget.isAlignBottom = widget.isAlignLeft = widget.isAlignRight = true;
          const visibleSize = view.getVisibleSize();
          const screenWidth = visibleSize.width;
          const screenHeight = visibleSize.height;
          const safeArea = sys.getSafeAreaRect();
          widget.top = screenHeight - safeArea.y - safeArea.height;
          widget.bottom = safeArea.y;
          widget.left = safeArea.x;
          widget.right = screenWidth - safeArea.x - safeArea.width;
          widget.updateAlignment();
          const curPos = this.node.position.clone();
          const anchorX = lastAnchorPoint.x - (curPos.x - lastPos.x) / uiTransComp.width;
          const anchorY = lastAnchorPoint.y - (curPos.y - lastPos.y) / uiTransComp.height;
          uiTransComp.setAnchorPoint(anchorX, anchorY);
          widgetManager.add(widget);
        }
      }) || _class$4) || _class$4) || _class$4); exports({ SafeArea: SafeArea, SafeAreaComponent: SafeArea });
      legacyCC.SafeArea = SafeArea;

      var _dec$3, _dec2$1, _dec3$1, _dec4, _dec5, _class$3, _class2$1, _initializer$1, _initializer2$1, _initializer3, _initializer4, _initializer5;
      let UICoordinateTracker = (_dec$3 = ccclass$3('cc.UICoordinateTracker'), _dec2$1 = executionOrder(110), _dec3$1 = type$2(Node$1), _dec4 = type$2(Camera), _dec5 = type$2([EventHandler]), _dec$3(_class$3 = _dec2$1(_class$3 = (_class2$1 = class UICoordinateTracker extends Component {
        constructor(...args) {
          super(...args);
          this.syncEvents = _initializer$1 && _initializer$1();
          this._target = _initializer2$1 && _initializer2$1();
          this._camera = _initializer3 && _initializer3();
          this._useScale = _initializer4 && _initializer4();
          this._distance = _initializer5 && _initializer5();
          this._transformPos = new Vec3();
          this._viewPos = new Vec3();
          this._canMove = true;
          this._lastWPos = new Vec3();
          this._lastCameraPos = new Vec3();
        }
        get target() {
          return this._target;
        }
        set target(value) {
          if (this._target === value) {
            return;
          }
          this._target = value;
          this._checkCanMove();
        }
        get camera() {
          return this._camera;
        }
        set camera(value) {
          if (this._camera === value) {
            return;
          }
          this._camera = value;
          this._checkCanMove();
        }
        get useScale() {
          return this._useScale;
        }
        set useScale(value) {
          if (this._useScale === value) {
            return;
          }
          this._useScale = value;
        }
        get distance() {
          return this._distance;
        }
        set distance(value) {
          if (this._distance === value) {
            return;
          }
          this._distance = value;
        }
        onEnable() {
          this._checkCanMove();
        }
        update() {
          const wPos = this.node.worldPosition;
          const camera = this._camera;
          if (!this._canMove || !camera || !camera.camera || this._lastWPos.equals(wPos) && this._lastCameraPos.equals(camera.node.worldPosition)) {
            return;
          }
          this._lastWPos.set(wPos);
          this._lastCameraPos.set(camera.node.worldPosition);
          camera.camera.update();
          camera.convertToUINode(wPos, this._target, this._transformPos);
          if (this._useScale) {
            Vec3.transformMat4(this._viewPos, this.node.worldPosition, camera.camera.matView);
          }
          if (this.syncEvents.length > 0) {
            const data = this._distance / Math.abs(this._viewPos.z);
            EventHandler.emitEvents(this.syncEvents, this._transformPos, data);
          }
        }
        _checkCanMove() {
          this._canMove = !!(this._camera && this._target);
        }
      }, (_applyDecoratedDescriptor(_class2$1.prototype, "target", [_dec3$1], Object.getOwnPropertyDescriptor(_class2$1.prototype, "target"), _class2$1.prototype), _applyDecoratedDescriptor(_class2$1.prototype, "camera", [_dec4], Object.getOwnPropertyDescriptor(_class2$1.prototype, "camera"), _class2$1.prototype), _initializer$1 = applyDecoratedInitializer(_class2$1.prototype, "syncEvents", [_dec5, serializable$3], function () {
        return [];
      }), _initializer2$1 = applyDecoratedInitializer(_class2$1.prototype, "_target", [serializable$3], function () {
        return null;
      }), _initializer3 = applyDecoratedInitializer(_class2$1.prototype, "_camera", [serializable$3], function () {
        return null;
      }), _initializer4 = applyDecoratedInitializer(_class2$1.prototype, "_useScale", [serializable$3], function () {
        return true;
      }), _initializer5 = applyDecoratedInitializer(_class2$1.prototype, "_distance", [serializable$3], function () {
        return 1;
      })), _class2$1)) || _class$3) || _class$3); exports({ UICoordinateTracker: UICoordinateTracker, UICoordinateTrackerComponent: UICoordinateTracker });

      var _dec$2, _class$2;
      const BlockEvents = [NodeEventType.TOUCH_START, NodeEventType.TOUCH_END, NodeEventType.TOUCH_MOVE, NodeEventType.MOUSE_DOWN, NodeEventType.MOUSE_MOVE, NodeEventType.MOUSE_UP, NodeEventType.MOUSE_ENTER, NodeEventType.MOUSE_LEAVE, NodeEventType.MOUSE_WHEEL];
      function stopPropagation(event) {
        event.propagationStopped = true;
      }
      let BlockInputEvents = (_dec$2 = ccclass$3('cc.BlockInputEvents'), _dec$2(_class$2 = class BlockInputEvents extends Component {
        onEnable() {
          for (let i = 0; i < BlockEvents.length; i++) {
            this.node.on(BlockEvents[i], stopPropagation, this);
          }
        }
        onDisable() {
          for (let i = 0; i < BlockEvents.length; i++) {
            this.node.off(BlockEvents[i], stopPropagation, this);
          }
        }
      }) || _class$2); exports({ BlockInputEvents: BlockInputEvents, BlockInputEventsComponent: BlockInputEvents });

      var _dec$1, _dec2, _dec3, _class$1, _class2, _initializer, _initializer2;
      let SubContextView = exports('SubContextView', (_dec$1 = ccclass$3('cc.SubContextView'), _dec2 = executionOrder(110), _dec3 = requireComponent(UITransform), _dec$1(_class$1 = _dec2(_class$1 = _dec3(_class$1 = (_class2 = class SubContextView extends Component {
        get designResolutionSize() {
          return this._designResolutionSize;
        }
        set designResolutionSize(value) {
          {
            return;
          }
        }
        get fps() {
          return this._fps;
        }
        set fps(value) {
          if (this._fps === value) {
            return;
          }
          this._fps = value;
          this._updateInterval = 1000 / value;
        }
        constructor() {
          super();
          this._fps = _initializer && _initializer();
          this._sprite = void 0;
          this._imageAsset = void 0;
          this._texture = void 0;
          this._updatedTime = 0;
          this._updateInterval = 0;
          this._openDataContext = void 0;
          this._content = void 0;
          this._designResolutionSize = _initializer2 && _initializer2();
          this._content = new Node$1('content');
          this._content.hideFlags |= CCObject.Flags.DontSave | CCObject.Flags.HideInHierarchy;
          this._sprite = null;
          this._imageAsset = new ImageAsset$1();
          this._openDataContext = null;
          this._updatedTime = performance.now();
          this._texture = new Texture2D$1();
        }
        onLoad() {
          if (minigame.getOpenDataContext) {
            this._updateInterval = 1000 / this._fps;
            this._openDataContext = minigame.getOpenDataContext();
            this._initSharedCanvas();
            this._initContentNode();
            this._updateSubContextView();
            this._updateContentLayer();
          } else {
            this.enabled = false;
          }
        }
        onEnable() {
          this._registerNodeEvent();
        }
        onDisable() {
          this._unregisterNodeEvent();
        }
        _initSharedCanvas() {
          if (this._openDataContext) {
            const sharedCanvas = this._openDataContext.canvas;
            let designWidth = this._designResolutionSize.width;
            let designHeight = this._designResolutionSize.height;
            sharedCanvas.width = designWidth;
            sharedCanvas.height = designHeight;
          }
        }
        _initContentNode() {
          if (this._openDataContext) {
            const sharedCanvas = this._openDataContext.canvas;
            const image = this._imageAsset;
            image.reset(sharedCanvas);
            this._texture.image = image;
            this._texture.create(sharedCanvas.width, sharedCanvas.height);
            this._sprite = this._content.getComponent(Sprite);
            if (!this._sprite) {
              this._sprite = this._content.addComponent(Sprite);
            }
            if (this._sprite.spriteFrame) {
              this._sprite.spriteFrame.texture = this._texture;
            } else {
              const sp = new SpriteFrame();
              sp.texture = this._texture;
              this._sprite.spriteFrame = sp;
            }
            this._content.parent = this.node;
          }
        }
        _updateSubContextView() {
          if (!this._openDataContext) {
            return;
          }
          const nodeTrans = this.node.getComponent(UITransform);
          const contentTrans = this._content.getComponent(UITransform);
          const scaleX = nodeTrans.width / contentTrans.width;
          const scaleY = nodeTrans.height / contentTrans.height;
          const scale = scaleX > scaleY ? scaleY : scaleX;
          contentTrans.width *= scale;
          contentTrans.height *= scale;
          const viewportRect = view.getViewportRect();
          const box = contentTrans.getBoundingBoxToWorld();
          const visibleSize = view.getVisibleSize();
          const dpr = screenAdapter.devicePixelRatio;
          const x = (viewportRect.width * (box.x / visibleSize.width) + viewportRect.x) / dpr;
          const y = (viewportRect.height * (box.y / visibleSize.height) + viewportRect.y) / dpr;
          const width = viewportRect.width * (box.width / visibleSize.width) / dpr;
          const height = viewportRect.height * (box.height / visibleSize.height) / dpr;
          this._openDataContext.postMessage({
            fromEngine: true,
            type: 'engine',
            event: 'viewport',
            x,
            y,
            width,
            height
          });
        }
        _updateSubContextTexture() {
          const img = this._imageAsset;
          if (!img || !this._openDataContext) {
            return;
          }
          if (img.width <= 0 || img.height <= 0) {
            return;
          }
          const sharedCanvas = this._openDataContext.canvas;
          img.reset(sharedCanvas);
          if (sharedCanvas.width > img.width || sharedCanvas.height > img.height) {
            this._texture.create(sharedCanvas.width, sharedCanvas.height);
          }
          this._texture.uploadData(sharedCanvas);
        }
        _registerNodeEvent() {
          this.node.on(NodeEventType.TRANSFORM_CHANGED, this._updateSubContextView, this);
          this.node.on(NodeEventType.SIZE_CHANGED, this._updateSubContextView, this);
          this.node.on(NodeEventType.LAYER_CHANGED, this._updateContentLayer, this);
        }
        _unregisterNodeEvent() {
          this.node.off(NodeEventType.TRANSFORM_CHANGED, this._updateSubContextView, this);
          this.node.off(NodeEventType.SIZE_CHANGED, this._updateSubContextView, this);
          this.node.off(NodeEventType.LAYER_CHANGED, this._updateContentLayer, this);
        }
        _updateContentLayer() {
          this._content.layer = this.node.layer;
        }
        update(dt) {
          const calledUpdateManually = dt === undefined;
          if (calledUpdateManually) {
            this._updateSubContextTexture();
            return;
          }
          const now = performance.now();
          const deltaTime = now - this._updatedTime;
          if (deltaTime >= this._updateInterval) {
            this._updatedTime += this._updateInterval;
            this._updateSubContextTexture();
          }
        }
        onDestroy() {
          this._content.destroy();
          this._texture.destroy();
          if (this._sprite) {
            this._sprite.destroy();
          }
          this._imageAsset.destroy();
          this._openDataContext = null;
        }
      }, (_initializer = applyDecoratedInitializer(_class2.prototype, "_fps", [serializable$3], function () {
        return 60;
      }), _initializer2 = applyDecoratedInitializer(_class2.prototype, "_designResolutionSize", [serializable$3], function () {
        return new Size$1(640, 960);
      })), _class2)) || _class$1) || _class$1) || _class$1));
      legacyCC.SubContextView = SubContextView;

      deprecateModuleExportedName({
        ButtonComponent: {
          newName: 'Button',
          since: '1.2.0',
          removed: false
        },
        EditBoxComponent: {
          newName: 'EditBox',
          since: '1.2.0',
          removed: false
        },
        LayoutComponent: {
          newName: 'Layout',
          since: '1.2.0',
          removed: false
        },
        ProgressBarComponent: {
          newName: 'ProgressBar',
          since: '1.2.0',
          removed: false
        },
        ScrollViewComponent: {
          newName: 'ScrollView',
          since: '1.2.0',
          removed: false
        },
        ScrollBarComponent: {
          newName: 'ScrollBar',
          since: '1.2.0',
          removed: false
        },
        SliderComponent: {
          newName: 'Slider',
          since: '1.2.0',
          removed: false
        },
        ToggleComponent: {
          newName: 'Toggle',
          since: '1.2.0',
          removed: false
        },
        ToggleContainerComponent: {
          newName: 'ToggleContainer',
          since: '1.2.0',
          removed: false
        },
        WidgetComponent: {
          newName: 'Widget',
          since: '1.2.0',
          removed: false
        },
        PageViewComponent: {
          newName: 'PageView',
          since: '1.2.0',
          removed: false
        },
        PageViewIndicatorComponent: {
          newName: 'PageViewIndicator',
          since: '1.2.0',
          removed: false
        },
        SafeAreaComponent: {
          newName: 'SafeArea',
          since: '1.2.0',
          removed: false
        },
        UICoordinateTrackerComponent: {
          newName: 'UICoordinateTracker',
          since: '1.2.0',
          removed: false
        },
        BlockInputEventsComponent: {
          newName: 'BlockInputEvents',
          since: '1.2.0',
          removed: false
        }
      });

      var _dec, _class;
      let UIReorderComponent = exports('UIReorderComponent', (_dec = ccclass$3('cc.UIReorderComponent'), _dec(_class = class UIReorderComponent {
        constructor() {
          warnID(1408, 'UIReorderComponent');
        }
      }) || _class));
      legacyCC.UIReorderComponent = UIReorderComponent;
      legacyCC.ButtonComponent = Button;
      setClassAlias(Button, 'cc.ButtonComponent');
      legacyCC.EditBoxComponent = EditBox;
      setClassAlias(EditBox, 'cc.EditBoxComponent');
      legacyCC.LayoutComponent = Layout;
      setClassAlias(Layout, 'cc.LayoutComponent');
      legacyCC.ProgressBarComponent = ProgressBar;
      setClassAlias(ProgressBar, 'cc.ProgressBarComponent');
      legacyCC.ScrollViewComponent = ScrollView;
      setClassAlias(ScrollView, 'cc.ScrollViewComponent');
      legacyCC.ScrollBarComponent = ScrollBar;
      setClassAlias(ScrollBar, 'cc.ScrollBarComponent');
      legacyCC.SliderComponent = Slider;
      setClassAlias(Slider, 'cc.SliderComponent');
      legacyCC.ToggleComponent = Toggle;
      setClassAlias(Toggle, 'cc.ToggleComponent');
      legacyCC.ToggleContainerComponent = ToggleContainer;
      setClassAlias(ToggleContainer, 'cc.ToggleContainerComponent');
      legacyCC.WidgetComponent = Widget;
      setClassAlias(Widget, 'cc.WidgetComponent');
      legacyCC.PageViewComponent = PageView;
      setClassAlias(PageView, 'cc.PageViewComponent');
      legacyCC.PageViewIndicatorComponent = PageViewIndicator;
      setClassAlias(PageViewIndicator, 'cc.PageViewIndicatorComponent');
      legacyCC.SafeAreaComponent = SafeArea;
      setClassAlias(SafeArea, 'cc.SafeAreaComponent');
      setClassAlias(UICoordinateTracker, 'cc.UICoordinateTrackerComponent');
      legacyCC.BlockInputEventsComponent = BlockInputEvents;
      setClassAlias(BlockInputEvents, 'cc.BlockInputEventsComponent');
      removeProperty(View.prototype, 'View.prototype', [{
        name: 'isAntiAliasEnabled',
        suggest: 'The API of Texture2d have been largely modified, no alternative'
      }, {
        name: 'enableAntiAlias',
        suggest: 'The API of Texture2d have been largely modified, no alternative'
      }]);
      markAsWarning(View.prototype, 'View.prototype', [{
        name: 'adjustViewportMeta'
      }, {
        name: 'enableAutoFullScreen',
        suggest: 'use screen.requestFullScreen() instead.'
      }, {
        name: 'isAutoFullScreenEnabled'
      }, {
        name: 'setCanvasSize',
        suggest: 'setting size in CSS pixels is not recommended, please use screen.windowSize instead.'
      }, {
        name: 'getCanvasSize',
        suggest: 'please use screen.windowSize instead.'
      }, {
        name: 'getFrameSize',
        suggest: 'getting size in CSS pixels is not recommended, please use screen.windowSize instead.'
      }, {
        name: 'setFrameSize',
        suggest: 'setting size in CSS pixels is not recommended, please use screen.windowSize instead.'
      }, {
        name: 'getDevicePixelRatio',
        suggest: 'use screen.devicePixelRatio instead.'
      }, {
        name: 'convertToLocationInView'
      }, {
        name: 'enableRetina'
      }, {
        name: 'isRetinaEnabled'
      }, {
        name: 'setRealPixelResolution'
      }]);

    })
  };
}));
